
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800100  00001486  0000151a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001486  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000506  0080018e  0080018e  000015a8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000015a8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001604  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000308  00000000  00000000  00001648  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000051c9  00000000  00000000  00001950  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001978  00000000  00000000  00006b19  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000022db  00000000  00000000  00008491  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009b0  00000000  00000000  0000a76c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010c4  00000000  00000000  0000b11c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000377b  00000000  00000000  0000c1e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  0000f95b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b2 c0       	rjmp	.+356    	; 0x16a <__bad_interrupt>
       6:	00 00       	nop
       8:	b0 c0       	rjmp	.+352    	; 0x16a <__bad_interrupt>
       a:	00 00       	nop
       c:	ae c0       	rjmp	.+348    	; 0x16a <__bad_interrupt>
       e:	00 00       	nop
      10:	ac c0       	rjmp	.+344    	; 0x16a <__bad_interrupt>
      12:	00 00       	nop
      14:	aa c0       	rjmp	.+340    	; 0x16a <__bad_interrupt>
      16:	00 00       	nop
      18:	a8 c0       	rjmp	.+336    	; 0x16a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a6 c0       	rjmp	.+332    	; 0x16a <__bad_interrupt>
      1e:	00 00       	nop
      20:	a4 c0       	rjmp	.+328    	; 0x16a <__bad_interrupt>
      22:	00 00       	nop
      24:	a2 c0       	rjmp	.+324    	; 0x16a <__bad_interrupt>
      26:	00 00       	nop
      28:	a0 c0       	rjmp	.+320    	; 0x16a <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9e c0       	rjmp	.+316    	; 0x16a <__bad_interrupt>
      2e:	00 00       	nop
      30:	9c c0       	rjmp	.+312    	; 0x16a <__bad_interrupt>
      32:	00 00       	nop
      34:	74 c5       	rjmp	.+2792   	; 0xb1e <__vector_13>
      36:	00 00       	nop
      38:	98 c0       	rjmp	.+304    	; 0x16a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	96 c0       	rjmp	.+300    	; 0x16a <__bad_interrupt>
      3e:	00 00       	nop
      40:	6d c5       	rjmp	.+2778   	; 0xb1c <__vector_16>
      42:	00 00       	nop
      44:	92 c0       	rjmp	.+292    	; 0x16a <__bad_interrupt>
      46:	00 00       	nop
      48:	90 c0       	rjmp	.+288    	; 0x16a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8e c0       	rjmp	.+284    	; 0x16a <__bad_interrupt>
      4e:	00 00       	nop
      50:	8c c0       	rjmp	.+280    	; 0x16a <__bad_interrupt>
      52:	00 00       	nop
      54:	a1 c6       	rjmp	.+3394   	; 0xd98 <__vector_21>
      56:	00 00       	nop
      58:	88 c0       	rjmp	.+272    	; 0x16a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	86 c0       	rjmp	.+268    	; 0x16a <__bad_interrupt>
      5e:	00 00       	nop
      60:	84 c0       	rjmp	.+264    	; 0x16a <__bad_interrupt>
      62:	00 00       	nop
      64:	82 c0       	rjmp	.+260    	; 0x16a <__bad_interrupt>
      66:	00 00       	nop
      68:	c8 c5       	rjmp	.+2960   	; 0xbfa <__vector_26>
      6a:	00 00       	nop
      6c:	7e c0       	rjmp	.+252    	; 0x16a <__bad_interrupt>
      6e:	00 00       	nop
      70:	d3 c6       	rjmp	.+3494   	; 0xe18 <__vector_28>
      72:	00 00       	nop
      74:	7a c0       	rjmp	.+244    	; 0x16a <__bad_interrupt>
      76:	00 00       	nop
      78:	78 c0       	rjmp	.+240    	; 0x16a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	76 c0       	rjmp	.+236    	; 0x16a <__bad_interrupt>
      7e:	00 00       	nop
      80:	74 c0       	rjmp	.+232    	; 0x16a <__bad_interrupt>
      82:	00 00       	nop
      84:	72 c0       	rjmp	.+228    	; 0x16a <__bad_interrupt>
      86:	00 00       	nop
      88:	70 c0       	rjmp	.+224    	; 0x16a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	19 06       	cpc	r1, r25
      8e:	6b 06       	cpc	r6, r27
      90:	6b 06       	cpc	r6, r27
      92:	6b 06       	cpc	r6, r27
      94:	6b 06       	cpc	r6, r27
      96:	6b 06       	cpc	r6, r27
      98:	6b 06       	cpc	r6, r27
      9a:	6b 06       	cpc	r6, r27
      9c:	19 06       	cpc	r1, r25
      9e:	6b 06       	cpc	r6, r27
      a0:	6b 06       	cpc	r6, r27
      a2:	6b 06       	cpc	r6, r27
      a4:	6b 06       	cpc	r6, r27
      a6:	6b 06       	cpc	r6, r27
      a8:	6b 06       	cpc	r6, r27
      aa:	6b 06       	cpc	r6, r27
      ac:	1b 06       	cpc	r1, r27
      ae:	6b 06       	cpc	r6, r27
      b0:	6b 06       	cpc	r6, r27
      b2:	6b 06       	cpc	r6, r27
      b4:	6b 06       	cpc	r6, r27
      b6:	6b 06       	cpc	r6, r27
      b8:	6b 06       	cpc	r6, r27
      ba:	6b 06       	cpc	r6, r27
      bc:	6b 06       	cpc	r6, r27
      be:	6b 06       	cpc	r6, r27
      c0:	6b 06       	cpc	r6, r27
      c2:	6b 06       	cpc	r6, r27
      c4:	6b 06       	cpc	r6, r27
      c6:	6b 06       	cpc	r6, r27
      c8:	6b 06       	cpc	r6, r27
      ca:	6b 06       	cpc	r6, r27
      cc:	1b 06       	cpc	r1, r27
      ce:	6b 06       	cpc	r6, r27
      d0:	6b 06       	cpc	r6, r27
      d2:	6b 06       	cpc	r6, r27
      d4:	6b 06       	cpc	r6, r27
      d6:	6b 06       	cpc	r6, r27
      d8:	6b 06       	cpc	r6, r27
      da:	6b 06       	cpc	r6, r27
      dc:	6b 06       	cpc	r6, r27
      de:	6b 06       	cpc	r6, r27
      e0:	6b 06       	cpc	r6, r27
      e2:	6b 06       	cpc	r6, r27
      e4:	6b 06       	cpc	r6, r27
      e6:	6b 06       	cpc	r6, r27
      e8:	6b 06       	cpc	r6, r27
      ea:	6b 06       	cpc	r6, r27
      ec:	67 06       	cpc	r6, r23
      ee:	6b 06       	cpc	r6, r27
      f0:	6b 06       	cpc	r6, r27
      f2:	6b 06       	cpc	r6, r27
      f4:	6b 06       	cpc	r6, r27
      f6:	6b 06       	cpc	r6, r27
      f8:	6b 06       	cpc	r6, r27
      fa:	6b 06       	cpc	r6, r27
      fc:	44 06       	cpc	r4, r20
      fe:	6b 06       	cpc	r6, r27
     100:	6b 06       	cpc	r6, r27
     102:	6b 06       	cpc	r6, r27
     104:	6b 06       	cpc	r6, r27
     106:	6b 06       	cpc	r6, r27
     108:	6b 06       	cpc	r6, r27
     10a:	6b 06       	cpc	r6, r27
     10c:	6b 06       	cpc	r6, r27
     10e:	6b 06       	cpc	r6, r27
     110:	6b 06       	cpc	r6, r27
     112:	6b 06       	cpc	r6, r27
     114:	6b 06       	cpc	r6, r27
     116:	6b 06       	cpc	r6, r27
     118:	6b 06       	cpc	r6, r27
     11a:	6b 06       	cpc	r6, r27
     11c:	38 06       	cpc	r3, r24
     11e:	6b 06       	cpc	r6, r27
     120:	6b 06       	cpc	r6, r27
     122:	6b 06       	cpc	r6, r27
     124:	6b 06       	cpc	r6, r27
     126:	6b 06       	cpc	r6, r27
     128:	6b 06       	cpc	r6, r27
     12a:	6b 06       	cpc	r6, r27
     12c:	56 06       	cpc	r5, r22

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e6 e8       	ldi	r30, 0x86	; 134
     142:	f4 e1       	ldi	r31, 0x14	; 20
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	ae 38       	cpi	r26, 0x8E	; 142
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	26 e0       	ldi	r18, 0x06	; 6
     156:	ae e8       	ldi	r26, 0x8E	; 142
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a4 39       	cpi	r26, 0x94	; 148
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	03 d4       	rcall	.+2054   	; 0x96c <main>
     166:	0c 94 41 0a 	jmp	0x1482	; 0x1482 <_exit>

0000016a <__bad_interrupt>:
     16a:	c3 c4       	rjmp	.+2438   	; 0xaf2 <__vector_default>

0000016c <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     16c:	ec e7       	ldi	r30, 0x7C	; 124
     16e:	f0 e0       	ldi	r31, 0x00	; 0
     170:	90 81       	ld	r25, Z
     172:	90 7e       	andi	r25, 0xE0	; 224
     174:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     176:	90 81       	ld	r25, Z
     178:	89 2b       	or	r24, r25
     17a:	80 83       	st	Z, r24
     17c:	08 95       	ret

0000017e <ADC_init>:
}

void ADC_init(void)
{
     17e:	cf 93       	push	r28
     180:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     182:	ec e7       	ldi	r30, 0x7C	; 124
     184:	f0 e0       	ldi	r31, 0x00	; 0
     186:	80 81       	ld	r24, Z
     188:	80 64       	ori	r24, 0x40	; 64
     18a:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     18c:	ca e7       	ldi	r28, 0x7A	; 122
     18e:	d0 e0       	ldi	r29, 0x00	; 0
     190:	88 81       	ld	r24, Y
     192:	81 60       	ori	r24, 0x01	; 1
     194:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     196:	88 81       	ld	r24, Y
     198:	82 60       	ori	r24, 0x02	; 2
     19a:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     19c:	88 81       	ld	r24, Y
     19e:	84 60       	ori	r24, 0x04	; 4
     1a0:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a2:	a4 e6       	ldi	r26, 0x64	; 100
     1a4:	b0 e0       	ldi	r27, 0x00	; 0
     1a6:	8c 91       	ld	r24, X
     1a8:	8e 7f       	andi	r24, 0xFE	; 254
     1aa:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1ac:	80 81       	ld	r24, Z
     1ae:	8f 7d       	andi	r24, 0xDF	; 223
     1b0:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b2:	8f e3       	ldi	r24, 0x3F	; 63
     1b4:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1b8:	88 81       	ld	r24, Y
     1ba:	80 68       	ori	r24, 0x80	; 128
     1bc:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1be:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c2:	8f e1       	ldi	r24, 0x1F	; 31
     1c4:	d3 df       	rcall	.-90     	; 0x16c <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1c6:	88 81       	ld	r24, Y
     1c8:	80 64       	ori	r24, 0x40	; 64
     1ca:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1cc:	ea e7       	ldi	r30, 0x7A	; 122
     1ce:	f0 e0       	ldi	r31, 0x00	; 0
     1d0:	80 81       	ld	r24, Z
     1d2:	84 ff       	sbrs	r24, 4
     1d4:	fd cf       	rjmp	.-6      	; 0x1d0 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1d6:	ea e7       	ldi	r30, 0x7A	; 122
     1d8:	f0 e0       	ldi	r31, 0x00	; 0
     1da:	80 81       	ld	r24, Z
     1dc:	80 64       	ori	r24, 0x40	; 64
     1de:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e0:	80 81       	ld	r24, Z
     1e2:	84 ff       	sbrs	r24, 4
     1e4:	fd cf       	rjmp	.-6      	; 0x1e0 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1e6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <__data_end+0x1>
     1f0:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f4:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1f8:	20 91 8e 01 	lds	r18, 0x018E	; 0x80018e <__data_end>
     1fc:	30 91 8f 01 	lds	r19, 0x018F	; 0x80018f <__data_end+0x1>
     200:	89 2f       	mov	r24, r25
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	98 2f       	mov	r25, r24
     206:	88 27       	eor	r24, r24
     208:	82 0f       	add	r24, r18
     20a:	93 1f       	adc	r25, r19
     20c:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <__data_end+0x1>
     210:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     214:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <__data_end>
     218:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <__data_end+0x1>
     21c:	99 23       	and	r25, r25
     21e:	1c f4       	brge	.+6      	; 0x226 <ADC_init+0xa8>
     220:	91 95       	neg	r25
     222:	81 95       	neg	r24
     224:	91 09       	sbc	r25, r1
     226:	05 97       	sbiw	r24, 0x05	; 5
     228:	2c f0       	brlt	.+10     	; 0x234 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22a:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <gas_sensor_initialization_errors>
     22e:	81 60       	ori	r24, 0x01	; 1
     230:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     234:	8e e1       	ldi	r24, 0x1E	; 30
     236:	9a df       	rcall	.-204    	; 0x16c <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     238:	ea e7       	ldi	r30, 0x7A	; 122
     23a:	f0 e0       	ldi	r31, 0x00	; 0
     23c:	80 81       	ld	r24, Z
     23e:	80 64       	ori	r24, 0x40	; 64
     240:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     242:	80 81       	ld	r24, Z
     244:	84 ff       	sbrs	r24, 4
     246:	fd cf       	rjmp	.-6      	; 0x242 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     248:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <__data_end+0x1>
     252:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     256:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25a:	20 91 8e 01 	lds	r18, 0x018E	; 0x80018e <__data_end>
     25e:	30 91 8f 01 	lds	r19, 0x018F	; 0x80018f <__data_end+0x1>
     262:	89 2f       	mov	r24, r25
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	98 2f       	mov	r25, r24
     268:	88 27       	eor	r24, r24
     26a:	82 0f       	add	r24, r18
     26c:	93 1f       	adc	r25, r19
     26e:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <__data_end+0x1>
     272:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     276:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <__data_end>
     27a:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <__data_end+0x1>
     27e:	81 5e       	subi	r24, 0xE1	; 225
     280:	91 09       	sbc	r25, r1
     282:	90 93 8f 01 	sts	0x018F, r25	; 0x80018f <__data_end+0x1>
     286:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28a:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <__data_end>
     28e:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <__data_end+0x1>
     292:	99 23       	and	r25, r25
     294:	1c f4       	brge	.+6      	; 0x29c <ADC_init+0x11e>
     296:	91 95       	neg	r25
     298:	81 95       	neg	r24
     29a:	91 09       	sbc	r25, r1
     29c:	05 97       	sbiw	r24, 0x05	; 5
     29e:	2c f0       	brlt	.+10     	; 0x2aa <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a0:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <gas_sensor_initialization_errors>
     2a4:	82 60       	ori	r24, 0x02	; 2
     2a6:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2aa:	ea e7       	ldi	r30, 0x7A	; 122
     2ac:	f0 e0       	ldi	r31, 0x00	; 0
     2ae:	80 81       	ld	r24, Z
     2b0:	8f 77       	andi	r24, 0x7F	; 127
     2b2:	80 83       	st	Z, r24
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	08 95       	ret

000002ba <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2ba:	87 e0       	ldi	r24, 0x07	; 7
     2bc:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2be:	85 b1       	in	r24, 0x05	; 5
     2c0:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2c2:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2c4:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2c6:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2c8:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2ca:	41 9a       	sbi	0x08, 1	; 8
     2cc:	08 95       	ret

000002ce <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2ce:	80 e0       	ldi	r24, 0x00	; 0
     2d0:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2d2:	2f ef       	ldi	r18, 0xFF	; 255
     2d4:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2d6:	fc 01       	movw	r30, r24
     2d8:	ee 0f       	add	r30, r30
     2da:	ff 1f       	adc	r31, r31
     2dc:	ee 0f       	add	r30, r30
     2de:	ff 1f       	adc	r31, r31
     2e0:	ee 53       	subi	r30, 0x3E	; 62
     2e2:	fd 4f       	sbci	r31, 0xFD	; 253
     2e4:	11 82       	std	Z+1, r1	; 0x01
     2e6:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2e8:	33 83       	std	Z+3, r19	; 0x03
     2ea:	22 83       	std	Z+2, r18	; 0x02
     2ec:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2ee:	85 30       	cpi	r24, 0x05	; 5
     2f0:	91 05       	cpc	r25, r1
     2f2:	89 f7       	brne	.-30     	; 0x2d6 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2f4:	08 95       	ret

000002f6 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2f6:	ef 92       	push	r14
     2f8:	ff 92       	push	r15
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
     302:	0f 2e       	mov	r0, r31
     304:	fc ea       	ldi	r31, 0xAC	; 172
     306:	ef 2e       	mov	r14, r31
     308:	f2 e0       	ldi	r31, 0x02	; 2
     30a:	ff 2e       	mov	r15, r31
     30c:	f0 2d       	mov	r31, r0
     30e:	00 e0       	ldi	r16, 0x00	; 0
     310:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     312:	c7 01       	movw	r24, r14
     314:	0e 94 2c 0a 	call	0x1458	; 0x1458 <eeprom_read_word>
     318:	e8 01       	movw	r28, r16
     31a:	cc 0f       	add	r28, r28
     31c:	dd 1f       	adc	r29, r29
     31e:	cc 0f       	add	r28, r28
     320:	dd 1f       	adc	r29, r29
     322:	ce 53       	subi	r28, 0x3E	; 62
     324:	dd 4f       	sbci	r29, 0xFD	; 253
     326:	99 83       	std	Y+1, r25	; 0x01
     328:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     32a:	c7 01       	movw	r24, r14
     32c:	02 96       	adiw	r24, 0x02	; 2
     32e:	0e 94 2c 0a 	call	0x1458	; 0x1458 <eeprom_read_word>
     332:	9b 83       	std	Y+3, r25	; 0x03
     334:	8a 83       	std	Y+2, r24	; 0x02
     336:	0f 5f       	subi	r16, 0xFF	; 255
     338:	1f 4f       	sbci	r17, 0xFF	; 255
     33a:	84 e0       	ldi	r24, 0x04	; 4
     33c:	e8 0e       	add	r14, r24
     33e:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     340:	05 30       	cpi	r16, 0x05	; 5
     342:	11 05       	cpc	r17, r1
     344:	31 f7       	brne	.-52     	; 0x312 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     346:	df 91       	pop	r29
     348:	cf 91       	pop	r28
     34a:	1f 91       	pop	r17
     34c:	0f 91       	pop	r16
     34e:	ff 90       	pop	r15
     350:	ef 90       	pop	r14
     352:	08 95       	ret

00000354 <gas_sensors_init>:

void gas_sensors_init(void)
{
     354:	af 92       	push	r10
     356:	bf 92       	push	r11
     358:	cf 92       	push	r12
     35a:	df 92       	push	r13
     35c:	ef 92       	push	r14
     35e:	ff 92       	push	r15
     360:	0f 93       	push	r16
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	1f 92       	push	r1
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     36e:	10 92 ed 02 	sts	0x02ED, r1	; 0x8002ed <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     372:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     376:	bf df       	rcall	.-130    	; 0x2f6 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     378:	aa df       	rcall	.-172    	; 0x2ce <get_gas_sensor_limits>
     37a:	ea e7       	ldi	r30, 0x7A	; 122
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     37c:	f0 e0       	ldi	r31, 0x00	; 0
     37e:	80 81       	ld	r24, Z
     380:	80 68       	ori	r24, 0x80	; 128
     382:	80 83       	st	Z, r24
     384:	19 82       	std	Y+1, r1	; 0x01
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     386:	89 81       	ldd	r24, Y+1	; 0x01
     388:	85 30       	cpi	r24, 0x05	; 5
     38a:	08 f0       	brcs	.+2      	; 0x38e <gas_sensors_init+0x3a>
     38c:	51 c0       	rjmp	.+162    	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
     38e:	0a e7       	ldi	r16, 0x7A	; 122
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     390:	10 e0       	ldi	r17, 0x00	; 0
     392:	0f 2e       	mov	r0, r31
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     394:	f8 e7       	ldi	r31, 0x78	; 120
     396:	ef 2e       	mov	r14, r31
     398:	f1 2c       	mov	r15, r1
     39a:	f0 2d       	mov	r31, r0
     39c:	bb 24       	eor	r11, r11
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     39e:	b3 94       	inc	r11
     3a0:	a1 2c       	mov	r10, r1
     3a2:	cc 24       	eor	r12, r12
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3a4:	c3 94       	inc	r12
     3a6:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	e0 de       	rcall	.-576    	; 0x16c <ADC_SetMux>
     3ac:	f8 01       	movw	r30, r16
		// Start conversion
		SetBit(ADCSRA, ADSC);
     3ae:	80 81       	ld	r24, Z
     3b0:	80 64       	ori	r24, 0x40	; 64
     3b2:	80 83       	st	Z, r24
     3b4:	f8 01       	movw	r30, r16
		while (BitIsClear(ADCSRA, ADIF))
     3b6:	80 81       	ld	r24, Z
     3b8:	84 ff       	sbrs	r24, 4
     3ba:	fc cf       	rjmp	.-8      	; 0x3b4 <gas_sensors_init+0x60>
     3bc:	f7 01       	movw	r30, r14
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3be:	80 81       	ld	r24, Z
     3c0:	91 81       	ldd	r25, Z+1	; 0x01
     3c2:	e9 81       	ldd	r30, Y+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3c4:	f0 e0       	ldi	r31, 0x00	; 0
     3c6:	ee 0f       	add	r30, r30
     3c8:	ff 1f       	adc	r31, r31
     3ca:	ee 0f       	add	r30, r30
     3cc:	ff 1f       	adc	r31, r31
     3ce:	ee 53       	subi	r30, 0x3E	; 62
     3d0:	fd 4f       	sbci	r31, 0xFD	; 253
     3d2:	20 81       	ld	r18, Z
     3d4:	31 81       	ldd	r19, Z+1	; 0x01
     3d6:	e9 81       	ldd	r30, Y+1	; 0x01
     3d8:	f0 e0       	ldi	r31, 0x00	; 0
     3da:	ee 0f       	add	r30, r30
     3dc:	ff 1f       	adc	r31, r31
     3de:	ee 0f       	add	r30, r30
     3e0:	ff 1f       	adc	r31, r31
     3e2:	ee 53       	subi	r30, 0x3E	; 62
     3e4:	fd 4f       	sbci	r31, 0xFD	; 253
     3e6:	62 81       	ldd	r22, Z+2	; 0x02
     3e8:	73 81       	ldd	r23, Z+3	; 0x03
     3ea:	4b 2d       	mov	r20, r11
     3ec:	82 17       	cp	r24, r18
     3ee:	93 07       	cpc	r25, r19
     3f0:	08 f0       	brcs	.+2      	; 0x3f4 <gas_sensors_init+0xa0>
     3f2:	4a 2d       	mov	r20, r10
     3f4:	41 11       	cpse	r20, r1
     3f6:	07 c0       	rjmp	.+14     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3f8:	2b 2d       	mov	r18, r11
     3fa:	68 17       	cp	r22, r24
     3fc:	79 07       	cpc	r23, r25
     3fe:	08 f0       	brcs	.+2      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
     400:	2a 2d       	mov	r18, r10
     402:	22 23       	and	r18, r18
     404:	71 f0       	breq	.+28     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
     406:	99 81       	ldd	r25, Y+1	; 0x01
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     408:	20 91 ed 02 	lds	r18, 0x02ED	; 0x8002ed <gas_sensor_initialization_errors>
     40c:	9d 5f       	subi	r25, 0xFD	; 253
     40e:	a6 01       	movw	r20, r12
     410:	02 c0       	rjmp	.+4      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
     412:	44 0f       	add	r20, r20
     414:	55 1f       	adc	r21, r21
     416:	9a 95       	dec	r25
     418:	e2 f7       	brpl	.-8      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
     41a:	ca 01       	movw	r24, r20
     41c:	82 2b       	or	r24, r18
     41e:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <gas_sensor_initialization_errors>
     422:	89 81       	ldd	r24, Y+1	; 0x01
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     424:	8f 5f       	subi	r24, 0xFF	; 255
     426:	89 83       	std	Y+1, r24	; 0x01
     428:	89 81       	ldd	r24, Y+1	; 0x01
     42a:	85 30       	cpi	r24, 0x05	; 5
     42c:	08 f4       	brcc	.+2      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
     42e:	bc cf       	rjmp	.-136    	; 0x3a8 <gas_sensors_init+0x54>
     430:	ea e7       	ldi	r30, 0x7A	; 122
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     432:	f0 e0       	ldi	r31, 0x00	; 0
     434:	80 81       	ld	r24, Z
     436:	8f 77       	andi	r24, 0x7F	; 127
     438:	80 83       	st	Z, r24
     43a:	0f 90       	pop	r0
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	1f 91       	pop	r17
     442:	0f 91       	pop	r16
     444:	ff 90       	pop	r15
     446:	ef 90       	pop	r14
     448:	df 90       	pop	r13
     44a:	cf 90       	pop	r12
     44c:	bf 90       	pop	r11
     44e:	af 90       	pop	r10
     450:	08 95       	ret

00000452 <start_gas_sensor_read>:
     452:	af 92       	push	r10

void start_gas_sensor_read(void)
{
     454:	bf 92       	push	r11
     456:	cf 92       	push	r12
     458:	df 92       	push	r13
     45a:	ef 92       	push	r14
     45c:	ff 92       	push	r15
     45e:	0f 93       	push	r16
     460:	1f 93       	push	r17
     462:	cf 93       	push	r28
     464:	df 93       	push	r29
     466:	00 d0       	rcall	.+0      	; 0x468 <start_gas_sensor_read+0x16>
     468:	1f 92       	push	r1
     46a:	cd b7       	in	r28, 0x3d	; 61
     46c:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     46e:	ea e7       	ldi	r30, 0x7A	; 122
     470:	f0 e0       	ldi	r31, 0x00	; 0
     472:	80 81       	ld	r24, Z
     474:	80 68       	ori	r24, 0x80	; 128
     476:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     478:	19 82       	std	Y+1, r1	; 0x01
     47a:	89 81       	ldd	r24, Y+1	; 0x01
     47c:	85 30       	cpi	r24, 0x05	; 5
     47e:	08 f0       	brcs	.+2      	; 0x482 <start_gas_sensor_read+0x30>
     480:	73 c0       	rjmp	.+230    	; 0x568 <start_gas_sensor_read+0x116>
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     482:	0a e7       	ldi	r16, 0x7A	; 122
     484:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     486:	0f 2e       	mov	r0, r31
     488:	f8 e7       	ldi	r31, 0x78	; 120
     48a:	ef 2e       	mov	r14, r31
     48c:	f1 2c       	mov	r15, r1
     48e:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     490:	cc 24       	eor	r12, r12
     492:	c3 94       	inc	r12
     494:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     496:	bb 24       	eor	r11, r11
     498:	b3 94       	inc	r11
     49a:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     49c:	89 81       	ldd	r24, Y+1	; 0x01
     49e:	66 de       	rcall	.-820    	; 0x16c <ADC_SetMux>
		total = 0;	// re-zero the average
     4a0:	1b 82       	std	Y+3, r1	; 0x03
     4a2:	1a 82       	std	Y+2, r1	; 0x02
     4a4:	24 e0       	ldi	r18, 0x04	; 4
     4a6:	30 e0       	ldi	r19, 0x00	; 0
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4a8:	f8 01       	movw	r30, r16
     4aa:	80 81       	ld	r24, Z
     4ac:	80 64       	ori	r24, 0x40	; 64
     4ae:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4b0:	f8 01       	movw	r30, r16
     4b2:	80 81       	ld	r24, Z
     4b4:	84 ff       	sbrs	r24, 4
     4b6:	fc cf       	rjmp	.-8      	; 0x4b0 <start_gas_sensor_read+0x5e>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4b8:	f7 01       	movw	r30, r14
     4ba:	80 81       	ld	r24, Z
     4bc:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4be:	e9 81       	ldd	r30, Y+1	; 0x01
     4c0:	f0 e0       	ldi	r31, 0x00	; 0
     4c2:	ee 0f       	add	r30, r30
     4c4:	ff 1f       	adc	r31, r31
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	ee 53       	subi	r30, 0x3E	; 62
     4cc:	fd 4f       	sbci	r31, 0xFD	; 253
     4ce:	40 81       	ld	r20, Z
     4d0:	51 81       	ldd	r21, Z+1	; 0x01
     4d2:	e9 81       	ldd	r30, Y+1	; 0x01
     4d4:	f0 e0       	ldi	r31, 0x00	; 0
     4d6:	ee 0f       	add	r30, r30
     4d8:	ff 1f       	adc	r31, r31
     4da:	ee 0f       	add	r30, r30
     4dc:	ff 1f       	adc	r31, r31
     4de:	ee 53       	subi	r30, 0x3E	; 62
     4e0:	fd 4f       	sbci	r31, 0xFD	; 253
     4e2:	02 80       	ldd	r0, Z+2	; 0x02
     4e4:	f3 81       	ldd	r31, Z+3	; 0x03
     4e6:	e0 2d       	mov	r30, r0
     4e8:	6b 2d       	mov	r22, r11
     4ea:	84 17       	cp	r24, r20
     4ec:	95 07       	cpc	r25, r21
     4ee:	08 f0       	brcs	.+2      	; 0x4f2 <start_gas_sensor_read+0xa0>
     4f0:	6a 2d       	mov	r22, r10
     4f2:	61 11       	cpse	r22, r1
     4f4:	07 c0       	rjmp	.+14     	; 0x504 <start_gas_sensor_read+0xb2>
     4f6:	4b 2d       	mov	r20, r11
     4f8:	e8 17       	cp	r30, r24
     4fa:	f9 07       	cpc	r31, r25
     4fc:	08 f0       	brcs	.+2      	; 0x500 <start_gas_sensor_read+0xae>
     4fe:	4a 2d       	mov	r20, r10
     500:	44 23       	and	r20, r20
     502:	71 f0       	breq	.+28     	; 0x520 <start_gas_sensor_read+0xce>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     504:	59 81       	ldd	r21, Y+1	; 0x01
     506:	60 91 ed 02 	lds	r22, 0x02ED	; 0x8002ed <gas_sensor_initialization_errors>
     50a:	5d 5f       	subi	r21, 0xFD	; 253
     50c:	f6 01       	movw	r30, r12
     50e:	02 c0       	rjmp	.+4      	; 0x514 <start_gas_sensor_read+0xc2>
     510:	ee 0f       	add	r30, r30
     512:	ff 1f       	adc	r31, r31
     514:	5a 95       	dec	r21
     516:	e2 f7       	brpl	.-8      	; 0x510 <start_gas_sensor_read+0xbe>
     518:	af 01       	movw	r20, r30
     51a:	46 2b       	or	r20, r22
     51c:	40 93 ed 02 	sts	0x02ED, r20	; 0x8002ed <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     520:	4a 81       	ldd	r20, Y+2	; 0x02
     522:	5b 81       	ldd	r21, Y+3	; 0x03
     524:	84 0f       	add	r24, r20
     526:	95 1f       	adc	r25, r21
     528:	9b 83       	std	Y+3, r25	; 0x03
     52a:	8a 83       	std	Y+2, r24	; 0x02
     52c:	21 50       	subi	r18, 0x01	; 1
     52e:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
     530:	09 f0       	breq	.+2      	; 0x534 <start_gas_sensor_read+0xe2>
     532:	ba cf       	rjmp	.-140    	; 0x4a8 <start_gas_sensor_read+0x56>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     534:	8a 81       	ldd	r24, Y+2	; 0x02
     536:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     538:	e9 81       	ldd	r30, Y+1	; 0x01
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	ef 51       	subi	r30, 0x1F	; 31
     542:	fd 4f       	sbci	r31, 0xFD	; 253
     544:	9c 01       	movw	r18, r24
     546:	99 23       	and	r25, r25
     548:	14 f4       	brge	.+4      	; 0x54e <start_gas_sensor_read+0xfc>
     54a:	2d 5f       	subi	r18, 0xFD	; 253
     54c:	3f 4f       	sbci	r19, 0xFF	; 255
     54e:	35 95       	asr	r19
     550:	27 95       	ror	r18
     552:	35 95       	asr	r19
     554:	27 95       	ror	r18
     556:	31 83       	std	Z+1, r19	; 0x01
     558:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     55a:	89 81       	ldd	r24, Y+1	; 0x01
     55c:	8f 5f       	subi	r24, 0xFF	; 255
     55e:	89 83       	std	Y+1, r24	; 0x01
     560:	89 81       	ldd	r24, Y+1	; 0x01
     562:	85 30       	cpi	r24, 0x05	; 5
     564:	08 f4       	brcc	.+2      	; 0x568 <start_gas_sensor_read+0x116>
     566:	9a cf       	rjmp	.-204    	; 0x49c <start_gas_sensor_read+0x4a>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     568:	0f 90       	pop	r0
     56a:	0f 90       	pop	r0
     56c:	0f 90       	pop	r0
     56e:	df 91       	pop	r29
     570:	cf 91       	pop	r28
     572:	1f 91       	pop	r17
     574:	0f 91       	pop	r16
     576:	ff 90       	pop	r15
     578:	ef 90       	pop	r14
     57a:	df 90       	pop	r13
     57c:	cf 90       	pop	r12
     57e:	bf 90       	pop	r11
     580:	af 90       	pop	r10
     582:	08 95       	ret

00000584 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     584:	1f 93       	push	r17
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     58a:	e4 ef       	ldi	r30, 0xF4	; 244
     58c:	f2 e0       	ldi	r31, 0x02	; 2
     58e:	84 ec       	ldi	r24, 0xC4	; 196
     590:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     592:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     594:	84 e0       	ldi	r24, 0x04	; 4
     596:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     598:	63 e0       	ldi	r22, 0x03	; 3
     59a:	cf 01       	movw	r24, r30
     59c:	e3 d2       	rcall	.+1478   	; 0xb64 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     59e:	de d2       	rcall	.+1468   	; 0xb5c <TWI_Transceiver_Busy>
     5a0:	81 11       	cpse	r24, r1
     5a2:	fd cf       	rjmp	.-6      	; 0x59e <LIDAR_distance+0x1a>
     5a4:	e4 ef       	ldi	r30, 0xF4	; 244
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5a6:	f2 e0       	ldi	r31, 0x02	; 2
     5a8:	84 ec       	ldi	r24, 0xC4	; 196
     5aa:	80 83       	st	Z, r24
     5ac:	81 e0       	ldi	r24, 0x01	; 1
	messageBuf[1] = 0x01; // Select register 0x01
     5ae:	81 83       	std	Z+1, r24	; 0x01
     5b0:	62 e0       	ldi	r22, 0x02	; 2
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b2:	cf 01       	movw	r24, r30
     5b4:	d7 d2       	rcall	.+1454   	; 0xb64 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5b6:	d2 d2       	rcall	.+1444   	; 0xb5c <TWI_Transceiver_Busy>
     5b8:	81 11       	cpse	r24, r1
     5ba:	fd cf       	rjmp	.-6      	; 0x5b6 <LIDAR_distance+0x32>
     5bc:	c4 ef       	ldi	r28, 0xF4	; 244
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5be:	d2 e0       	ldi	r29, 0x02	; 2
     5c0:	15 ec       	ldi	r17, 0xC5	; 197
     5c2:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5c4:	19 82       	std	Y+1, r1	; 0x01
     5c6:	62 e0       	ldi	r22, 0x02	; 2
     5c8:	ce 01       	movw	r24, r28
     5ca:	cc d2       	rcall	.+1432   	; 0xb64 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5cc:	c7 d2       	rcall	.+1422   	; 0xb5c <TWI_Transceiver_Busy>
     5ce:	81 11       	cpse	r24, r1
     5d0:	fd cf       	rjmp	.-6      	; 0x5cc <LIDAR_distance+0x48>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5d2:	62 e0       	ldi	r22, 0x02	; 2
     5d4:	ce 01       	movw	r24, r28
     5d6:	f2 d2       	rcall	.+1508   	; 0xbbc <TWI_Get_Data_From_Transceiver>
     5d8:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     5dc:	89 81       	ldd	r24, Y+1	; 0x01
		testing = messageBuf[1]; //This is here for debug purposes
     5de:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <testing>
     5e2:	80 fd       	sbrc	r24, 0
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5e4:	ee cf       	rjmp	.-36     	; 0x5c2 <LIDAR_distance+0x3e>
     5e6:	e4 ef       	ldi	r30, 0xF4	; 244
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5e8:	f2 e0       	ldi	r31, 0x02	; 2
     5ea:	84 ec       	ldi	r24, 0xC4	; 196
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     5ec:	80 83       	st	Z, r24
     5ee:	8f e8       	ldi	r24, 0x8F	; 143
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5f0:	81 83       	std	Z+1, r24	; 0x01
     5f2:	62 e0       	ldi	r22, 0x02	; 2
     5f4:	cf 01       	movw	r24, r30
     5f6:	b6 d2       	rcall	.+1388   	; 0xb64 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     5f8:	b1 d2       	rcall	.+1378   	; 0xb5c <TWI_Transceiver_Busy>
     5fa:	81 11       	cpse	r24, r1
     5fc:	fd cf       	rjmp	.-6      	; 0x5f8 <LIDAR_distance+0x74>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5fe:	e4 ef       	ldi	r30, 0xF4	; 244
     600:	f2 e0       	ldi	r31, 0x02	; 2
     602:	85 ec       	ldi	r24, 0xC5	; 197
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     604:	80 83       	st	Z, r24
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     606:	11 82       	std	Z+1, r1	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     608:	12 82       	std	Z+2, r1	; 0x02
     60a:	63 e0       	ldi	r22, 0x03	; 3
     60c:	cf 01       	movw	r24, r30
	while ( TWI_Transceiver_Busy() );	
     60e:	aa d2       	rcall	.+1364   	; 0xb64 <TWI_Start_Transceiver_With_Data>
     610:	a5 d2       	rcall	.+1354   	; 0xb5c <TWI_Transceiver_Busy>
     612:	81 11       	cpse	r24, r1
     614:	fd cf       	rjmp	.-6      	; 0x610 <LIDAR_distance+0x8c>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     616:	63 e0       	ldi	r22, 0x03	; 3
     618:	84 ef       	ldi	r24, 0xF4	; 244
     61a:	92 e0       	ldi	r25, 0x02	; 2
     61c:	cf d2       	rcall	.+1438   	; 0xbbc <TWI_Get_Data_From_Transceiver>
     61e:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     622:	e4 ef       	ldi	r30, 0xF4	; 244
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     624:	f2 e0       	ldi	r31, 0x02	; 2
     626:	81 81       	ldd	r24, Z+1	; 0x01
	// That's all, folks...
	return(Ldistance);
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	98 2f       	mov	r25, r24
     62c:	88 27       	eor	r24, r24
     62e:	22 81       	ldd	r18, Z+2	; 0x02
     630:	82 0f       	add	r24, r18
}
     632:	91 1d       	adc	r25, r1
     634:	df 91       	pop	r29
     636:	cf 91       	pop	r28
     638:	1f 91       	pop	r17
     63a:	08 95       	ret

0000063c <BME_read_correction_coefficients>:
     63c:	ff 92       	push	r15
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
	return (long)(v_x1_u32r>>12);
}
     63e:	0f 93       	push	r16
     640:	1f 93       	push	r17
     642:	cf 93       	push	r28
     644:	df 93       	push	r29
     646:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     64a:	88 23       	and	r24, r24
     64c:	31 f1       	breq	.+76     	; 0x69a <BME_read_correction_coefficients+0x5e>
     64e:	c5 e0       	ldi	r28, 0x05	; 5
     650:	d3 e0       	ldi	r29, 0x03	; 3
     652:	0f 2e       	mov	r0, r31
     654:	fc ee       	ldi	r31, 0xEC	; 236
     656:	ff 2e       	mov	r15, r31
     658:	f0 2d       	mov	r31, r0
     65a:	03 ef       	ldi	r16, 0xF3	; 243
     65c:	1d ee       	ldi	r17, 0xED	; 237
     65e:	f8 82       	st	Y, r15
     660:	09 83       	std	Y+1, r16	; 0x01
     662:	62 e0       	ldi	r22, 0x02	; 2
     664:	ce 01       	movw	r24, r28
     666:	7e d2       	rcall	.+1276   	; 0xb64 <TWI_Start_Transceiver_With_Data>
     668:	79 d2       	rcall	.+1266   	; 0xb5c <TWI_Transceiver_Busy>
     66a:	81 11       	cpse	r24, r1
     66c:	fd cf       	rjmp	.-6      	; 0x668 <BME_read_correction_coefficients+0x2c>
     66e:	18 83       	st	Y, r17
     670:	6a e1       	ldi	r22, 0x1A	; 26
     672:	ce 01       	movw	r24, r28
     674:	77 d2       	rcall	.+1262   	; 0xb64 <TWI_Start_Transceiver_With_Data>
     676:	72 d2       	rcall	.+1252   	; 0xb5c <TWI_Transceiver_Busy>
     678:	81 11       	cpse	r24, r1
     67a:	fd cf       	rjmp	.-6      	; 0x676 <BME_read_correction_coefficients+0x3a>
     67c:	6a e1       	ldi	r22, 0x1A	; 26
     67e:	ce 01       	movw	r24, r28
     680:	9d d2       	rcall	.+1338   	; 0xbbc <TWI_Get_Data_From_Transceiver>
     682:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     686:	89 81       	ldd	r24, Y+1	; 0x01
     688:	83 fb       	bst	r24, 3
     68a:	88 27       	eor	r24, r24
     68c:	80 f9       	bld	r24, 0
     68e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     692:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     696:	81 11       	cpse	r24, r1
     698:	e2 cf       	rjmp	.-60     	; 0x65e <BME_read_correction_coefficients+0x22>
     69a:	e5 e0       	ldi	r30, 0x05	; 5
     69c:	f3 e0       	ldi	r31, 0x03	; 3
     69e:	8c ee       	ldi	r24, 0xEC	; 236
     6a0:	80 83       	st	Z, r24
     6a2:	88 e8       	ldi	r24, 0x88	; 136
     6a4:	81 83       	std	Z+1, r24	; 0x01
     6a6:	62 e0       	ldi	r22, 0x02	; 2
     6a8:	cf 01       	movw	r24, r30
     6aa:	5c d2       	rcall	.+1208   	; 0xb64 <TWI_Start_Transceiver_With_Data>
     6ac:	57 d2       	rcall	.+1198   	; 0xb5c <TWI_Transceiver_Busy>
     6ae:	81 11       	cpse	r24, r1
     6b0:	fd cf       	rjmp	.-6      	; 0x6ac <BME_read_correction_coefficients+0x70>
     6b2:	8d ee       	ldi	r24, 0xED	; 237
     6b4:	80 93 05 03 	sts	0x0305, r24	; 0x800305 <BMEmessageBuf>
     6b8:	6b e1       	ldi	r22, 0x1B	; 27
     6ba:	85 e0       	ldi	r24, 0x05	; 5
     6bc:	93 e0       	ldi	r25, 0x03	; 3
     6be:	52 d2       	rcall	.+1188   	; 0xb64 <TWI_Start_Transceiver_With_Data>
     6c0:	4d d2       	rcall	.+1178   	; 0xb5c <TWI_Transceiver_Busy>
     6c2:	81 11       	cpse	r24, r1
     6c4:	fd cf       	rjmp	.-6      	; 0x6c0 <BME_read_correction_coefficients+0x84>
     6c6:	6b e1       	ldi	r22, 0x1B	; 27
     6c8:	85 e0       	ldi	r24, 0x05	; 5
     6ca:	93 e0       	ldi	r25, 0x03	; 3
     6cc:	77 d2       	rcall	.+1262   	; 0xbbc <TWI_Get_Data_From_Transceiver>
     6ce:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     6d2:	c6 e0       	ldi	r28, 0x06	; 6
     6d4:	d3 e0       	ldi	r29, 0x03	; 3
     6d6:	0e e0       	ldi	r16, 0x0E	; 14
     6d8:	14 e0       	ldi	r17, 0x04	; 4
     6da:	21 e2       	ldi	r18, 0x21	; 33
     6dc:	33 e0       	ldi	r19, 0x03	; 3
     6de:	d8 01       	movw	r26, r16
     6e0:	fe 01       	movw	r30, r28
     6e2:	81 91       	ld	r24, Z+
     6e4:	8d 93       	st	X+, r24
     6e6:	e2 17       	cp	r30, r18
     6e8:	f3 07       	cpc	r31, r19
     6ea:	d9 f7       	brne	.-10     	; 0x6e2 <BME_read_correction_coefficients+0xa6>
     6ec:	8b e1       	ldi	r24, 0x1B	; 27
     6ee:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <i.2424>
     6f2:	ee e0       	ldi	r30, 0x0E	; 14
     6f4:	f4 e0       	ldi	r31, 0x04	; 4
     6f6:	81 81       	ldd	r24, Z+1	; 0x01
     6f8:	90 e0       	ldi	r25, 0x00	; 0
     6fa:	98 2f       	mov	r25, r24
     6fc:	88 27       	eor	r24, r24
     6fe:	20 81       	ld	r18, Z
     700:	82 2b       	or	r24, r18
     702:	90 93 09 04 	sts	0x0409, r25	; 0x800409 <dig_T1+0x1>
     706:	80 93 08 04 	sts	0x0408, r24	; 0x800408 <dig_T1>
     70a:	83 81       	ldd	r24, Z+3	; 0x03
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	98 2f       	mov	r25, r24
     710:	88 27       	eor	r24, r24
     712:	22 81       	ldd	r18, Z+2	; 0x02
     714:	82 2b       	or	r24, r18
     716:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <dig_T2+0x1>
     71a:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <dig_T2>
     71e:	85 81       	ldd	r24, Z+5	; 0x05
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	98 2f       	mov	r25, r24
     724:	88 27       	eor	r24, r24
     726:	24 81       	ldd	r18, Z+4	; 0x04
     728:	82 2b       	or	r24, r18
     72a:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <dig_T3+0x1>
     72e:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <dig_T3>
     732:	87 81       	ldd	r24, Z+7	; 0x07
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	98 2f       	mov	r25, r24
     738:	88 27       	eor	r24, r24
     73a:	26 81       	ldd	r18, Z+6	; 0x06
     73c:	82 2b       	or	r24, r18
     73e:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <dig_P1+0x1>
     742:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <dig_P1>
     746:	81 85       	ldd	r24, Z+9	; 0x09
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	98 2f       	mov	r25, r24
     74c:	88 27       	eor	r24, r24
     74e:	20 85       	ldd	r18, Z+8	; 0x08
     750:	82 2b       	or	r24, r18
     752:	90 93 41 04 	sts	0x0441, r25	; 0x800441 <dig_P2+0x1>
     756:	80 93 40 04 	sts	0x0440, r24	; 0x800440 <dig_P2>
     75a:	83 85       	ldd	r24, Z+11	; 0x0b
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	98 2f       	mov	r25, r24
     760:	88 27       	eor	r24, r24
     762:	22 85       	ldd	r18, Z+10	; 0x0a
     764:	82 2b       	or	r24, r18
     766:	90 93 7b 04 	sts	0x047B, r25	; 0x80047b <dig_P3+0x1>
     76a:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <dig_P3>
     76e:	85 85       	ldd	r24, Z+13	; 0x0d
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	98 2f       	mov	r25, r24
     774:	88 27       	eor	r24, r24
     776:	24 85       	ldd	r18, Z+12	; 0x0c
     778:	82 2b       	or	r24, r18
     77a:	90 93 43 04 	sts	0x0443, r25	; 0x800443 <dig_P4+0x1>
     77e:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <dig_P4>
     782:	87 85       	ldd	r24, Z+15	; 0x0f
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	98 2f       	mov	r25, r24
     788:	88 27       	eor	r24, r24
     78a:	26 85       	ldd	r18, Z+14	; 0x0e
     78c:	82 2b       	or	r24, r18
     78e:	90 93 52 04 	sts	0x0452, r25	; 0x800452 <dig_P5+0x1>
     792:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <dig_P5>
     796:	81 89       	ldd	r24, Z+17	; 0x11
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	98 2f       	mov	r25, r24
     79c:	88 27       	eor	r24, r24
     79e:	20 89       	ldd	r18, Z+16	; 0x10
     7a0:	82 2b       	or	r24, r18
     7a2:	90 93 87 04 	sts	0x0487, r25	; 0x800487 <dig_P6+0x1>
     7a6:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <dig_P6>
     7aa:	83 89       	ldd	r24, Z+19	; 0x13
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	98 2f       	mov	r25, r24
     7b0:	88 27       	eor	r24, r24
     7b2:	22 89       	ldd	r18, Z+18	; 0x12
     7b4:	82 2b       	or	r24, r18
     7b6:	90 93 07 04 	sts	0x0407, r25	; 0x800407 <dig_P7+0x1>
     7ba:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <dig_P7>
     7be:	85 89       	ldd	r24, Z+21	; 0x15
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	98 2f       	mov	r25, r24
     7c4:	88 27       	eor	r24, r24
     7c6:	24 89       	ldd	r18, Z+20	; 0x14
     7c8:	82 2b       	or	r24, r18
     7ca:	90 93 7d 04 	sts	0x047D, r25	; 0x80047d <dig_P8+0x1>
     7ce:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <dig_P8>
     7d2:	87 89       	ldd	r24, Z+23	; 0x17
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	98 2f       	mov	r25, r24
     7d8:	88 27       	eor	r24, r24
     7da:	26 89       	ldd	r18, Z+22	; 0x16
     7dc:	82 2b       	or	r24, r18
     7de:	90 93 83 04 	sts	0x0483, r25	; 0x800483 <dig_P9+0x1>
     7e2:	80 93 82 04 	sts	0x0482, r24	; 0x800482 <dig_P9>
     7e6:	81 8d       	ldd	r24, Z+25	; 0x19
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	90 93 3b 04 	sts	0x043B, r25	; 0x80043b <dig_H1+0x1>
     7ee:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <dig_H1>
     7f2:	e5 e0       	ldi	r30, 0x05	; 5
     7f4:	f3 e0       	ldi	r31, 0x03	; 3
     7f6:	8c ee       	ldi	r24, 0xEC	; 236
     7f8:	80 83       	st	Z, r24
     7fa:	81 ee       	ldi	r24, 0xE1	; 225
     7fc:	81 83       	std	Z+1, r24	; 0x01
     7fe:	62 e0       	ldi	r22, 0x02	; 2
     800:	cf 01       	movw	r24, r30
     802:	b0 d1       	rcall	.+864    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     804:	ab d1       	rcall	.+854    	; 0xb5c <TWI_Transceiver_Busy>
     806:	81 11       	cpse	r24, r1
     808:	fd cf       	rjmp	.-6      	; 0x804 <BME_read_correction_coefficients+0x1c8>
     80a:	8d ee       	ldi	r24, 0xED	; 237
     80c:	80 93 05 03 	sts	0x0305, r24	; 0x800305 <BMEmessageBuf>
     810:	68 e0       	ldi	r22, 0x08	; 8
     812:	85 e0       	ldi	r24, 0x05	; 5
     814:	93 e0       	ldi	r25, 0x03	; 3
     816:	a6 d1       	rcall	.+844    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     818:	a1 d1       	rcall	.+834    	; 0xb5c <TWI_Transceiver_Busy>
     81a:	81 11       	cpse	r24, r1
     81c:	fd cf       	rjmp	.-6      	; 0x818 <BME_read_correction_coefficients+0x1dc>
     81e:	68 e0       	ldi	r22, 0x08	; 8
     820:	85 e0       	ldi	r24, 0x05	; 5
     822:	93 e0       	ldi	r25, 0x03	; 3
     824:	cb d1       	rcall	.+918    	; 0xbbc <TWI_Get_Data_From_Transceiver>
     826:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     82a:	2d e0       	ldi	r18, 0x0D	; 13
     82c:	33 e0       	ldi	r19, 0x03	; 3
     82e:	89 91       	ld	r24, Y+
     830:	f8 01       	movw	r30, r16
     832:	81 93       	st	Z+, r24
     834:	8f 01       	movw	r16, r30
     836:	c2 17       	cp	r28, r18
     838:	d3 07       	cpc	r29, r19
     83a:	c9 f7       	brne	.-14     	; 0x82e <BME_read_correction_coefficients+0x1f2>
     83c:	87 e0       	ldi	r24, 0x07	; 7
     83e:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <i.2424>
     842:	ee e0       	ldi	r30, 0x0E	; 14
     844:	f4 e0       	ldi	r31, 0x04	; 4
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	90 e0       	ldi	r25, 0x00	; 0
     84a:	98 2f       	mov	r25, r24
     84c:	88 27       	eor	r24, r24
     84e:	21 81       	ldd	r18, Z+1	; 0x01
     850:	82 2b       	or	r24, r18
     852:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <dig_H2+0x1>
     856:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <dig_H2>
     85a:	83 81       	ldd	r24, Z+3	; 0x03
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	90 93 81 04 	sts	0x0481, r25	; 0x800481 <dig_H3+0x1>
     862:	80 93 80 04 	sts	0x0480, r24	; 0x800480 <dig_H3>
     866:	85 81       	ldd	r24, Z+5	; 0x05
     868:	82 95       	swap	r24
     86a:	86 95       	lsr	r24
     86c:	87 70       	andi	r24, 0x07	; 7
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	24 81       	ldd	r18, Z+4	; 0x04
     872:	40 e1       	ldi	r20, 0x10	; 16
     874:	24 9f       	mul	r18, r20
     876:	90 01       	movw	r18, r0
     878:	11 24       	eor	r1, r1
     87a:	28 2b       	or	r18, r24
     87c:	39 2b       	or	r19, r25
     87e:	30 93 0b 04 	sts	0x040B, r19	; 0x80040b <dig_H4+0x1>
     882:	20 93 0a 04 	sts	0x040A, r18	; 0x80040a <dig_H4>
     886:	26 81       	ldd	r18, Z+6	; 0x06
     888:	40 e1       	ldi	r20, 0x10	; 16
     88a:	24 9f       	mul	r18, r20
     88c:	90 01       	movw	r18, r0
     88e:	11 24       	eor	r1, r1
     890:	82 2b       	or	r24, r18
     892:	93 2b       	or	r25, r19
     894:	90 93 7f 04 	sts	0x047F, r25	; 0x80047f <dig_H5+0x1>
     898:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <dig_H5>
     89c:	87 81       	ldd	r24, Z+7	; 0x07
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	90 93 4c 04 	sts	0x044C, r25	; 0x80044c <dig_H6+0x1>
     8a4:	80 93 4b 04 	sts	0x044B, r24	; 0x80044b <dig_H6>
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	08 95       	ret

000008b4 <bme280basic_init>:
     8b4:	e5 e0       	ldi	r30, 0x05	; 5
     8b6:	f3 e0       	ldi	r31, 0x03	; 3
     8b8:	8c ee       	ldi	r24, 0xEC	; 236
     8ba:	80 83       	st	Z, r24
     8bc:	80 ee       	ldi	r24, 0xE0	; 224
     8be:	81 83       	std	Z+1, r24	; 0x01
     8c0:	86 eb       	ldi	r24, 0xB6	; 182
     8c2:	82 83       	std	Z+2, r24	; 0x02
     8c4:	63 e0       	ldi	r22, 0x03	; 3
     8c6:	cf 01       	movw	r24, r30
     8c8:	4d d1       	rcall	.+666    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     8ca:	48 d1       	rcall	.+656    	; 0xb5c <TWI_Transceiver_Busy>
     8cc:	81 11       	cpse	r24, r1
     8ce:	fd cf       	rjmp	.-6      	; 0x8ca <bme280basic_init+0x16>
     8d0:	e5 e0       	ldi	r30, 0x05	; 5
     8d2:	f3 e0       	ldi	r31, 0x03	; 3
     8d4:	8c ee       	ldi	r24, 0xEC	; 236
     8d6:	80 83       	st	Z, r24
     8d8:	80 ed       	ldi	r24, 0xD0	; 208
     8da:	81 83       	std	Z+1, r24	; 0x01
     8dc:	62 e0       	ldi	r22, 0x02	; 2
     8de:	cf 01       	movw	r24, r30
     8e0:	41 d1       	rcall	.+642    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     8e2:	3c d1       	rcall	.+632    	; 0xb5c <TWI_Transceiver_Busy>
     8e4:	81 11       	cpse	r24, r1
     8e6:	fd cf       	rjmp	.-6      	; 0x8e2 <bme280basic_init+0x2e>
     8e8:	8d ee       	ldi	r24, 0xED	; 237
     8ea:	80 93 05 03 	sts	0x0305, r24	; 0x800305 <BMEmessageBuf>
     8ee:	62 e0       	ldi	r22, 0x02	; 2
     8f0:	85 e0       	ldi	r24, 0x05	; 5
     8f2:	93 e0       	ldi	r25, 0x03	; 3
     8f4:	37 d1       	rcall	.+622    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     8f6:	32 d1       	rcall	.+612    	; 0xb5c <TWI_Transceiver_Busy>
     8f8:	81 11       	cpse	r24, r1
     8fa:	fd cf       	rjmp	.-6      	; 0x8f6 <bme280basic_init+0x42>
     8fc:	62 e0       	ldi	r22, 0x02	; 2
     8fe:	85 e0       	ldi	r24, 0x05	; 5
     900:	93 e0       	ldi	r25, 0x03	; 3
     902:	5c d1       	rcall	.+696    	; 0xbbc <TWI_Get_Data_From_Transceiver>
     904:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <TWI_XFER_STATUS>
     908:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <BMEmessageBuf+0x1>
     90c:	80 36       	cpi	r24, 0x60	; 96
     90e:	69 f5       	brne	.+90     	; 0x96a <bme280basic_init+0xb6>
     910:	e5 e0       	ldi	r30, 0x05	; 5
     912:	f3 e0       	ldi	r31, 0x03	; 3
     914:	8c ee       	ldi	r24, 0xEC	; 236
     916:	80 83       	st	Z, r24
     918:	82 ef       	ldi	r24, 0xF2	; 242
     91a:	81 83       	std	Z+1, r24	; 0x01
     91c:	81 e0       	ldi	r24, 0x01	; 1
     91e:	82 83       	std	Z+2, r24	; 0x02
     920:	63 e0       	ldi	r22, 0x03	; 3
     922:	cf 01       	movw	r24, r30
     924:	1f d1       	rcall	.+574    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     926:	1a d1       	rcall	.+564    	; 0xb5c <TWI_Transceiver_Busy>
     928:	81 11       	cpse	r24, r1
     92a:	fd cf       	rjmp	.-6      	; 0x926 <bme280basic_init+0x72>
     92c:	e5 e0       	ldi	r30, 0x05	; 5
     92e:	f3 e0       	ldi	r31, 0x03	; 3
     930:	8c ee       	ldi	r24, 0xEC	; 236
     932:	80 83       	st	Z, r24
     934:	85 ef       	ldi	r24, 0xF5	; 245
     936:	81 83       	std	Z+1, r24	; 0x01
     938:	80 e1       	ldi	r24, 0x10	; 16
     93a:	82 83       	std	Z+2, r24	; 0x02
     93c:	63 e0       	ldi	r22, 0x03	; 3
     93e:	cf 01       	movw	r24, r30
     940:	11 d1       	rcall	.+546    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     942:	0c d1       	rcall	.+536    	; 0xb5c <TWI_Transceiver_Busy>
     944:	81 11       	cpse	r24, r1
     946:	fd cf       	rjmp	.-6      	; 0x942 <bme280basic_init+0x8e>
     948:	79 de       	rcall	.-782    	; 0x63c <BME_read_correction_coefficients>
     94a:	81 e3       	ldi	r24, 0x31	; 49
     94c:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <BMEtriggerbyte>
     950:	e5 e0       	ldi	r30, 0x05	; 5
     952:	f3 e0       	ldi	r31, 0x03	; 3
     954:	9c ee       	ldi	r25, 0xEC	; 236
     956:	90 83       	st	Z, r25
     958:	94 ef       	ldi	r25, 0xF4	; 244
     95a:	91 83       	std	Z+1, r25	; 0x01
     95c:	82 83       	std	Z+2, r24	; 0x02
     95e:	63 e0       	ldi	r22, 0x03	; 3
     960:	cf 01       	movw	r24, r30
     962:	00 d1       	rcall	.+512    	; 0xb64 <TWI_Start_Transceiver_With_Data>
     964:	fb d0       	rcall	.+502    	; 0xb5c <TWI_Transceiver_Busy>
     966:	81 11       	cpse	r24, r1
     968:	fd cf       	rjmp	.-6      	; 0x964 <bme280basic_init+0xb0>
     96a:	08 95       	ret

0000096c <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
     96c:	a6 dc       	rcall	.-1716   	; 0x2ba <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
     96e:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <seconds+0x1>
     972:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <seconds>
	ItsTime=0;
     976:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
     97a:	8b e2       	ldi	r24, 0x2B	; 43
     97c:	91 e0       	ldi	r25, 0x01	; 1
     97e:	90 93 91 06 	sts	0x0691, r25	; 0x800691 <__iob+0x3>
     982:	80 93 90 06 	sts	0x0690, r24	; 0x800690 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
     986:	c0 d0       	rcall	.+384    	; 0xb08 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
     988:	81 e8       	ldi	r24, 0x81	; 129
     98a:	90 e0       	ldi	r25, 0x00	; 0
     98c:	ba d1       	rcall	.+884    	; 0xd02 <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
     98e:	81 e8       	ldi	r24, 0x81	; 129
     990:	90 e0       	ldi	r25, 0x00	; 0
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
     992:	2f d2       	rcall	.+1118   	; 0xdf2 <USART1_init>
     994:	d9 d0       	rcall	.+434    	; 0xb48 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
     996:	f3 db       	rcall	.-2074   	; 0x17e <ADC_init>
     998:	dd dc       	rcall	.-1606   	; 0x354 <gas_sensors_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
     99a:	2a 9a       	sbi	0x05, 2	; 5
     99c:	2f e7       	ldi	r18, 0x7F	; 127
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
     99e:	84 e8       	ldi	r24, 0x84	; 132
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9a0:	9e e1       	ldi	r25, 0x1E	; 30
     9a2:	21 50       	subi	r18, 0x01	; 1
     9a4:	80 40       	sbci	r24, 0x00	; 0
     9a6:	90 40       	sbci	r25, 0x00	; 0
     9a8:	e1 f7       	brne	.-8      	; 0x9a2 <main+0x36>
     9aa:	00 c0       	rjmp	.+0      	; 0x9ac <main+0x40>
     9ac:	00 00       	nop
     9ae:	2a 98       	cbi	0x05, 2	; 5
     9b0:	ef e7       	ldi	r30, 0x7F	; 127
	_delay_ms(500);
	ClearBit(PORTB, PORTB2);
     9b2:	f4 e8       	ldi	r31, 0x84	; 132
     9b4:	2e e1       	ldi	r18, 0x1E	; 30
     9b6:	e1 50       	subi	r30, 0x01	; 1
     9b8:	f0 40       	sbci	r31, 0x00	; 0
     9ba:	20 40       	sbci	r18, 0x00	; 0
     9bc:	e1 f7       	brne	.-8      	; 0x9b6 <main+0x4a>
     9be:	00 c0       	rjmp	.+0      	; 0x9c0 <main+0x54>
     9c0:	00 00       	nop
	_delay_ms(500);
	// 
	// Start all interrupts
	sei();
     9c2:	78 94       	sei
	//
	// Initialize and check the BME interface...
	bme280basic_init();
     9c4:	77 df       	rcall	.-274    	; 0x8b4 <bme280basic_init>
     9c6:	81 e0       	ldi	r24, 0x01	; 1
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
     9c8:	91 e0       	ldi	r25, 0x01	; 1
     9ca:	d8 d1       	rcall	.+944    	; 0xd7c <USART0_putstring>
     9cc:	0f 2e       	mov	r0, r31
     9ce:	fa e3       	ldi	r31, 0x3A	; 58
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
     9d0:	af 2e       	mov	r10, r31
     9d2:	f1 e0       	ldi	r31, 0x01	; 1
     9d4:	bf 2e       	mov	r11, r31
     9d6:	f0 2d       	mov	r31, r0
     9d8:	0f 2e       	mov	r0, r31
     9da:	fe e8       	ldi	r31, 0x8E	; 142
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("%s",messageWant);
     9dc:	cf 2e       	mov	r12, r31
     9de:	f5 e0       	ldi	r31, 0x05	; 5
     9e0:	df 2e       	mov	r13, r31
     9e2:	f0 2d       	mov	r31, r0
     9e4:	0f 2e       	mov	r0, r31
     9e6:	f8 e4       	ldi	r31, 0x48	; 72
     9e8:	ef 2e       	mov	r14, r31
     9ea:	f1 e0       	ldi	r31, 0x01	; 1
     9ec:	ff 2e       	mov	r15, r31
     9ee:	f0 2d       	mov	r31, r0
     9f0:	0f 2e       	mov	r0, r31
     9f2:	fb e4       	ldi	r31, 0x4B	; 75
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
 			printf("LIDAR distance = %u", distance);
     9f4:	8f 2e       	mov	r8, r31
     9f6:	f1 e0       	ldi	r31, 0x01	; 1
     9f8:	9f 2e       	mov	r9, r31
     9fa:	f0 2d       	mov	r31, r0
     9fc:	c1 ee       	ldi	r28, 0xE1	; 225
     9fe:	d2 e0       	ldi	r29, 0x02	; 2
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
     a00:	0f 2e       	mov	r0, r31
     a02:	ff e5       	ldi	r31, 0x5F	; 95
     a04:	6f 2e       	mov	r6, r31
     a06:	f1 e0       	ldi	r31, 0x01	; 1
     a08:	7f 2e       	mov	r7, r31
     a0a:	f0 2d       	mov	r31, r0
     a0c:	0f 2e       	mov	r0, r31
     a0e:	f8 e6       	ldi	r31, 0x68	; 104
 			printf("\nH = %u", raw_gas_vector[1]);
     a10:	4f 2e       	mov	r4, r31
     a12:	f1 e0       	ldi	r31, 0x01	; 1
     a14:	5f 2e       	mov	r5, r31
     a16:	f0 2d       	mov	r31, r0
     a18:	0f 2e       	mov	r0, r31
     a1a:	f0 e7       	ldi	r31, 0x70	; 112
 			printf("\nNA = %u", raw_gas_vector[2]);
     a1c:	2f 2e       	mov	r2, r31
     a1e:	f1 e0       	ldi	r31, 0x01	; 1
     a20:	3f 2e       	mov	r3, r31
     a22:	f0 2d       	mov	r31, r0
     a24:	09 ec       	ldi	r16, 0xC9	; 201
     a26:	10 e0       	ldi	r17, 0x00	; 0
// 			printf("\n Humidity in percent relative humidity= %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
     a28:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <ItsTime>
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag
     a2c:	81 30       	cpi	r24, 0x01	; 1
     a2e:	e1 f7       	brne	.-8      	; 0xa28 <main+0xbc>
     a30:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <ItsTime>
			ItsTime = 0; 
     a34:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <seconds>
			seconds++;
     a38:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <seconds+0x1>
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <seconds+0x1>
     a42:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <seconds>
     a46:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <seconds>
			printf("\nSeconds = %u", seconds);
     a4a:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <seconds+0x1>
     a4e:	9f 93       	push	r25
     a50:	8f 93       	push	r24
     a52:	bf 92       	push	r11
     a54:	af 92       	push	r10
     a56:	40 d2       	rcall	.+1152   	; 0xed8 <printf>
     a58:	df 92       	push	r13
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("%s",messageWant);
     a5a:	cf 92       	push	r12
     a5c:	ff 92       	push	r15
     a5e:	ef 92       	push	r14
     a60:	3b d2       	rcall	.+1142   	; 0xed8 <printf>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	94 e3       	ldi	r25, 0x34	; 52
     a66:	ec e0       	ldi	r30, 0x0C	; 12
     a68:	81 50       	subi	r24, 0x01	; 1
     a6a:	90 40       	sbci	r25, 0x00	; 0
     a6c:	e0 40       	sbci	r30, 0x00	; 0
     a6e:	e1 f7       	brne	.-8      	; 0xa68 <main+0xfc>
     a70:	00 c0       	rjmp	.+0      	; 0xa72 <main+0x106>
     a72:	00 00       	nop
			// Now we want to read each sensor - and send out the data,
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
     a74:	87 dd       	rcall	.-1266   	; 0x584 <LIDAR_distance>
     a76:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <distance>
     a7a:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <distance+0x1>
     a7e:	9f 93       	push	r25
 			printf("LIDAR distance = %u", distance);
     a80:	8f 93       	push	r24
     a82:	9f 92       	push	r9
     a84:	8f 92       	push	r8
     a86:	28 d2       	rcall	.+1104   	; 0xed8 <printf>
     a88:	e4 dc       	rcall	.-1592   	; 0x452 <start_gas_sensor_read>
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
     a8a:	89 81       	ldd	r24, Y+1	; 0x01
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
     a8c:	8f 93       	push	r24
     a8e:	88 81       	ld	r24, Y
     a90:	8f 93       	push	r24
     a92:	7f 92       	push	r7
     a94:	6f 92       	push	r6
     a96:	20 d2       	rcall	.+1088   	; 0xed8 <printf>
     a98:	8b 81       	ldd	r24, Y+3	; 0x03
 			printf("\nH = %u", raw_gas_vector[1]);
     a9a:	8f 93       	push	r24
     a9c:	8a 81       	ldd	r24, Y+2	; 0x02
     a9e:	8f 93       	push	r24
     aa0:	5f 92       	push	r5
     aa2:	4f 92       	push	r4
     aa4:	19 d2       	rcall	.+1074   	; 0xed8 <printf>
     aa6:	8d 81       	ldd	r24, Y+5	; 0x05
 			printf("\nNA = %u", raw_gas_vector[2]);
     aa8:	8f 93       	push	r24
     aaa:	8c 81       	ldd	r24, Y+4	; 0x04
     aac:	8f 93       	push	r24
     aae:	3f 92       	push	r3
     ab0:	2f 92       	push	r2
     ab2:	12 d2       	rcall	.+1060   	; 0xed8 <printf>
     ab4:	8f 81       	ldd	r24, Y+7	; 0x07
     ab6:	8f 93       	push	r24
 			printf("\nCH4 = %u", raw_gas_vector[3]);
     ab8:	8e 81       	ldd	r24, Y+6	; 0x06
     aba:	8f 93       	push	r24
     abc:	89 e7       	ldi	r24, 0x79	; 121
     abe:	91 e0       	ldi	r25, 0x01	; 1
     ac0:	9f 93       	push	r25
     ac2:	8f 93       	push	r24
     ac4:	09 d2       	rcall	.+1042   	; 0xed8 <printf>
     ac6:	89 85       	ldd	r24, Y+9	; 0x09
     ac8:	8f 93       	push	r24
 			printf("\nO3 = %u\n", raw_gas_vector[4]);
     aca:	88 85       	ldd	r24, Y+8	; 0x08
     acc:	8f 93       	push	r24
     ace:	83 e8       	ldi	r24, 0x83	; 131
     ad0:	91 e0       	ldi	r25, 0x01	; 1
     ad2:	9f 93       	push	r25
     ad4:	8f 93       	push	r24
     ad6:	00 d2       	rcall	.+1024   	; 0xed8 <printf>
     ad8:	f8 01       	movw	r30, r16
     ada:	80 81       	ld	r24, Z
     adc:	80 69       	ori	r24, 0x90	; 144
// 			printf("\n Humidity in percent relative humidity= %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
     ade:	80 83       	st	Z, r24
     ae0:	8d b7       	in	r24, 0x3d	; 61
     ae2:	9e b7       	in	r25, 0x3e	; 62
     ae4:	80 96       	adiw	r24, 0x20	; 32
     ae6:	0f b6       	in	r0, 0x3f	; 63
     ae8:	f8 94       	cli
     aea:	9e bf       	out	0x3e, r25	; 62
     aec:	0f be       	out	0x3f, r0	; 63
     aee:	8d bf       	out	0x3d, r24	; 61
     af0:	9b cf       	rjmp	.-202    	; 0xa28 <main+0xbc>

00000af2 <__vector_default>:
     af2:	1f 92       	push	r1
     af4:	0f 92       	push	r0
     af6:	0f b6       	in	r0, 0x3f	; 63
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
     af8:	0f 92       	push	r0
     afa:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
     afc:	2a 9a       	sbi	0x05, 2	; 5
     afe:	0f 90       	pop	r0
     b00:	0f be       	out	0x3f, r0	; 63
     b02:	0f 90       	pop	r0
     b04:	1f 90       	pop	r1
     b06:	18 95       	reti

00000b08 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
     b08:	8d e0       	ldi	r24, 0x0D	; 13
     b0a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
     b0e:	8a e4       	ldi	r24, 0x4A	; 74
     b10:	9c e4       	ldi	r25, 0x4C	; 76
     b12:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     b16:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     b1a:	08 95       	ret

00000b1c <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
     b1c:	18 95       	reti

00000b1e <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
     b1e:	1f 92       	push	r1
     b20:	0f 92       	push	r0
     b22:	0f b6       	in	r0, 0x3f	; 63
     b24:	0f 92       	push	r0
     b26:	11 24       	eor	r1, r1
     b28:	8f 93       	push	r24
     b2a:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
     b2c:	95 b1       	in	r25, 0x05	; 5
     b2e:	82 e0       	ldi	r24, 0x02	; 2
     b30:	89 27       	eor	r24, r25
     b32:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
     b34:	81 e0       	ldi	r24, 0x01	; 1
     b36:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <ItsTime>
}
     b3a:	9f 91       	pop	r25
     b3c:	8f 91       	pop	r24
     b3e:	0f 90       	pop	r0
     b40:	0f be       	out	0x3f, r0	; 63
     b42:	0f 90       	pop	r0
     b44:	1f 90       	pop	r1
     b46:	18 95       	reti

00000b48 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     b48:	81 e1       	ldi	r24, 0x11	; 17
     b4a:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
     b4e:	8f ef       	ldi	r24, 0xFF	; 255
     b50:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     b54:	84 e0       	ldi	r24, 0x04	; 4
     b56:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     b5a:	08 95       	ret

00000b5c <TWI_Transceiver_Busy>:
     b5c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     b60:	81 78       	andi	r24, 0x81	; 129
     b62:	08 95       	ret

00000b64 <TWI_Start_Transceiver_With_Data>:
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	ec 01       	movw	r28, r24
     b6a:	ec eb       	ldi	r30, 0xBC	; 188
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	90 81       	ld	r25, Z
     b70:	91 78       	andi	r25, 0x81	; 129
     b72:	e9 f7       	brne	.-6      	; 0xb6e <TWI_Start_Transceiver_With_Data+0xa>
     b74:	60 93 93 01 	sts	0x0193, r22	; 0x800193 <TWI_msgSize>
     b78:	88 81       	ld	r24, Y
     b7a:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <TWI_buf>
     b7e:	80 fd       	sbrc	r24, 0
     b80:	12 c0       	rjmp	.+36     	; 0xba6 <TWI_Start_Transceiver_With_Data+0x42>
     b82:	62 30       	cpi	r22, 0x02	; 2
     b84:	80 f0       	brcs	.+32     	; 0xba6 <TWI_Start_Transceiver_With_Data+0x42>
     b86:	fe 01       	movw	r30, r28
     b88:	31 96       	adiw	r30, 0x01	; 1
     b8a:	a5 e9       	ldi	r26, 0x95	; 149
     b8c:	b1 e0       	ldi	r27, 0x01	; 1
     b8e:	62 50       	subi	r22, 0x02	; 2
     b90:	26 2f       	mov	r18, r22
     b92:	30 e0       	ldi	r19, 0x00	; 0
     b94:	2e 5f       	subi	r18, 0xFE	; 254
     b96:	3f 4f       	sbci	r19, 0xFF	; 255
     b98:	2c 0f       	add	r18, r28
     b9a:	3d 1f       	adc	r19, r29
     b9c:	91 91       	ld	r25, Z+
     b9e:	9d 93       	st	X+, r25
     ba0:	e2 17       	cp	r30, r18
     ba2:	f3 07       	cpc	r31, r19
     ba4:	d9 f7       	brne	.-10     	; 0xb9c <TWI_Start_Transceiver_With_Data+0x38>
     ba6:	10 92 92 01 	sts	0x0192, r1	; 0x800192 <TWI_statusReg>
     baa:	88 ef       	ldi	r24, 0xF8	; 248
     bac:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
     bb0:	85 ea       	ldi	r24, 0xA5	; 165
     bb2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
     bbc:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
     bbe:	ec eb       	ldi	r30, 0xBC	; 188
     bc0:	f0 e0       	ldi	r31, 0x00	; 0
     bc2:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     bc4:	91 78       	andi	r25, 0x81	; 129
     bc6:	e9 f7       	brne	.-6      	; 0xbc2 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
     bc8:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <TWI_statusReg>
     bcc:	80 ff       	sbrs	r24, 0
     bce:	11 c0       	rjmp	.+34     	; 0xbf2 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     bd0:	66 23       	and	r22, r22
     bd2:	79 f0       	breq	.+30     	; 0xbf2 <TWI_Get_Data_From_Transceiver+0x36>
     bd4:	a4 e9       	ldi	r26, 0x94	; 148
     bd6:	b1 e0       	ldi	r27, 0x01	; 1
     bd8:	fa 01       	movw	r30, r20
     bda:	61 50       	subi	r22, 0x01	; 1
     bdc:	26 2f       	mov	r18, r22
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	2f 5f       	subi	r18, 0xFF	; 255
     be2:	3f 4f       	sbci	r19, 0xFF	; 255
     be4:	24 0f       	add	r18, r20
     be6:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
     be8:	9d 91       	ld	r25, X+
     bea:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     bec:	e2 17       	cp	r30, r18
     bee:	f3 07       	cpc	r31, r19
     bf0:	d9 f7       	brne	.-10     	; 0xbe8 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
     bf2:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <TWI_statusReg>
}
     bf6:	81 70       	andi	r24, 0x01	; 1
     bf8:	08 95       	ret

00000bfa <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
     bfa:	1f 92       	push	r1
     bfc:	0f 92       	push	r0
     bfe:	0f b6       	in	r0, 0x3f	; 63
     c00:	0f 92       	push	r0
     c02:	11 24       	eor	r1, r1
     c04:	0b b6       	in	r0, 0x3b	; 59
     c06:	0f 92       	push	r0
     c08:	2f 93       	push	r18
     c0a:	3f 93       	push	r19
     c0c:	8f 93       	push	r24
     c0e:	9f 93       	push	r25
     c10:	af 93       	push	r26
     c12:	bf 93       	push	r27
     c14:	ef 93       	push	r30
     c16:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
     c18:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
     c1c:	8e 2f       	mov	r24, r30
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	fc 01       	movw	r30, r24
     c22:	38 97       	sbiw	r30, 0x08	; 8
     c24:	e1 35       	cpi	r30, 0x51	; 81
     c26:	f1 05       	cpc	r31, r1
     c28:	08 f0       	brcs	.+2      	; 0xc2c <__vector_26+0x32>
     c2a:	55 c0       	rjmp	.+170    	; 0xcd6 <__vector_26+0xdc>
     c2c:	ea 5b       	subi	r30, 0xBA	; 186
     c2e:	ff 4f       	sbci	r31, 0xFF	; 255
     c30:	4a c1       	rjmp	.+660    	; 0xec6 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
     c32:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <TWI_bufPtr.1674>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
     c36:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <TWI_bufPtr.1674>
     c3a:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <TWI_msgSize>
     c3e:	e8 17       	cp	r30, r24
     c40:	70 f4       	brcc	.+28     	; 0xc5e <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
     c42:	81 e0       	ldi	r24, 0x01	; 1
     c44:	8e 0f       	add	r24, r30
     c46:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <TWI_bufPtr.1674>
     c4a:	f0 e0       	ldi	r31, 0x00	; 0
     c4c:	ec 56       	subi	r30, 0x6C	; 108
     c4e:	fe 4f       	sbci	r31, 0xFE	; 254
     c50:	80 81       	ld	r24, Z
     c52:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     c56:	85 e8       	ldi	r24, 0x85	; 133
     c58:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     c5c:	43 c0       	rjmp	.+134    	; 0xce4 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
     c5e:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <TWI_statusReg>
     c62:	81 60       	ori	r24, 0x01	; 1
     c64:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     c68:	84 e9       	ldi	r24, 0x94	; 148
     c6a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     c6e:	3a c0       	rjmp	.+116    	; 0xce4 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
     c70:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <TWI_bufPtr.1674>
     c74:	81 e0       	ldi	r24, 0x01	; 1
     c76:	8e 0f       	add	r24, r30
     c78:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <TWI_bufPtr.1674>
     c7c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	ec 56       	subi	r30, 0x6C	; 108
     c84:	fe 4f       	sbci	r31, 0xFE	; 254
     c86:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
     c88:	20 91 91 01 	lds	r18, 0x0191	; 0x800191 <TWI_bufPtr.1674>
     c8c:	30 e0       	ldi	r19, 0x00	; 0
     c8e:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <TWI_msgSize>
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	28 17       	cp	r18, r24
     c98:	39 07       	cpc	r19, r25
     c9a:	24 f4       	brge	.+8      	; 0xca4 <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     c9c:	85 ec       	ldi	r24, 0xC5	; 197
     c9e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     ca2:	20 c0       	rjmp	.+64     	; 0xce4 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     ca4:	85 e8       	ldi	r24, 0x85	; 133
     ca6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     caa:	1c c0       	rjmp	.+56     	; 0xce4 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
     cac:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     cb0:	e0 91 91 01 	lds	r30, 0x0191	; 0x800191 <TWI_bufPtr.1674>
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	ec 56       	subi	r30, 0x6C	; 108
     cb8:	fe 4f       	sbci	r31, 0xFE	; 254
     cba:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
     cbc:	80 91 92 01 	lds	r24, 0x0192	; 0x800192 <TWI_statusReg>
     cc0:	81 60       	ori	r24, 0x01	; 1
     cc2:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     cc6:	84 e9       	ldi	r24, 0x94	; 148
     cc8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
     ccc:	0b c0       	rjmp	.+22     	; 0xce4 <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     cce:	85 ea       	ldi	r24, 0xA5	; 165
     cd0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
     cd4:	07 c0       	rjmp	.+14     	; 0xce4 <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     cd6:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
     cda:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
     cde:	84 e0       	ldi	r24, 0x04	; 4
     ce0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
     ce4:	ff 91       	pop	r31
     ce6:	ef 91       	pop	r30
     ce8:	bf 91       	pop	r27
     cea:	af 91       	pop	r26
     cec:	9f 91       	pop	r25
     cee:	8f 91       	pop	r24
     cf0:	3f 91       	pop	r19
     cf2:	2f 91       	pop	r18
     cf4:	0f 90       	pop	r0
     cf6:	0b be       	out	0x3b, r0	; 59
     cf8:	0f 90       	pop	r0
     cfa:	0f be       	out	0x3f, r0	; 63
     cfc:	0f 90       	pop	r0
     cfe:	1f 90       	pop	r1
     d00:	18 95       	reti

00000d02 <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
     d02:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     d06:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     d0a:	88 e0       	ldi	r24, 0x08	; 8
     d0c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     d10:	86 e0       	ldi	r24, 0x06	; 6
     d12:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     d16:	10 92 a6 02 	sts	0x02A6, r1	; 0x8002a6 <UART0_RxTail>
     d1a:	10 92 a7 02 	sts	0x02A7, r1	; 0x8002a7 <UART0_RxHead>
     d1e:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <UART0_TxTail>
     d22:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <UART0_TxHead>
     d26:	08 95       	ret

00000d28 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
     d28:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <UART0_TxHead>
     d2c:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
     d2e:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <UART0_TxTail>
     d32:	29 17       	cp	r18, r25
     d34:	e1 f3       	breq	.-8      	; 0xd2e <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
     d36:	e2 2f       	mov	r30, r18
     d38:	f0 e0       	ldi	r31, 0x00	; 0
     d3a:	ea 55       	subi	r30, 0x5A	; 90
     d3c:	fe 4f       	sbci	r31, 0xFE	; 254
     d3e:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
     d40:	20 93 a5 01 	sts	0x01A5, r18	; 0x8001a5 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
     d44:	e1 ec       	ldi	r30, 0xC1	; 193
     d46:	f0 e0       	ldi	r31, 0x00	; 0
     d48:	80 81       	ld	r24, Z
     d4a:	80 62       	ori	r24, 0x20	; 32
     d4c:	80 83       	st	Z, r24
     d4e:	08 95       	ret

00000d50 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
     d50:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <UART0_TxHead>
     d54:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
     d56:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <UART0_TxTail>
     d5a:	29 17       	cp	r18, r25
     d5c:	e1 f3       	breq	.-8      	; 0xd56 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
     d5e:	e2 2f       	mov	r30, r18
     d60:	f0 e0       	ldi	r31, 0x00	; 0
     d62:	ea 55       	subi	r30, 0x5A	; 90
     d64:	fe 4f       	sbci	r31, 0xFE	; 254
     d66:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
     d68:	20 93 a5 01 	sts	0x01A5, r18	; 0x8001a5 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
     d6c:	e1 ec       	ldi	r30, 0xC1	; 193
     d6e:	f0 e0       	ldi	r31, 0x00	; 0
     d70:	80 81       	ld	r24, Z
     d72:	80 62       	ori	r24, 0x20	; 32
     d74:	80 83       	st	Z, r24
	return(0);
}
     d76:	80 e0       	ldi	r24, 0x00	; 0
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	08 95       	ret

00000d7c <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
     d7c:	cf 93       	push	r28
     d7e:	df 93       	push	r29
     d80:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
     d82:	88 81       	ld	r24, Y
     d84:	88 23       	and	r24, r24
     d86:	29 f0       	breq	.+10     	; 0xd92 <USART0_putstring+0x16>
     d88:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
     d8a:	ce df       	rcall	.-100    	; 0xd28 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
     d8c:	89 91       	ld	r24, Y+
     d8e:	81 11       	cpse	r24, r1
     d90:	fc cf       	rjmp	.-8      	; 0xd8a <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
     d92:	df 91       	pop	r29
     d94:	cf 91       	pop	r28
     d96:	08 95       	ret

00000d98 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
     d98:	1f 92       	push	r1
     d9a:	0f 92       	push	r0
     d9c:	0f b6       	in	r0, 0x3f	; 63
     d9e:	0f 92       	push	r0
     da0:	11 24       	eor	r1, r1
     da2:	0b b6       	in	r0, 0x3b	; 59
     da4:	0f 92       	push	r0
     da6:	8f 93       	push	r24
     da8:	9f 93       	push	r25
     daa:	ef 93       	push	r30
     dac:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
     dae:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <UART0_TxHead>
     db2:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <UART0_TxTail>
     db6:	98 17       	cp	r25, r24
     db8:	61 f0       	breq	.+24     	; 0xdd2 <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
     dba:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <UART0_TxTail>
     dbe:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
     dc0:	e0 93 a4 01 	sts	0x01A4, r30	; 0x8001a4 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
     dc4:	f0 e0       	ldi	r31, 0x00	; 0
     dc6:	ea 55       	subi	r30, 0x5A	; 90
     dc8:	fe 4f       	sbci	r31, 0xFE	; 254
     dca:	80 81       	ld	r24, Z
     dcc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     dd0:	05 c0       	rjmp	.+10     	; 0xddc <__vector_21+0x44>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
     dd2:	e1 ec       	ldi	r30, 0xC1	; 193
     dd4:	f0 e0       	ldi	r31, 0x00	; 0
     dd6:	80 81       	ld	r24, Z
     dd8:	8f 7d       	andi	r24, 0xDF	; 223
     dda:	80 83       	st	Z, r24
	}
     ddc:	ff 91       	pop	r31
     dde:	ef 91       	pop	r30
     de0:	9f 91       	pop	r25
     de2:	8f 91       	pop	r24
     de4:	0f 90       	pop	r0
     de6:	0b be       	out	0x3b, r0	; 59
     de8:	0f 90       	pop	r0
     dea:	0f be       	out	0x3f, r0	; 63
     dec:	0f 90       	pop	r0
     dee:	1f 90       	pop	r1
     df0:	18 95       	reti

00000df2 <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
     df2:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     df6:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     dfa:	80 e9       	ldi	r24, 0x90	; 144
     dfc:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
     e00:	86 e0       	ldi	r24, 0x06	; 6
     e02:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
     e06:	10 92 aa 02 	sts	0x02AA, r1	; 0x8002aa <UART1_RxTail>
     e0a:	10 92 ab 02 	sts	0x02AB, r1	; 0x8002ab <UART1_RxHead>
     e0e:	10 92 a8 02 	sts	0x02A8, r1	; 0x8002a8 <UART1_TxTail>
     e12:	10 92 a9 02 	sts	0x02A9, r1	; 0x8002a9 <UART1_TxHead>
     e16:	08 95       	ret

00000e18 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
     e18:	1f 92       	push	r1
     e1a:	0f 92       	push	r0
     e1c:	0f b6       	in	r0, 0x3f	; 63
     e1e:	0f 92       	push	r0
     e20:	11 24       	eor	r1, r1
     e22:	0b b6       	in	r0, 0x3b	; 59
     e24:	0f 92       	push	r0
     e26:	2f 93       	push	r18
     e28:	3f 93       	push	r19
     e2a:	8f 93       	push	r24
     e2c:	9f 93       	push	r25
     e2e:	af 93       	push	r26
     e30:	bf 93       	push	r27
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	ef 93       	push	r30
     e38:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
     e3a:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
     e3e:	80 91 ab 02 	lds	r24, 0x02AB	; 0x8002ab <UART1_RxHead>
     e42:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
     e44:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
     e48:	20 91 aa 02 	lds	r18, 0x02AA	; 0x8002aa <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
     e4c:	e8 2f       	mov	r30, r24
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	e2 57       	subi	r30, 0x72	; 114
     e52:	fb 4f       	sbci	r31, 0xFB	; 251
     e54:	90 83       	st	Z, r25
	
	if (data == 10)
     e56:	9a 30       	cpi	r25, 0x0A	; 10
     e58:	29 f5       	brne	.+74     	; 0xea4 <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
     e5a:	90 91 93 04 	lds	r25, 0x0493	; 0x800493 <UART1_RxBuf+0x5>
     e5e:	97 34       	cpi	r25, 0x47	; 71
     e60:	e9 f4       	brne	.+58     	; 0xe9c <__vector_28+0x84>
     e62:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
     e64:	2e 2f       	mov	r18, r30
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	d9 01       	movw	r26, r18
     e6a:	a2 57       	subi	r26, 0x72	; 114
     e6c:	ba 4f       	sbci	r27, 0xFA	; 250
     e6e:	e9 01       	movw	r28, r18
     e70:	c2 57       	subi	r28, 0x72	; 114
     e72:	db 4f       	sbci	r29, 0xFB	; 251
     e74:	99 81       	ldd	r25, Y+1	; 0x01
     e76:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
     e78:	ef 5f       	subi	r30, 0xFF	; 255
     e7a:	8e 17       	cp	r24, r30
     e7c:	98 f7       	brcc	.-26     	; 0xe64 <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i]=0x00; //messageWant[i+1]=0x00;
     e7e:	f0 e0       	ldi	r31, 0x00	; 0
     e80:	e2 57       	subi	r30, 0x72	; 114
     e82:	fa 4f       	sbci	r31, 0xFA	; 250
     e84:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
     e86:	e9 ec       	ldi	r30, 0xC9	; 201
     e88:	f0 e0       	ldi	r31, 0x00	; 0
     e8a:	80 81       	ld	r24, Z
     e8c:	10 82       	st	Z, r1
 			ItsTime = 1;
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <ItsTime>
 			ToggleBit(PORTB, PORTB1);
     e94:	95 b1       	in	r25, 0x05	; 5
     e96:	82 e0       	ldi	r24, 0x02	; 2
     e98:	89 27       	eor	r24, r25
     e9a:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
     e9c:	10 92 aa 02 	sts	0x02AA, r1	; 0x8002aa <UART1_RxTail>
		UART1_RxHead = 0;
     ea0:	10 92 ab 02 	sts	0x02AB, r1	; 0x8002ab <UART1_RxHead>
	}
}
     ea4:	ff 91       	pop	r31
     ea6:	ef 91       	pop	r30
     ea8:	df 91       	pop	r29
     eaa:	cf 91       	pop	r28
     eac:	bf 91       	pop	r27
     eae:	af 91       	pop	r26
     eb0:	9f 91       	pop	r25
     eb2:	8f 91       	pop	r24
     eb4:	3f 91       	pop	r19
     eb6:	2f 91       	pop	r18
     eb8:	0f 90       	pop	r0
     eba:	0b be       	out	0x3b, r0	; 59
     ebc:	0f 90       	pop	r0
     ebe:	0f be       	out	0x3f, r0	; 63
     ec0:	0f 90       	pop	r0
     ec2:	1f 90       	pop	r1
     ec4:	18 95       	reti

00000ec6 <__tablejump2__>:
     ec6:	ee 0f       	add	r30, r30
     ec8:	ff 1f       	adc	r31, r31
     eca:	00 24       	eor	r0, r0
     ecc:	00 1c       	adc	r0, r0
     ece:	0b be       	out	0x3b, r0	; 59
     ed0:	07 90       	elpm	r0, Z+
     ed2:	f6 91       	elpm	r31, Z
     ed4:	e0 2d       	mov	r30, r0
     ed6:	09 94       	ijmp

00000ed8 <printf>:
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	cd b7       	in	r28, 0x3d	; 61
     ede:	de b7       	in	r29, 0x3e	; 62
     ee0:	ae 01       	movw	r20, r28
     ee2:	4b 5f       	subi	r20, 0xFB	; 251
     ee4:	5f 4f       	sbci	r21, 0xFF	; 255
     ee6:	fa 01       	movw	r30, r20
     ee8:	61 91       	ld	r22, Z+
     eea:	71 91       	ld	r23, Z+
     eec:	af 01       	movw	r20, r30
     eee:	80 91 90 06 	lds	r24, 0x0690	; 0x800690 <__iob+0x2>
     ef2:	90 91 91 06 	lds	r25, 0x0691	; 0x800691 <__iob+0x3>
     ef6:	03 d0       	rcall	.+6      	; 0xefe <vfprintf>
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	08 95       	ret

00000efe <vfprintf>:
     efe:	2f 92       	push	r2
     f00:	3f 92       	push	r3
     f02:	4f 92       	push	r4
     f04:	5f 92       	push	r5
     f06:	6f 92       	push	r6
     f08:	7f 92       	push	r7
     f0a:	8f 92       	push	r8
     f0c:	9f 92       	push	r9
     f0e:	af 92       	push	r10
     f10:	bf 92       	push	r11
     f12:	cf 92       	push	r12
     f14:	df 92       	push	r13
     f16:	ef 92       	push	r14
     f18:	ff 92       	push	r15
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	cd b7       	in	r28, 0x3d	; 61
     f24:	de b7       	in	r29, 0x3e	; 62
     f26:	2b 97       	sbiw	r28, 0x0b	; 11
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	cd bf       	out	0x3d, r28	; 61
     f32:	6c 01       	movw	r12, r24
     f34:	7b 01       	movw	r14, r22
     f36:	8a 01       	movw	r16, r20
     f38:	fc 01       	movw	r30, r24
     f3a:	17 82       	std	Z+7, r1	; 0x07
     f3c:	16 82       	std	Z+6, r1	; 0x06
     f3e:	83 81       	ldd	r24, Z+3	; 0x03
     f40:	81 ff       	sbrs	r24, 1
     f42:	bf c1       	rjmp	.+894    	; 0x12c2 <vfprintf+0x3c4>
     f44:	ce 01       	movw	r24, r28
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	3c 01       	movw	r6, r24
     f4a:	f6 01       	movw	r30, r12
     f4c:	93 81       	ldd	r25, Z+3	; 0x03
     f4e:	f7 01       	movw	r30, r14
     f50:	93 fd       	sbrc	r25, 3
     f52:	85 91       	lpm	r24, Z+
     f54:	93 ff       	sbrs	r25, 3
     f56:	81 91       	ld	r24, Z+
     f58:	7f 01       	movw	r14, r30
     f5a:	88 23       	and	r24, r24
     f5c:	09 f4       	brne	.+2      	; 0xf60 <vfprintf+0x62>
     f5e:	ad c1       	rjmp	.+858    	; 0x12ba <vfprintf+0x3bc>
     f60:	85 32       	cpi	r24, 0x25	; 37
     f62:	39 f4       	brne	.+14     	; 0xf72 <vfprintf+0x74>
     f64:	93 fd       	sbrc	r25, 3
     f66:	85 91       	lpm	r24, Z+
     f68:	93 ff       	sbrs	r25, 3
     f6a:	81 91       	ld	r24, Z+
     f6c:	7f 01       	movw	r14, r30
     f6e:	85 32       	cpi	r24, 0x25	; 37
     f70:	21 f4       	brne	.+8      	; 0xf7a <vfprintf+0x7c>
     f72:	b6 01       	movw	r22, r12
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	d6 d1       	rcall	.+940    	; 0x1324 <fputc>
     f78:	e8 cf       	rjmp	.-48     	; 0xf4a <vfprintf+0x4c>
     f7a:	91 2c       	mov	r9, r1
     f7c:	21 2c       	mov	r2, r1
     f7e:	31 2c       	mov	r3, r1
     f80:	ff e1       	ldi	r31, 0x1F	; 31
     f82:	f3 15       	cp	r31, r3
     f84:	d8 f0       	brcs	.+54     	; 0xfbc <vfprintf+0xbe>
     f86:	8b 32       	cpi	r24, 0x2B	; 43
     f88:	79 f0       	breq	.+30     	; 0xfa8 <vfprintf+0xaa>
     f8a:	38 f4       	brcc	.+14     	; 0xf9a <vfprintf+0x9c>
     f8c:	80 32       	cpi	r24, 0x20	; 32
     f8e:	79 f0       	breq	.+30     	; 0xfae <vfprintf+0xb0>
     f90:	83 32       	cpi	r24, 0x23	; 35
     f92:	a1 f4       	brne	.+40     	; 0xfbc <vfprintf+0xbe>
     f94:	23 2d       	mov	r18, r3
     f96:	20 61       	ori	r18, 0x10	; 16
     f98:	1d c0       	rjmp	.+58     	; 0xfd4 <vfprintf+0xd6>
     f9a:	8d 32       	cpi	r24, 0x2D	; 45
     f9c:	61 f0       	breq	.+24     	; 0xfb6 <vfprintf+0xb8>
     f9e:	80 33       	cpi	r24, 0x30	; 48
     fa0:	69 f4       	brne	.+26     	; 0xfbc <vfprintf+0xbe>
     fa2:	23 2d       	mov	r18, r3
     fa4:	21 60       	ori	r18, 0x01	; 1
     fa6:	16 c0       	rjmp	.+44     	; 0xfd4 <vfprintf+0xd6>
     fa8:	83 2d       	mov	r24, r3
     faa:	82 60       	ori	r24, 0x02	; 2
     fac:	38 2e       	mov	r3, r24
     fae:	e3 2d       	mov	r30, r3
     fb0:	e4 60       	ori	r30, 0x04	; 4
     fb2:	3e 2e       	mov	r3, r30
     fb4:	2a c0       	rjmp	.+84     	; 0x100a <vfprintf+0x10c>
     fb6:	f3 2d       	mov	r31, r3
     fb8:	f8 60       	ori	r31, 0x08	; 8
     fba:	1d c0       	rjmp	.+58     	; 0xff6 <vfprintf+0xf8>
     fbc:	37 fc       	sbrc	r3, 7
     fbe:	2d c0       	rjmp	.+90     	; 0x101a <vfprintf+0x11c>
     fc0:	20 ed       	ldi	r18, 0xD0	; 208
     fc2:	28 0f       	add	r18, r24
     fc4:	2a 30       	cpi	r18, 0x0A	; 10
     fc6:	40 f0       	brcs	.+16     	; 0xfd8 <vfprintf+0xda>
     fc8:	8e 32       	cpi	r24, 0x2E	; 46
     fca:	b9 f4       	brne	.+46     	; 0xffa <vfprintf+0xfc>
     fcc:	36 fc       	sbrc	r3, 6
     fce:	75 c1       	rjmp	.+746    	; 0x12ba <vfprintf+0x3bc>
     fd0:	23 2d       	mov	r18, r3
     fd2:	20 64       	ori	r18, 0x40	; 64
     fd4:	32 2e       	mov	r3, r18
     fd6:	19 c0       	rjmp	.+50     	; 0x100a <vfprintf+0x10c>
     fd8:	36 fe       	sbrs	r3, 6
     fda:	06 c0       	rjmp	.+12     	; 0xfe8 <vfprintf+0xea>
     fdc:	8a e0       	ldi	r24, 0x0A	; 10
     fde:	98 9e       	mul	r9, r24
     fe0:	20 0d       	add	r18, r0
     fe2:	11 24       	eor	r1, r1
     fe4:	92 2e       	mov	r9, r18
     fe6:	11 c0       	rjmp	.+34     	; 0x100a <vfprintf+0x10c>
     fe8:	ea e0       	ldi	r30, 0x0A	; 10
     fea:	2e 9e       	mul	r2, r30
     fec:	20 0d       	add	r18, r0
     fee:	11 24       	eor	r1, r1
     ff0:	22 2e       	mov	r2, r18
     ff2:	f3 2d       	mov	r31, r3
     ff4:	f0 62       	ori	r31, 0x20	; 32
     ff6:	3f 2e       	mov	r3, r31
     ff8:	08 c0       	rjmp	.+16     	; 0x100a <vfprintf+0x10c>
     ffa:	8c 36       	cpi	r24, 0x6C	; 108
     ffc:	21 f4       	brne	.+8      	; 0x1006 <vfprintf+0x108>
     ffe:	83 2d       	mov	r24, r3
    1000:	80 68       	ori	r24, 0x80	; 128
    1002:	38 2e       	mov	r3, r24
    1004:	02 c0       	rjmp	.+4      	; 0x100a <vfprintf+0x10c>
    1006:	88 36       	cpi	r24, 0x68	; 104
    1008:	41 f4       	brne	.+16     	; 0x101a <vfprintf+0x11c>
    100a:	f7 01       	movw	r30, r14
    100c:	93 fd       	sbrc	r25, 3
    100e:	85 91       	lpm	r24, Z+
    1010:	93 ff       	sbrs	r25, 3
    1012:	81 91       	ld	r24, Z+
    1014:	7f 01       	movw	r14, r30
    1016:	81 11       	cpse	r24, r1
    1018:	b3 cf       	rjmp	.-154    	; 0xf80 <vfprintf+0x82>
    101a:	98 2f       	mov	r25, r24
    101c:	9f 7d       	andi	r25, 0xDF	; 223
    101e:	95 54       	subi	r25, 0x45	; 69
    1020:	93 30       	cpi	r25, 0x03	; 3
    1022:	28 f4       	brcc	.+10     	; 0x102e <vfprintf+0x130>
    1024:	0c 5f       	subi	r16, 0xFC	; 252
    1026:	1f 4f       	sbci	r17, 0xFF	; 255
    1028:	9f e3       	ldi	r25, 0x3F	; 63
    102a:	99 83       	std	Y+1, r25	; 0x01
    102c:	0d c0       	rjmp	.+26     	; 0x1048 <vfprintf+0x14a>
    102e:	83 36       	cpi	r24, 0x63	; 99
    1030:	31 f0       	breq	.+12     	; 0x103e <vfprintf+0x140>
    1032:	83 37       	cpi	r24, 0x73	; 115
    1034:	71 f0       	breq	.+28     	; 0x1052 <vfprintf+0x154>
    1036:	83 35       	cpi	r24, 0x53	; 83
    1038:	09 f0       	breq	.+2      	; 0x103c <vfprintf+0x13e>
    103a:	55 c0       	rjmp	.+170    	; 0x10e6 <vfprintf+0x1e8>
    103c:	20 c0       	rjmp	.+64     	; 0x107e <vfprintf+0x180>
    103e:	f8 01       	movw	r30, r16
    1040:	80 81       	ld	r24, Z
    1042:	89 83       	std	Y+1, r24	; 0x01
    1044:	0e 5f       	subi	r16, 0xFE	; 254
    1046:	1f 4f       	sbci	r17, 0xFF	; 255
    1048:	88 24       	eor	r8, r8
    104a:	83 94       	inc	r8
    104c:	91 2c       	mov	r9, r1
    104e:	53 01       	movw	r10, r6
    1050:	12 c0       	rjmp	.+36     	; 0x1076 <vfprintf+0x178>
    1052:	28 01       	movw	r4, r16
    1054:	f2 e0       	ldi	r31, 0x02	; 2
    1056:	4f 0e       	add	r4, r31
    1058:	51 1c       	adc	r5, r1
    105a:	f8 01       	movw	r30, r16
    105c:	a0 80       	ld	r10, Z
    105e:	b1 80       	ldd	r11, Z+1	; 0x01
    1060:	36 fe       	sbrs	r3, 6
    1062:	03 c0       	rjmp	.+6      	; 0x106a <vfprintf+0x16c>
    1064:	69 2d       	mov	r22, r9
    1066:	70 e0       	ldi	r23, 0x00	; 0
    1068:	02 c0       	rjmp	.+4      	; 0x106e <vfprintf+0x170>
    106a:	6f ef       	ldi	r22, 0xFF	; 255
    106c:	7f ef       	ldi	r23, 0xFF	; 255
    106e:	c5 01       	movw	r24, r10
    1070:	4e d1       	rcall	.+668    	; 0x130e <strnlen>
    1072:	4c 01       	movw	r8, r24
    1074:	82 01       	movw	r16, r4
    1076:	f3 2d       	mov	r31, r3
    1078:	ff 77       	andi	r31, 0x7F	; 127
    107a:	3f 2e       	mov	r3, r31
    107c:	15 c0       	rjmp	.+42     	; 0x10a8 <vfprintf+0x1aa>
    107e:	28 01       	movw	r4, r16
    1080:	22 e0       	ldi	r18, 0x02	; 2
    1082:	42 0e       	add	r4, r18
    1084:	51 1c       	adc	r5, r1
    1086:	f8 01       	movw	r30, r16
    1088:	a0 80       	ld	r10, Z
    108a:	b1 80       	ldd	r11, Z+1	; 0x01
    108c:	36 fe       	sbrs	r3, 6
    108e:	03 c0       	rjmp	.+6      	; 0x1096 <vfprintf+0x198>
    1090:	69 2d       	mov	r22, r9
    1092:	70 e0       	ldi	r23, 0x00	; 0
    1094:	02 c0       	rjmp	.+4      	; 0x109a <vfprintf+0x19c>
    1096:	6f ef       	ldi	r22, 0xFF	; 255
    1098:	7f ef       	ldi	r23, 0xFF	; 255
    109a:	c5 01       	movw	r24, r10
    109c:	2d d1       	rcall	.+602    	; 0x12f8 <strnlen_P>
    109e:	4c 01       	movw	r8, r24
    10a0:	f3 2d       	mov	r31, r3
    10a2:	f0 68       	ori	r31, 0x80	; 128
    10a4:	3f 2e       	mov	r3, r31
    10a6:	82 01       	movw	r16, r4
    10a8:	33 fc       	sbrc	r3, 3
    10aa:	19 c0       	rjmp	.+50     	; 0x10de <vfprintf+0x1e0>
    10ac:	82 2d       	mov	r24, r2
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	88 16       	cp	r8, r24
    10b2:	99 06       	cpc	r9, r25
    10b4:	a0 f4       	brcc	.+40     	; 0x10de <vfprintf+0x1e0>
    10b6:	b6 01       	movw	r22, r12
    10b8:	80 e2       	ldi	r24, 0x20	; 32
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	33 d1       	rcall	.+614    	; 0x1324 <fputc>
    10be:	2a 94       	dec	r2
    10c0:	f5 cf       	rjmp	.-22     	; 0x10ac <vfprintf+0x1ae>
    10c2:	f5 01       	movw	r30, r10
    10c4:	37 fc       	sbrc	r3, 7
    10c6:	85 91       	lpm	r24, Z+
    10c8:	37 fe       	sbrs	r3, 7
    10ca:	81 91       	ld	r24, Z+
    10cc:	5f 01       	movw	r10, r30
    10ce:	b6 01       	movw	r22, r12
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	28 d1       	rcall	.+592    	; 0x1324 <fputc>
    10d4:	21 10       	cpse	r2, r1
    10d6:	2a 94       	dec	r2
    10d8:	21 e0       	ldi	r18, 0x01	; 1
    10da:	82 1a       	sub	r8, r18
    10dc:	91 08       	sbc	r9, r1
    10de:	81 14       	cp	r8, r1
    10e0:	91 04       	cpc	r9, r1
    10e2:	79 f7       	brne	.-34     	; 0x10c2 <vfprintf+0x1c4>
    10e4:	e1 c0       	rjmp	.+450    	; 0x12a8 <vfprintf+0x3aa>
    10e6:	84 36       	cpi	r24, 0x64	; 100
    10e8:	11 f0       	breq	.+4      	; 0x10ee <vfprintf+0x1f0>
    10ea:	89 36       	cpi	r24, 0x69	; 105
    10ec:	39 f5       	brne	.+78     	; 0x113c <vfprintf+0x23e>
    10ee:	f8 01       	movw	r30, r16
    10f0:	37 fe       	sbrs	r3, 7
    10f2:	07 c0       	rjmp	.+14     	; 0x1102 <vfprintf+0x204>
    10f4:	60 81       	ld	r22, Z
    10f6:	71 81       	ldd	r23, Z+1	; 0x01
    10f8:	82 81       	ldd	r24, Z+2	; 0x02
    10fa:	93 81       	ldd	r25, Z+3	; 0x03
    10fc:	0c 5f       	subi	r16, 0xFC	; 252
    10fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1100:	08 c0       	rjmp	.+16     	; 0x1112 <vfprintf+0x214>
    1102:	60 81       	ld	r22, Z
    1104:	71 81       	ldd	r23, Z+1	; 0x01
    1106:	07 2e       	mov	r0, r23
    1108:	00 0c       	add	r0, r0
    110a:	88 0b       	sbc	r24, r24
    110c:	99 0b       	sbc	r25, r25
    110e:	0e 5f       	subi	r16, 0xFE	; 254
    1110:	1f 4f       	sbci	r17, 0xFF	; 255
    1112:	f3 2d       	mov	r31, r3
    1114:	ff 76       	andi	r31, 0x6F	; 111
    1116:	3f 2e       	mov	r3, r31
    1118:	97 ff       	sbrs	r25, 7
    111a:	09 c0       	rjmp	.+18     	; 0x112e <vfprintf+0x230>
    111c:	90 95       	com	r25
    111e:	80 95       	com	r24
    1120:	70 95       	com	r23
    1122:	61 95       	neg	r22
    1124:	7f 4f       	sbci	r23, 0xFF	; 255
    1126:	8f 4f       	sbci	r24, 0xFF	; 255
    1128:	9f 4f       	sbci	r25, 0xFF	; 255
    112a:	f0 68       	ori	r31, 0x80	; 128
    112c:	3f 2e       	mov	r3, r31
    112e:	2a e0       	ldi	r18, 0x0A	; 10
    1130:	30 e0       	ldi	r19, 0x00	; 0
    1132:	a3 01       	movw	r20, r6
    1134:	33 d1       	rcall	.+614    	; 0x139c <__ultoa_invert>
    1136:	88 2e       	mov	r8, r24
    1138:	86 18       	sub	r8, r6
    113a:	44 c0       	rjmp	.+136    	; 0x11c4 <vfprintf+0x2c6>
    113c:	85 37       	cpi	r24, 0x75	; 117
    113e:	31 f4       	brne	.+12     	; 0x114c <vfprintf+0x24e>
    1140:	23 2d       	mov	r18, r3
    1142:	2f 7e       	andi	r18, 0xEF	; 239
    1144:	b2 2e       	mov	r11, r18
    1146:	2a e0       	ldi	r18, 0x0A	; 10
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	25 c0       	rjmp	.+74     	; 0x1196 <vfprintf+0x298>
    114c:	93 2d       	mov	r25, r3
    114e:	99 7f       	andi	r25, 0xF9	; 249
    1150:	b9 2e       	mov	r11, r25
    1152:	8f 36       	cpi	r24, 0x6F	; 111
    1154:	c1 f0       	breq	.+48     	; 0x1186 <vfprintf+0x288>
    1156:	18 f4       	brcc	.+6      	; 0x115e <vfprintf+0x260>
    1158:	88 35       	cpi	r24, 0x58	; 88
    115a:	79 f0       	breq	.+30     	; 0x117a <vfprintf+0x27c>
    115c:	ae c0       	rjmp	.+348    	; 0x12ba <vfprintf+0x3bc>
    115e:	80 37       	cpi	r24, 0x70	; 112
    1160:	19 f0       	breq	.+6      	; 0x1168 <vfprintf+0x26a>
    1162:	88 37       	cpi	r24, 0x78	; 120
    1164:	21 f0       	breq	.+8      	; 0x116e <vfprintf+0x270>
    1166:	a9 c0       	rjmp	.+338    	; 0x12ba <vfprintf+0x3bc>
    1168:	e9 2f       	mov	r30, r25
    116a:	e0 61       	ori	r30, 0x10	; 16
    116c:	be 2e       	mov	r11, r30
    116e:	b4 fe       	sbrs	r11, 4
    1170:	0d c0       	rjmp	.+26     	; 0x118c <vfprintf+0x28e>
    1172:	fb 2d       	mov	r31, r11
    1174:	f4 60       	ori	r31, 0x04	; 4
    1176:	bf 2e       	mov	r11, r31
    1178:	09 c0       	rjmp	.+18     	; 0x118c <vfprintf+0x28e>
    117a:	34 fe       	sbrs	r3, 4
    117c:	0a c0       	rjmp	.+20     	; 0x1192 <vfprintf+0x294>
    117e:	29 2f       	mov	r18, r25
    1180:	26 60       	ori	r18, 0x06	; 6
    1182:	b2 2e       	mov	r11, r18
    1184:	06 c0       	rjmp	.+12     	; 0x1192 <vfprintf+0x294>
    1186:	28 e0       	ldi	r18, 0x08	; 8
    1188:	30 e0       	ldi	r19, 0x00	; 0
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <vfprintf+0x298>
    118c:	20 e1       	ldi	r18, 0x10	; 16
    118e:	30 e0       	ldi	r19, 0x00	; 0
    1190:	02 c0       	rjmp	.+4      	; 0x1196 <vfprintf+0x298>
    1192:	20 e1       	ldi	r18, 0x10	; 16
    1194:	32 e0       	ldi	r19, 0x02	; 2
    1196:	f8 01       	movw	r30, r16
    1198:	b7 fe       	sbrs	r11, 7
    119a:	07 c0       	rjmp	.+14     	; 0x11aa <vfprintf+0x2ac>
    119c:	60 81       	ld	r22, Z
    119e:	71 81       	ldd	r23, Z+1	; 0x01
    11a0:	82 81       	ldd	r24, Z+2	; 0x02
    11a2:	93 81       	ldd	r25, Z+3	; 0x03
    11a4:	0c 5f       	subi	r16, 0xFC	; 252
    11a6:	1f 4f       	sbci	r17, 0xFF	; 255
    11a8:	06 c0       	rjmp	.+12     	; 0x11b6 <vfprintf+0x2b8>
    11aa:	60 81       	ld	r22, Z
    11ac:	71 81       	ldd	r23, Z+1	; 0x01
    11ae:	80 e0       	ldi	r24, 0x00	; 0
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	0e 5f       	subi	r16, 0xFE	; 254
    11b4:	1f 4f       	sbci	r17, 0xFF	; 255
    11b6:	a3 01       	movw	r20, r6
    11b8:	f1 d0       	rcall	.+482    	; 0x139c <__ultoa_invert>
    11ba:	88 2e       	mov	r8, r24
    11bc:	86 18       	sub	r8, r6
    11be:	fb 2d       	mov	r31, r11
    11c0:	ff 77       	andi	r31, 0x7F	; 127
    11c2:	3f 2e       	mov	r3, r31
    11c4:	36 fe       	sbrs	r3, 6
    11c6:	0d c0       	rjmp	.+26     	; 0x11e2 <vfprintf+0x2e4>
    11c8:	23 2d       	mov	r18, r3
    11ca:	2e 7f       	andi	r18, 0xFE	; 254
    11cc:	a2 2e       	mov	r10, r18
    11ce:	89 14       	cp	r8, r9
    11d0:	58 f4       	brcc	.+22     	; 0x11e8 <vfprintf+0x2ea>
    11d2:	34 fe       	sbrs	r3, 4
    11d4:	0b c0       	rjmp	.+22     	; 0x11ec <vfprintf+0x2ee>
    11d6:	32 fc       	sbrc	r3, 2
    11d8:	09 c0       	rjmp	.+18     	; 0x11ec <vfprintf+0x2ee>
    11da:	83 2d       	mov	r24, r3
    11dc:	8e 7e       	andi	r24, 0xEE	; 238
    11de:	a8 2e       	mov	r10, r24
    11e0:	05 c0       	rjmp	.+10     	; 0x11ec <vfprintf+0x2ee>
    11e2:	b8 2c       	mov	r11, r8
    11e4:	a3 2c       	mov	r10, r3
    11e6:	03 c0       	rjmp	.+6      	; 0x11ee <vfprintf+0x2f0>
    11e8:	b8 2c       	mov	r11, r8
    11ea:	01 c0       	rjmp	.+2      	; 0x11ee <vfprintf+0x2f0>
    11ec:	b9 2c       	mov	r11, r9
    11ee:	a4 fe       	sbrs	r10, 4
    11f0:	0f c0       	rjmp	.+30     	; 0x1210 <vfprintf+0x312>
    11f2:	fe 01       	movw	r30, r28
    11f4:	e8 0d       	add	r30, r8
    11f6:	f1 1d       	adc	r31, r1
    11f8:	80 81       	ld	r24, Z
    11fa:	80 33       	cpi	r24, 0x30	; 48
    11fc:	21 f4       	brne	.+8      	; 0x1206 <vfprintf+0x308>
    11fe:	9a 2d       	mov	r25, r10
    1200:	99 7e       	andi	r25, 0xE9	; 233
    1202:	a9 2e       	mov	r10, r25
    1204:	09 c0       	rjmp	.+18     	; 0x1218 <vfprintf+0x31a>
    1206:	a2 fe       	sbrs	r10, 2
    1208:	06 c0       	rjmp	.+12     	; 0x1216 <vfprintf+0x318>
    120a:	b3 94       	inc	r11
    120c:	b3 94       	inc	r11
    120e:	04 c0       	rjmp	.+8      	; 0x1218 <vfprintf+0x31a>
    1210:	8a 2d       	mov	r24, r10
    1212:	86 78       	andi	r24, 0x86	; 134
    1214:	09 f0       	breq	.+2      	; 0x1218 <vfprintf+0x31a>
    1216:	b3 94       	inc	r11
    1218:	a3 fc       	sbrc	r10, 3
    121a:	10 c0       	rjmp	.+32     	; 0x123c <vfprintf+0x33e>
    121c:	a0 fe       	sbrs	r10, 0
    121e:	06 c0       	rjmp	.+12     	; 0x122c <vfprintf+0x32e>
    1220:	b2 14       	cp	r11, r2
    1222:	80 f4       	brcc	.+32     	; 0x1244 <vfprintf+0x346>
    1224:	28 0c       	add	r2, r8
    1226:	92 2c       	mov	r9, r2
    1228:	9b 18       	sub	r9, r11
    122a:	0d c0       	rjmp	.+26     	; 0x1246 <vfprintf+0x348>
    122c:	b2 14       	cp	r11, r2
    122e:	58 f4       	brcc	.+22     	; 0x1246 <vfprintf+0x348>
    1230:	b6 01       	movw	r22, r12
    1232:	80 e2       	ldi	r24, 0x20	; 32
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	76 d0       	rcall	.+236    	; 0x1324 <fputc>
    1238:	b3 94       	inc	r11
    123a:	f8 cf       	rjmp	.-16     	; 0x122c <vfprintf+0x32e>
    123c:	b2 14       	cp	r11, r2
    123e:	18 f4       	brcc	.+6      	; 0x1246 <vfprintf+0x348>
    1240:	2b 18       	sub	r2, r11
    1242:	02 c0       	rjmp	.+4      	; 0x1248 <vfprintf+0x34a>
    1244:	98 2c       	mov	r9, r8
    1246:	21 2c       	mov	r2, r1
    1248:	a4 fe       	sbrs	r10, 4
    124a:	0f c0       	rjmp	.+30     	; 0x126a <vfprintf+0x36c>
    124c:	b6 01       	movw	r22, r12
    124e:	80 e3       	ldi	r24, 0x30	; 48
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	68 d0       	rcall	.+208    	; 0x1324 <fputc>
    1254:	a2 fe       	sbrs	r10, 2
    1256:	16 c0       	rjmp	.+44     	; 0x1284 <vfprintf+0x386>
    1258:	a1 fc       	sbrc	r10, 1
    125a:	03 c0       	rjmp	.+6      	; 0x1262 <vfprintf+0x364>
    125c:	88 e7       	ldi	r24, 0x78	; 120
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	02 c0       	rjmp	.+4      	; 0x1266 <vfprintf+0x368>
    1262:	88 e5       	ldi	r24, 0x58	; 88
    1264:	90 e0       	ldi	r25, 0x00	; 0
    1266:	b6 01       	movw	r22, r12
    1268:	0c c0       	rjmp	.+24     	; 0x1282 <vfprintf+0x384>
    126a:	8a 2d       	mov	r24, r10
    126c:	86 78       	andi	r24, 0x86	; 134
    126e:	51 f0       	breq	.+20     	; 0x1284 <vfprintf+0x386>
    1270:	a1 fe       	sbrs	r10, 1
    1272:	02 c0       	rjmp	.+4      	; 0x1278 <vfprintf+0x37a>
    1274:	8b e2       	ldi	r24, 0x2B	; 43
    1276:	01 c0       	rjmp	.+2      	; 0x127a <vfprintf+0x37c>
    1278:	80 e2       	ldi	r24, 0x20	; 32
    127a:	a7 fc       	sbrc	r10, 7
    127c:	8d e2       	ldi	r24, 0x2D	; 45
    127e:	b6 01       	movw	r22, r12
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	50 d0       	rcall	.+160    	; 0x1324 <fputc>
    1284:	89 14       	cp	r8, r9
    1286:	30 f4       	brcc	.+12     	; 0x1294 <vfprintf+0x396>
    1288:	b6 01       	movw	r22, r12
    128a:	80 e3       	ldi	r24, 0x30	; 48
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	4a d0       	rcall	.+148    	; 0x1324 <fputc>
    1290:	9a 94       	dec	r9
    1292:	f8 cf       	rjmp	.-16     	; 0x1284 <vfprintf+0x386>
    1294:	8a 94       	dec	r8
    1296:	f3 01       	movw	r30, r6
    1298:	e8 0d       	add	r30, r8
    129a:	f1 1d       	adc	r31, r1
    129c:	80 81       	ld	r24, Z
    129e:	b6 01       	movw	r22, r12
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	40 d0       	rcall	.+128    	; 0x1324 <fputc>
    12a4:	81 10       	cpse	r8, r1
    12a6:	f6 cf       	rjmp	.-20     	; 0x1294 <vfprintf+0x396>
    12a8:	22 20       	and	r2, r2
    12aa:	09 f4       	brne	.+2      	; 0x12ae <vfprintf+0x3b0>
    12ac:	4e ce       	rjmp	.-868    	; 0xf4a <vfprintf+0x4c>
    12ae:	b6 01       	movw	r22, r12
    12b0:	80 e2       	ldi	r24, 0x20	; 32
    12b2:	90 e0       	ldi	r25, 0x00	; 0
    12b4:	37 d0       	rcall	.+110    	; 0x1324 <fputc>
    12b6:	2a 94       	dec	r2
    12b8:	f7 cf       	rjmp	.-18     	; 0x12a8 <vfprintf+0x3aa>
    12ba:	f6 01       	movw	r30, r12
    12bc:	86 81       	ldd	r24, Z+6	; 0x06
    12be:	97 81       	ldd	r25, Z+7	; 0x07
    12c0:	02 c0       	rjmp	.+4      	; 0x12c6 <vfprintf+0x3c8>
    12c2:	8f ef       	ldi	r24, 0xFF	; 255
    12c4:	9f ef       	ldi	r25, 0xFF	; 255
    12c6:	2b 96       	adiw	r28, 0x0b	; 11
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	de bf       	out	0x3e, r29	; 62
    12ce:	0f be       	out	0x3f, r0	; 63
    12d0:	cd bf       	out	0x3d, r28	; 61
    12d2:	df 91       	pop	r29
    12d4:	cf 91       	pop	r28
    12d6:	1f 91       	pop	r17
    12d8:	0f 91       	pop	r16
    12da:	ff 90       	pop	r15
    12dc:	ef 90       	pop	r14
    12de:	df 90       	pop	r13
    12e0:	cf 90       	pop	r12
    12e2:	bf 90       	pop	r11
    12e4:	af 90       	pop	r10
    12e6:	9f 90       	pop	r9
    12e8:	8f 90       	pop	r8
    12ea:	7f 90       	pop	r7
    12ec:	6f 90       	pop	r6
    12ee:	5f 90       	pop	r5
    12f0:	4f 90       	pop	r4
    12f2:	3f 90       	pop	r3
    12f4:	2f 90       	pop	r2
    12f6:	08 95       	ret

000012f8 <strnlen_P>:
    12f8:	fc 01       	movw	r30, r24
    12fa:	05 90       	lpm	r0, Z+
    12fc:	61 50       	subi	r22, 0x01	; 1
    12fe:	70 40       	sbci	r23, 0x00	; 0
    1300:	01 10       	cpse	r0, r1
    1302:	d8 f7       	brcc	.-10     	; 0x12fa <strnlen_P+0x2>
    1304:	80 95       	com	r24
    1306:	90 95       	com	r25
    1308:	8e 0f       	add	r24, r30
    130a:	9f 1f       	adc	r25, r31
    130c:	08 95       	ret

0000130e <strnlen>:
    130e:	fc 01       	movw	r30, r24
    1310:	61 50       	subi	r22, 0x01	; 1
    1312:	70 40       	sbci	r23, 0x00	; 0
    1314:	01 90       	ld	r0, Z+
    1316:	01 10       	cpse	r0, r1
    1318:	d8 f7       	brcc	.-10     	; 0x1310 <strnlen+0x2>
    131a:	80 95       	com	r24
    131c:	90 95       	com	r25
    131e:	8e 0f       	add	r24, r30
    1320:	9f 1f       	adc	r25, r31
    1322:	08 95       	ret

00001324 <fputc>:
    1324:	0f 93       	push	r16
    1326:	1f 93       	push	r17
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	fb 01       	movw	r30, r22
    132e:	23 81       	ldd	r18, Z+3	; 0x03
    1330:	21 fd       	sbrc	r18, 1
    1332:	03 c0       	rjmp	.+6      	; 0x133a <fputc+0x16>
    1334:	8f ef       	ldi	r24, 0xFF	; 255
    1336:	9f ef       	ldi	r25, 0xFF	; 255
    1338:	2c c0       	rjmp	.+88     	; 0x1392 <fputc+0x6e>
    133a:	22 ff       	sbrs	r18, 2
    133c:	16 c0       	rjmp	.+44     	; 0x136a <fputc+0x46>
    133e:	46 81       	ldd	r20, Z+6	; 0x06
    1340:	57 81       	ldd	r21, Z+7	; 0x07
    1342:	24 81       	ldd	r18, Z+4	; 0x04
    1344:	35 81       	ldd	r19, Z+5	; 0x05
    1346:	42 17       	cp	r20, r18
    1348:	53 07       	cpc	r21, r19
    134a:	44 f4       	brge	.+16     	; 0x135c <fputc+0x38>
    134c:	a0 81       	ld	r26, Z
    134e:	b1 81       	ldd	r27, Z+1	; 0x01
    1350:	9d 01       	movw	r18, r26
    1352:	2f 5f       	subi	r18, 0xFF	; 255
    1354:	3f 4f       	sbci	r19, 0xFF	; 255
    1356:	31 83       	std	Z+1, r19	; 0x01
    1358:	20 83       	st	Z, r18
    135a:	8c 93       	st	X, r24
    135c:	26 81       	ldd	r18, Z+6	; 0x06
    135e:	37 81       	ldd	r19, Z+7	; 0x07
    1360:	2f 5f       	subi	r18, 0xFF	; 255
    1362:	3f 4f       	sbci	r19, 0xFF	; 255
    1364:	37 83       	std	Z+7, r19	; 0x07
    1366:	26 83       	std	Z+6, r18	; 0x06
    1368:	14 c0       	rjmp	.+40     	; 0x1392 <fputc+0x6e>
    136a:	8b 01       	movw	r16, r22
    136c:	ec 01       	movw	r28, r24
    136e:	fb 01       	movw	r30, r22
    1370:	00 84       	ldd	r0, Z+8	; 0x08
    1372:	f1 85       	ldd	r31, Z+9	; 0x09
    1374:	e0 2d       	mov	r30, r0
    1376:	09 95       	icall
    1378:	89 2b       	or	r24, r25
    137a:	e1 f6       	brne	.-72     	; 0x1334 <fputc+0x10>
    137c:	d8 01       	movw	r26, r16
    137e:	16 96       	adiw	r26, 0x06	; 6
    1380:	8d 91       	ld	r24, X+
    1382:	9c 91       	ld	r25, X
    1384:	17 97       	sbiw	r26, 0x07	; 7
    1386:	01 96       	adiw	r24, 0x01	; 1
    1388:	17 96       	adiw	r26, 0x07	; 7
    138a:	9c 93       	st	X, r25
    138c:	8e 93       	st	-X, r24
    138e:	16 97       	sbiw	r26, 0x06	; 6
    1390:	ce 01       	movw	r24, r28
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	08 95       	ret

0000139c <__ultoa_invert>:
    139c:	fa 01       	movw	r30, r20
    139e:	aa 27       	eor	r26, r26
    13a0:	28 30       	cpi	r18, 0x08	; 8
    13a2:	51 f1       	breq	.+84     	; 0x13f8 <__ultoa_invert+0x5c>
    13a4:	20 31       	cpi	r18, 0x10	; 16
    13a6:	81 f1       	breq	.+96     	; 0x1408 <__ultoa_invert+0x6c>
    13a8:	e8 94       	clt
    13aa:	6f 93       	push	r22
    13ac:	6e 7f       	andi	r22, 0xFE	; 254
    13ae:	6e 5f       	subi	r22, 0xFE	; 254
    13b0:	7f 4f       	sbci	r23, 0xFF	; 255
    13b2:	8f 4f       	sbci	r24, 0xFF	; 255
    13b4:	9f 4f       	sbci	r25, 0xFF	; 255
    13b6:	af 4f       	sbci	r26, 0xFF	; 255
    13b8:	b1 e0       	ldi	r27, 0x01	; 1
    13ba:	3e d0       	rcall	.+124    	; 0x1438 <__ultoa_invert+0x9c>
    13bc:	b4 e0       	ldi	r27, 0x04	; 4
    13be:	3c d0       	rcall	.+120    	; 0x1438 <__ultoa_invert+0x9c>
    13c0:	67 0f       	add	r22, r23
    13c2:	78 1f       	adc	r23, r24
    13c4:	89 1f       	adc	r24, r25
    13c6:	9a 1f       	adc	r25, r26
    13c8:	a1 1d       	adc	r26, r1
    13ca:	68 0f       	add	r22, r24
    13cc:	79 1f       	adc	r23, r25
    13ce:	8a 1f       	adc	r24, r26
    13d0:	91 1d       	adc	r25, r1
    13d2:	a1 1d       	adc	r26, r1
    13d4:	6a 0f       	add	r22, r26
    13d6:	71 1d       	adc	r23, r1
    13d8:	81 1d       	adc	r24, r1
    13da:	91 1d       	adc	r25, r1
    13dc:	a1 1d       	adc	r26, r1
    13de:	20 d0       	rcall	.+64     	; 0x1420 <__ultoa_invert+0x84>
    13e0:	09 f4       	brne	.+2      	; 0x13e4 <__ultoa_invert+0x48>
    13e2:	68 94       	set
    13e4:	3f 91       	pop	r19
    13e6:	2a e0       	ldi	r18, 0x0A	; 10
    13e8:	26 9f       	mul	r18, r22
    13ea:	11 24       	eor	r1, r1
    13ec:	30 19       	sub	r19, r0
    13ee:	30 5d       	subi	r19, 0xD0	; 208
    13f0:	31 93       	st	Z+, r19
    13f2:	de f6       	brtc	.-74     	; 0x13aa <__ultoa_invert+0xe>
    13f4:	cf 01       	movw	r24, r30
    13f6:	08 95       	ret
    13f8:	46 2f       	mov	r20, r22
    13fa:	47 70       	andi	r20, 0x07	; 7
    13fc:	40 5d       	subi	r20, 0xD0	; 208
    13fe:	41 93       	st	Z+, r20
    1400:	b3 e0       	ldi	r27, 0x03	; 3
    1402:	0f d0       	rcall	.+30     	; 0x1422 <__ultoa_invert+0x86>
    1404:	c9 f7       	brne	.-14     	; 0x13f8 <__ultoa_invert+0x5c>
    1406:	f6 cf       	rjmp	.-20     	; 0x13f4 <__ultoa_invert+0x58>
    1408:	46 2f       	mov	r20, r22
    140a:	4f 70       	andi	r20, 0x0F	; 15
    140c:	40 5d       	subi	r20, 0xD0	; 208
    140e:	4a 33       	cpi	r20, 0x3A	; 58
    1410:	18 f0       	brcs	.+6      	; 0x1418 <__ultoa_invert+0x7c>
    1412:	49 5d       	subi	r20, 0xD9	; 217
    1414:	31 fd       	sbrc	r19, 1
    1416:	40 52       	subi	r20, 0x20	; 32
    1418:	41 93       	st	Z+, r20
    141a:	02 d0       	rcall	.+4      	; 0x1420 <__ultoa_invert+0x84>
    141c:	a9 f7       	brne	.-22     	; 0x1408 <__ultoa_invert+0x6c>
    141e:	ea cf       	rjmp	.-44     	; 0x13f4 <__ultoa_invert+0x58>
    1420:	b4 e0       	ldi	r27, 0x04	; 4
    1422:	a6 95       	lsr	r26
    1424:	97 95       	ror	r25
    1426:	87 95       	ror	r24
    1428:	77 95       	ror	r23
    142a:	67 95       	ror	r22
    142c:	ba 95       	dec	r27
    142e:	c9 f7       	brne	.-14     	; 0x1422 <__ultoa_invert+0x86>
    1430:	00 97       	sbiw	r24, 0x00	; 0
    1432:	61 05       	cpc	r22, r1
    1434:	71 05       	cpc	r23, r1
    1436:	08 95       	ret
    1438:	9b 01       	movw	r18, r22
    143a:	ac 01       	movw	r20, r24
    143c:	0a 2e       	mov	r0, r26
    143e:	06 94       	lsr	r0
    1440:	57 95       	ror	r21
    1442:	47 95       	ror	r20
    1444:	37 95       	ror	r19
    1446:	27 95       	ror	r18
    1448:	ba 95       	dec	r27
    144a:	c9 f7       	brne	.-14     	; 0x143e <__ultoa_invert+0xa2>
    144c:	62 0f       	add	r22, r18
    144e:	73 1f       	adc	r23, r19
    1450:	84 1f       	adc	r24, r20
    1452:	95 1f       	adc	r25, r21
    1454:	a0 1d       	adc	r26, r0
    1456:	08 95       	ret

00001458 <eeprom_read_word>:
    1458:	a8 e1       	ldi	r26, 0x18	; 24
    145a:	b0 e0       	ldi	r27, 0x00	; 0
    145c:	42 e0       	ldi	r20, 0x02	; 2
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	02 c0       	rjmp	.+4      	; 0x1466 <eeprom_read_blraw>

00001462 <eeprom_read_block>:
    1462:	dc 01       	movw	r26, r24
    1464:	cb 01       	movw	r24, r22

00001466 <eeprom_read_blraw>:
    1466:	fc 01       	movw	r30, r24
    1468:	f9 99       	sbic	0x1f, 1	; 31
    146a:	fe cf       	rjmp	.-4      	; 0x1468 <eeprom_read_blraw+0x2>
    146c:	06 c0       	rjmp	.+12     	; 0x147a <eeprom_read_blraw+0x14>
    146e:	f2 bd       	out	0x22, r31	; 34
    1470:	e1 bd       	out	0x21, r30	; 33
    1472:	f8 9a       	sbi	0x1f, 0	; 31
    1474:	31 96       	adiw	r30, 0x01	; 1
    1476:	00 b4       	in	r0, 0x20	; 32
    1478:	0d 92       	st	X+, r0
    147a:	41 50       	subi	r20, 0x01	; 1
    147c:	50 40       	sbci	r21, 0x00	; 0
    147e:	b8 f7       	brcc	.-18     	; 0x146e <eeprom_read_blraw+0x8>
    1480:	08 95       	ret

00001482 <_exit>:
    1482:	f8 94       	cli

00001484 <__stop_program>:
    1484:	ff cf       	rjmp	.-2      	; 0x1484 <__stop_program>
