
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d8  00800100  00001a10  00001aa4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a10  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005ce  008001d8  008001d8  00001b7c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001b7c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001bd8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002f8  00000000  00000000  00001c18  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004d61  00000000  00000000  00001f10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017cb  00000000  00000000  00006c71  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000021c6  00000000  00000000  0000843c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000954  00000000  00000000  0000a604  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000104f  00000000  00000000  0000af58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003663  00000000  00000000  0000bfa7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  0000f60a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8e c0       	rjmp	.+284    	; 0x11e <__ctors_end>
       2:	00 00       	nop
       4:	a8 c0       	rjmp	.+336    	; 0x156 <__bad_interrupt>
       6:	00 00       	nop
       8:	a6 c0       	rjmp	.+332    	; 0x156 <__bad_interrupt>
       a:	00 00       	nop
       c:	a4 c0       	rjmp	.+328    	; 0x156 <__bad_interrupt>
       e:	00 00       	nop
      10:	a2 c0       	rjmp	.+324    	; 0x156 <__bad_interrupt>
      12:	00 00       	nop
      14:	a0 c0       	rjmp	.+320    	; 0x156 <__bad_interrupt>
      16:	00 00       	nop
      18:	9e c0       	rjmp	.+316    	; 0x156 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9c c0       	rjmp	.+312    	; 0x156 <__bad_interrupt>
      1e:	00 00       	nop
      20:	9a c0       	rjmp	.+308    	; 0x156 <__bad_interrupt>
      22:	00 00       	nop
      24:	98 c0       	rjmp	.+304    	; 0x156 <__bad_interrupt>
      26:	00 00       	nop
      28:	96 c0       	rjmp	.+300    	; 0x156 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	94 c0       	rjmp	.+296    	; 0x156 <__bad_interrupt>
      2e:	00 00       	nop
      30:	92 c0       	rjmp	.+292    	; 0x156 <__bad_interrupt>
      32:	00 00       	nop
      34:	b2 c7       	rjmp	.+3940   	; 0xf9a <__vector_13>
      36:	00 00       	nop
      38:	8e c0       	rjmp	.+284    	; 0x156 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8c c0       	rjmp	.+280    	; 0x156 <__bad_interrupt>
      3e:	00 00       	nop
      40:	ab c7       	rjmp	.+3926   	; 0xf98 <__vector_16>
      42:	00 00       	nop
      44:	88 c0       	rjmp	.+272    	; 0x156 <__bad_interrupt>
      46:	00 00       	nop
      48:	86 c0       	rjmp	.+268    	; 0x156 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	84 c0       	rjmp	.+264    	; 0x156 <__bad_interrupt>
      4e:	00 00       	nop
      50:	82 c0       	rjmp	.+260    	; 0x156 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 06 09 	jmp	0x120c	; 0x120c <__vector_21>
      58:	7e c0       	rjmp	.+252    	; 0x156 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7c c0       	rjmp	.+248    	; 0x156 <__bad_interrupt>
      5e:	00 00       	nop
      60:	7a c0       	rjmp	.+244    	; 0x156 <__bad_interrupt>
      62:	00 00       	nop
      64:	78 c0       	rjmp	.+240    	; 0x156 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 3b 08 	jmp	0x1076	; 0x1076 <__vector_26>
      6c:	74 c0       	rjmp	.+232    	; 0x156 <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 42 09 	jmp	0x1284	; 0x1284 <__vector_28>
      74:	0c 94 8a 09 	jmp	0x1314	; 0x1314 <__vector_29>
      78:	6e c0       	rjmp	.+220    	; 0x156 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	55 08       	sbc	r5, r5
      7e:	a7 08       	sbc	r10, r7
      80:	a7 08       	sbc	r10, r7
      82:	a7 08       	sbc	r10, r7
      84:	a7 08       	sbc	r10, r7
      86:	a7 08       	sbc	r10, r7
      88:	a7 08       	sbc	r10, r7
      8a:	a7 08       	sbc	r10, r7
      8c:	55 08       	sbc	r5, r5
      8e:	a7 08       	sbc	r10, r7
      90:	a7 08       	sbc	r10, r7
      92:	a7 08       	sbc	r10, r7
      94:	a7 08       	sbc	r10, r7
      96:	a7 08       	sbc	r10, r7
      98:	a7 08       	sbc	r10, r7
      9a:	a7 08       	sbc	r10, r7
      9c:	57 08       	sbc	r5, r7
      9e:	a7 08       	sbc	r10, r7
      a0:	a7 08       	sbc	r10, r7
      a2:	a7 08       	sbc	r10, r7
      a4:	a7 08       	sbc	r10, r7
      a6:	a7 08       	sbc	r10, r7
      a8:	a7 08       	sbc	r10, r7
      aa:	a7 08       	sbc	r10, r7
      ac:	a7 08       	sbc	r10, r7
      ae:	a7 08       	sbc	r10, r7
      b0:	a7 08       	sbc	r10, r7
      b2:	a7 08       	sbc	r10, r7
      b4:	a7 08       	sbc	r10, r7
      b6:	a7 08       	sbc	r10, r7
      b8:	a7 08       	sbc	r10, r7
      ba:	a7 08       	sbc	r10, r7
      bc:	57 08       	sbc	r5, r7
      be:	a7 08       	sbc	r10, r7
      c0:	a7 08       	sbc	r10, r7
      c2:	a7 08       	sbc	r10, r7
      c4:	a7 08       	sbc	r10, r7
      c6:	a7 08       	sbc	r10, r7
      c8:	a7 08       	sbc	r10, r7
      ca:	a7 08       	sbc	r10, r7
      cc:	a7 08       	sbc	r10, r7
      ce:	a7 08       	sbc	r10, r7
      d0:	a7 08       	sbc	r10, r7
      d2:	a7 08       	sbc	r10, r7
      d4:	a7 08       	sbc	r10, r7
      d6:	a7 08       	sbc	r10, r7
      d8:	a7 08       	sbc	r10, r7
      da:	a7 08       	sbc	r10, r7
      dc:	a3 08       	sbc	r10, r3
      de:	a7 08       	sbc	r10, r7
      e0:	a7 08       	sbc	r10, r7
      e2:	a7 08       	sbc	r10, r7
      e4:	a7 08       	sbc	r10, r7
      e6:	a7 08       	sbc	r10, r7
      e8:	a7 08       	sbc	r10, r7
      ea:	a7 08       	sbc	r10, r7
      ec:	80 08       	sbc	r8, r0
      ee:	a7 08       	sbc	r10, r7
      f0:	a7 08       	sbc	r10, r7
      f2:	a7 08       	sbc	r10, r7
      f4:	a7 08       	sbc	r10, r7
      f6:	a7 08       	sbc	r10, r7
      f8:	a7 08       	sbc	r10, r7
      fa:	a7 08       	sbc	r10, r7
      fc:	a7 08       	sbc	r10, r7
      fe:	a7 08       	sbc	r10, r7
     100:	a7 08       	sbc	r10, r7
     102:	a7 08       	sbc	r10, r7
     104:	a7 08       	sbc	r10, r7
     106:	a7 08       	sbc	r10, r7
     108:	a7 08       	sbc	r10, r7
     10a:	a7 08       	sbc	r10, r7
     10c:	74 08       	sbc	r7, r4
     10e:	a7 08       	sbc	r10, r7
     110:	a7 08       	sbc	r10, r7
     112:	a7 08       	sbc	r10, r7
     114:	a7 08       	sbc	r10, r7
     116:	a7 08       	sbc	r10, r7
     118:	a7 08       	sbc	r10, r7
     11a:	a7 08       	sbc	r10, r7
     11c:	92 08       	sbc	r9, r2

0000011e <__ctors_end>:
     11e:	11 24       	eor	r1, r1
     120:	1f be       	out	0x3f, r1	; 63
     122:	cf ef       	ldi	r28, 0xFF	; 255
     124:	d8 e0       	ldi	r29, 0x08	; 8
     126:	de bf       	out	0x3e, r29	; 62
     128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
     12a:	11 e0       	ldi	r17, 0x01	; 1
     12c:	a0 e0       	ldi	r26, 0x00	; 0
     12e:	b1 e0       	ldi	r27, 0x01	; 1
     130:	e0 e1       	ldi	r30, 0x10	; 16
     132:	fa e1       	ldi	r31, 0x1A	; 26
     134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
     136:	05 90       	lpm	r0, Z+
     138:	0d 92       	st	X+, r0
     13a:	a8 3d       	cpi	r26, 0xD8	; 216
     13c:	b1 07       	cpc	r27, r17
     13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
     140:	27 e0       	ldi	r18, 0x07	; 7
     142:	a8 ed       	ldi	r26, 0xD8	; 216
     144:	b1 e0       	ldi	r27, 0x01	; 1
     146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
     148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
     14a:	a6 3a       	cpi	r26, 0xA6	; 166
     14c:	b2 07       	cpc	r27, r18
     14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
     150:	28 d6       	rcall	.+3152   	; 0xda2 <main>
     152:	0c 94 06 0d 	jmp	0x1a0c	; 0x1a0c <_exit>

00000156 <__bad_interrupt>:
     156:	54 cf       	rjmp	.-344    	; 0x0 <__vectors>

00000158 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     158:	ec e7       	ldi	r30, 0x7C	; 124
     15a:	f0 e0       	ldi	r31, 0x00	; 0
     15c:	90 81       	ld	r25, Z
     15e:	90 7e       	andi	r25, 0xE0	; 224
     160:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     162:	90 81       	ld	r25, Z
     164:	89 2b       	or	r24, r25
     166:	80 83       	st	Z, r24
     168:	08 95       	ret

0000016a <ADC_init>:
}

void ADC_init(void)
{
     16a:	cf 93       	push	r28
     16c:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     16e:	ec e7       	ldi	r30, 0x7C	; 124
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	80 81       	ld	r24, Z
     174:	80 64       	ori	r24, 0x40	; 64
     176:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     178:	ca e7       	ldi	r28, 0x7A	; 122
     17a:	d0 e0       	ldi	r29, 0x00	; 0
     17c:	88 81       	ld	r24, Y
     17e:	81 60       	ori	r24, 0x01	; 1
     180:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     182:	88 81       	ld	r24, Y
     184:	82 60       	ori	r24, 0x02	; 2
     186:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     188:	88 81       	ld	r24, Y
     18a:	84 60       	ori	r24, 0x04	; 4
     18c:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     18e:	a4 e6       	ldi	r26, 0x64	; 100
     190:	b0 e0       	ldi	r27, 0x00	; 0
     192:	8c 91       	ld	r24, X
     194:	8e 7f       	andi	r24, 0xFE	; 254
     196:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     198:	80 81       	ld	r24, Z
     19a:	8f 7d       	andi	r24, 0xDF	; 223
     19c:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     19e:	8f e3       	ldi	r24, 0x3F	; 63
     1a0:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1a4:	88 81       	ld	r24, Y
     1a6:	80 68       	ori	r24, 0x80	; 128
     1a8:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1aa:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1ae:	8f e1       	ldi	r24, 0x1F	; 31
     1b0:	d3 df       	rcall	.-90     	; 0x158 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1b2:	88 81       	ld	r24, Y
     1b4:	80 64       	ori	r24, 0x40	; 64
     1b6:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1b8:	ea e7       	ldi	r30, 0x7A	; 122
     1ba:	f0 e0       	ldi	r31, 0x00	; 0
     1bc:	80 81       	ld	r24, Z
     1be:	84 ff       	sbrs	r24, 4
     1c0:	fd cf       	rjmp	.-6      	; 0x1bc <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1c2:	ea e7       	ldi	r30, 0x7A	; 122
     1c4:	f0 e0       	ldi	r31, 0x00	; 0
     1c6:	80 81       	ld	r24, Z
     1c8:	80 64       	ori	r24, 0x40	; 64
     1ca:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1cc:	80 81       	ld	r24, Z
     1ce:	84 ff       	sbrs	r24, 4
     1d0:	fd cf       	rjmp	.-6      	; 0x1cc <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1d2:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <__data_end+0x1>
     1dc:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1e0:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1e4:	20 91 d8 01 	lds	r18, 0x01D8	; 0x8001d8 <__data_end>
     1e8:	30 91 d9 01 	lds	r19, 0x01D9	; 0x8001d9 <__data_end+0x1>
     1ec:	89 2f       	mov	r24, r25
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	98 2f       	mov	r25, r24
     1f2:	88 27       	eor	r24, r24
     1f4:	82 0f       	add	r24, r18
     1f6:	93 1f       	adc	r25, r19
     1f8:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <__data_end+0x1>
     1fc:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     200:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <__data_end>
     204:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <__data_end+0x1>
     208:	99 23       	and	r25, r25
     20a:	1c f4       	brge	.+6      	; 0x212 <ADC_init+0xa8>
     20c:	91 95       	neg	r25
     20e:	81 95       	neg	r24
     210:	91 09       	sbc	r25, r1
     212:	05 97       	sbiw	r24, 0x05	; 5
     214:	2c f0       	brlt	.+10     	; 0x220 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     216:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <gas_sensor_initialization_errors>
     21a:	81 60       	ori	r24, 0x01	; 1
     21c:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     220:	8e e1       	ldi	r24, 0x1E	; 30
     222:	9a df       	rcall	.-204    	; 0x158 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     224:	ea e7       	ldi	r30, 0x7A	; 122
     226:	f0 e0       	ldi	r31, 0x00	; 0
     228:	80 81       	ld	r24, Z
     22a:	80 64       	ori	r24, 0x40	; 64
     22c:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     22e:	80 81       	ld	r24, Z
     230:	84 ff       	sbrs	r24, 4
     232:	fd cf       	rjmp	.-6      	; 0x22e <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     234:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <__data_end+0x1>
     23e:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     242:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     246:	20 91 d8 01 	lds	r18, 0x01D8	; 0x8001d8 <__data_end>
     24a:	30 91 d9 01 	lds	r19, 0x01D9	; 0x8001d9 <__data_end+0x1>
     24e:	89 2f       	mov	r24, r25
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	98 2f       	mov	r25, r24
     254:	88 27       	eor	r24, r24
     256:	82 0f       	add	r24, r18
     258:	93 1f       	adc	r25, r19
     25a:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <__data_end+0x1>
     25e:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     262:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <__data_end>
     266:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <__data_end+0x1>
     26a:	81 5e       	subi	r24, 0xE1	; 225
     26c:	91 09       	sbc	r25, r1
     26e:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <__data_end+0x1>
     272:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     276:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <__data_end>
     27a:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <__data_end+0x1>
     27e:	99 23       	and	r25, r25
     280:	1c f4       	brge	.+6      	; 0x288 <ADC_init+0x11e>
     282:	91 95       	neg	r25
     284:	81 95       	neg	r24
     286:	91 09       	sbc	r25, r1
     288:	05 97       	sbiw	r24, 0x05	; 5
     28a:	2c f0       	brlt	.+10     	; 0x296 <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     28c:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <gas_sensor_initialization_errors>
     290:	82 60       	ori	r24, 0x02	; 2
     292:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     296:	ea e7       	ldi	r30, 0x7A	; 122
     298:	f0 e0       	ldi	r31, 0x00	; 0
     29a:	80 81       	ld	r24, Z
     29c:	8f 77       	andi	r24, 0x7F	; 127
     29e:	80 83       	st	Z, r24
     2a0:	df 91       	pop	r29
     2a2:	cf 91       	pop	r28
     2a4:	08 95       	ret

000002a6 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2a6:	87 e0       	ldi	r24, 0x07	; 7
     2a8:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2aa:	85 b1       	in	r24, 0x05	; 5
     2ac:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2ae:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2b0:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2b2:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2b4:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2b6:	41 9a       	sbi	0x08, 1	; 8
     2b8:	08 95       	ret

000002ba <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2ba:	80 e0       	ldi	r24, 0x00	; 0
     2bc:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2be:	2f ef       	ldi	r18, 0xFF	; 255
     2c0:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2c2:	fc 01       	movw	r30, r24
     2c4:	ee 0f       	add	r30, r30
     2c6:	ff 1f       	adc	r31, r31
     2c8:	ee 0f       	add	r30, r30
     2ca:	ff 1f       	adc	r31, r31
     2cc:	e3 5f       	subi	r30, 0xF3	; 243
     2ce:	fb 4f       	sbci	r31, 0xFB	; 251
     2d0:	11 82       	std	Z+1, r1	; 0x01
     2d2:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2d4:	33 83       	std	Z+3, r19	; 0x03
     2d6:	22 83       	std	Z+2, r18	; 0x02
     2d8:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2da:	85 30       	cpi	r24, 0x05	; 5
     2dc:	91 05       	cpc	r25, r1
     2de:	89 f7       	brne	.-30     	; 0x2c2 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2e0:	08 95       	ret

000002e2 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2e2:	ef 92       	push	r14
     2e4:	ff 92       	push	r15
     2e6:	0f 93       	push	r16
     2e8:	1f 93       	push	r17
     2ea:	cf 93       	push	r28
     2ec:	df 93       	push	r29
     2ee:	0f 2e       	mov	r0, r31
     2f0:	f7 ef       	ldi	r31, 0xF7	; 247
     2f2:	ef 2e       	mov	r14, r31
     2f4:	f3 e0       	ldi	r31, 0x03	; 3
     2f6:	ff 2e       	mov	r15, r31
     2f8:	f0 2d       	mov	r31, r0
     2fa:	00 e0       	ldi	r16, 0x00	; 0
     2fc:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     2fe:	c7 01       	movw	r24, r14
     300:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <eeprom_read_word>
     304:	e8 01       	movw	r28, r16
     306:	cc 0f       	add	r28, r28
     308:	dd 1f       	adc	r29, r29
     30a:	cc 0f       	add	r28, r28
     30c:	dd 1f       	adc	r29, r29
     30e:	c3 5f       	subi	r28, 0xF3	; 243
     310:	db 4f       	sbci	r29, 0xFB	; 251
     312:	99 83       	std	Y+1, r25	; 0x01
     314:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     316:	c7 01       	movw	r24, r14
     318:	02 96       	adiw	r24, 0x02	; 2
     31a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <eeprom_read_word>
     31e:	9b 83       	std	Y+3, r25	; 0x03
     320:	8a 83       	std	Y+2, r24	; 0x02
     322:	0f 5f       	subi	r16, 0xFF	; 255
     324:	1f 4f       	sbci	r17, 0xFF	; 255
     326:	84 e0       	ldi	r24, 0x04	; 4
     328:	e8 0e       	add	r14, r24
     32a:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     32c:	05 30       	cpi	r16, 0x05	; 5
     32e:	11 05       	cpc	r17, r1
     330:	31 f7       	brne	.-52     	; 0x2fe <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     332:	df 91       	pop	r29
     334:	cf 91       	pop	r28
     336:	1f 91       	pop	r17
     338:	0f 91       	pop	r16
     33a:	ff 90       	pop	r15
     33c:	ef 90       	pop	r14
     33e:	08 95       	ret

00000340 <gas_sensors_init>:

void gas_sensors_init(void)
{
     340:	af 92       	push	r10
     342:	bf 92       	push	r11
     344:	cf 92       	push	r12
     346:	df 92       	push	r13
     348:	ef 92       	push	r14
     34a:	ff 92       	push	r15
     34c:	0f 93       	push	r16
     34e:	1f 93       	push	r17
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     354:	1f 92       	push	r1
     356:	cd b7       	in	r28, 0x3d	; 61
     358:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     35a:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     35e:	10 92 2a 04 	sts	0x042A, r1	; 0x80042a <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     362:	bf df       	rcall	.-130    	; 0x2e2 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     364:	aa df       	rcall	.-172    	; 0x2ba <get_gas_sensor_limits>
     366:	ea e7       	ldi	r30, 0x7A	; 122
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     368:	f0 e0       	ldi	r31, 0x00	; 0
     36a:	80 81       	ld	r24, Z
     36c:	80 68       	ori	r24, 0x80	; 128
     36e:	80 83       	st	Z, r24
     370:	19 82       	std	Y+1, r1	; 0x01
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     372:	89 81       	ldd	r24, Y+1	; 0x01
     374:	85 30       	cpi	r24, 0x05	; 5
     376:	08 f0       	brcs	.+2      	; 0x37a <gas_sensors_init+0x3a>
     378:	51 c0       	rjmp	.+162    	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     37a:	0a e7       	ldi	r16, 0x7A	; 122
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     37c:	10 e0       	ldi	r17, 0x00	; 0
     37e:	0f 2e       	mov	r0, r31
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     380:	f8 e7       	ldi	r31, 0x78	; 120
     382:	ef 2e       	mov	r14, r31
     384:	f1 2c       	mov	r15, r1
     386:	f0 2d       	mov	r31, r0
     388:	bb 24       	eor	r11, r11
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     38a:	b3 94       	inc	r11
     38c:	a1 2c       	mov	r10, r1
     38e:	cc 24       	eor	r12, r12
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     390:	c3 94       	inc	r12
     392:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	e0 de       	rcall	.-576    	; 0x158 <ADC_SetMux>
     398:	f8 01       	movw	r30, r16
		// Start conversion
		SetBit(ADCSRA, ADSC);
     39a:	80 81       	ld	r24, Z
     39c:	80 64       	ori	r24, 0x40	; 64
     39e:	80 83       	st	Z, r24
     3a0:	f8 01       	movw	r30, r16
		while (BitIsClear(ADCSRA, ADIF))
     3a2:	80 81       	ld	r24, Z
     3a4:	84 ff       	sbrs	r24, 4
     3a6:	fc cf       	rjmp	.-8      	; 0x3a0 <gas_sensors_init+0x60>
     3a8:	f7 01       	movw	r30, r14
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3aa:	80 81       	ld	r24, Z
     3ac:	91 81       	ldd	r25, Z+1	; 0x01
     3ae:	e9 81       	ldd	r30, Y+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3b0:	f0 e0       	ldi	r31, 0x00	; 0
     3b2:	ee 0f       	add	r30, r30
     3b4:	ff 1f       	adc	r31, r31
     3b6:	ee 0f       	add	r30, r30
     3b8:	ff 1f       	adc	r31, r31
     3ba:	e3 5f       	subi	r30, 0xF3	; 243
     3bc:	fb 4f       	sbci	r31, 0xFB	; 251
     3be:	20 81       	ld	r18, Z
     3c0:	31 81       	ldd	r19, Z+1	; 0x01
     3c2:	e9 81       	ldd	r30, Y+1	; 0x01
     3c4:	f0 e0       	ldi	r31, 0x00	; 0
     3c6:	ee 0f       	add	r30, r30
     3c8:	ff 1f       	adc	r31, r31
     3ca:	ee 0f       	add	r30, r30
     3cc:	ff 1f       	adc	r31, r31
     3ce:	e3 5f       	subi	r30, 0xF3	; 243
     3d0:	fb 4f       	sbci	r31, 0xFB	; 251
     3d2:	62 81       	ldd	r22, Z+2	; 0x02
     3d4:	73 81       	ldd	r23, Z+3	; 0x03
     3d6:	4b 2d       	mov	r20, r11
     3d8:	82 17       	cp	r24, r18
     3da:	93 07       	cpc	r25, r19
     3dc:	08 f0       	brcs	.+2      	; 0x3e0 <gas_sensors_init+0xa0>
     3de:	4a 2d       	mov	r20, r10
     3e0:	41 11       	cpse	r20, r1
     3e2:	07 c0       	rjmp	.+14     	; 0x3f2 <gas_sensors_init+0xb2>
     3e4:	2b 2d       	mov	r18, r11
     3e6:	68 17       	cp	r22, r24
     3e8:	79 07       	cpc	r23, r25
     3ea:	08 f0       	brcs	.+2      	; 0x3ee <gas_sensors_init+0xae>
     3ec:	2a 2d       	mov	r18, r10
     3ee:	22 23       	and	r18, r18
     3f0:	71 f0       	breq	.+28     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     3f2:	99 81       	ldd	r25, Y+1	; 0x01
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3f4:	20 91 37 04 	lds	r18, 0x0437	; 0x800437 <gas_sensor_initialization_errors>
     3f8:	9d 5f       	subi	r25, 0xFD	; 253
     3fa:	a6 01       	movw	r20, r12
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
     3fe:	44 0f       	add	r20, r20
     400:	55 1f       	adc	r21, r21
     402:	9a 95       	dec	r25
     404:	e2 f7       	brpl	.-8      	; 0x3fe <gas_sensors_init+0xbe>
     406:	ca 01       	movw	r24, r20
     408:	82 2b       	or	r24, r18
     40a:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <gas_sensor_initialization_errors>
     40e:	89 81       	ldd	r24, Y+1	; 0x01
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     410:	8f 5f       	subi	r24, 0xFF	; 255
     412:	89 83       	std	Y+1, r24	; 0x01
     414:	89 81       	ldd	r24, Y+1	; 0x01
     416:	85 30       	cpi	r24, 0x05	; 5
     418:	08 f4       	brcc	.+2      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     41a:	bc cf       	rjmp	.-136    	; 0x394 <gas_sensors_init+0x54>
     41c:	ea e7       	ldi	r30, 0x7A	; 122
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     41e:	f0 e0       	ldi	r31, 0x00	; 0
     420:	80 81       	ld	r24, Z
     422:	8f 77       	andi	r24, 0x7F	; 127
     424:	80 83       	st	Z, r24
     426:	0f 90       	pop	r0
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     428:	df 91       	pop	r29
     42a:	cf 91       	pop	r28
     42c:	1f 91       	pop	r17
     42e:	0f 91       	pop	r16
     430:	ff 90       	pop	r15
     432:	ef 90       	pop	r14
     434:	df 90       	pop	r13
     436:	cf 90       	pop	r12
     438:	bf 90       	pop	r11
     43a:	af 90       	pop	r10
     43c:	08 95       	ret

0000043e <start_gas_sensor_read>:
     43e:	af 92       	push	r10

void start_gas_sensor_read(void)
{
     440:	bf 92       	push	r11
     442:	cf 92       	push	r12
     444:	df 92       	push	r13
     446:	ef 92       	push	r14
     448:	ff 92       	push	r15
     44a:	0f 93       	push	r16
     44c:	1f 93       	push	r17
     44e:	cf 93       	push	r28
     450:	df 93       	push	r29
     452:	00 d0       	rcall	.+0      	; 0x454 <start_gas_sensor_read+0x16>
     454:	1f 92       	push	r1
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     45a:	ea e7       	ldi	r30, 0x7A	; 122
     45c:	f0 e0       	ldi	r31, 0x00	; 0
     45e:	80 81       	ld	r24, Z
     460:	80 68       	ori	r24, 0x80	; 128
     462:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     464:	19 82       	std	Y+1, r1	; 0x01
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	85 30       	cpi	r24, 0x05	; 5
     46a:	08 f0       	brcs	.+2      	; 0x46e <start_gas_sensor_read+0x30>
     46c:	73 c0       	rjmp	.+230    	; 0x554 <start_gas_sensor_read+0x116>
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     46e:	0a e7       	ldi	r16, 0x7A	; 122
     470:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     472:	0f 2e       	mov	r0, r31
     474:	f8 e7       	ldi	r31, 0x78	; 120
     476:	ef 2e       	mov	r14, r31
     478:	f1 2c       	mov	r15, r1
     47a:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     47c:	cc 24       	eor	r12, r12
     47e:	c3 94       	inc	r12
     480:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     482:	bb 24       	eor	r11, r11
     484:	b3 94       	inc	r11
     486:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	66 de       	rcall	.-820    	; 0x158 <ADC_SetMux>
		total = 0;	// re-zero the average
     48c:	1b 82       	std	Y+3, r1	; 0x03
     48e:	1a 82       	std	Y+2, r1	; 0x02
     490:	24 e0       	ldi	r18, 0x04	; 4
     492:	30 e0       	ldi	r19, 0x00	; 0
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     494:	f8 01       	movw	r30, r16
     496:	80 81       	ld	r24, Z
     498:	80 64       	ori	r24, 0x40	; 64
     49a:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     49c:	f8 01       	movw	r30, r16
     49e:	80 81       	ld	r24, Z
     4a0:	84 ff       	sbrs	r24, 4
     4a2:	fc cf       	rjmp	.-8      	; 0x49c <start_gas_sensor_read+0x5e>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4a4:	f7 01       	movw	r30, r14
     4a6:	80 81       	ld	r24, Z
     4a8:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4aa:	e9 81       	ldd	r30, Y+1	; 0x01
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
     4ae:	ee 0f       	add	r30, r30
     4b0:	ff 1f       	adc	r31, r31
     4b2:	ee 0f       	add	r30, r30
     4b4:	ff 1f       	adc	r31, r31
     4b6:	e3 5f       	subi	r30, 0xF3	; 243
     4b8:	fb 4f       	sbci	r31, 0xFB	; 251
     4ba:	40 81       	ld	r20, Z
     4bc:	51 81       	ldd	r21, Z+1	; 0x01
     4be:	e9 81       	ldd	r30, Y+1	; 0x01
     4c0:	f0 e0       	ldi	r31, 0x00	; 0
     4c2:	ee 0f       	add	r30, r30
     4c4:	ff 1f       	adc	r31, r31
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	e3 5f       	subi	r30, 0xF3	; 243
     4cc:	fb 4f       	sbci	r31, 0xFB	; 251
     4ce:	02 80       	ldd	r0, Z+2	; 0x02
     4d0:	f3 81       	ldd	r31, Z+3	; 0x03
     4d2:	e0 2d       	mov	r30, r0
     4d4:	6b 2d       	mov	r22, r11
     4d6:	84 17       	cp	r24, r20
     4d8:	95 07       	cpc	r25, r21
     4da:	08 f0       	brcs	.+2      	; 0x4de <start_gas_sensor_read+0xa0>
     4dc:	6a 2d       	mov	r22, r10
     4de:	61 11       	cpse	r22, r1
     4e0:	07 c0       	rjmp	.+14     	; 0x4f0 <start_gas_sensor_read+0xb2>
     4e2:	4b 2d       	mov	r20, r11
     4e4:	e8 17       	cp	r30, r24
     4e6:	f9 07       	cpc	r31, r25
     4e8:	08 f0       	brcs	.+2      	; 0x4ec <start_gas_sensor_read+0xae>
     4ea:	4a 2d       	mov	r20, r10
     4ec:	44 23       	and	r20, r20
     4ee:	71 f0       	breq	.+28     	; 0x50c <start_gas_sensor_read+0xce>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     4f0:	59 81       	ldd	r21, Y+1	; 0x01
     4f2:	60 91 37 04 	lds	r22, 0x0437	; 0x800437 <gas_sensor_initialization_errors>
     4f6:	5d 5f       	subi	r21, 0xFD	; 253
     4f8:	f6 01       	movw	r30, r12
     4fa:	02 c0       	rjmp	.+4      	; 0x500 <start_gas_sensor_read+0xc2>
     4fc:	ee 0f       	add	r30, r30
     4fe:	ff 1f       	adc	r31, r31
     500:	5a 95       	dec	r21
     502:	e2 f7       	brpl	.-8      	; 0x4fc <start_gas_sensor_read+0xbe>
     504:	af 01       	movw	r20, r30
     506:	46 2b       	or	r20, r22
     508:	40 93 37 04 	sts	0x0437, r20	; 0x800437 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     50c:	4a 81       	ldd	r20, Y+2	; 0x02
     50e:	5b 81       	ldd	r21, Y+3	; 0x03
     510:	84 0f       	add	r24, r20
     512:	95 1f       	adc	r25, r21
     514:	9b 83       	std	Y+3, r25	; 0x03
     516:	8a 83       	std	Y+2, r24	; 0x02
     518:	21 50       	subi	r18, 0x01	; 1
     51a:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
     51c:	09 f0       	breq	.+2      	; 0x520 <start_gas_sensor_read+0xe2>
     51e:	ba cf       	rjmp	.-140    	; 0x494 <start_gas_sensor_read+0x56>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     520:	8a 81       	ldd	r24, Y+2	; 0x02
     522:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     524:	e9 81       	ldd	r30, Y+1	; 0x01
     526:	f0 e0       	ldi	r31, 0x00	; 0
     528:	ee 0f       	add	r30, r30
     52a:	ff 1f       	adc	r31, r31
     52c:	e5 5d       	subi	r30, 0xD5	; 213
     52e:	fb 4f       	sbci	r31, 0xFB	; 251
     530:	9c 01       	movw	r18, r24
     532:	99 23       	and	r25, r25
     534:	14 f4       	brge	.+4      	; 0x53a <start_gas_sensor_read+0xfc>
     536:	2d 5f       	subi	r18, 0xFD	; 253
     538:	3f 4f       	sbci	r19, 0xFF	; 255
     53a:	35 95       	asr	r19
     53c:	27 95       	ror	r18
     53e:	35 95       	asr	r19
     540:	27 95       	ror	r18
     542:	31 83       	std	Z+1, r19	; 0x01
     544:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	8f 5f       	subi	r24, 0xFF	; 255
     54a:	89 83       	std	Y+1, r24	; 0x01
     54c:	89 81       	ldd	r24, Y+1	; 0x01
     54e:	85 30       	cpi	r24, 0x05	; 5
     550:	08 f4       	brcc	.+2      	; 0x554 <start_gas_sensor_read+0x116>
     552:	9a cf       	rjmp	.-204    	; 0x488 <start_gas_sensor_read+0x4a>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     554:	0f 90       	pop	r0
     556:	0f 90       	pop	r0
     558:	0f 90       	pop	r0
     55a:	df 91       	pop	r29
     55c:	cf 91       	pop	r28
     55e:	1f 91       	pop	r17
     560:	0f 91       	pop	r16
     562:	ff 90       	pop	r15
     564:	ef 90       	pop	r14
     566:	df 90       	pop	r13
     568:	cf 90       	pop	r12
     56a:	bf 90       	pop	r11
     56c:	af 90       	pop	r10
     56e:	08 95       	ret

00000570 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     570:	1f 93       	push	r17
     572:	cf 93       	push	r28
     574:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     576:	ee e3       	ldi	r30, 0x3E	; 62
     578:	f4 e0       	ldi	r31, 0x04	; 4
     57a:	84 ec       	ldi	r24, 0xC4	; 196
     57c:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     57e:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     580:	84 e0       	ldi	r24, 0x04	; 4
     582:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     584:	63 e0       	ldi	r22, 0x03	; 3
     586:	cf 01       	movw	r24, r30
     588:	2b d5       	rcall	.+2646   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     58a:	26 d5       	rcall	.+2636   	; 0xfd8 <TWI_Transceiver_Busy>
     58c:	81 11       	cpse	r24, r1
     58e:	fd cf       	rjmp	.-6      	; 0x58a <LIDAR_distance+0x1a>
     590:	ee e3       	ldi	r30, 0x3E	; 62
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     592:	f4 e0       	ldi	r31, 0x04	; 4
     594:	84 ec       	ldi	r24, 0xC4	; 196
     596:	80 83       	st	Z, r24
     598:	81 e0       	ldi	r24, 0x01	; 1
	messageBuf[1] = 0x01; // Select register 0x01
     59a:	81 83       	std	Z+1, r24	; 0x01
     59c:	62 e0       	ldi	r22, 0x02	; 2
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     59e:	cf 01       	movw	r24, r30
     5a0:	1f d5       	rcall	.+2622   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5a2:	1a d5       	rcall	.+2612   	; 0xfd8 <TWI_Transceiver_Busy>
     5a4:	81 11       	cpse	r24, r1
     5a6:	fd cf       	rjmp	.-6      	; 0x5a2 <LIDAR_distance+0x32>
     5a8:	ce e3       	ldi	r28, 0x3E	; 62
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5aa:	d4 e0       	ldi	r29, 0x04	; 4
     5ac:	15 ec       	ldi	r17, 0xC5	; 197
     5ae:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b0:	19 82       	std	Y+1, r1	; 0x01
     5b2:	62 e0       	ldi	r22, 0x02	; 2
     5b4:	ce 01       	movw	r24, r28
     5b6:	14 d5       	rcall	.+2600   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5b8:	0f d5       	rcall	.+2590   	; 0xfd8 <TWI_Transceiver_Busy>
     5ba:	81 11       	cpse	r24, r1
     5bc:	fd cf       	rjmp	.-6      	; 0x5b8 <LIDAR_distance+0x48>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5be:	62 e0       	ldi	r22, 0x02	; 2
     5c0:	ce 01       	movw	r24, r28
     5c2:	3a d5       	rcall	.+2676   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     5c4:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     5c8:	89 81       	ldd	r24, Y+1	; 0x01
		testing = messageBuf[1]; //This is here for debug purposes
     5ca:	80 93 4f 05 	sts	0x054F, r24	; 0x80054f <testing>
     5ce:	80 fd       	sbrc	r24, 0
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5d0:	ee cf       	rjmp	.-36     	; 0x5ae <LIDAR_distance+0x3e>
     5d2:	ee e3       	ldi	r30, 0x3E	; 62
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5d4:	f4 e0       	ldi	r31, 0x04	; 4
     5d6:	84 ec       	ldi	r24, 0xC4	; 196
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     5d8:	80 83       	st	Z, r24
     5da:	8f e8       	ldi	r24, 0x8F	; 143
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5dc:	81 83       	std	Z+1, r24	; 0x01
     5de:	62 e0       	ldi	r22, 0x02	; 2
     5e0:	cf 01       	movw	r24, r30
     5e2:	fe d4       	rcall	.+2556   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     5e4:	f9 d4       	rcall	.+2546   	; 0xfd8 <TWI_Transceiver_Busy>
     5e6:	81 11       	cpse	r24, r1
     5e8:	fd cf       	rjmp	.-6      	; 0x5e4 <LIDAR_distance+0x74>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5ea:	ee e3       	ldi	r30, 0x3E	; 62
     5ec:	f4 e0       	ldi	r31, 0x04	; 4
     5ee:	85 ec       	ldi	r24, 0xC5	; 197
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     5f0:	80 83       	st	Z, r24
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     5f2:	11 82       	std	Z+1, r1	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     5f4:	12 82       	std	Z+2, r1	; 0x02
     5f6:	63 e0       	ldi	r22, 0x03	; 3
     5f8:	cf 01       	movw	r24, r30
	while ( TWI_Transceiver_Busy() );	
     5fa:	f2 d4       	rcall	.+2532   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
     5fc:	ed d4       	rcall	.+2522   	; 0xfd8 <TWI_Transceiver_Busy>
     5fe:	81 11       	cpse	r24, r1
     600:	fd cf       	rjmp	.-6      	; 0x5fc <LIDAR_distance+0x8c>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     602:	63 e0       	ldi	r22, 0x03	; 3
     604:	8e e3       	ldi	r24, 0x3E	; 62
     606:	94 e0       	ldi	r25, 0x04	; 4
     608:	17 d5       	rcall	.+2606   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     60a:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     60e:	ee e3       	ldi	r30, 0x3E	; 62
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     610:	f4 e0       	ldi	r31, 0x04	; 4
     612:	81 81       	ldd	r24, Z+1	; 0x01
	// That's all, folks...
	return(Ldistance);
     614:	90 e0       	ldi	r25, 0x00	; 0
     616:	98 2f       	mov	r25, r24
     618:	88 27       	eor	r24, r24
     61a:	22 81       	ldd	r18, Z+2	; 0x02
     61c:	82 0f       	add	r24, r18
}
     61e:	91 1d       	adc	r25, r1
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	1f 91       	pop	r17
     626:	08 95       	ret

00000628 <BME_read_correction_coefficients>:
     628:	ff 92       	push	r15
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     62a:	0f 93       	push	r16
     62c:	1f 93       	push	r17
     62e:	cf 93       	push	r28
     630:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     632:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     636:	88 23       	and	r24, r24
     638:	31 f1       	breq	.+76     	; 0x686 <BME_read_correction_coefficients+0x5e>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     63a:	cf e4       	ldi	r28, 0x4F	; 79
     63c:	d4 e0       	ldi	r29, 0x04	; 4
     63e:	0f 2e       	mov	r0, r31
     640:	fc ee       	ldi	r31, 0xEC	; 236
     642:	ff 2e       	mov	r15, r31
     644:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     646:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     648:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     64a:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     64c:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     64e:	62 e0       	ldi	r22, 0x02	; 2
     650:	ce 01       	movw	r24, r28
     652:	c6 d4       	rcall	.+2444   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     654:	c1 d4       	rcall	.+2434   	; 0xfd8 <TWI_Transceiver_Busy>
     656:	81 11       	cpse	r24, r1
     658:	fd cf       	rjmp	.-6      	; 0x654 <BME_read_correction_coefficients+0x2c>
     65a:	18 83       	st	Y, r17
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     65c:	6a e1       	ldi	r22, 0x1A	; 26
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     65e:	ce 01       	movw	r24, r28
     660:	bf d4       	rcall	.+2430   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     662:	ba d4       	rcall	.+2420   	; 0xfd8 <TWI_Transceiver_Busy>
     664:	81 11       	cpse	r24, r1
     666:	fd cf       	rjmp	.-6      	; 0x662 <BME_read_correction_coefficients+0x3a>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     668:	6a e1       	ldi	r22, 0x1A	; 26
     66a:	ce 01       	movw	r24, r28
     66c:	e5 d4       	rcall	.+2506   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     66e:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     672:	89 81       	ldd	r24, Y+1	; 0x01
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     674:	83 fb       	bst	r24, 3
     676:	88 27       	eor	r24, r24
     678:	80 f9       	bld	r24, 0
     67a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     67e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     682:	81 11       	cpse	r24, r1
     684:	e2 cf       	rjmp	.-60     	; 0x64a <BME_read_correction_coefficients+0x22>
     686:	ef e4       	ldi	r30, 0x4F	; 79
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     688:	f4 e0       	ldi	r31, 0x04	; 4
     68a:	8c ee       	ldi	r24, 0xEC	; 236
     68c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     68e:	88 e8       	ldi	r24, 0x88	; 136
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     690:	81 83       	std	Z+1, r24	; 0x01
     692:	62 e0       	ldi	r22, 0x02	; 2
     694:	cf 01       	movw	r24, r30
     696:	a4 d4       	rcall	.+2376   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     698:	9f d4       	rcall	.+2366   	; 0xfd8 <TWI_Transceiver_Busy>
     69a:	81 11       	cpse	r24, r1
     69c:	fd cf       	rjmp	.-6      	; 0x698 <BME_read_correction_coefficients+0x70>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     69e:	8d ee       	ldi	r24, 0xED	; 237
     6a0:	80 93 4f 04 	sts	0x044F, r24	; 0x80044f <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want eight bytes back, so use 9 in the function call.
     6a4:	6a e1       	ldi	r22, 0x1A	; 26
     6a6:	8f e4       	ldi	r24, 0x4F	; 79
     6a8:	94 e0       	ldi	r25, 0x04	; 4
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6aa:	9a d4       	rcall	.+2356   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
     6ac:	95 d4       	rcall	.+2346   	; 0xfd8 <TWI_Transceiver_Busy>
     6ae:	81 11       	cpse	r24, r1
     6b0:	fd cf       	rjmp	.-6      	; 0x6ac <BME_read_correction_coefficients+0x84>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     6b2:	6a e1       	ldi	r22, 0x1A	; 26
     6b4:	8f e4       	ldi	r24, 0x4F	; 79
     6b6:	94 e0       	ldi	r25, 0x04	; 4
     6b8:	bf d4       	rcall	.+2430   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     6ba:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     6be:	e0 e5       	ldi	r30, 0x50	; 80
     6c0:	f4 e0       	ldi	r31, 0x04	; 4
     6c2:	a6 e5       	ldi	r26, 0x56	; 86
     6c4:	b5 e0       	ldi	r27, 0x05	; 5
     6c6:	2a e6       	ldi	r18, 0x6A	; 106
     6c8:	34 e0       	ldi	r19, 0x04	; 4
     6ca:	81 91       	ld	r24, Z+
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<26;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     6cc:	8d 93       	st	X+, r24
     6ce:	e2 17       	cp	r30, r18
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<26;i++) 	{
     6d0:	f3 07       	cpc	r31, r19
     6d2:	d9 f7       	brne	.-10     	; 0x6ca <BME_read_correction_coefficients+0xa2>
     6d4:	8a e1       	ldi	r24, 0x1A	; 26
     6d6:	80 93 db 01 	sts	0x01DB, r24	; 0x8001db <i.2416>
     6da:	e6 e5       	ldi	r30, 0x56	; 86
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     6dc:	f5 e0       	ldi	r31, 0x05	; 5
     6de:	81 81       	ldd	r24, Z+1	; 0x01
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	98 2f       	mov	r25, r24
     6e4:	88 27       	eor	r24, r24
     6e6:	20 81       	ld	r18, Z
     6e8:	82 2b       	or	r24, r18
     6ea:	90 93 53 05 	sts	0x0553, r25	; 0x800553 <dig_T1+0x1>
     6ee:	80 93 52 05 	sts	0x0552, r24	; 0x800552 <dig_T1>
     6f2:	83 81       	ldd	r24, Z+3	; 0x03
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     6f4:	90 e0       	ldi	r25, 0x00	; 0
     6f6:	98 2f       	mov	r25, r24
     6f8:	88 27       	eor	r24, r24
     6fa:	22 81       	ldd	r18, Z+2	; 0x02
     6fc:	82 2b       	or	r24, r18
     6fe:	90 93 55 05 	sts	0x0555, r25	; 0x800555 <dig_T2+0x1>
     702:	80 93 54 05 	sts	0x0554, r24	; 0x800554 <dig_T2>
     706:	85 81       	ldd	r24, Z+5	; 0x05
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	98 2f       	mov	r25, r24
     70c:	88 27       	eor	r24, r24
     70e:	24 81       	ldd	r18, Z+4	; 0x04
     710:	82 2b       	or	r24, r18
     712:	90 93 99 05 	sts	0x0599, r25	; 0x800599 <dig_T3+0x1>
     716:	80 93 98 05 	sts	0x0598, r24	; 0x800598 <dig_T3>
     71a:	87 81       	ldd	r24, Z+7	; 0x07
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	98 2f       	mov	r25, r24
     720:	88 27       	eor	r24, r24
     722:	26 81       	ldd	r18, Z+6	; 0x06
     724:	82 2b       	or	r24, r18
     726:	90 93 91 05 	sts	0x0591, r25	; 0x800591 <dig_P1+0x1>
     72a:	80 93 90 05 	sts	0x0590, r24	; 0x800590 <dig_P1>
     72e:	81 85       	ldd	r24, Z+9	; 0x09
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	98 2f       	mov	r25, r24
     734:	88 27       	eor	r24, r24
     736:	20 85       	ldd	r18, Z+8	; 0x08
     738:	82 2b       	or	r24, r18
     73a:	90 93 79 05 	sts	0x0579, r25	; 0x800579 <dig_P2+0x1>
     73e:	80 93 78 05 	sts	0x0578, r24	; 0x800578 <dig_P2>
     742:	83 85       	ldd	r24, Z+11	; 0x0b
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	98 2f       	mov	r25, r24
     748:	88 27       	eor	r24, r24
     74a:	22 85       	ldd	r18, Z+10	; 0x0a
     74c:	82 2b       	or	r24, r18
     74e:	90 93 93 05 	sts	0x0593, r25	; 0x800593 <dig_P3+0x1>
     752:	80 93 92 05 	sts	0x0592, r24	; 0x800592 <dig_P3>
     756:	85 85       	ldd	r24, Z+13	; 0x0d
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	98 2f       	mov	r25, r24
     75c:	88 27       	eor	r24, r24
     75e:	24 85       	ldd	r18, Z+12	; 0x0c
     760:	82 2b       	or	r24, r18
     762:	90 93 7b 05 	sts	0x057B, r25	; 0x80057b <dig_P4+0x1>
     766:	80 93 7a 05 	sts	0x057A, r24	; 0x80057a <dig_P4>
     76a:	87 85       	ldd	r24, Z+15	; 0x0f
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	98 2f       	mov	r25, r24
     770:	88 27       	eor	r24, r24
     772:	26 85       	ldd	r18, Z+14	; 0x0e
     774:	82 2b       	or	r24, r18
     776:	90 93 84 05 	sts	0x0584, r25	; 0x800584 <dig_P5+0x1>
     77a:	80 93 83 05 	sts	0x0583, r24	; 0x800583 <dig_P5>
     77e:	81 89       	ldd	r24, Z+17	; 0x11
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     780:	90 e0       	ldi	r25, 0x00	; 0
     782:	98 2f       	mov	r25, r24
     784:	88 27       	eor	r24, r24
     786:	20 89       	ldd	r18, Z+16	; 0x10
     788:	82 2b       	or	r24, r18
     78a:	90 93 9b 05 	sts	0x059B, r25	; 0x80059b <dig_P6+0x1>
     78e:	80 93 9a 05 	sts	0x059A, r24	; 0x80059a <dig_P6>
     792:	83 89       	ldd	r24, Z+19	; 0x13
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	98 2f       	mov	r25, r24
     798:	88 27       	eor	r24, r24
     79a:	22 89       	ldd	r18, Z+18	; 0x12
     79c:	82 2b       	or	r24, r18
     79e:	90 93 51 05 	sts	0x0551, r25	; 0x800551 <dig_P7+0x1>
     7a2:	80 93 50 05 	sts	0x0550, r24	; 0x800550 <dig_P7>
     7a6:	85 89       	ldd	r24, Z+21	; 0x15
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	98 2f       	mov	r25, r24
     7ac:	88 27       	eor	r24, r24
     7ae:	24 89       	ldd	r18, Z+20	; 0x14
     7b0:	82 2b       	or	r24, r18
     7b2:	90 93 95 05 	sts	0x0595, r25	; 0x800595 <dig_P8+0x1>
     7b6:	80 93 94 05 	sts	0x0594, r24	; 0x800594 <dig_P8>
     7ba:	87 89       	ldd	r24, Z+23	; 0x17
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	98 2f       	mov	r25, r24
     7c0:	88 27       	eor	r24, r24
     7c2:	26 89       	ldd	r18, Z+22	; 0x16
     7c4:	82 2b       	or	r24, r18
     7c6:	90 93 97 05 	sts	0x0597, r25	; 0x800597 <dig_P9+0x1>
     7ca:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <dig_P9>
     7ce:	df 91       	pop	r29
}
     7d0:	cf 91       	pop	r28
     7d2:	1f 91       	pop	r17
     7d4:	0f 91       	pop	r16
     7d6:	ff 90       	pop	r15
     7d8:	08 95       	ret

000007da <bme280basic_init>:
     7da:	ef e4       	ldi	r30, 0x4F	; 79
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     7dc:	f4 e0       	ldi	r31, 0x04	; 4
     7de:	8c ee       	ldi	r24, 0xEC	; 236
     7e0:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     7e2:	80 ee       	ldi	r24, 0xE0	; 224
     7e4:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     7e6:	86 eb       	ldi	r24, 0xB6	; 182
     7e8:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     7ea:	63 e0       	ldi	r22, 0x03	; 3
     7ec:	cf 01       	movw	r24, r30
     7ee:	f8 d3       	rcall	.+2032   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     7f0:	f3 d3       	rcall	.+2022   	; 0xfd8 <TWI_Transceiver_Busy>
     7f2:	81 11       	cpse	r24, r1
     7f4:	fd cf       	rjmp	.-6      	; 0x7f0 <bme280basic_init+0x16>
     7f6:	ef e4       	ldi	r30, 0x4F	; 79
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     7f8:	f4 e0       	ldi	r31, 0x04	; 4
     7fa:	8c ee       	ldi	r24, 0xEC	; 236
     7fc:	80 83       	st	Z, r24
     7fe:	80 ed       	ldi	r24, 0xD0	; 208
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     800:	81 83       	std	Z+1, r24	; 0x01
     802:	62 e0       	ldi	r22, 0x02	; 2
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     804:	cf 01       	movw	r24, r30
     806:	ec d3       	rcall	.+2008   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     808:	e7 d3       	rcall	.+1998   	; 0xfd8 <TWI_Transceiver_Busy>
     80a:	81 11       	cpse	r24, r1
     80c:	fd cf       	rjmp	.-6      	; 0x808 <bme280basic_init+0x2e>
     80e:	8d ee       	ldi	r24, 0xED	; 237
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     810:	80 93 4f 04 	sts	0x044F, r24	; 0x80044f <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     814:	62 e0       	ldi	r22, 0x02	; 2
     816:	8f e4       	ldi	r24, 0x4F	; 79
     818:	94 e0       	ldi	r25, 0x04	; 4
     81a:	e2 d3       	rcall	.+1988   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     81c:	dd d3       	rcall	.+1978   	; 0xfd8 <TWI_Transceiver_Busy>
     81e:	81 11       	cpse	r24, r1
     820:	fd cf       	rjmp	.-6      	; 0x81c <bme280basic_init+0x42>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     822:	62 e0       	ldi	r22, 0x02	; 2
     824:	8f e4       	ldi	r24, 0x4F	; 79
     826:	94 e0       	ldi	r25, 0x04	; 4
     828:	07 d4       	rcall	.+2062   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     82a:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     82e:	80 91 50 04 	lds	r24, 0x0450	; 0x800450 <BMEmessageBuf+0x1>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     832:	80 36       	cpi	r24, 0x60	; 96
     834:	69 f5       	brne	.+90     	; 0x890 <bme280basic_init+0xb6>
     836:	ef e4       	ldi	r30, 0x4F	; 79
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     838:	f4 e0       	ldi	r31, 0x04	; 4
     83a:	8c ee       	ldi	r24, 0xEC	; 236
     83c:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     83e:	82 ef       	ldi	r24, 0xF2	; 242
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     840:	81 83       	std	Z+1, r24	; 0x01
     842:	81 e0       	ldi	r24, 0x01	; 1
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     844:	82 83       	std	Z+2, r24	; 0x02
     846:	63 e0       	ldi	r22, 0x03	; 3
     848:	cf 01       	movw	r24, r30
     84a:	ca d3       	rcall	.+1940   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     84c:	c5 d3       	rcall	.+1930   	; 0xfd8 <TWI_Transceiver_Busy>
     84e:	81 11       	cpse	r24, r1
     850:	fd cf       	rjmp	.-6      	; 0x84c <bme280basic_init+0x72>
     852:	ef e4       	ldi	r30, 0x4F	; 79
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     854:	f4 e0       	ldi	r31, 0x04	; 4
     856:	8c ee       	ldi	r24, 0xEC	; 236
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     858:	80 83       	st	Z, r24
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     85a:	85 ef       	ldi	r24, 0xF5	; 245
     85c:	81 83       	std	Z+1, r24	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     85e:	80 e1       	ldi	r24, 0x10	; 16
     860:	82 83       	std	Z+2, r24	; 0x02
     862:	63 e0       	ldi	r22, 0x03	; 3
     864:	cf 01       	movw	r24, r30
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     866:	bc d3       	rcall	.+1912   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
     868:	b7 d3       	rcall	.+1902   	; 0xfd8 <TWI_Transceiver_Busy>
     86a:	81 11       	cpse	r24, r1
     86c:	fd cf       	rjmp	.-6      	; 0x868 <bme280basic_init+0x8e>
		//
		BME_read_correction_coefficients();
     86e:	dc de       	rcall	.-584    	; 0x628 <BME_read_correction_coefficients>
     870:	81 e3       	ldi	r24, 0x31	; 49
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     872:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     876:	ef e4       	ldi	r30, 0x4F	; 79
     878:	f4 e0       	ldi	r31, 0x04	; 4
     87a:	9c ee       	ldi	r25, 0xEC	; 236
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     87c:	90 83       	st	Z, r25
     87e:	94 ef       	ldi	r25, 0xF4	; 244
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     880:	91 83       	std	Z+1, r25	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     882:	82 83       	std	Z+2, r24	; 0x02
     884:	63 e0       	ldi	r22, 0x03	; 3
     886:	cf 01       	movw	r24, r30
     888:	ab d3       	rcall	.+1878   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     88a:	a6 d3       	rcall	.+1868   	; 0xfd8 <TWI_Transceiver_Busy>
     88c:	81 11       	cpse	r24, r1
     88e:	fd cf       	rjmp	.-6      	; 0x88a <bme280basic_init+0xb0>
     890:	08 95       	ret

00000892 <bme280basic_bulk_data_read>:
     892:	ff 92       	push	r15
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     89c:	81 e0       	ldi	r24, 0x01	; 1
     89e:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <BMEbusy.2461>
	while (BMEbusy) {
     8a2:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <BMEbusy.2461>
     8a6:	88 23       	and	r24, r24
     8a8:	31 f1       	breq	.+76     	; 0x8f6 <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8aa:	cf e4       	ldi	r28, 0x4F	; 79
     8ac:	d4 e0       	ldi	r29, 0x04	; 4
     8ae:	0f 2e       	mov	r0, r31
     8b0:	fc ee       	ldi	r31, 0xEC	; 236
     8b2:	ff 2e       	mov	r15, r31
     8b4:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     8b6:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     8b8:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8ba:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     8bc:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     8be:	62 e0       	ldi	r22, 0x02	; 2
     8c0:	ce 01       	movw	r24, r28
     8c2:	8e d3       	rcall	.+1820   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     8c4:	89 d3       	rcall	.+1810   	; 0xfd8 <TWI_Transceiver_Busy>
     8c6:	81 11       	cpse	r24, r1
     8c8:	fd cf       	rjmp	.-6      	; 0x8c4 <bme280basic_bulk_data_read+0x32>
     8ca:	18 83       	st	Y, r17
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     8cc:	62 e0       	ldi	r22, 0x02	; 2
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     8ce:	ce 01       	movw	r24, r28
     8d0:	87 d3       	rcall	.+1806   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     8d2:	82 d3       	rcall	.+1796   	; 0xfd8 <TWI_Transceiver_Busy>
     8d4:	81 11       	cpse	r24, r1
     8d6:	fd cf       	rjmp	.-6      	; 0x8d2 <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     8d8:	62 e0       	ldi	r22, 0x02	; 2
     8da:	ce 01       	movw	r24, r28
     8dc:	ad d3       	rcall	.+1882   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     8de:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     8e4:	83 fb       	bst	r24, 3
     8e6:	88 27       	eor	r24, r24
     8e8:	80 f9       	bld	r24, 0
     8ea:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <BMEbusy.2461>
     8ee:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <BMEbusy.2461>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     8f2:	81 11       	cpse	r24, r1
     8f4:	e2 cf       	rjmp	.-60     	; 0x8ba <bme280basic_bulk_data_read+0x28>
     8f6:	ef e4       	ldi	r30, 0x4F	; 79
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8f8:	f4 e0       	ldi	r31, 0x04	; 4
     8fa:	8c ee       	ldi	r24, 0xEC	; 236
     8fc:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     8fe:	87 ef       	ldi	r24, 0xF7	; 247
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     900:	81 83       	std	Z+1, r24	; 0x01
     902:	62 e0       	ldi	r22, 0x02	; 2
     904:	cf 01       	movw	r24, r30
     906:	6c d3       	rcall	.+1752   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     908:	67 d3       	rcall	.+1742   	; 0xfd8 <TWI_Transceiver_Busy>
     90a:	81 11       	cpse	r24, r1
     90c:	fd cf       	rjmp	.-6      	; 0x908 <__stack+0x9>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     90e:	8d ee       	ldi	r24, 0xED	; 237
     910:	80 93 4f 04 	sts	0x044F, r24	; 0x80044f <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     914:	69 e0       	ldi	r22, 0x09	; 9
     916:	8f e4       	ldi	r24, 0x4F	; 79
     918:	94 e0       	ldi	r25, 0x04	; 4
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     91a:	62 d3       	rcall	.+1732   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
     91c:	5d d3       	rcall	.+1722   	; 0xfd8 <TWI_Transceiver_Busy>
     91e:	81 11       	cpse	r24, r1
     920:	fd cf       	rjmp	.-6      	; 0x91c <__stack+0x1d>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     922:	69 e0       	ldi	r22, 0x09	; 9
     924:	8f e4       	ldi	r24, 0x4F	; 79
     926:	94 e0       	ldi	r25, 0x04	; 4
     928:	87 d3       	rcall	.+1806   	; 0x1038 <TWI_Get_Data_From_Transceiver>
     92a:	80 93 4e 04 	sts	0x044E, r24	; 0x80044e <TWI_XFER_STATUS>
     92e:	e0 e5       	ldi	r30, 0x50	; 80
     930:	f4 e0       	ldi	r31, 0x04	; 4
     932:	a6 e5       	ldi	r26, 0x56	; 86
     934:	b5 e0       	ldi	r27, 0x05	; 5
     936:	28 e5       	ldi	r18, 0x58	; 88
     938:	34 e0       	ldi	r19, 0x04	; 4
     93a:	81 91       	ld	r24, Z+
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     93c:	8d 93       	st	X+, r24
     93e:	e2 17       	cp	r30, r18
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     940:	f3 07       	cpc	r31, r19
     942:	d9 f7       	brne	.-10     	; 0x93a <__stack+0x3b>
     944:	e6 e5       	ldi	r30, 0x56	; 86
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     946:	f5 e0       	ldi	r31, 0x05	; 5
     948:	80 81       	ld	r24, Z
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	a0 e0       	ldi	r26, 0x00	; 0
     94e:	b0 e0       	ldi	r27, 0x00	; 0
     950:	ac 01       	movw	r20, r24
     952:	bd 01       	movw	r22, r26
     954:	03 2e       	mov	r0, r19
     956:	3c e0       	ldi	r19, 0x0C	; 12
     958:	44 0f       	add	r20, r20
     95a:	55 1f       	adc	r21, r21
     95c:	66 1f       	adc	r22, r22
     95e:	77 1f       	adc	r23, r23
     960:	3a 95       	dec	r19
     962:	d1 f7       	brne	.-12     	; 0x958 <__stack+0x59>
     964:	30 2d       	mov	r19, r0
     966:	91 81       	ldd	r25, Z+1	; 0x01
     968:	89 2f       	mov	r24, r25
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	a0 e0       	ldi	r26, 0x00	; 0
     96e:	b0 e0       	ldi	r27, 0x00	; 0
     970:	88 0f       	add	r24, r24
     972:	99 1f       	adc	r25, r25
     974:	aa 1f       	adc	r26, r26
     976:	bb 1f       	adc	r27, r27
     978:	88 0f       	add	r24, r24
     97a:	99 1f       	adc	r25, r25
     97c:	aa 1f       	adc	r26, r26
     97e:	bb 1f       	adc	r27, r27
     980:	88 0f       	add	r24, r24
     982:	99 1f       	adc	r25, r25
     984:	aa 1f       	adc	r26, r26
     986:	bb 1f       	adc	r27, r27
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	aa 1f       	adc	r26, r26
     98e:	bb 1f       	adc	r27, r27
     990:	84 2b       	or	r24, r20
     992:	95 2b       	or	r25, r21
     994:	a6 2b       	or	r26, r22
     996:	b7 2b       	or	r27, r23
     998:	22 81       	ldd	r18, Z+2	; 0x02
     99a:	22 95       	swap	r18
     99c:	2f 70       	andi	r18, 0x0F	; 15
     99e:	82 2b       	or	r24, r18
     9a0:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <rawPress>
     9a4:	90 93 87 05 	sts	0x0587, r25	; 0x800587 <rawPress+0x1>
     9a8:	a0 93 88 05 	sts	0x0588, r26	; 0x800588 <rawPress+0x2>
     9ac:	b0 93 89 05 	sts	0x0589, r27	; 0x800589 <rawPress+0x3>
     9b0:	83 81       	ldd	r24, Z+3	; 0x03
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	a0 e0       	ldi	r26, 0x00	; 0
     9b6:	b0 e0       	ldi	r27, 0x00	; 0
     9b8:	ac 01       	movw	r20, r24
     9ba:	bd 01       	movw	r22, r26
     9bc:	03 2e       	mov	r0, r19
     9be:	3c e0       	ldi	r19, 0x0C	; 12
     9c0:	44 0f       	add	r20, r20
     9c2:	55 1f       	adc	r21, r21
     9c4:	66 1f       	adc	r22, r22
     9c6:	77 1f       	adc	r23, r23
     9c8:	3a 95       	dec	r19
     9ca:	d1 f7       	brne	.-12     	; 0x9c0 <__stack+0xc1>
     9cc:	30 2d       	mov	r19, r0
     9ce:	94 81       	ldd	r25, Z+4	; 0x04
     9d0:	89 2f       	mov	r24, r25
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	a0 e0       	ldi	r26, 0x00	; 0
     9d6:	b0 e0       	ldi	r27, 0x00	; 0
     9d8:	88 0f       	add	r24, r24
     9da:	99 1f       	adc	r25, r25
     9dc:	aa 1f       	adc	r26, r26
     9de:	bb 1f       	adc	r27, r27
     9e0:	88 0f       	add	r24, r24
     9e2:	99 1f       	adc	r25, r25
     9e4:	aa 1f       	adc	r26, r26
     9e6:	bb 1f       	adc	r27, r27
     9e8:	88 0f       	add	r24, r24
     9ea:	99 1f       	adc	r25, r25
     9ec:	aa 1f       	adc	r26, r26
     9ee:	bb 1f       	adc	r27, r27
     9f0:	88 0f       	add	r24, r24
     9f2:	99 1f       	adc	r25, r25
     9f4:	aa 1f       	adc	r26, r26
     9f6:	bb 1f       	adc	r27, r27
     9f8:	84 2b       	or	r24, r20
     9fa:	95 2b       	or	r25, r21
     9fc:	a6 2b       	or	r26, r22
     9fe:	b7 2b       	or	r27, r23
     a00:	25 81       	ldd	r18, Z+5	; 0x05
     a02:	22 95       	swap	r18
     a04:	2f 70       	andi	r18, 0x0F	; 15
     a06:	82 2b       	or	r24, r18
     a08:	80 93 74 05 	sts	0x0574, r24	; 0x800574 <rawTemp>
     a0c:	90 93 75 05 	sts	0x0575, r25	; 0x800575 <rawTemp+0x1>
     a10:	a0 93 76 05 	sts	0x0576, r26	; 0x800576 <rawTemp+0x2>
     a14:	b0 93 77 05 	sts	0x0577, r27	; 0x800577 <rawTemp+0x3>
     a18:	86 81       	ldd	r24, Z+6	; 0x06
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     a1a:	90 e0       	ldi	r25, 0x00	; 0
     a1c:	a0 e0       	ldi	r26, 0x00	; 0
     a1e:	b0 e0       	ldi	r27, 0x00	; 0
     a20:	ba 2f       	mov	r27, r26
     a22:	a9 2f       	mov	r26, r25
     a24:	98 2f       	mov	r25, r24
     a26:	88 27       	eor	r24, r24
     a28:	27 81       	ldd	r18, Z+7	; 0x07
     a2a:	82 2b       	or	r24, r18
     a2c:	80 93 8a 05 	sts	0x058A, r24	; 0x80058a <rawHum>
     a30:	90 93 8b 05 	sts	0x058B, r25	; 0x80058b <rawHum+0x1>
     a34:	a0 93 8c 05 	sts	0x058C, r26	; 0x80058c <rawHum+0x2>
     a38:	b0 93 8d 05 	sts	0x058D, r27	; 0x80058d <rawHum+0x3>
     a3c:	ef e4       	ldi	r30, 0x4F	; 79
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     a3e:	f4 e0       	ldi	r31, 0x04	; 4
     a40:	8c ee       	ldi	r24, 0xEC	; 236
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     a42:	80 83       	st	Z, r24
     a44:	84 ef       	ldi	r24, 0xF4	; 244
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     a46:	81 83       	std	Z+1, r24	; 0x01
     a48:	81 e3       	ldi	r24, 0x31	; 49
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     a4a:	82 83       	std	Z+2, r24	; 0x02
     a4c:	63 e0       	ldi	r22, 0x03	; 3
     a4e:	cf 01       	movw	r24, r30
     a50:	c7 d2       	rcall	.+1422   	; 0xfe0 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     a52:	c2 d2       	rcall	.+1412   	; 0xfd8 <TWI_Transceiver_Busy>
     a54:	81 11       	cpse	r24, r1
     a56:	fd cf       	rjmp	.-6      	; 0xa52 <__stack+0x153>
     a58:	df 91       	pop	r29
	//  All done - and the next measurement cycle has  been kicked off!
}
     a5a:	cf 91       	pop	r28
     a5c:	1f 91       	pop	r17
     a5e:	0f 91       	pop	r16
     a60:	ff 90       	pop	r15
     a62:	08 95       	ret

00000a64 <BME280_compensate_T_int32>:
     a64:	8f 92       	push	r8

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     a66:	9f 92       	push	r9
     a68:	af 92       	push	r10
     a6a:	bf 92       	push	r11
     a6c:	cf 92       	push	r12
     a6e:	df 92       	push	r13
     a70:	ef 92       	push	r14
     a72:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     a74:	20 91 52 05 	lds	r18, 0x0552	; 0x800552 <dig_T1>
     a78:	30 91 53 05 	lds	r19, 0x0553	; 0x800553 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     a7c:	6b 01       	movw	r12, r22
     a7e:	7c 01       	movw	r14, r24
     a80:	68 94       	set
     a82:	13 f8       	bld	r1, 3
     a84:	f5 94       	asr	r15
     a86:	e7 94       	ror	r14
     a88:	d7 94       	ror	r13
     a8a:	c7 94       	ror	r12
     a8c:	16 94       	lsr	r1
     a8e:	d1 f7       	brne	.-12     	; 0xa84 <BME280_compensate_T_int32+0x20>
     a90:	c2 1a       	sub	r12, r18
     a92:	d3 0a       	sbc	r13, r19
     a94:	e1 08       	sbc	r14, r1
     a96:	f1 08       	sbc	r15, r1
	t_fine = var1 + var2;
     a98:	dc 01       	movw	r26, r24
     a9a:	cb 01       	movw	r24, r22
     a9c:	68 94       	set
     a9e:	12 f8       	bld	r1, 2
     aa0:	b5 95       	asr	r27
     aa2:	a7 95       	ror	r26
     aa4:	97 95       	ror	r25
     aa6:	87 95       	ror	r24
     aa8:	16 94       	lsr	r1
     aaa:	d1 f7       	brne	.-12     	; 0xaa0 <BME280_compensate_T_int32+0x3c>
     aac:	22 0f       	add	r18, r18
     aae:	33 1f       	adc	r19, r19
     ab0:	4c 01       	movw	r8, r24
     ab2:	5d 01       	movw	r10, r26
     ab4:	82 1a       	sub	r8, r18
     ab6:	93 0a       	sbc	r9, r19
     ab8:	a1 08       	sbc	r10, r1
     aba:	b1 08       	sbc	r11, r1
     abc:	a5 01       	movw	r20, r10
     abe:	94 01       	movw	r18, r8
     ac0:	a0 91 54 05 	lds	r26, 0x0554	; 0x800554 <dig_T2>
     ac4:	b0 91 55 05 	lds	r27, 0x0555	; 0x800555 <dig_T2+0x1>
     ac8:	89 d4       	rcall	.+2322   	; 0x13dc <__mulshisi3>
     aca:	4b 01       	movw	r8, r22
     acc:	5c 01       	movw	r10, r24
     ace:	07 2e       	mov	r0, r23
     ad0:	7b e0       	ldi	r23, 0x0B	; 11
     ad2:	b5 94       	asr	r11
     ad4:	a7 94       	ror	r10
     ad6:	97 94       	ror	r9
     ad8:	87 94       	ror	r8
     ada:	7a 95       	dec	r23
     adc:	d1 f7       	brne	.-12     	; 0xad2 <BME280_compensate_T_int32+0x6e>
     ade:	70 2d       	mov	r23, r0
     ae0:	a7 01       	movw	r20, r14
     ae2:	96 01       	movw	r18, r12
     ae4:	c7 01       	movw	r24, r14
     ae6:	b6 01       	movw	r22, r12
     ae8:	3e d4       	rcall	.+2172   	; 0x1366 <__mulsi3>
     aea:	9b 01       	movw	r18, r22
     aec:	ac 01       	movw	r20, r24
     aee:	01 2e       	mov	r0, r17
     af0:	1c e0       	ldi	r17, 0x0C	; 12
     af2:	55 95       	asr	r21
     af4:	47 95       	ror	r20
     af6:	37 95       	ror	r19
     af8:	27 95       	ror	r18
     afa:	1a 95       	dec	r17
     afc:	d1 f7       	brne	.-12     	; 0xaf2 <BME280_compensate_T_int32+0x8e>
     afe:	10 2d       	mov	r17, r0
     b00:	a0 91 98 05 	lds	r26, 0x0598	; 0x800598 <dig_T3>
     b04:	b0 91 99 05 	lds	r27, 0x0599	; 0x800599 <dig_T3+0x1>
     b08:	69 d4       	rcall	.+2258   	; 0x13dc <__mulshisi3>
     b0a:	dc 01       	movw	r26, r24
     b0c:	cb 01       	movw	r24, r22
     b0e:	07 2e       	mov	r0, r23
     b10:	7e e0       	ldi	r23, 0x0E	; 14
     b12:	b5 95       	asr	r27
     b14:	a7 95       	ror	r26
     b16:	97 95       	ror	r25
     b18:	87 95       	ror	r24
     b1a:	7a 95       	dec	r23
     b1c:	d1 f7       	brne	.-12     	; 0xb12 <BME280_compensate_T_int32+0xae>
     b1e:	70 2d       	mov	r23, r0
     b20:	88 0d       	add	r24, r8
     b22:	99 1d       	adc	r25, r9
     b24:	aa 1d       	adc	r26, r10
     b26:	bb 1d       	adc	r27, r11
     b28:	80 93 9c 05 	sts	0x059C, r24	; 0x80059c <t_fine>
     b2c:	90 93 9d 05 	sts	0x059D, r25	; 0x80059d <t_fine+0x1>
     b30:	a0 93 9e 05 	sts	0x059E, r26	; 0x80059e <t_fine+0x2>
     b34:	b0 93 9f 05 	sts	0x059F, r27	; 0x80059f <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
	return T;
     b38:	6c 01       	movw	r12, r24
     b3a:	7d 01       	movw	r14, r26
     b3c:	cc 0c       	add	r12, r12
     b3e:	dd 1c       	adc	r13, r13
     b40:	ee 1c       	adc	r14, r14
     b42:	ff 1c       	adc	r15, r15
     b44:	cc 0c       	add	r12, r12
     b46:	dd 1c       	adc	r13, r13
     b48:	ee 1c       	adc	r14, r14
     b4a:	ff 1c       	adc	r15, r15
     b4c:	8c 0d       	add	r24, r12
     b4e:	9d 1d       	adc	r25, r13
     b50:	ae 1d       	adc	r26, r14
     b52:	bf 1d       	adc	r27, r15
     b54:	80 58       	subi	r24, 0x80	; 128
     b56:	9f 4f       	sbci	r25, 0xFF	; 255
     b58:	af 4f       	sbci	r26, 0xFF	; 255
     b5a:	bf 4f       	sbci	r27, 0xFF	; 255
     b5c:	69 2f       	mov	r22, r25
     b5e:	7a 2f       	mov	r23, r26
     b60:	8b 2f       	mov	r24, r27
     b62:	99 27       	eor	r25, r25
     b64:	87 fd       	sbrc	r24, 7
     b66:	9a 95       	dec	r25
}
     b68:	ff 90       	pop	r15
     b6a:	ef 90       	pop	r14
     b6c:	df 90       	pop	r13
     b6e:	cf 90       	pop	r12
     b70:	bf 90       	pop	r11
     b72:	af 90       	pop	r10
     b74:	9f 90       	pop	r9
     b76:	8f 90       	pop	r8
     b78:	08 95       	ret

00000b7a <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     b7a:	4f 92       	push	r4
     b7c:	5f 92       	push	r5
     b7e:	6f 92       	push	r6
     b80:	7f 92       	push	r7
     b82:	8f 92       	push	r8
     b84:	9f 92       	push	r9
     b86:	af 92       	push	r10
     b88:	bf 92       	push	r11
     b8a:	cf 92       	push	r12
     b8c:	df 92       	push	r13
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	00 d0       	rcall	.+0      	; 0xb98 <BME280_compensate_P_int64+0x1e>
     b98:	00 d0       	rcall	.+0      	; 0xb9a <BME280_compensate_P_int64+0x20>
     b9a:	cd b7       	in	r28, 0x3d	; 61
     b9c:	de b7       	in	r29, 0x3e	; 62
     b9e:	2b 01       	movw	r4, r22
     ba0:	3c 01       	movw	r6, r24
	long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     ba2:	c0 90 9c 05 	lds	r12, 0x059C	; 0x80059c <t_fine>
     ba6:	d0 90 9d 05 	lds	r13, 0x059D	; 0x80059d <t_fine+0x1>
     baa:	e0 90 9e 05 	lds	r14, 0x059E	; 0x80059e <t_fine+0x2>
     bae:	f0 90 9f 05 	lds	r15, 0x059F	; 0x80059f <t_fine+0x3>
     bb2:	24 ef       	ldi	r18, 0xF4	; 244
     bb4:	d2 1a       	sub	r13, r18
     bb6:	21 e0       	ldi	r18, 0x01	; 1
     bb8:	e2 0a       	sbc	r14, r18
     bba:	f1 08       	sbc	r15, r1
	var2 = var1*var1*(long)dig_P6;
     bbc:	a7 01       	movw	r20, r14
     bbe:	96 01       	movw	r18, r12
     bc0:	c7 01       	movw	r24, r14
     bc2:	b6 01       	movw	r22, r12
     bc4:	d0 d3       	rcall	.+1952   	; 0x1366 <__mulsi3>
     bc6:	69 83       	std	Y+1, r22	; 0x01
     bc8:	7a 83       	std	Y+2, r23	; 0x02
     bca:	8b 83       	std	Y+3, r24	; 0x03
     bcc:	9c 83       	std	Y+4, r25	; 0x04
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     bce:	a0 91 78 05 	lds	r26, 0x0578	; 0x800578 <dig_P2>
     bd2:	b0 91 79 05 	lds	r27, 0x0579	; 0x800579 <dig_P2+0x1>
     bd6:	02 d4       	rcall	.+2052   	; 0x13dc <__mulshisi3>
     bd8:	4b 01       	movw	r8, r22
     bda:	5c 01       	movw	r10, r24
     bdc:	07 2e       	mov	r0, r23
     bde:	7c e0       	ldi	r23, 0x0C	; 12
     be0:	88 0c       	add	r8, r8
     be2:	99 1c       	adc	r9, r9
     be4:	aa 1c       	adc	r10, r10
     be6:	bb 1c       	adc	r11, r11
     be8:	7a 95       	dec	r23
     bea:	d1 f7       	brne	.-12     	; 0xbe0 <BME280_compensate_P_int64+0x66>
     bec:	70 2d       	mov	r23, r0
	var1 = (((((long)1)<<47)+var1))*((long)dig_P1)>>33;
     bee:	a0 91 92 05 	lds	r26, 0x0592	; 0x800592 <dig_P3>
     bf2:	b0 91 93 05 	lds	r27, 0x0593	; 0x800593 <dig_P3+0x1>
     bf6:	29 81       	ldd	r18, Y+1	; 0x01
     bf8:	3a 81       	ldd	r19, Y+2	; 0x02
     bfa:	4b 81       	ldd	r20, Y+3	; 0x03
     bfc:	5c 81       	ldd	r21, Y+4	; 0x04
     bfe:	ee d3       	rcall	.+2012   	; 0x13dc <__mulshisi3>
     c00:	bb 27       	eor	r27, r27
     c02:	97 fd       	sbrc	r25, 7
     c04:	ba 95       	dec	r27
     c06:	a9 2f       	mov	r26, r25
     c08:	98 2f       	mov	r25, r24
     c0a:	87 2f       	mov	r24, r23
     c0c:	9c 01       	movw	r18, r24
     c0e:	ad 01       	movw	r20, r26
     c10:	28 0d       	add	r18, r8
     c12:	39 1d       	adc	r19, r9
     c14:	4a 1d       	adc	r20, r10
     c16:	5b 1d       	adc	r21, r11
     c18:	a0 91 90 05 	lds	r26, 0x0590	; 0x800590 <dig_P1>
     c1c:	b0 91 91 05 	lds	r27, 0x0591	; 0x800591 <dig_P1+0x1>
     c20:	d3 d3       	rcall	.+1958   	; 0x13c8 <__muluhisi3>
     c22:	4b 01       	movw	r8, r22
     c24:	5c 01       	movw	r10, r24
     c26:	bb 0c       	add	r11, r11
     c28:	88 08       	sbc	r8, r8
     c2a:	98 2c       	mov	r9, r8
     c2c:	54 01       	movw	r10, r8
	if (var1 == 0)
     c2e:	81 14       	cp	r8, r1
     c30:	91 04       	cpc	r9, r1
     c32:	a1 04       	cpc	r10, r1
     c34:	b1 04       	cpc	r11, r1
     c36:	09 f4       	brne	.+2      	; 0xc3a <BME280_compensate_P_int64+0xc0>
     c38:	9e c0       	rjmp	.+316    	; 0xd76 <BME280_compensate_P_int64+0x1fc>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     c3a:	a0 91 9a 05 	lds	r26, 0x059A	; 0x80059a <dig_P6>
     c3e:	b0 91 9b 05 	lds	r27, 0x059B	; 0x80059b <dig_P6+0x1>
     c42:	29 81       	ldd	r18, Y+1	; 0x01
     c44:	3a 81       	ldd	r19, Y+2	; 0x02
     c46:	4b 81       	ldd	r20, Y+3	; 0x03
     c48:	5c 81       	ldd	r21, Y+4	; 0x04
     c4a:	c8 d3       	rcall	.+1936   	; 0x13dc <__mulshisi3>
     c4c:	69 83       	std	Y+1, r22	; 0x01
     c4e:	7a 83       	std	Y+2, r23	; 0x02
     c50:	8b 83       	std	Y+3, r24	; 0x03
     c52:	9c 83       	std	Y+4, r25	; 0x04
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     c54:	77 24       	eor	r7, r7
     c56:	46 94       	lsr	r4
     c58:	77 94       	ror	r7
     c5a:	66 24       	eor	r6, r6
     c5c:	55 24       	eor	r5, r5
     c5e:	44 24       	eor	r4, r4
     c60:	a0 91 83 05 	lds	r26, 0x0583	; 0x800583 <dig_P5>
     c64:	b0 91 84 05 	lds	r27, 0x0584	; 0x800584 <dig_P5+0x1>
     c68:	a7 01       	movw	r20, r14
     c6a:	96 01       	movw	r18, r12
     c6c:	b7 d3       	rcall	.+1902   	; 0x13dc <__mulshisi3>
     c6e:	dc 01       	movw	r26, r24
     c70:	cb 01       	movw	r24, r22
     c72:	07 2e       	mov	r0, r23
     c74:	71 e1       	ldi	r23, 0x11	; 17
     c76:	88 0f       	add	r24, r24
     c78:	99 1f       	adc	r25, r25
     c7a:	aa 1f       	adc	r26, r26
     c7c:	bb 1f       	adc	r27, r27
     c7e:	7a 95       	dec	r23
     c80:	d1 f7       	brne	.-12     	; 0xc76 <BME280_compensate_P_int64+0xfc>
     c82:	70 2d       	mov	r23, r0
     c84:	29 81       	ldd	r18, Y+1	; 0x01
     c86:	3a 81       	ldd	r19, Y+2	; 0x02
     c88:	4b 81       	ldd	r20, Y+3	; 0x03
     c8a:	5c 81       	ldd	r21, Y+4	; 0x04
     c8c:	82 0f       	add	r24, r18
     c8e:	93 1f       	adc	r25, r19
     c90:	a4 1f       	adc	r26, r20
     c92:	b5 1f       	adc	r27, r21
     c94:	a3 01       	movw	r20, r6
     c96:	92 01       	movw	r18, r4
     c98:	28 1b       	sub	r18, r24
     c9a:	39 0b       	sbc	r19, r25
     c9c:	4a 0b       	sbc	r20, r26
     c9e:	5b 0b       	sbc	r21, r27
     ca0:	a5 e3       	ldi	r26, 0x35	; 53
     ca2:	bc e0       	ldi	r27, 0x0C	; 12
     ca4:	91 d3       	rcall	.+1826   	; 0x13c8 <__muluhisi3>
     ca6:	a5 01       	movw	r20, r10
     ca8:	94 01       	movw	r18, r8
     caa:	6c d3       	rcall	.+1752   	; 0x1384 <__divmodsi4>
     cac:	49 01       	movw	r8, r18
     cae:	5a 01       	movw	r10, r20
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     cb0:	69 01       	movw	r12, r18
     cb2:	7a 01       	movw	r14, r20
     cb4:	0b 2e       	mov	r0, r27
     cb6:	bd e0       	ldi	r27, 0x0D	; 13
     cb8:	f5 94       	asr	r15
     cba:	e7 94       	ror	r14
     cbc:	d7 94       	ror	r13
     cbe:	c7 94       	ror	r12
     cc0:	ba 95       	dec	r27
     cc2:	d1 f7       	brne	.-12     	; 0xcb8 <BME280_compensate_P_int64+0x13e>
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+((long)dig_P7)<<4;
     cc4:	b0 2d       	mov	r27, r0
     cc6:	a0 91 96 05 	lds	r26, 0x0596	; 0x800596 <dig_P9>
     cca:	b0 91 97 05 	lds	r27, 0x0597	; 0x800597 <dig_P9+0x1>
     cce:	a7 01       	movw	r20, r14
     cd0:	96 01       	movw	r18, r12
     cd2:	84 d3       	rcall	.+1800   	; 0x13dc <__mulshisi3>
     cd4:	9b 01       	movw	r18, r22
     cd6:	ac 01       	movw	r20, r24
     cd8:	c7 01       	movw	r24, r14
     cda:	b6 01       	movw	r22, r12
     cdc:	44 d3       	rcall	.+1672   	; 0x1366 <__mulsi3>
     cde:	dc 01       	movw	r26, r24
     ce0:	cb 01       	movw	r24, r22
     ce2:	07 2e       	mov	r0, r23
     ce4:	79 e1       	ldi	r23, 0x19	; 25
     ce6:	b5 95       	asr	r27
     ce8:	a7 95       	ror	r26
     cea:	97 95       	ror	r25
     cec:	87 95       	ror	r24
     cee:	7a 95       	dec	r23
     cf0:	d1 f7       	brne	.-12     	; 0xce6 <BME280_compensate_P_int64+0x16c>
     cf2:	70 2d       	mov	r23, r0
     cf4:	6c 01       	movw	r12, r24
     cf6:	7d 01       	movw	r14, r26
     cf8:	c8 0c       	add	r12, r8
     cfa:	d9 1c       	adc	r13, r9
     cfc:	ea 1c       	adc	r14, r10
     cfe:	fb 1c       	adc	r15, r11
     d00:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <dig_P8>
     d04:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <dig_P8+0x1>
     d08:	a5 01       	movw	r20, r10
     d0a:	94 01       	movw	r18, r8
     d0c:	67 d3       	rcall	.+1742   	; 0x13dc <__mulshisi3>
     d0e:	dc 01       	movw	r26, r24
     d10:	cb 01       	movw	r24, r22
     d12:	07 2e       	mov	r0, r23
     d14:	73 e1       	ldi	r23, 0x13	; 19
     d16:	b5 95       	asr	r27
     d18:	a7 95       	ror	r26
     d1a:	97 95       	ror	r25
     d1c:	87 95       	ror	r24
     d1e:	7a 95       	dec	r23
     d20:	d1 f7       	brne	.-12     	; 0xd16 <BME280_compensate_P_int64+0x19c>
     d22:	70 2d       	mov	r23, r0
     d24:	8c 0d       	add	r24, r12
     d26:	9d 1d       	adc	r25, r13
     d28:	ae 1d       	adc	r26, r14
     d2a:	bf 1d       	adc	r27, r15
     d2c:	49 2f       	mov	r20, r25
     d2e:	5a 2f       	mov	r21, r26
     d30:	6b 2f       	mov	r22, r27
     d32:	77 27       	eor	r23, r23
     d34:	67 fd       	sbrc	r22, 7
     d36:	7a 95       	dec	r23
     d38:	80 91 50 05 	lds	r24, 0x0550	; 0x800550 <dig_P7>
     d3c:	90 91 51 05 	lds	r25, 0x0551	; 0x800551 <dig_P7+0x1>
     d40:	09 2e       	mov	r0, r25
     d42:	00 0c       	add	r0, r0
     d44:	aa 0b       	sbc	r26, r26
     d46:	bb 0b       	sbc	r27, r27
     d48:	84 0f       	add	r24, r20
     d4a:	95 1f       	adc	r25, r21
     d4c:	a6 1f       	adc	r26, r22
     d4e:	b7 1f       	adc	r27, r23
     d50:	88 0f       	add	r24, r24
     d52:	99 1f       	adc	r25, r25
     d54:	aa 1f       	adc	r26, r26
     d56:	bb 1f       	adc	r27, r27
     d58:	88 0f       	add	r24, r24
     d5a:	99 1f       	adc	r25, r25
     d5c:	aa 1f       	adc	r26, r26
     d5e:	bb 1f       	adc	r27, r27
	return(long)p;
     d60:	bc 01       	movw	r22, r24
     d62:	cd 01       	movw	r24, r26
     d64:	66 0f       	add	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	88 1f       	adc	r24, r24
     d6a:	99 1f       	adc	r25, r25
     d6c:	66 0f       	add	r22, r22
     d6e:	77 1f       	adc	r23, r23
     d70:	88 1f       	adc	r24, r24
     d72:	99 1f       	adc	r25, r25
     d74:	03 c0       	rjmp	.+6      	; 0xd7c <BME280_compensate_P_int64+0x202>
	var2 = var2 + (((long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long)1)<<47)+var1))*((long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
     d76:	60 e0       	ldi	r22, 0x00	; 0
     d78:	70 e0       	ldi	r23, 0x00	; 0
     d7a:	cb 01       	movw	r24, r22
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+((long)dig_P7)<<4;
	return(long)p;
}
     d7c:	0f 90       	pop	r0
     d7e:	0f 90       	pop	r0
     d80:	0f 90       	pop	r0
     d82:	0f 90       	pop	r0
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	ff 90       	pop	r15
     d8a:	ef 90       	pop	r14
     d8c:	df 90       	pop	r13
     d8e:	cf 90       	pop	r12
     d90:	bf 90       	pop	r11
     d92:	af 90       	pop	r10
     d94:	9f 90       	pop	r9
     d96:	8f 90       	pop	r8
     d98:	7f 90       	pop	r7
     d9a:	6f 90       	pop	r6
     d9c:	5f 90       	pop	r5
     d9e:	4f 90       	pop	r4
     da0:	08 95       	ret

00000da2 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
     da2:	81 da       	rcall	.-2814   	; 0x2a6 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
     da4:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <seconds+0x1>
     da8:	10 92 8e 05 	sts	0x058E, r1	; 0x80058e <seconds>
	ItsTime=0;
     dac:	10 92 0c 04 	sts	0x040C, r1	; 0x80040c <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout0;
     db0:	8b e2       	ldi	r24, 0x2B	; 43
     db2:	91 e0       	ldi	r25, 0x01	; 1
     db4:	90 93 a3 07 	sts	0x07A3, r25	; 0x8007a3 <__iob+0x3>
     db8:	80 93 a2 07 	sts	0x07A2, r24	; 0x8007a2 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
     dbc:	e0 d0       	rcall	.+448    	; 0xf7e <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
     dbe:	81 e8       	ldi	r24, 0x81	; 129
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	d9 d1       	rcall	.+946    	; 0x1176 <USART0_init>
	USART1_init(MYUBRR1);
     dc4:	81 e8       	ldi	r24, 0x81	; 129
     dc6:	90 e0       	ldi	r25, 0x00	; 0
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
     dc8:	4a d2       	rcall	.+1172   	; 0x125e <USART1_init>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
     dca:	fc d0       	rcall	.+504    	; 0xfc4 <TWI_Master_Initialise>
	//
	// FOR DEBUG ONLY: Initialize the RGB sensor - Craig uses this to ensure I2C is working
//	RGBsensor_init();
	//
 	// initialize the gas sensors
	gas_sensors_init();
     dcc:	ce d9       	rcall	.-3172   	; 0x16a <ADC_init>
     dce:	b8 da       	rcall	.-2704   	; 0x340 <gas_sensors_init>
	// 
	// Start all interrupts
	sei();
     dd0:	78 94       	sei
	//
	// Initialize the pressure / temperature /  humidity sensor
	// BME280_init(); 
	//
	// Check the BME interface...
	bme280basic_init();
     dd2:	03 dd       	rcall	.-1530   	; 0x7da <bme280basic_init>
     dd4:	81 e0       	ldi	r24, 0x01	; 1
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
     dd6:	91 e0       	ldi	r25, 0x01	; 1
     dd8:	0b d2       	rcall	.+1046   	; 0x11f0 <USART0_putstring>
     dda:	2f e7       	ldi	r18, 0x7F	; 127
     ddc:	84 e8       	ldi	r24, 0x84	; 132
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     dde:	9e e1       	ldi	r25, 0x1E	; 30
     de0:	21 50       	subi	r18, 0x01	; 1
     de2:	80 40       	sbci	r24, 0x00	; 0
     de4:	90 40       	sbci	r25, 0x00	; 0
     de6:	e1 f7       	brne	.-8      	; 0xde0 <main+0x3e>
     de8:	00 c0       	rjmp	.+0      	; 0xdea <main+0x48>
     dea:	00 00       	nop
     dec:	8a e3       	ldi	r24, 0x3A	; 58
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
    printf("hi ");
     dee:	91 e0       	ldi	r25, 0x01	; 1
     df0:	9f 93       	push	r25
     df2:	8f 93       	push	r24
     df4:	61 d3       	rcall	.+1730   	; 0x14b8 <printf>
     df6:	0f 90       	pop	r0
     df8:	0f 90       	pop	r0
     dfa:	0f 2e       	mov	r0, r31
     dfc:	fe e3       	ldi	r31, 0x3E	; 62
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u \n", seconds);
     dfe:	ef 2e       	mov	r14, r31
     e00:	f1 e0       	ldi	r31, 0x01	; 1
     e02:	ff 2e       	mov	r15, r31
     e04:	f0 2d       	mov	r31, r0
     e06:	0f 2e       	mov	r0, r31
     e08:	f4 ed       	ldi	r31, 0xD4	; 212
     e0a:	8f 2e       	mov	r8, r31
     e0c:	f6 e0       	ldi	r31, 0x06	; 6
     e0e:	9f 2e       	mov	r9, r31
     e10:	f0 2d       	mov	r31, r0
     e12:	0f 2e       	mov	r0, r31
     e14:	fe e4       	ldi	r31, 0x4E	; 78
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
     e16:	af 2e       	mov	r10, r31
     e18:	f1 e0       	ldi	r31, 0x01	; 1
     e1a:	bf 2e       	mov	r11, r31
     e1c:	f0 2d       	mov	r31, r0
     e1e:	0b e2       	ldi	r16, 0x2B	; 43
     e20:	14 e0       	ldi	r17, 0x04	; 4
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
     e22:	0f 2e       	mov	r0, r31
     e24:	f3 e6       	ldi	r31, 0x63	; 99
     e26:	cf 2e       	mov	r12, r31
     e28:	f1 e0       	ldi	r31, 0x01	; 1
     e2a:	df 2e       	mov	r13, r31
     e2c:	f0 2d       	mov	r31, r0
     e2e:	0f 2e       	mov	r0, r31
     e30:	f9 e7       	ldi	r31, 0x79	; 121
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
     e32:	6f 2e       	mov	r6, r31
     e34:	f1 e0       	ldi	r31, 0x01	; 1
     e36:	7f 2e       	mov	r7, r31
     e38:	f0 2d       	mov	r31, r0
     e3a:	0f 2e       	mov	r0, r31
     e3c:	f8 e8       	ldi	r31, 0x88	; 136
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
     e3e:	4f 2e       	mov	r4, r31
     e40:	f1 e0       	ldi	r31, 0x01	; 1
     e42:	5f 2e       	mov	r5, r31
     e44:	f0 2d       	mov	r31, r0
     e46:	0f 2e       	mov	r0, r31
     e48:	f6 e9       	ldi	r31, 0x96	; 150
 			printf("\nMethane = %u", raw_gas_vector[3]);
     e4a:	2f 2e       	mov	r2, r31
     e4c:	f1 e0       	ldi	r31, 0x01	; 1
     e4e:	3f 2e       	mov	r3, r31
     e50:	f0 2d       	mov	r31, r0
     e52:	80 91 0c 04 	lds	r24, 0x040C	; 0x80040c <ItsTime>
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
     e56:	81 30       	cpi	r24, 0x01	; 1
     e58:	e1 f7       	brne	.-8      	; 0xe52 <main+0xb0>
     e5a:	10 92 0c 04 	sts	0x040C, r1	; 0x80040c <ItsTime>
			ItsTime = 0; 
     e5e:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <seconds>
			seconds++;
     e62:	90 91 8f 05 	lds	r25, 0x058F	; 0x80058f <seconds+0x1>
     e66:	01 96       	adiw	r24, 0x01	; 1
     e68:	90 93 8f 05 	sts	0x058F, r25	; 0x80058f <seconds+0x1>
     e6c:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <seconds>
     e70:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <seconds>
			printf("\nSeconds = %u \n", seconds);
     e74:	90 91 8f 05 	lds	r25, 0x058F	; 0x80058f <seconds+0x1>
     e78:	9f 93       	push	r25
     e7a:	8f 93       	push	r24
     e7c:	ff 92       	push	r15
     e7e:	ef 92       	push	r14
     e80:	1b d3       	rcall	.+1590   	; 0x14b8 <printf>
     e82:	c0 ea       	ldi	r28, 0xA0	; 160
     e84:	d6 e0       	ldi	r29, 0x06	; 6
     e86:	0f 90       	pop	r0
     e88:	0f 90       	pop	r0
     e8a:	0f 90       	pop	r0
     e8c:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 51; i++)
			{
				USART0_TransmitByte(messageWant[i]);
     e8e:	89 91       	ld	r24, Y+
     e90:	85 d1       	rcall	.+778    	; 0x119c <USART0_TransmitByte>
     e92:	c8 15       	cp	r28, r8
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 51; i++)
     e94:	d9 05       	cpc	r29, r9
			printf("\n=================");
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
     e96:	d9 f7       	brne	.-10     	; 0xe8e <main+0xec>
     e98:	6b db       	rcall	.-2346   	; 0x570 <LIDAR_distance>
     e9a:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <distance>
     e9e:	90 93 27 04 	sts	0x0427, r25	; 0x800427 <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
     ea2:	9f 93       	push	r25
     ea4:	8f 93       	push	r24
     ea6:	bf 92       	push	r11
     ea8:	af 92       	push	r10
     eaa:	06 d3       	rcall	.+1548   	; 0x14b8 <printf>
			// Davita has this routine specified in the notebook.
			//============================
			//
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
     eac:	c8 da       	rcall	.-2672   	; 0x43e <start_gas_sensor_read>
     eae:	f8 01       	movw	r30, r16
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
     eb0:	81 81       	ldd	r24, Z+1	; 0x01
     eb2:	8f 93       	push	r24
     eb4:	80 81       	ld	r24, Z
     eb6:	8f 93       	push	r24
     eb8:	df 92       	push	r13
     eba:	cf 92       	push	r12
     ebc:	fd d2       	rcall	.+1530   	; 0x14b8 <printf>
     ebe:	f8 01       	movw	r30, r16
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
     ec0:	83 81       	ldd	r24, Z+3	; 0x03
     ec2:	8f 93       	push	r24
     ec4:	82 81       	ldd	r24, Z+2	; 0x02
     ec6:	8f 93       	push	r24
     ec8:	7f 92       	push	r7
     eca:	6f 92       	push	r6
     ecc:	f5 d2       	rcall	.+1514   	; 0x14b8 <printf>
     ece:	f8 01       	movw	r30, r16
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
     ed0:	85 81       	ldd	r24, Z+5	; 0x05
     ed2:	8f 93       	push	r24
     ed4:	84 81       	ldd	r24, Z+4	; 0x04
     ed6:	8f 93       	push	r24
     ed8:	5f 92       	push	r5
     eda:	4f 92       	push	r4
     edc:	ed d2       	rcall	.+1498   	; 0x14b8 <printf>
     ede:	f8 01       	movw	r30, r16
 			printf("\nMethane = %u", raw_gas_vector[3]);
     ee0:	87 81       	ldd	r24, Z+7	; 0x07
     ee2:	8f 93       	push	r24
     ee4:	86 81       	ldd	r24, Z+6	; 0x06
     ee6:	8f 93       	push	r24
     ee8:	3f 92       	push	r3
     eea:	2f 92       	push	r2
     eec:	e5 d2       	rcall	.+1482   	; 0x14b8 <printf>
     eee:	f8 01       	movw	r30, r16
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
     ef0:	81 85       	ldd	r24, Z+9	; 0x09
     ef2:	8f 93       	push	r24
     ef4:	80 85       	ldd	r24, Z+8	; 0x08
     ef6:	8f 93       	push	r24
     ef8:	84 ea       	ldi	r24, 0xA4	; 164
     efa:	91 e0       	ldi	r25, 0x01	; 1
     efc:	9f 93       	push	r25
     efe:	8f 93       	push	r24
     f00:	db d2       	rcall	.+1462   	; 0x14b8 <printf>
     f02:	c7 dc       	rcall	.-1650   	; 0x892 <bme280basic_bulk_data_read>
			// Now test the BME interface...
			// THIS ROUTINE NOT YET WRITTEN
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
     f04:	60 91 74 05 	lds	r22, 0x0574	; 0x800574 <rawTemp>
			tempCelsius = BME280_compensate_T_int32(rawTemp);
     f08:	70 91 75 05 	lds	r23, 0x0575	; 0x800575 <rawTemp+0x1>
     f0c:	80 91 76 05 	lds	r24, 0x0576	; 0x800576 <rawTemp+0x2>
     f10:	90 91 77 05 	lds	r25, 0x0577	; 0x800577 <rawTemp+0x3>
     f14:	a7 dd       	rcall	.-1202   	; 0xa64 <BME280_compensate_T_int32>
     f16:	60 93 70 05 	sts	0x0570, r22	; 0x800570 <tempCelsius>
     f1a:	70 93 71 05 	sts	0x0571, r23	; 0x800571 <tempCelsius+0x1>
     f1e:	80 93 72 05 	sts	0x0572, r24	; 0x800572 <tempCelsius+0x2>
     f22:	90 93 73 05 	sts	0x0573, r25	; 0x800573 <tempCelsius+0x3>
     f26:	9f 93       	push	r25
 			printf("\nCelsius = %lu\n", tempCelsius);
     f28:	8f 93       	push	r24
     f2a:	7f 93       	push	r23
     f2c:	6f 93       	push	r22
     f2e:	81 eb       	ldi	r24, 0xB1	; 177
     f30:	91 e0       	ldi	r25, 0x01	; 1
     f32:	9f 93       	push	r25
     f34:	8f 93       	push	r24
     f36:	c0 d2       	rcall	.+1408   	; 0x14b8 <printf>
     f38:	60 91 86 05 	lds	r22, 0x0586	; 0x800586 <rawPress>
			pressure = BME280_compensate_P_int64(rawPress);
     f3c:	70 91 87 05 	lds	r23, 0x0587	; 0x800587 <rawPress+0x1>
     f40:	80 91 88 05 	lds	r24, 0x0588	; 0x800588 <rawPress+0x2>
     f44:	90 91 89 05 	lds	r25, 0x0589	; 0x800589 <rawPress+0x3>
     f48:	18 de       	rcall	.-976    	; 0xb7a <BME280_compensate_P_int64>
     f4a:	60 93 7d 05 	sts	0x057D, r22	; 0x80057d <pressure>
     f4e:	70 93 7e 05 	sts	0x057E, r23	; 0x80057e <pressure+0x1>
     f52:	80 93 7f 05 	sts	0x057F, r24	; 0x80057f <pressure+0x2>
     f56:	90 93 80 05 	sts	0x0580, r25	; 0x800580 <pressure+0x3>
     f5a:	9f 93       	push	r25
     f5c:	8f 93       	push	r24
			printf("\nPressure in Pa = %lu\n", pressure);
     f5e:	7f 93       	push	r23
     f60:	6f 93       	push	r22
     f62:	81 ec       	ldi	r24, 0xC1	; 193
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	9f 93       	push	r25
     f68:	8f 93       	push	r24
     f6a:	a6 d2       	rcall	.+1356   	; 0x14b8 <printf>
     f6c:	8d b7       	in	r24, 0x3d	; 61
     f6e:	9e b7       	in	r25, 0x3e	; 62
     f70:	84 96       	adiw	r24, 0x24	; 36
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	f8 94       	cli
     f76:	9e bf       	out	0x3e, r25	; 62
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	8d bf       	out	0x3d, r24	; 61
     f7c:	6a cf       	rjmp	.-300    	; 0xe52 <main+0xb0>

00000f7e <initialize_timer_counter_1>:
     f7e:	8d e0       	ldi	r24, 0x0D	; 13
     f80:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
     f84:	8a e4       	ldi	r24, 0x4A	; 74
     f86:	9c e4       	ldi	r25, 0x4C	; 76
     f88:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     f8c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
     f90:	82 e0       	ldi	r24, 0x02	; 2
     f92:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
     f96:	08 95       	ret

00000f98 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
     f98:	18 95       	reti

00000f9a <__vector_13>:
}
*/


ISR(TIMER1_COMPA_vect)
{
     f9a:	1f 92       	push	r1
     f9c:	0f 92       	push	r0
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	0f 92       	push	r0
     fa2:	11 24       	eor	r1, r1
     fa4:	8f 93       	push	r24
     fa6:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
     fa8:	95 b1       	in	r25, 0x05	; 5
     faa:	82 e0       	ldi	r24, 0x02	; 2
     fac:	89 27       	eor	r24, r25
     fae:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <ItsTime>
}
     fb6:	9f 91       	pop	r25
     fb8:	8f 91       	pop	r24
     fba:	0f 90       	pop	r0
     fbc:	0f be       	out	0x3f, r0	; 63
     fbe:	0f 90       	pop	r0
     fc0:	1f 90       	pop	r1
     fc2:	18 95       	reti

00000fc4 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     fc4:	81 e1       	ldi	r24, 0x11	; 17
     fc6:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
     fca:	8f ef       	ldi	r24, 0xFF	; 255
     fcc:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
     fd0:	84 e0       	ldi	r24, 0x04	; 4
     fd2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     fd6:	08 95       	ret

00000fd8 <TWI_Transceiver_Busy>:
     fd8:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
     fdc:	81 78       	andi	r24, 0x81	; 129
     fde:	08 95       	ret

00000fe0 <TWI_Start_Transceiver_With_Data>:
     fe0:	cf 93       	push	r28
     fe2:	df 93       	push	r29
     fe4:	ec 01       	movw	r28, r24
     fe6:	ec eb       	ldi	r30, 0xBC	; 188
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	90 81       	ld	r25, Z
     fec:	91 78       	andi	r25, 0x81	; 129
     fee:	e9 f7       	brne	.-6      	; 0xfea <TWI_Start_Transceiver_With_Data+0xa>
     ff0:	60 93 de 01 	sts	0x01DE, r22	; 0x8001de <TWI_msgSize>
     ff4:	88 81       	ld	r24, Y
     ff6:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <TWI_buf>
     ffa:	80 fd       	sbrc	r24, 0
     ffc:	12 c0       	rjmp	.+36     	; 0x1022 <TWI_Start_Transceiver_With_Data+0x42>
     ffe:	62 30       	cpi	r22, 0x02	; 2
    1000:	80 f0       	brcs	.+32     	; 0x1022 <TWI_Start_Transceiver_With_Data+0x42>
    1002:	fe 01       	movw	r30, r28
    1004:	31 96       	adiw	r30, 0x01	; 1
    1006:	a0 ee       	ldi	r26, 0xE0	; 224
    1008:	b1 e0       	ldi	r27, 0x01	; 1
    100a:	62 50       	subi	r22, 0x02	; 2
    100c:	26 2f       	mov	r18, r22
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	2e 5f       	subi	r18, 0xFE	; 254
    1012:	3f 4f       	sbci	r19, 0xFF	; 255
    1014:	2c 0f       	add	r18, r28
    1016:	3d 1f       	adc	r19, r29
    1018:	91 91       	ld	r25, Z+
    101a:	9d 93       	st	X+, r25
    101c:	e2 17       	cp	r30, r18
    101e:	f3 07       	cpc	r31, r19
    1020:	d9 f7       	brne	.-10     	; 0x1018 <TWI_Start_Transceiver_With_Data+0x38>
    1022:	10 92 dd 01 	sts	0x01DD, r1	; 0x8001dd <TWI_statusReg>
    1026:	88 ef       	ldi	r24, 0xF8	; 248
    1028:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    102c:	85 ea       	ldi	r24, 0xA5	; 165
    102e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	08 95       	ret

00001038 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1038:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    103a:	ec eb       	ldi	r30, 0xBC	; 188
    103c:	f0 e0       	ldi	r31, 0x00	; 0
    103e:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1040:	91 78       	andi	r25, 0x81	; 129
    1042:	e9 f7       	brne	.-6      	; 0x103e <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1044:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <TWI_statusReg>
    1048:	80 ff       	sbrs	r24, 0
    104a:	11 c0       	rjmp	.+34     	; 0x106e <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    104c:	66 23       	and	r22, r22
    104e:	79 f0       	breq	.+30     	; 0x106e <TWI_Get_Data_From_Transceiver+0x36>
    1050:	af ed       	ldi	r26, 0xDF	; 223
    1052:	b1 e0       	ldi	r27, 0x01	; 1
    1054:	fa 01       	movw	r30, r20
    1056:	61 50       	subi	r22, 0x01	; 1
    1058:	26 2f       	mov	r18, r22
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	2f 5f       	subi	r18, 0xFF	; 255
    105e:	3f 4f       	sbci	r19, 0xFF	; 255
    1060:	24 0f       	add	r18, r20
    1062:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    1064:	9d 91       	ld	r25, X+
    1066:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1068:	e2 17       	cp	r30, r18
    106a:	f3 07       	cpc	r31, r19
    106c:	d9 f7       	brne	.-10     	; 0x1064 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    106e:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <TWI_statusReg>
}
    1072:	81 70       	andi	r24, 0x01	; 1
    1074:	08 95       	ret

00001076 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    1076:	1f 92       	push	r1
    1078:	0f 92       	push	r0
    107a:	0f b6       	in	r0, 0x3f	; 63
    107c:	0f 92       	push	r0
    107e:	11 24       	eor	r1, r1
    1080:	2f 93       	push	r18
    1082:	3f 93       	push	r19
    1084:	8f 93       	push	r24
    1086:	9f 93       	push	r25
    1088:	af 93       	push	r26
    108a:	bf 93       	push	r27
    108c:	ef 93       	push	r30
    108e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1090:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1094:	8e 2f       	mov	r24, r30
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	fc 01       	movw	r30, r24
    109a:	38 97       	sbiw	r30, 0x08	; 8
    109c:	e1 35       	cpi	r30, 0x51	; 81
    109e:	f1 05       	cpc	r31, r1
    10a0:	08 f0       	brcs	.+2      	; 0x10a4 <__vector_26+0x2e>
    10a2:	55 c0       	rjmp	.+170    	; 0x114e <__vector_26+0xd8>
    10a4:	e2 5c       	subi	r30, 0xC2	; 194
    10a6:	ff 4f       	sbci	r31, 0xFF	; 255
    10a8:	89 c1       	rjmp	.+786    	; 0x13bc <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    10aa:	10 92 dc 01 	sts	0x01DC, r1	; 0x8001dc <TWI_bufPtr.1674>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    10ae:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <TWI_bufPtr.1674>
    10b2:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <TWI_msgSize>
    10b6:	e8 17       	cp	r30, r24
    10b8:	70 f4       	brcc	.+28     	; 0x10d6 <__vector_26+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	8e 0f       	add	r24, r30
    10be:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <TWI_bufPtr.1674>
    10c2:	f0 e0       	ldi	r31, 0x00	; 0
    10c4:	e1 52       	subi	r30, 0x21	; 33
    10c6:	fe 4f       	sbci	r31, 0xFE	; 254
    10c8:	80 81       	ld	r24, Z
    10ca:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    10ce:	85 e8       	ldi	r24, 0x85	; 133
    10d0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    10d4:	43 c0       	rjmp	.+134    	; 0x115c <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    10d6:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <TWI_statusReg>
    10da:	81 60       	ori	r24, 0x01	; 1
    10dc:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    10e0:	84 e9       	ldi	r24, 0x94	; 148
    10e2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    10e6:	3a c0       	rjmp	.+116    	; 0x115c <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    10e8:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <TWI_bufPtr.1674>
    10ec:	81 e0       	ldi	r24, 0x01	; 1
    10ee:	8e 0f       	add	r24, r30
    10f0:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <TWI_bufPtr.1674>
    10f4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    10f8:	f0 e0       	ldi	r31, 0x00	; 0
    10fa:	e1 52       	subi	r30, 0x21	; 33
    10fc:	fe 4f       	sbci	r31, 0xFE	; 254
    10fe:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1100:	20 91 dc 01 	lds	r18, 0x01DC	; 0x8001dc <TWI_bufPtr.1674>
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <TWI_msgSize>
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	01 97       	sbiw	r24, 0x01	; 1
    110e:	28 17       	cp	r18, r24
    1110:	39 07       	cpc	r19, r25
    1112:	24 f4       	brge	.+8      	; 0x111c <__vector_26+0xa6>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1114:	85 ec       	ldi	r24, 0xC5	; 197
    1116:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    111a:	20 c0       	rjmp	.+64     	; 0x115c <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    111c:	85 e8       	ldi	r24, 0x85	; 133
    111e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1122:	1c c0       	rjmp	.+56     	; 0x115c <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    1124:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1128:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <TWI_bufPtr.1674>
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	e1 52       	subi	r30, 0x21	; 33
    1130:	fe 4f       	sbci	r31, 0xFE	; 254
    1132:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1134:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <TWI_statusReg>
    1138:	81 60       	ori	r24, 0x01	; 1
    113a:	80 93 dd 01 	sts	0x01DD, r24	; 0x8001dd <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    113e:	84 e9       	ldi	r24, 0x94	; 148
    1140:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    1144:	0b c0       	rjmp	.+22     	; 0x115c <__vector_26+0xe6>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1146:	85 ea       	ldi	r24, 0xA5	; 165
    1148:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    114c:	07 c0       	rjmp	.+14     	; 0x115c <__vector_26+0xe6>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    114e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1152:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1156:	84 e0       	ldi	r24, 0x04	; 4
    1158:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    115c:	ff 91       	pop	r31
    115e:	ef 91       	pop	r30
    1160:	bf 91       	pop	r27
    1162:	af 91       	pop	r26
    1164:	9f 91       	pop	r25
    1166:	8f 91       	pop	r24
    1168:	3f 91       	pop	r19
    116a:	2f 91       	pop	r18
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    1176:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    117a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    117e:	88 e9       	ldi	r24, 0x98	; 152
    1180:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1184:	8e e0       	ldi	r24, 0x0E	; 14
    1186:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    118a:	10 92 f1 02 	sts	0x02F1, r1	; 0x8002f1 <UART0_RxTail>
    118e:	10 92 f2 02 	sts	0x02F2, r1	; 0x8002f2 <UART0_RxHead>
    1192:	10 92 ef 01 	sts	0x01EF, r1	; 0x8001ef <UART0_TxTail>
    1196:	10 92 f0 01 	sts	0x01F0, r1	; 0x8001f0 <UART0_TxHead>
    119a:	08 95       	ret

0000119c <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    119c:	20 91 f0 01 	lds	r18, 0x01F0	; 0x8001f0 <UART0_TxHead>
    11a0:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    11a2:	90 91 ef 01 	lds	r25, 0x01EF	; 0x8001ef <UART0_TxTail>
    11a6:	29 17       	cp	r18, r25
    11a8:	e1 f3       	breq	.-8      	; 0x11a2 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    11aa:	e2 2f       	mov	r30, r18
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	ef 50       	subi	r30, 0x0F	; 15
    11b0:	fe 4f       	sbci	r31, 0xFE	; 254
    11b2:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    11b4:	20 93 f0 01 	sts	0x01F0, r18	; 0x8001f0 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    11b8:	e1 ec       	ldi	r30, 0xC1	; 193
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	80 81       	ld	r24, Z
    11be:	80 62       	ori	r24, 0x20	; 32
    11c0:	80 83       	st	Z, r24
    11c2:	08 95       	ret

000011c4 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    11c4:	20 91 f0 01 	lds	r18, 0x01F0	; 0x8001f0 <UART0_TxHead>
    11c8:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    11ca:	90 91 ef 01 	lds	r25, 0x01EF	; 0x8001ef <UART0_TxTail>
    11ce:	29 17       	cp	r18, r25
    11d0:	e1 f3       	breq	.-8      	; 0x11ca <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    11d2:	e2 2f       	mov	r30, r18
    11d4:	f0 e0       	ldi	r31, 0x00	; 0
    11d6:	ef 50       	subi	r30, 0x0F	; 15
    11d8:	fe 4f       	sbci	r31, 0xFE	; 254
    11da:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    11dc:	20 93 f0 01 	sts	0x01F0, r18	; 0x8001f0 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    11e0:	e1 ec       	ldi	r30, 0xC1	; 193
    11e2:	f0 e0       	ldi	r31, 0x00	; 0
    11e4:	80 81       	ld	r24, Z
    11e6:	80 62       	ori	r24, 0x20	; 32
    11e8:	80 83       	st	Z, r24
	return(0);
}
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	08 95       	ret

000011f0 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    11f6:	88 81       	ld	r24, Y
    11f8:	88 23       	and	r24, r24
    11fa:	29 f0       	breq	.+10     	; 0x1206 <USART0_putstring+0x16>
    11fc:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    11fe:	ce df       	rcall	.-100    	; 0x119c <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    1200:	89 91       	ld	r24, Y+
    1202:	81 11       	cpse	r24, r1
    1204:	fc cf       	rjmp	.-8      	; 0x11fe <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	08 95       	ret

0000120c <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    120c:	1f 92       	push	r1
    120e:	0f 92       	push	r0
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	0f 92       	push	r0
    1214:	11 24       	eor	r1, r1
    1216:	8f 93       	push	r24
    1218:	9f 93       	push	r25
    121a:	ef 93       	push	r30
    121c:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    121e:	90 91 f0 01 	lds	r25, 0x01F0	; 0x8001f0 <UART0_TxHead>
    1222:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <UART0_TxTail>
    1226:	98 17       	cp	r25, r24
    1228:	61 f0       	breq	.+24     	; 0x1242 <__vector_21+0x36>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    122a:	e0 91 ef 01 	lds	r30, 0x01EF	; 0x8001ef <UART0_TxTail>
    122e:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1230:	e0 93 ef 01 	sts	0x01EF, r30	; 0x8001ef <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1234:	f0 e0       	ldi	r31, 0x00	; 0
    1236:	ef 50       	subi	r30, 0x0F	; 15
    1238:	fe 4f       	sbci	r31, 0xFE	; 254
    123a:	80 81       	ld	r24, Z
    123c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1240:	05 c0       	rjmp	.+10     	; 0x124c <__vector_21+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1242:	e1 ec       	ldi	r30, 0xC1	; 193
    1244:	f0 e0       	ldi	r31, 0x00	; 0
    1246:	80 81       	ld	r24, Z
    1248:	8f 7d       	andi	r24, 0xDF	; 223
    124a:	80 83       	st	Z, r24
	}
    124c:	ff 91       	pop	r31
    124e:	ef 91       	pop	r30
    1250:	9f 91       	pop	r25
    1252:	8f 91       	pop	r24
    1254:	0f 90       	pop	r0
    1256:	0f be       	out	0x3f, r0	; 63
    1258:	0f 90       	pop	r0
    125a:	1f 90       	pop	r1
    125c:	18 95       	reti

0000125e <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    125e:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1262:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1266:	88 e9       	ldi	r24, 0x98	; 152
    1268:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    126c:	86 e0       	ldi	r24, 0x06	; 6
    126e:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1272:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <UART1_RxTail>
    1276:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <UART1_RxHead>
    127a:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <UART1_TxTail>
    127e:	10 92 f4 02 	sts	0x02F4, r1	; 0x8002f4 <UART1_TxHead>
    1282:	08 95       	ret

00001284 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1284:	1f 92       	push	r1
    1286:	0f 92       	push	r0
    1288:	0f b6       	in	r0, 0x3f	; 63
    128a:	0f 92       	push	r0
    128c:	11 24       	eor	r1, r1
    128e:	2f 93       	push	r18
    1290:	3f 93       	push	r19
    1292:	8f 93       	push	r24
    1294:	9f 93       	push	r25
    1296:	af 93       	push	r26
    1298:	bf 93       	push	r27
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
    129e:	ef 93       	push	r30
    12a0:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    12a2:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    12a6:	80 91 f6 03 	lds	r24, 0x03F6	; 0x8003f6 <UART1_RxHead>
    12aa:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    12ac:	80 93 f6 03 	sts	0x03F6, r24	; 0x8003f6 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    12b0:	20 91 f5 03 	lds	r18, 0x03F5	; 0x8003f5 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    12b4:	e8 2f       	mov	r30, r24
    12b6:	f0 e0       	ldi	r31, 0x00	; 0
    12b8:	e0 56       	subi	r30, 0x60	; 96
    12ba:	fa 4f       	sbci	r31, 0xFA	; 250
    12bc:	90 83       	st	Z, r25
	
	if (data == 10)
    12be:	9a 30       	cpi	r25, 0x0A	; 10
    12c0:	d1 f4       	brne	.+52     	; 0x12f6 <__vector_28+0x72>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'L')
    12c2:	90 91 a5 05 	lds	r25, 0x05A5	; 0x8005a5 <UART1_RxBuf+0x5>
    12c6:	9c 34       	cpi	r25, 0x4C	; 76
    12c8:	91 f4       	brne	.+36     	; 0x12ee <__vector_28+0x6a>
    12ca:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
    12cc:	2e 2f       	mov	r18, r30
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	d9 01       	movw	r26, r18
    12d2:	a0 56       	subi	r26, 0x60	; 96
    12d4:	b9 4f       	sbci	r27, 0xF9	; 249
    12d6:	e9 01       	movw	r28, r18
    12d8:	c0 56       	subi	r28, 0x60	; 96
    12da:	da 4f       	sbci	r29, 0xFA	; 250
    12dc:	98 81       	ld	r25, Y
    12de:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'L')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    12e0:	ef 5f       	subi	r30, 0xFF	; 255
    12e2:	8e 17       	cp	r24, r30
    12e4:	98 f7       	brcc	.-26     	; 0x12cc <__vector_28+0x48>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
    12e6:	f0 e0       	ldi	r31, 0x00	; 0
    12e8:	e0 56       	subi	r30, 0x60	; 96
    12ea:	f9 4f       	sbci	r31, 0xF9	; 249
    12ec:	11 82       	std	Z+1, r1	; 0x01
		}
		UART1_RxTail = 0;
    12ee:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <UART1_RxTail>
		UART1_RxHead = 0;
    12f2:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <UART1_RxHead>
	}
}
    12f6:	ff 91       	pop	r31
    12f8:	ef 91       	pop	r30
    12fa:	df 91       	pop	r29
    12fc:	cf 91       	pop	r28
    12fe:	bf 91       	pop	r27
    1300:	af 91       	pop	r26
    1302:	9f 91       	pop	r25
    1304:	8f 91       	pop	r24
    1306:	3f 91       	pop	r19
    1308:	2f 91       	pop	r18
    130a:	0f 90       	pop	r0
    130c:	0f be       	out	0x3f, r0	; 63
    130e:	0f 90       	pop	r0
    1310:	1f 90       	pop	r1
    1312:	18 95       	reti

00001314 <__vector_29>:

ISR(USART1_UDRE_vect)
{
    1314:	1f 92       	push	r1
    1316:	0f 92       	push	r0
    1318:	0f b6       	in	r0, 0x3f	; 63
    131a:	0f 92       	push	r0
    131c:	11 24       	eor	r1, r1
    131e:	8f 93       	push	r24
    1320:	9f 93       	push	r25
    1322:	ef 93       	push	r30
    1324:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
    1326:	90 91 f4 02 	lds	r25, 0x02F4	; 0x8002f4 <UART1_TxHead>
    132a:	80 91 f3 02 	lds	r24, 0x02F3	; 0x8002f3 <UART1_TxTail>
    132e:	98 17       	cp	r25, r24
    1330:	61 f0       	breq	.+24     	; 0x134a <__vector_29+0x36>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
    1332:	e0 91 f3 02 	lds	r30, 0x02F3	; 0x8002f3 <UART1_TxTail>
    1336:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
    1338:	e0 93 f3 02 	sts	0x02F3, r30	; 0x8002f3 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
    133c:	f0 e0       	ldi	r31, 0x00	; 0
    133e:	eb 50       	subi	r30, 0x0B	; 11
    1340:	fd 4f       	sbci	r31, 0xFD	; 253
    1342:	80 81       	ld	r24, Z
    1344:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1348:	05 c0       	rjmp	.+10     	; 0x1354 <__vector_29+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
    134a:	e9 ec       	ldi	r30, 0xC9	; 201
    134c:	f0 e0       	ldi	r31, 0x00	; 0
    134e:	80 81       	ld	r24, Z
    1350:	8f 7d       	andi	r24, 0xDF	; 223
    1352:	80 83       	st	Z, r24
	}
    1354:	ff 91       	pop	r31
    1356:	ef 91       	pop	r30
    1358:	9f 91       	pop	r25
    135a:	8f 91       	pop	r24
    135c:	0f 90       	pop	r0
    135e:	0f be       	out	0x3f, r0	; 63
    1360:	0f 90       	pop	r0
    1362:	1f 90       	pop	r1
    1364:	18 95       	reti

00001366 <__mulsi3>:
    1366:	db 01       	movw	r26, r22
    1368:	8f 93       	push	r24
    136a:	9f 93       	push	r25
    136c:	2d d0       	rcall	.+90     	; 0x13c8 <__muluhisi3>
    136e:	bf 91       	pop	r27
    1370:	af 91       	pop	r26
    1372:	a2 9f       	mul	r26, r18
    1374:	80 0d       	add	r24, r0
    1376:	91 1d       	adc	r25, r1
    1378:	a3 9f       	mul	r26, r19
    137a:	90 0d       	add	r25, r0
    137c:	b2 9f       	mul	r27, r18
    137e:	90 0d       	add	r25, r0
    1380:	11 24       	eor	r1, r1
    1382:	08 95       	ret

00001384 <__divmodsi4>:
    1384:	05 2e       	mov	r0, r21
    1386:	97 fb       	bst	r25, 7
    1388:	16 f4       	brtc	.+4      	; 0x138e <__divmodsi4+0xa>
    138a:	00 94       	com	r0
    138c:	0f d0       	rcall	.+30     	; 0x13ac <__negsi2>
    138e:	57 fd       	sbrc	r21, 7
    1390:	05 d0       	rcall	.+10     	; 0x139c <__divmodsi4_neg2>
    1392:	61 d0       	rcall	.+194    	; 0x1456 <__udivmodsi4>
    1394:	07 fc       	sbrc	r0, 7
    1396:	02 d0       	rcall	.+4      	; 0x139c <__divmodsi4_neg2>
    1398:	46 f4       	brtc	.+16     	; 0x13aa <__divmodsi4_exit>
    139a:	08 c0       	rjmp	.+16     	; 0x13ac <__negsi2>

0000139c <__divmodsi4_neg2>:
    139c:	50 95       	com	r21
    139e:	40 95       	com	r20
    13a0:	30 95       	com	r19
    13a2:	21 95       	neg	r18
    13a4:	3f 4f       	sbci	r19, 0xFF	; 255
    13a6:	4f 4f       	sbci	r20, 0xFF	; 255
    13a8:	5f 4f       	sbci	r21, 0xFF	; 255

000013aa <__divmodsi4_exit>:
    13aa:	08 95       	ret

000013ac <__negsi2>:
    13ac:	90 95       	com	r25
    13ae:	80 95       	com	r24
    13b0:	70 95       	com	r23
    13b2:	61 95       	neg	r22
    13b4:	7f 4f       	sbci	r23, 0xFF	; 255
    13b6:	8f 4f       	sbci	r24, 0xFF	; 255
    13b8:	9f 4f       	sbci	r25, 0xFF	; 255
    13ba:	08 95       	ret

000013bc <__tablejump2__>:
    13bc:	ee 0f       	add	r30, r30
    13be:	ff 1f       	adc	r31, r31
    13c0:	05 90       	lpm	r0, Z+
    13c2:	f4 91       	lpm	r31, Z
    13c4:	e0 2d       	mov	r30, r0
    13c6:	09 94       	ijmp

000013c8 <__muluhisi3>:
    13c8:	68 d0       	rcall	.+208    	; 0x149a <__umulhisi3>
    13ca:	a5 9f       	mul	r26, r21
    13cc:	90 0d       	add	r25, r0
    13ce:	b4 9f       	mul	r27, r20
    13d0:	90 0d       	add	r25, r0
    13d2:	a4 9f       	mul	r26, r20
    13d4:	80 0d       	add	r24, r0
    13d6:	91 1d       	adc	r25, r1
    13d8:	11 24       	eor	r1, r1
    13da:	08 95       	ret

000013dc <__mulshisi3>:
    13dc:	b7 ff       	sbrs	r27, 7
    13de:	f4 cf       	rjmp	.-24     	; 0x13c8 <__muluhisi3>

000013e0 <__mulohisi3>:
    13e0:	f3 df       	rcall	.-26     	; 0x13c8 <__muluhisi3>
    13e2:	82 1b       	sub	r24, r18
    13e4:	93 0b       	sbc	r25, r19
    13e6:	08 95       	ret

000013e8 <__prologue_saves__>:
    13e8:	2f 92       	push	r2
    13ea:	3f 92       	push	r3
    13ec:	4f 92       	push	r4
    13ee:	5f 92       	push	r5
    13f0:	6f 92       	push	r6
    13f2:	7f 92       	push	r7
    13f4:	8f 92       	push	r8
    13f6:	9f 92       	push	r9
    13f8:	af 92       	push	r10
    13fa:	bf 92       	push	r11
    13fc:	cf 92       	push	r12
    13fe:	df 92       	push	r13
    1400:	ef 92       	push	r14
    1402:	ff 92       	push	r15
    1404:	0f 93       	push	r16
    1406:	1f 93       	push	r17
    1408:	cf 93       	push	r28
    140a:	df 93       	push	r29
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	ca 1b       	sub	r28, r26
    1412:	db 0b       	sbc	r29, r27
    1414:	0f b6       	in	r0, 0x3f	; 63
    1416:	f8 94       	cli
    1418:	de bf       	out	0x3e, r29	; 62
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	cd bf       	out	0x3d, r28	; 61
    141e:	09 94       	ijmp

00001420 <__epilogue_restores__>:
    1420:	2a 88       	ldd	r2, Y+18	; 0x12
    1422:	39 88       	ldd	r3, Y+17	; 0x11
    1424:	48 88       	ldd	r4, Y+16	; 0x10
    1426:	5f 84       	ldd	r5, Y+15	; 0x0f
    1428:	6e 84       	ldd	r6, Y+14	; 0x0e
    142a:	7d 84       	ldd	r7, Y+13	; 0x0d
    142c:	8c 84       	ldd	r8, Y+12	; 0x0c
    142e:	9b 84       	ldd	r9, Y+11	; 0x0b
    1430:	aa 84       	ldd	r10, Y+10	; 0x0a
    1432:	b9 84       	ldd	r11, Y+9	; 0x09
    1434:	c8 84       	ldd	r12, Y+8	; 0x08
    1436:	df 80       	ldd	r13, Y+7	; 0x07
    1438:	ee 80       	ldd	r14, Y+6	; 0x06
    143a:	fd 80       	ldd	r15, Y+5	; 0x05
    143c:	0c 81       	ldd	r16, Y+4	; 0x04
    143e:	1b 81       	ldd	r17, Y+3	; 0x03
    1440:	aa 81       	ldd	r26, Y+2	; 0x02
    1442:	b9 81       	ldd	r27, Y+1	; 0x01
    1444:	ce 0f       	add	r28, r30
    1446:	d1 1d       	adc	r29, r1
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	de bf       	out	0x3e, r29	; 62
    144e:	0f be       	out	0x3f, r0	; 63
    1450:	cd bf       	out	0x3d, r28	; 61
    1452:	ed 01       	movw	r28, r26
    1454:	08 95       	ret

00001456 <__udivmodsi4>:
    1456:	a1 e2       	ldi	r26, 0x21	; 33
    1458:	1a 2e       	mov	r1, r26
    145a:	aa 1b       	sub	r26, r26
    145c:	bb 1b       	sub	r27, r27
    145e:	fd 01       	movw	r30, r26
    1460:	0d c0       	rjmp	.+26     	; 0x147c <__udivmodsi4_ep>

00001462 <__udivmodsi4_loop>:
    1462:	aa 1f       	adc	r26, r26
    1464:	bb 1f       	adc	r27, r27
    1466:	ee 1f       	adc	r30, r30
    1468:	ff 1f       	adc	r31, r31
    146a:	a2 17       	cp	r26, r18
    146c:	b3 07       	cpc	r27, r19
    146e:	e4 07       	cpc	r30, r20
    1470:	f5 07       	cpc	r31, r21
    1472:	20 f0       	brcs	.+8      	; 0x147c <__udivmodsi4_ep>
    1474:	a2 1b       	sub	r26, r18
    1476:	b3 0b       	sbc	r27, r19
    1478:	e4 0b       	sbc	r30, r20
    147a:	f5 0b       	sbc	r31, r21

0000147c <__udivmodsi4_ep>:
    147c:	66 1f       	adc	r22, r22
    147e:	77 1f       	adc	r23, r23
    1480:	88 1f       	adc	r24, r24
    1482:	99 1f       	adc	r25, r25
    1484:	1a 94       	dec	r1
    1486:	69 f7       	brne	.-38     	; 0x1462 <__udivmodsi4_loop>
    1488:	60 95       	com	r22
    148a:	70 95       	com	r23
    148c:	80 95       	com	r24
    148e:	90 95       	com	r25
    1490:	9b 01       	movw	r18, r22
    1492:	ac 01       	movw	r20, r24
    1494:	bd 01       	movw	r22, r26
    1496:	cf 01       	movw	r24, r30
    1498:	08 95       	ret

0000149a <__umulhisi3>:
    149a:	a2 9f       	mul	r26, r18
    149c:	b0 01       	movw	r22, r0
    149e:	b3 9f       	mul	r27, r19
    14a0:	c0 01       	movw	r24, r0
    14a2:	a3 9f       	mul	r26, r19
    14a4:	70 0d       	add	r23, r0
    14a6:	81 1d       	adc	r24, r1
    14a8:	11 24       	eor	r1, r1
    14aa:	91 1d       	adc	r25, r1
    14ac:	b2 9f       	mul	r27, r18
    14ae:	70 0d       	add	r23, r0
    14b0:	81 1d       	adc	r24, r1
    14b2:	11 24       	eor	r1, r1
    14b4:	91 1d       	adc	r25, r1
    14b6:	08 95       	ret

000014b8 <printf>:
    14b8:	a0 e0       	ldi	r26, 0x00	; 0
    14ba:	b0 e0       	ldi	r27, 0x00	; 0
    14bc:	e1 e6       	ldi	r30, 0x61	; 97
    14be:	fa e0       	ldi	r31, 0x0A	; 10
    14c0:	a3 cf       	rjmp	.-186    	; 0x1408 <__prologue_saves__+0x20>
    14c2:	ae 01       	movw	r20, r28
    14c4:	4b 5f       	subi	r20, 0xFB	; 251
    14c6:	5f 4f       	sbci	r21, 0xFF	; 255
    14c8:	fa 01       	movw	r30, r20
    14ca:	61 91       	ld	r22, Z+
    14cc:	71 91       	ld	r23, Z+
    14ce:	af 01       	movw	r20, r30
    14d0:	80 91 a2 07 	lds	r24, 0x07A2	; 0x8007a2 <__iob+0x2>
    14d4:	90 91 a3 07 	lds	r25, 0x07A3	; 0x8007a3 <__iob+0x3>
    14d8:	02 d0       	rcall	.+4      	; 0x14de <vfprintf>
    14da:	e2 e0       	ldi	r30, 0x02	; 2
    14dc:	b1 cf       	rjmp	.-158    	; 0x1440 <__epilogue_restores__+0x20>

000014de <vfprintf>:
    14de:	ab e0       	ldi	r26, 0x0B	; 11
    14e0:	b0 e0       	ldi	r27, 0x00	; 0
    14e2:	e4 e7       	ldi	r30, 0x74	; 116
    14e4:	fa e0       	ldi	r31, 0x0A	; 10
    14e6:	80 cf       	rjmp	.-256    	; 0x13e8 <__prologue_saves__>
    14e8:	6c 01       	movw	r12, r24
    14ea:	7b 01       	movw	r14, r22
    14ec:	8a 01       	movw	r16, r20
    14ee:	fc 01       	movw	r30, r24
    14f0:	17 82       	std	Z+7, r1	; 0x07
    14f2:	16 82       	std	Z+6, r1	; 0x06
    14f4:	83 81       	ldd	r24, Z+3	; 0x03
    14f6:	81 ff       	sbrs	r24, 1
    14f8:	bf c1       	rjmp	.+894    	; 0x1878 <vfprintf+0x39a>
    14fa:	ce 01       	movw	r24, r28
    14fc:	01 96       	adiw	r24, 0x01	; 1
    14fe:	3c 01       	movw	r6, r24
    1500:	f6 01       	movw	r30, r12
    1502:	93 81       	ldd	r25, Z+3	; 0x03
    1504:	f7 01       	movw	r30, r14
    1506:	93 fd       	sbrc	r25, 3
    1508:	85 91       	lpm	r24, Z+
    150a:	93 ff       	sbrs	r25, 3
    150c:	81 91       	ld	r24, Z+
    150e:	7f 01       	movw	r14, r30
    1510:	88 23       	and	r24, r24
    1512:	09 f4       	brne	.+2      	; 0x1516 <vfprintf+0x38>
    1514:	ad c1       	rjmp	.+858    	; 0x1870 <vfprintf+0x392>
    1516:	85 32       	cpi	r24, 0x25	; 37
    1518:	39 f4       	brne	.+14     	; 0x1528 <vfprintf+0x4a>
    151a:	93 fd       	sbrc	r25, 3
    151c:	85 91       	lpm	r24, Z+
    151e:	93 ff       	sbrs	r25, 3
    1520:	81 91       	ld	r24, Z+
    1522:	7f 01       	movw	r14, r30
    1524:	85 32       	cpi	r24, 0x25	; 37
    1526:	21 f4       	brne	.+8      	; 0x1530 <vfprintf+0x52>
    1528:	b6 01       	movw	r22, r12
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	c0 d1       	rcall	.+896    	; 0x18ae <fputc>
    152e:	e8 cf       	rjmp	.-48     	; 0x1500 <vfprintf+0x22>
    1530:	91 2c       	mov	r9, r1
    1532:	21 2c       	mov	r2, r1
    1534:	31 2c       	mov	r3, r1
    1536:	ff e1       	ldi	r31, 0x1F	; 31
    1538:	f3 15       	cp	r31, r3
    153a:	d8 f0       	brcs	.+54     	; 0x1572 <vfprintf+0x94>
    153c:	8b 32       	cpi	r24, 0x2B	; 43
    153e:	79 f0       	breq	.+30     	; 0x155e <vfprintf+0x80>
    1540:	38 f4       	brcc	.+14     	; 0x1550 <vfprintf+0x72>
    1542:	80 32       	cpi	r24, 0x20	; 32
    1544:	79 f0       	breq	.+30     	; 0x1564 <vfprintf+0x86>
    1546:	83 32       	cpi	r24, 0x23	; 35
    1548:	a1 f4       	brne	.+40     	; 0x1572 <vfprintf+0x94>
    154a:	23 2d       	mov	r18, r3
    154c:	20 61       	ori	r18, 0x10	; 16
    154e:	1d c0       	rjmp	.+58     	; 0x158a <vfprintf+0xac>
    1550:	8d 32       	cpi	r24, 0x2D	; 45
    1552:	61 f0       	breq	.+24     	; 0x156c <vfprintf+0x8e>
    1554:	80 33       	cpi	r24, 0x30	; 48
    1556:	69 f4       	brne	.+26     	; 0x1572 <vfprintf+0x94>
    1558:	23 2d       	mov	r18, r3
    155a:	21 60       	ori	r18, 0x01	; 1
    155c:	16 c0       	rjmp	.+44     	; 0x158a <vfprintf+0xac>
    155e:	83 2d       	mov	r24, r3
    1560:	82 60       	ori	r24, 0x02	; 2
    1562:	38 2e       	mov	r3, r24
    1564:	e3 2d       	mov	r30, r3
    1566:	e4 60       	ori	r30, 0x04	; 4
    1568:	3e 2e       	mov	r3, r30
    156a:	2a c0       	rjmp	.+84     	; 0x15c0 <vfprintf+0xe2>
    156c:	f3 2d       	mov	r31, r3
    156e:	f8 60       	ori	r31, 0x08	; 8
    1570:	1d c0       	rjmp	.+58     	; 0x15ac <vfprintf+0xce>
    1572:	37 fc       	sbrc	r3, 7
    1574:	2d c0       	rjmp	.+90     	; 0x15d0 <vfprintf+0xf2>
    1576:	20 ed       	ldi	r18, 0xD0	; 208
    1578:	28 0f       	add	r18, r24
    157a:	2a 30       	cpi	r18, 0x0A	; 10
    157c:	40 f0       	brcs	.+16     	; 0x158e <vfprintf+0xb0>
    157e:	8e 32       	cpi	r24, 0x2E	; 46
    1580:	b9 f4       	brne	.+46     	; 0x15b0 <vfprintf+0xd2>
    1582:	36 fc       	sbrc	r3, 6
    1584:	75 c1       	rjmp	.+746    	; 0x1870 <vfprintf+0x392>
    1586:	23 2d       	mov	r18, r3
    1588:	20 64       	ori	r18, 0x40	; 64
    158a:	32 2e       	mov	r3, r18
    158c:	19 c0       	rjmp	.+50     	; 0x15c0 <vfprintf+0xe2>
    158e:	36 fe       	sbrs	r3, 6
    1590:	06 c0       	rjmp	.+12     	; 0x159e <vfprintf+0xc0>
    1592:	8a e0       	ldi	r24, 0x0A	; 10
    1594:	98 9e       	mul	r9, r24
    1596:	20 0d       	add	r18, r0
    1598:	11 24       	eor	r1, r1
    159a:	92 2e       	mov	r9, r18
    159c:	11 c0       	rjmp	.+34     	; 0x15c0 <vfprintf+0xe2>
    159e:	ea e0       	ldi	r30, 0x0A	; 10
    15a0:	2e 9e       	mul	r2, r30
    15a2:	20 0d       	add	r18, r0
    15a4:	11 24       	eor	r1, r1
    15a6:	22 2e       	mov	r2, r18
    15a8:	f3 2d       	mov	r31, r3
    15aa:	f0 62       	ori	r31, 0x20	; 32
    15ac:	3f 2e       	mov	r3, r31
    15ae:	08 c0       	rjmp	.+16     	; 0x15c0 <vfprintf+0xe2>
    15b0:	8c 36       	cpi	r24, 0x6C	; 108
    15b2:	21 f4       	brne	.+8      	; 0x15bc <vfprintf+0xde>
    15b4:	83 2d       	mov	r24, r3
    15b6:	80 68       	ori	r24, 0x80	; 128
    15b8:	38 2e       	mov	r3, r24
    15ba:	02 c0       	rjmp	.+4      	; 0x15c0 <vfprintf+0xe2>
    15bc:	88 36       	cpi	r24, 0x68	; 104
    15be:	41 f4       	brne	.+16     	; 0x15d0 <vfprintf+0xf2>
    15c0:	f7 01       	movw	r30, r14
    15c2:	93 fd       	sbrc	r25, 3
    15c4:	85 91       	lpm	r24, Z+
    15c6:	93 ff       	sbrs	r25, 3
    15c8:	81 91       	ld	r24, Z+
    15ca:	7f 01       	movw	r14, r30
    15cc:	81 11       	cpse	r24, r1
    15ce:	b3 cf       	rjmp	.-154    	; 0x1536 <vfprintf+0x58>
    15d0:	98 2f       	mov	r25, r24
    15d2:	9f 7d       	andi	r25, 0xDF	; 223
    15d4:	95 54       	subi	r25, 0x45	; 69
    15d6:	93 30       	cpi	r25, 0x03	; 3
    15d8:	28 f4       	brcc	.+10     	; 0x15e4 <vfprintf+0x106>
    15da:	0c 5f       	subi	r16, 0xFC	; 252
    15dc:	1f 4f       	sbci	r17, 0xFF	; 255
    15de:	9f e3       	ldi	r25, 0x3F	; 63
    15e0:	99 83       	std	Y+1, r25	; 0x01
    15e2:	0d c0       	rjmp	.+26     	; 0x15fe <vfprintf+0x120>
    15e4:	83 36       	cpi	r24, 0x63	; 99
    15e6:	31 f0       	breq	.+12     	; 0x15f4 <vfprintf+0x116>
    15e8:	83 37       	cpi	r24, 0x73	; 115
    15ea:	71 f0       	breq	.+28     	; 0x1608 <vfprintf+0x12a>
    15ec:	83 35       	cpi	r24, 0x53	; 83
    15ee:	09 f0       	breq	.+2      	; 0x15f2 <vfprintf+0x114>
    15f0:	55 c0       	rjmp	.+170    	; 0x169c <vfprintf+0x1be>
    15f2:	20 c0       	rjmp	.+64     	; 0x1634 <vfprintf+0x156>
    15f4:	f8 01       	movw	r30, r16
    15f6:	80 81       	ld	r24, Z
    15f8:	89 83       	std	Y+1, r24	; 0x01
    15fa:	0e 5f       	subi	r16, 0xFE	; 254
    15fc:	1f 4f       	sbci	r17, 0xFF	; 255
    15fe:	88 24       	eor	r8, r8
    1600:	83 94       	inc	r8
    1602:	91 2c       	mov	r9, r1
    1604:	53 01       	movw	r10, r6
    1606:	12 c0       	rjmp	.+36     	; 0x162c <vfprintf+0x14e>
    1608:	28 01       	movw	r4, r16
    160a:	f2 e0       	ldi	r31, 0x02	; 2
    160c:	4f 0e       	add	r4, r31
    160e:	51 1c       	adc	r5, r1
    1610:	f8 01       	movw	r30, r16
    1612:	a0 80       	ld	r10, Z
    1614:	b1 80       	ldd	r11, Z+1	; 0x01
    1616:	36 fe       	sbrs	r3, 6
    1618:	03 c0       	rjmp	.+6      	; 0x1620 <vfprintf+0x142>
    161a:	69 2d       	mov	r22, r9
    161c:	70 e0       	ldi	r23, 0x00	; 0
    161e:	02 c0       	rjmp	.+4      	; 0x1624 <vfprintf+0x146>
    1620:	6f ef       	ldi	r22, 0xFF	; 255
    1622:	7f ef       	ldi	r23, 0xFF	; 255
    1624:	c5 01       	movw	r24, r10
    1626:	38 d1       	rcall	.+624    	; 0x1898 <strnlen>
    1628:	4c 01       	movw	r8, r24
    162a:	82 01       	movw	r16, r4
    162c:	f3 2d       	mov	r31, r3
    162e:	ff 77       	andi	r31, 0x7F	; 127
    1630:	3f 2e       	mov	r3, r31
    1632:	15 c0       	rjmp	.+42     	; 0x165e <vfprintf+0x180>
    1634:	28 01       	movw	r4, r16
    1636:	22 e0       	ldi	r18, 0x02	; 2
    1638:	42 0e       	add	r4, r18
    163a:	51 1c       	adc	r5, r1
    163c:	f8 01       	movw	r30, r16
    163e:	a0 80       	ld	r10, Z
    1640:	b1 80       	ldd	r11, Z+1	; 0x01
    1642:	36 fe       	sbrs	r3, 6
    1644:	03 c0       	rjmp	.+6      	; 0x164c <vfprintf+0x16e>
    1646:	69 2d       	mov	r22, r9
    1648:	70 e0       	ldi	r23, 0x00	; 0
    164a:	02 c0       	rjmp	.+4      	; 0x1650 <vfprintf+0x172>
    164c:	6f ef       	ldi	r22, 0xFF	; 255
    164e:	7f ef       	ldi	r23, 0xFF	; 255
    1650:	c5 01       	movw	r24, r10
    1652:	17 d1       	rcall	.+558    	; 0x1882 <strnlen_P>
    1654:	4c 01       	movw	r8, r24
    1656:	f3 2d       	mov	r31, r3
    1658:	f0 68       	ori	r31, 0x80	; 128
    165a:	3f 2e       	mov	r3, r31
    165c:	82 01       	movw	r16, r4
    165e:	33 fc       	sbrc	r3, 3
    1660:	19 c0       	rjmp	.+50     	; 0x1694 <vfprintf+0x1b6>
    1662:	82 2d       	mov	r24, r2
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	88 16       	cp	r8, r24
    1668:	99 06       	cpc	r9, r25
    166a:	a0 f4       	brcc	.+40     	; 0x1694 <vfprintf+0x1b6>
    166c:	b6 01       	movw	r22, r12
    166e:	80 e2       	ldi	r24, 0x20	; 32
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	1d d1       	rcall	.+570    	; 0x18ae <fputc>
    1674:	2a 94       	dec	r2
    1676:	f5 cf       	rjmp	.-22     	; 0x1662 <vfprintf+0x184>
    1678:	f5 01       	movw	r30, r10
    167a:	37 fc       	sbrc	r3, 7
    167c:	85 91       	lpm	r24, Z+
    167e:	37 fe       	sbrs	r3, 7
    1680:	81 91       	ld	r24, Z+
    1682:	5f 01       	movw	r10, r30
    1684:	b6 01       	movw	r22, r12
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	12 d1       	rcall	.+548    	; 0x18ae <fputc>
    168a:	21 10       	cpse	r2, r1
    168c:	2a 94       	dec	r2
    168e:	21 e0       	ldi	r18, 0x01	; 1
    1690:	82 1a       	sub	r8, r18
    1692:	91 08       	sbc	r9, r1
    1694:	81 14       	cp	r8, r1
    1696:	91 04       	cpc	r9, r1
    1698:	79 f7       	brne	.-34     	; 0x1678 <vfprintf+0x19a>
    169a:	e1 c0       	rjmp	.+450    	; 0x185e <vfprintf+0x380>
    169c:	84 36       	cpi	r24, 0x64	; 100
    169e:	11 f0       	breq	.+4      	; 0x16a4 <vfprintf+0x1c6>
    16a0:	89 36       	cpi	r24, 0x69	; 105
    16a2:	39 f5       	brne	.+78     	; 0x16f2 <vfprintf+0x214>
    16a4:	f8 01       	movw	r30, r16
    16a6:	37 fe       	sbrs	r3, 7
    16a8:	07 c0       	rjmp	.+14     	; 0x16b8 <vfprintf+0x1da>
    16aa:	60 81       	ld	r22, Z
    16ac:	71 81       	ldd	r23, Z+1	; 0x01
    16ae:	82 81       	ldd	r24, Z+2	; 0x02
    16b0:	93 81       	ldd	r25, Z+3	; 0x03
    16b2:	0c 5f       	subi	r16, 0xFC	; 252
    16b4:	1f 4f       	sbci	r17, 0xFF	; 255
    16b6:	08 c0       	rjmp	.+16     	; 0x16c8 <vfprintf+0x1ea>
    16b8:	60 81       	ld	r22, Z
    16ba:	71 81       	ldd	r23, Z+1	; 0x01
    16bc:	07 2e       	mov	r0, r23
    16be:	00 0c       	add	r0, r0
    16c0:	88 0b       	sbc	r24, r24
    16c2:	99 0b       	sbc	r25, r25
    16c4:	0e 5f       	subi	r16, 0xFE	; 254
    16c6:	1f 4f       	sbci	r17, 0xFF	; 255
    16c8:	f3 2d       	mov	r31, r3
    16ca:	ff 76       	andi	r31, 0x6F	; 111
    16cc:	3f 2e       	mov	r3, r31
    16ce:	97 ff       	sbrs	r25, 7
    16d0:	09 c0       	rjmp	.+18     	; 0x16e4 <vfprintf+0x206>
    16d2:	90 95       	com	r25
    16d4:	80 95       	com	r24
    16d6:	70 95       	com	r23
    16d8:	61 95       	neg	r22
    16da:	7f 4f       	sbci	r23, 0xFF	; 255
    16dc:	8f 4f       	sbci	r24, 0xFF	; 255
    16de:	9f 4f       	sbci	r25, 0xFF	; 255
    16e0:	f0 68       	ori	r31, 0x80	; 128
    16e2:	3f 2e       	mov	r3, r31
    16e4:	2a e0       	ldi	r18, 0x0A	; 10
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	a3 01       	movw	r20, r6
    16ea:	1d d1       	rcall	.+570    	; 0x1926 <__ultoa_invert>
    16ec:	88 2e       	mov	r8, r24
    16ee:	86 18       	sub	r8, r6
    16f0:	44 c0       	rjmp	.+136    	; 0x177a <vfprintf+0x29c>
    16f2:	85 37       	cpi	r24, 0x75	; 117
    16f4:	31 f4       	brne	.+12     	; 0x1702 <vfprintf+0x224>
    16f6:	23 2d       	mov	r18, r3
    16f8:	2f 7e       	andi	r18, 0xEF	; 239
    16fa:	b2 2e       	mov	r11, r18
    16fc:	2a e0       	ldi	r18, 0x0A	; 10
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	25 c0       	rjmp	.+74     	; 0x174c <vfprintf+0x26e>
    1702:	93 2d       	mov	r25, r3
    1704:	99 7f       	andi	r25, 0xF9	; 249
    1706:	b9 2e       	mov	r11, r25
    1708:	8f 36       	cpi	r24, 0x6F	; 111
    170a:	c1 f0       	breq	.+48     	; 0x173c <vfprintf+0x25e>
    170c:	18 f4       	brcc	.+6      	; 0x1714 <vfprintf+0x236>
    170e:	88 35       	cpi	r24, 0x58	; 88
    1710:	79 f0       	breq	.+30     	; 0x1730 <vfprintf+0x252>
    1712:	ae c0       	rjmp	.+348    	; 0x1870 <vfprintf+0x392>
    1714:	80 37       	cpi	r24, 0x70	; 112
    1716:	19 f0       	breq	.+6      	; 0x171e <vfprintf+0x240>
    1718:	88 37       	cpi	r24, 0x78	; 120
    171a:	21 f0       	breq	.+8      	; 0x1724 <vfprintf+0x246>
    171c:	a9 c0       	rjmp	.+338    	; 0x1870 <vfprintf+0x392>
    171e:	e9 2f       	mov	r30, r25
    1720:	e0 61       	ori	r30, 0x10	; 16
    1722:	be 2e       	mov	r11, r30
    1724:	b4 fe       	sbrs	r11, 4
    1726:	0d c0       	rjmp	.+26     	; 0x1742 <vfprintf+0x264>
    1728:	fb 2d       	mov	r31, r11
    172a:	f4 60       	ori	r31, 0x04	; 4
    172c:	bf 2e       	mov	r11, r31
    172e:	09 c0       	rjmp	.+18     	; 0x1742 <vfprintf+0x264>
    1730:	34 fe       	sbrs	r3, 4
    1732:	0a c0       	rjmp	.+20     	; 0x1748 <vfprintf+0x26a>
    1734:	29 2f       	mov	r18, r25
    1736:	26 60       	ori	r18, 0x06	; 6
    1738:	b2 2e       	mov	r11, r18
    173a:	06 c0       	rjmp	.+12     	; 0x1748 <vfprintf+0x26a>
    173c:	28 e0       	ldi	r18, 0x08	; 8
    173e:	30 e0       	ldi	r19, 0x00	; 0
    1740:	05 c0       	rjmp	.+10     	; 0x174c <vfprintf+0x26e>
    1742:	20 e1       	ldi	r18, 0x10	; 16
    1744:	30 e0       	ldi	r19, 0x00	; 0
    1746:	02 c0       	rjmp	.+4      	; 0x174c <vfprintf+0x26e>
    1748:	20 e1       	ldi	r18, 0x10	; 16
    174a:	32 e0       	ldi	r19, 0x02	; 2
    174c:	f8 01       	movw	r30, r16
    174e:	b7 fe       	sbrs	r11, 7
    1750:	07 c0       	rjmp	.+14     	; 0x1760 <vfprintf+0x282>
    1752:	60 81       	ld	r22, Z
    1754:	71 81       	ldd	r23, Z+1	; 0x01
    1756:	82 81       	ldd	r24, Z+2	; 0x02
    1758:	93 81       	ldd	r25, Z+3	; 0x03
    175a:	0c 5f       	subi	r16, 0xFC	; 252
    175c:	1f 4f       	sbci	r17, 0xFF	; 255
    175e:	06 c0       	rjmp	.+12     	; 0x176c <vfprintf+0x28e>
    1760:	60 81       	ld	r22, Z
    1762:	71 81       	ldd	r23, Z+1	; 0x01
    1764:	80 e0       	ldi	r24, 0x00	; 0
    1766:	90 e0       	ldi	r25, 0x00	; 0
    1768:	0e 5f       	subi	r16, 0xFE	; 254
    176a:	1f 4f       	sbci	r17, 0xFF	; 255
    176c:	a3 01       	movw	r20, r6
    176e:	db d0       	rcall	.+438    	; 0x1926 <__ultoa_invert>
    1770:	88 2e       	mov	r8, r24
    1772:	86 18       	sub	r8, r6
    1774:	fb 2d       	mov	r31, r11
    1776:	ff 77       	andi	r31, 0x7F	; 127
    1778:	3f 2e       	mov	r3, r31
    177a:	36 fe       	sbrs	r3, 6
    177c:	0d c0       	rjmp	.+26     	; 0x1798 <vfprintf+0x2ba>
    177e:	23 2d       	mov	r18, r3
    1780:	2e 7f       	andi	r18, 0xFE	; 254
    1782:	a2 2e       	mov	r10, r18
    1784:	89 14       	cp	r8, r9
    1786:	58 f4       	brcc	.+22     	; 0x179e <vfprintf+0x2c0>
    1788:	34 fe       	sbrs	r3, 4
    178a:	0b c0       	rjmp	.+22     	; 0x17a2 <vfprintf+0x2c4>
    178c:	32 fc       	sbrc	r3, 2
    178e:	09 c0       	rjmp	.+18     	; 0x17a2 <vfprintf+0x2c4>
    1790:	83 2d       	mov	r24, r3
    1792:	8e 7e       	andi	r24, 0xEE	; 238
    1794:	a8 2e       	mov	r10, r24
    1796:	05 c0       	rjmp	.+10     	; 0x17a2 <vfprintf+0x2c4>
    1798:	b8 2c       	mov	r11, r8
    179a:	a3 2c       	mov	r10, r3
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <vfprintf+0x2c6>
    179e:	b8 2c       	mov	r11, r8
    17a0:	01 c0       	rjmp	.+2      	; 0x17a4 <vfprintf+0x2c6>
    17a2:	b9 2c       	mov	r11, r9
    17a4:	a4 fe       	sbrs	r10, 4
    17a6:	0f c0       	rjmp	.+30     	; 0x17c6 <vfprintf+0x2e8>
    17a8:	fe 01       	movw	r30, r28
    17aa:	e8 0d       	add	r30, r8
    17ac:	f1 1d       	adc	r31, r1
    17ae:	80 81       	ld	r24, Z
    17b0:	80 33       	cpi	r24, 0x30	; 48
    17b2:	21 f4       	brne	.+8      	; 0x17bc <vfprintf+0x2de>
    17b4:	9a 2d       	mov	r25, r10
    17b6:	99 7e       	andi	r25, 0xE9	; 233
    17b8:	a9 2e       	mov	r10, r25
    17ba:	09 c0       	rjmp	.+18     	; 0x17ce <vfprintf+0x2f0>
    17bc:	a2 fe       	sbrs	r10, 2
    17be:	06 c0       	rjmp	.+12     	; 0x17cc <vfprintf+0x2ee>
    17c0:	b3 94       	inc	r11
    17c2:	b3 94       	inc	r11
    17c4:	04 c0       	rjmp	.+8      	; 0x17ce <vfprintf+0x2f0>
    17c6:	8a 2d       	mov	r24, r10
    17c8:	86 78       	andi	r24, 0x86	; 134
    17ca:	09 f0       	breq	.+2      	; 0x17ce <vfprintf+0x2f0>
    17cc:	b3 94       	inc	r11
    17ce:	a3 fc       	sbrc	r10, 3
    17d0:	10 c0       	rjmp	.+32     	; 0x17f2 <vfprintf+0x314>
    17d2:	a0 fe       	sbrs	r10, 0
    17d4:	06 c0       	rjmp	.+12     	; 0x17e2 <vfprintf+0x304>
    17d6:	b2 14       	cp	r11, r2
    17d8:	80 f4       	brcc	.+32     	; 0x17fa <vfprintf+0x31c>
    17da:	28 0c       	add	r2, r8
    17dc:	92 2c       	mov	r9, r2
    17de:	9b 18       	sub	r9, r11
    17e0:	0d c0       	rjmp	.+26     	; 0x17fc <vfprintf+0x31e>
    17e2:	b2 14       	cp	r11, r2
    17e4:	58 f4       	brcc	.+22     	; 0x17fc <vfprintf+0x31e>
    17e6:	b6 01       	movw	r22, r12
    17e8:	80 e2       	ldi	r24, 0x20	; 32
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	60 d0       	rcall	.+192    	; 0x18ae <fputc>
    17ee:	b3 94       	inc	r11
    17f0:	f8 cf       	rjmp	.-16     	; 0x17e2 <vfprintf+0x304>
    17f2:	b2 14       	cp	r11, r2
    17f4:	18 f4       	brcc	.+6      	; 0x17fc <vfprintf+0x31e>
    17f6:	2b 18       	sub	r2, r11
    17f8:	02 c0       	rjmp	.+4      	; 0x17fe <vfprintf+0x320>
    17fa:	98 2c       	mov	r9, r8
    17fc:	21 2c       	mov	r2, r1
    17fe:	a4 fe       	sbrs	r10, 4
    1800:	0f c0       	rjmp	.+30     	; 0x1820 <vfprintf+0x342>
    1802:	b6 01       	movw	r22, r12
    1804:	80 e3       	ldi	r24, 0x30	; 48
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	52 d0       	rcall	.+164    	; 0x18ae <fputc>
    180a:	a2 fe       	sbrs	r10, 2
    180c:	16 c0       	rjmp	.+44     	; 0x183a <vfprintf+0x35c>
    180e:	a1 fc       	sbrc	r10, 1
    1810:	03 c0       	rjmp	.+6      	; 0x1818 <vfprintf+0x33a>
    1812:	88 e7       	ldi	r24, 0x78	; 120
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	02 c0       	rjmp	.+4      	; 0x181c <vfprintf+0x33e>
    1818:	88 e5       	ldi	r24, 0x58	; 88
    181a:	90 e0       	ldi	r25, 0x00	; 0
    181c:	b6 01       	movw	r22, r12
    181e:	0c c0       	rjmp	.+24     	; 0x1838 <vfprintf+0x35a>
    1820:	8a 2d       	mov	r24, r10
    1822:	86 78       	andi	r24, 0x86	; 134
    1824:	51 f0       	breq	.+20     	; 0x183a <vfprintf+0x35c>
    1826:	a1 fe       	sbrs	r10, 1
    1828:	02 c0       	rjmp	.+4      	; 0x182e <vfprintf+0x350>
    182a:	8b e2       	ldi	r24, 0x2B	; 43
    182c:	01 c0       	rjmp	.+2      	; 0x1830 <vfprintf+0x352>
    182e:	80 e2       	ldi	r24, 0x20	; 32
    1830:	a7 fc       	sbrc	r10, 7
    1832:	8d e2       	ldi	r24, 0x2D	; 45
    1834:	b6 01       	movw	r22, r12
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	3a d0       	rcall	.+116    	; 0x18ae <fputc>
    183a:	89 14       	cp	r8, r9
    183c:	30 f4       	brcc	.+12     	; 0x184a <vfprintf+0x36c>
    183e:	b6 01       	movw	r22, r12
    1840:	80 e3       	ldi	r24, 0x30	; 48
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	34 d0       	rcall	.+104    	; 0x18ae <fputc>
    1846:	9a 94       	dec	r9
    1848:	f8 cf       	rjmp	.-16     	; 0x183a <vfprintf+0x35c>
    184a:	8a 94       	dec	r8
    184c:	f3 01       	movw	r30, r6
    184e:	e8 0d       	add	r30, r8
    1850:	f1 1d       	adc	r31, r1
    1852:	80 81       	ld	r24, Z
    1854:	b6 01       	movw	r22, r12
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	2a d0       	rcall	.+84     	; 0x18ae <fputc>
    185a:	81 10       	cpse	r8, r1
    185c:	f6 cf       	rjmp	.-20     	; 0x184a <vfprintf+0x36c>
    185e:	22 20       	and	r2, r2
    1860:	09 f4       	brne	.+2      	; 0x1864 <vfprintf+0x386>
    1862:	4e ce       	rjmp	.-868    	; 0x1500 <vfprintf+0x22>
    1864:	b6 01       	movw	r22, r12
    1866:	80 e2       	ldi	r24, 0x20	; 32
    1868:	90 e0       	ldi	r25, 0x00	; 0
    186a:	21 d0       	rcall	.+66     	; 0x18ae <fputc>
    186c:	2a 94       	dec	r2
    186e:	f7 cf       	rjmp	.-18     	; 0x185e <vfprintf+0x380>
    1870:	f6 01       	movw	r30, r12
    1872:	86 81       	ldd	r24, Z+6	; 0x06
    1874:	97 81       	ldd	r25, Z+7	; 0x07
    1876:	02 c0       	rjmp	.+4      	; 0x187c <vfprintf+0x39e>
    1878:	8f ef       	ldi	r24, 0xFF	; 255
    187a:	9f ef       	ldi	r25, 0xFF	; 255
    187c:	2b 96       	adiw	r28, 0x0b	; 11
    187e:	e2 e1       	ldi	r30, 0x12	; 18
    1880:	cf cd       	rjmp	.-1122   	; 0x1420 <__epilogue_restores__>

00001882 <strnlen_P>:
    1882:	fc 01       	movw	r30, r24
    1884:	05 90       	lpm	r0, Z+
    1886:	61 50       	subi	r22, 0x01	; 1
    1888:	70 40       	sbci	r23, 0x00	; 0
    188a:	01 10       	cpse	r0, r1
    188c:	d8 f7       	brcc	.-10     	; 0x1884 <strnlen_P+0x2>
    188e:	80 95       	com	r24
    1890:	90 95       	com	r25
    1892:	8e 0f       	add	r24, r30
    1894:	9f 1f       	adc	r25, r31
    1896:	08 95       	ret

00001898 <strnlen>:
    1898:	fc 01       	movw	r30, r24
    189a:	61 50       	subi	r22, 0x01	; 1
    189c:	70 40       	sbci	r23, 0x00	; 0
    189e:	01 90       	ld	r0, Z+
    18a0:	01 10       	cpse	r0, r1
    18a2:	d8 f7       	brcc	.-10     	; 0x189a <strnlen+0x2>
    18a4:	80 95       	com	r24
    18a6:	90 95       	com	r25
    18a8:	8e 0f       	add	r24, r30
    18aa:	9f 1f       	adc	r25, r31
    18ac:	08 95       	ret

000018ae <fputc>:
    18ae:	0f 93       	push	r16
    18b0:	1f 93       	push	r17
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	fb 01       	movw	r30, r22
    18b8:	23 81       	ldd	r18, Z+3	; 0x03
    18ba:	21 fd       	sbrc	r18, 1
    18bc:	03 c0       	rjmp	.+6      	; 0x18c4 <fputc+0x16>
    18be:	8f ef       	ldi	r24, 0xFF	; 255
    18c0:	9f ef       	ldi	r25, 0xFF	; 255
    18c2:	2c c0       	rjmp	.+88     	; 0x191c <fputc+0x6e>
    18c4:	22 ff       	sbrs	r18, 2
    18c6:	16 c0       	rjmp	.+44     	; 0x18f4 <fputc+0x46>
    18c8:	46 81       	ldd	r20, Z+6	; 0x06
    18ca:	57 81       	ldd	r21, Z+7	; 0x07
    18cc:	24 81       	ldd	r18, Z+4	; 0x04
    18ce:	35 81       	ldd	r19, Z+5	; 0x05
    18d0:	42 17       	cp	r20, r18
    18d2:	53 07       	cpc	r21, r19
    18d4:	44 f4       	brge	.+16     	; 0x18e6 <fputc+0x38>
    18d6:	a0 81       	ld	r26, Z
    18d8:	b1 81       	ldd	r27, Z+1	; 0x01
    18da:	9d 01       	movw	r18, r26
    18dc:	2f 5f       	subi	r18, 0xFF	; 255
    18de:	3f 4f       	sbci	r19, 0xFF	; 255
    18e0:	31 83       	std	Z+1, r19	; 0x01
    18e2:	20 83       	st	Z, r18
    18e4:	8c 93       	st	X, r24
    18e6:	26 81       	ldd	r18, Z+6	; 0x06
    18e8:	37 81       	ldd	r19, Z+7	; 0x07
    18ea:	2f 5f       	subi	r18, 0xFF	; 255
    18ec:	3f 4f       	sbci	r19, 0xFF	; 255
    18ee:	37 83       	std	Z+7, r19	; 0x07
    18f0:	26 83       	std	Z+6, r18	; 0x06
    18f2:	14 c0       	rjmp	.+40     	; 0x191c <fputc+0x6e>
    18f4:	8b 01       	movw	r16, r22
    18f6:	ec 01       	movw	r28, r24
    18f8:	fb 01       	movw	r30, r22
    18fa:	00 84       	ldd	r0, Z+8	; 0x08
    18fc:	f1 85       	ldd	r31, Z+9	; 0x09
    18fe:	e0 2d       	mov	r30, r0
    1900:	09 95       	icall
    1902:	89 2b       	or	r24, r25
    1904:	e1 f6       	brne	.-72     	; 0x18be <fputc+0x10>
    1906:	d8 01       	movw	r26, r16
    1908:	16 96       	adiw	r26, 0x06	; 6
    190a:	8d 91       	ld	r24, X+
    190c:	9c 91       	ld	r25, X
    190e:	17 97       	sbiw	r26, 0x07	; 7
    1910:	01 96       	adiw	r24, 0x01	; 1
    1912:	17 96       	adiw	r26, 0x07	; 7
    1914:	9c 93       	st	X, r25
    1916:	8e 93       	st	-X, r24
    1918:	16 97       	sbiw	r26, 0x06	; 6
    191a:	ce 01       	movw	r24, r28
    191c:	df 91       	pop	r29
    191e:	cf 91       	pop	r28
    1920:	1f 91       	pop	r17
    1922:	0f 91       	pop	r16
    1924:	08 95       	ret

00001926 <__ultoa_invert>:
    1926:	fa 01       	movw	r30, r20
    1928:	aa 27       	eor	r26, r26
    192a:	28 30       	cpi	r18, 0x08	; 8
    192c:	51 f1       	breq	.+84     	; 0x1982 <__ultoa_invert+0x5c>
    192e:	20 31       	cpi	r18, 0x10	; 16
    1930:	81 f1       	breq	.+96     	; 0x1992 <__ultoa_invert+0x6c>
    1932:	e8 94       	clt
    1934:	6f 93       	push	r22
    1936:	6e 7f       	andi	r22, 0xFE	; 254
    1938:	6e 5f       	subi	r22, 0xFE	; 254
    193a:	7f 4f       	sbci	r23, 0xFF	; 255
    193c:	8f 4f       	sbci	r24, 0xFF	; 255
    193e:	9f 4f       	sbci	r25, 0xFF	; 255
    1940:	af 4f       	sbci	r26, 0xFF	; 255
    1942:	b1 e0       	ldi	r27, 0x01	; 1
    1944:	3e d0       	rcall	.+124    	; 0x19c2 <__ultoa_invert+0x9c>
    1946:	b4 e0       	ldi	r27, 0x04	; 4
    1948:	3c d0       	rcall	.+120    	; 0x19c2 <__ultoa_invert+0x9c>
    194a:	67 0f       	add	r22, r23
    194c:	78 1f       	adc	r23, r24
    194e:	89 1f       	adc	r24, r25
    1950:	9a 1f       	adc	r25, r26
    1952:	a1 1d       	adc	r26, r1
    1954:	68 0f       	add	r22, r24
    1956:	79 1f       	adc	r23, r25
    1958:	8a 1f       	adc	r24, r26
    195a:	91 1d       	adc	r25, r1
    195c:	a1 1d       	adc	r26, r1
    195e:	6a 0f       	add	r22, r26
    1960:	71 1d       	adc	r23, r1
    1962:	81 1d       	adc	r24, r1
    1964:	91 1d       	adc	r25, r1
    1966:	a1 1d       	adc	r26, r1
    1968:	20 d0       	rcall	.+64     	; 0x19aa <__ultoa_invert+0x84>
    196a:	09 f4       	brne	.+2      	; 0x196e <__ultoa_invert+0x48>
    196c:	68 94       	set
    196e:	3f 91       	pop	r19
    1970:	2a e0       	ldi	r18, 0x0A	; 10
    1972:	26 9f       	mul	r18, r22
    1974:	11 24       	eor	r1, r1
    1976:	30 19       	sub	r19, r0
    1978:	30 5d       	subi	r19, 0xD0	; 208
    197a:	31 93       	st	Z+, r19
    197c:	de f6       	brtc	.-74     	; 0x1934 <__ultoa_invert+0xe>
    197e:	cf 01       	movw	r24, r30
    1980:	08 95       	ret
    1982:	46 2f       	mov	r20, r22
    1984:	47 70       	andi	r20, 0x07	; 7
    1986:	40 5d       	subi	r20, 0xD0	; 208
    1988:	41 93       	st	Z+, r20
    198a:	b3 e0       	ldi	r27, 0x03	; 3
    198c:	0f d0       	rcall	.+30     	; 0x19ac <__ultoa_invert+0x86>
    198e:	c9 f7       	brne	.-14     	; 0x1982 <__ultoa_invert+0x5c>
    1990:	f6 cf       	rjmp	.-20     	; 0x197e <__ultoa_invert+0x58>
    1992:	46 2f       	mov	r20, r22
    1994:	4f 70       	andi	r20, 0x0F	; 15
    1996:	40 5d       	subi	r20, 0xD0	; 208
    1998:	4a 33       	cpi	r20, 0x3A	; 58
    199a:	18 f0       	brcs	.+6      	; 0x19a2 <__ultoa_invert+0x7c>
    199c:	49 5d       	subi	r20, 0xD9	; 217
    199e:	31 fd       	sbrc	r19, 1
    19a0:	40 52       	subi	r20, 0x20	; 32
    19a2:	41 93       	st	Z+, r20
    19a4:	02 d0       	rcall	.+4      	; 0x19aa <__ultoa_invert+0x84>
    19a6:	a9 f7       	brne	.-22     	; 0x1992 <__ultoa_invert+0x6c>
    19a8:	ea cf       	rjmp	.-44     	; 0x197e <__ultoa_invert+0x58>
    19aa:	b4 e0       	ldi	r27, 0x04	; 4
    19ac:	a6 95       	lsr	r26
    19ae:	97 95       	ror	r25
    19b0:	87 95       	ror	r24
    19b2:	77 95       	ror	r23
    19b4:	67 95       	ror	r22
    19b6:	ba 95       	dec	r27
    19b8:	c9 f7       	brne	.-14     	; 0x19ac <__ultoa_invert+0x86>
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	61 05       	cpc	r22, r1
    19be:	71 05       	cpc	r23, r1
    19c0:	08 95       	ret
    19c2:	9b 01       	movw	r18, r22
    19c4:	ac 01       	movw	r20, r24
    19c6:	0a 2e       	mov	r0, r26
    19c8:	06 94       	lsr	r0
    19ca:	57 95       	ror	r21
    19cc:	47 95       	ror	r20
    19ce:	37 95       	ror	r19
    19d0:	27 95       	ror	r18
    19d2:	ba 95       	dec	r27
    19d4:	c9 f7       	brne	.-14     	; 0x19c8 <__ultoa_invert+0xa2>
    19d6:	62 0f       	add	r22, r18
    19d8:	73 1f       	adc	r23, r19
    19da:	84 1f       	adc	r24, r20
    19dc:	95 1f       	adc	r25, r21
    19de:	a0 1d       	adc	r26, r0
    19e0:	08 95       	ret

000019e2 <eeprom_read_word>:
    19e2:	a8 e1       	ldi	r26, 0x18	; 24
    19e4:	b0 e0       	ldi	r27, 0x00	; 0
    19e6:	42 e0       	ldi	r20, 0x02	; 2
    19e8:	50 e0       	ldi	r21, 0x00	; 0
    19ea:	02 c0       	rjmp	.+4      	; 0x19f0 <eeprom_read_blraw>

000019ec <eeprom_read_block>:
    19ec:	dc 01       	movw	r26, r24
    19ee:	cb 01       	movw	r24, r22

000019f0 <eeprom_read_blraw>:
    19f0:	fc 01       	movw	r30, r24
    19f2:	f9 99       	sbic	0x1f, 1	; 31
    19f4:	fe cf       	rjmp	.-4      	; 0x19f2 <eeprom_read_blraw+0x2>
    19f6:	06 c0       	rjmp	.+12     	; 0x1a04 <eeprom_read_blraw+0x14>
    19f8:	f2 bd       	out	0x22, r31	; 34
    19fa:	e1 bd       	out	0x21, r30	; 33
    19fc:	f8 9a       	sbi	0x1f, 0	; 31
    19fe:	31 96       	adiw	r30, 0x01	; 1
    1a00:	00 b4       	in	r0, 0x20	; 32
    1a02:	0d 92       	st	X+, r0
    1a04:	41 50       	subi	r20, 0x01	; 1
    1a06:	50 40       	sbci	r21, 0x00	; 0
    1a08:	b8 f7       	brcc	.-18     	; 0x19f8 <eeprom_read_blraw+0x8>
    1a0a:	08 95       	ret

00001a0c <_exit>:
    1a0c:	f8 94       	cli

00001a0e <__stop_program>:
    1a0e:	ff cf       	rjmp	.-2      	; 0x1a0e <__stop_program>
