
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000096  00800100  00000fb6  0000104a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000fb6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000404  00800196  00800196  000010e0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000010e0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000113c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000240  00000000  00000000  00001180  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000030c7  00000000  00000000  000013c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000152a  00000000  00000000  00004487  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001860  00000000  00000000  000059b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000600  00000000  00000000  00007214  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ba0  00000000  00000000  00007814  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001661  00000000  00000000  000083b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000198  00000000  00000000  00009a15  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
   2:	00 00       	nop
   4:	b1 c0       	rjmp	.+354    	; 0x168 <__bad_interrupt>
   6:	00 00       	nop
   8:	af c0       	rjmp	.+350    	; 0x168 <__bad_interrupt>
   a:	00 00       	nop
   c:	ad c0       	rjmp	.+346    	; 0x168 <__bad_interrupt>
   e:	00 00       	nop
  10:	ab c0       	rjmp	.+342    	; 0x168 <__bad_interrupt>
  12:	00 00       	nop
  14:	a9 c0       	rjmp	.+338    	; 0x168 <__bad_interrupt>
  16:	00 00       	nop
  18:	a7 c0       	rjmp	.+334    	; 0x168 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	a5 c0       	rjmp	.+330    	; 0x168 <__bad_interrupt>
  1e:	00 00       	nop
  20:	a3 c0       	rjmp	.+326    	; 0x168 <__bad_interrupt>
  22:	00 00       	nop
  24:	a1 c0       	rjmp	.+322    	; 0x168 <__bad_interrupt>
  26:	00 00       	nop
  28:	9f c0       	rjmp	.+318    	; 0x168 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	9d c0       	rjmp	.+314    	; 0x168 <__bad_interrupt>
  2e:	00 00       	nop
  30:	9b c0       	rjmp	.+310    	; 0x168 <__bad_interrupt>
  32:	00 00       	nop
  34:	69 c3       	rjmp	.+1746   	; 0x708 <__vector_13>
  36:	00 00       	nop
  38:	97 c0       	rjmp	.+302    	; 0x168 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	95 c0       	rjmp	.+298    	; 0x168 <__bad_interrupt>
  3e:	00 00       	nop
  40:	62 c3       	rjmp	.+1732   	; 0x706 <__vector_16>
  42:	00 00       	nop
  44:	91 c0       	rjmp	.+290    	; 0x168 <__bad_interrupt>
  46:	00 00       	nop
  48:	8f c0       	rjmp	.+286    	; 0x168 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	8d c0       	rjmp	.+282    	; 0x168 <__bad_interrupt>
  4e:	00 00       	nop
  50:	8b c0       	rjmp	.+278    	; 0x168 <__bad_interrupt>
  52:	00 00       	nop
  54:	3d c4       	rjmp	.+2170   	; 0x8d0 <__vector_21>
  56:	00 00       	nop
  58:	87 c0       	rjmp	.+270    	; 0x168 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	85 c0       	rjmp	.+266    	; 0x168 <__bad_interrupt>
  5e:	00 00       	nop
  60:	83 c0       	rjmp	.+262    	; 0x168 <__bad_interrupt>
  62:	00 00       	nop
  64:	81 c0       	rjmp	.+258    	; 0x168 <__bad_interrupt>
  66:	00 00       	nop
  68:	64 c3       	rjmp	.+1736   	; 0x732 <__vector_26>
  6a:	00 00       	nop
  6c:	7d c0       	rjmp	.+250    	; 0x168 <__bad_interrupt>
  6e:	00 00       	nop
  70:	6f c4       	rjmp	.+2270   	; 0x950 <__vector_28>
  72:	00 00       	nop
  74:	79 c0       	rjmp	.+242    	; 0x168 <__bad_interrupt>
  76:	00 00       	nop
  78:	77 c0       	rjmp	.+238    	; 0x168 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	75 c0       	rjmp	.+234    	; 0x168 <__bad_interrupt>
  7e:	00 00       	nop
  80:	73 c0       	rjmp	.+230    	; 0x168 <__bad_interrupt>
  82:	00 00       	nop
  84:	71 c0       	rjmp	.+226    	; 0x168 <__bad_interrupt>
  86:	00 00       	nop
  88:	6f c0       	rjmp	.+222    	; 0x168 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	b5 03       	fmuls	r19, r21
  8e:	07 04       	cpc	r0, r7
  90:	07 04       	cpc	r0, r7
  92:	07 04       	cpc	r0, r7
  94:	07 04       	cpc	r0, r7
  96:	07 04       	cpc	r0, r7
  98:	07 04       	cpc	r0, r7
  9a:	07 04       	cpc	r0, r7
  9c:	b5 03       	fmuls	r19, r21
  9e:	07 04       	cpc	r0, r7
  a0:	07 04       	cpc	r0, r7
  a2:	07 04       	cpc	r0, r7
  a4:	07 04       	cpc	r0, r7
  a6:	07 04       	cpc	r0, r7
  a8:	07 04       	cpc	r0, r7
  aa:	07 04       	cpc	r0, r7
  ac:	b7 03       	fmuls	r19, r23
  ae:	07 04       	cpc	r0, r7
  b0:	07 04       	cpc	r0, r7
  b2:	07 04       	cpc	r0, r7
  b4:	07 04       	cpc	r0, r7
  b6:	07 04       	cpc	r0, r7
  b8:	07 04       	cpc	r0, r7
  ba:	07 04       	cpc	r0, r7
  bc:	07 04       	cpc	r0, r7
  be:	07 04       	cpc	r0, r7
  c0:	07 04       	cpc	r0, r7
  c2:	07 04       	cpc	r0, r7
  c4:	07 04       	cpc	r0, r7
  c6:	07 04       	cpc	r0, r7
  c8:	07 04       	cpc	r0, r7
  ca:	07 04       	cpc	r0, r7
  cc:	b7 03       	fmuls	r19, r23
  ce:	07 04       	cpc	r0, r7
  d0:	07 04       	cpc	r0, r7
  d2:	07 04       	cpc	r0, r7
  d4:	07 04       	cpc	r0, r7
  d6:	07 04       	cpc	r0, r7
  d8:	07 04       	cpc	r0, r7
  da:	07 04       	cpc	r0, r7
  dc:	07 04       	cpc	r0, r7
  de:	07 04       	cpc	r0, r7
  e0:	07 04       	cpc	r0, r7
  e2:	07 04       	cpc	r0, r7
  e4:	07 04       	cpc	r0, r7
  e6:	07 04       	cpc	r0, r7
  e8:	07 04       	cpc	r0, r7
  ea:	07 04       	cpc	r0, r7
  ec:	03 04       	cpc	r0, r3
  ee:	07 04       	cpc	r0, r7
  f0:	07 04       	cpc	r0, r7
  f2:	07 04       	cpc	r0, r7
  f4:	07 04       	cpc	r0, r7
  f6:	07 04       	cpc	r0, r7
  f8:	07 04       	cpc	r0, r7
  fa:	07 04       	cpc	r0, r7
  fc:	e0 03       	fmuls	r22, r16
  fe:	07 04       	cpc	r0, r7
 100:	07 04       	cpc	r0, r7
 102:	07 04       	cpc	r0, r7
 104:	07 04       	cpc	r0, r7
 106:	07 04       	cpc	r0, r7
 108:	07 04       	cpc	r0, r7
 10a:	07 04       	cpc	r0, r7
 10c:	07 04       	cpc	r0, r7
 10e:	07 04       	cpc	r0, r7
 110:	07 04       	cpc	r0, r7
 112:	07 04       	cpc	r0, r7
 114:	07 04       	cpc	r0, r7
 116:	07 04       	cpc	r0, r7
 118:	07 04       	cpc	r0, r7
 11a:	07 04       	cpc	r0, r7
 11c:	d4 03       	fmuls	r21, r20
 11e:	07 04       	cpc	r0, r7
 120:	07 04       	cpc	r0, r7
 122:	07 04       	cpc	r0, r7
 124:	07 04       	cpc	r0, r7
 126:	07 04       	cpc	r0, r7
 128:	07 04       	cpc	r0, r7
 12a:	07 04       	cpc	r0, r7
 12c:	f2 03       	fmuls	r23, r18

0000012e <__ctors_end>:
 12e:	11 24       	eor	r1, r1
 130:	1f be       	out	0x3f, r1	; 63
 132:	cf ef       	ldi	r28, 0xFF	; 255
 134:	d0 e4       	ldi	r29, 0x40	; 64
 136:	de bf       	out	0x3e, r29	; 62
 138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
 13a:	11 e0       	ldi	r17, 0x01	; 1
 13c:	a0 e0       	ldi	r26, 0x00	; 0
 13e:	b1 e0       	ldi	r27, 0x01	; 1
 140:	e6 eb       	ldi	r30, 0xB6	; 182
 142:	ff e0       	ldi	r31, 0x0F	; 15
 144:	00 e0       	ldi	r16, 0x00	; 0
 146:	0b bf       	out	0x3b, r16	; 59
 148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
 14a:	07 90       	elpm	r0, Z+
 14c:	0d 92       	st	X+, r0
 14e:	a6 39       	cpi	r26, 0x96	; 150
 150:	b1 07       	cpc	r27, r17
 152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
 154:	25 e0       	ldi	r18, 0x05	; 5
 156:	a6 e9       	ldi	r26, 0x96	; 150
 158:	b1 e0       	ldi	r27, 0x01	; 1
 15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
 15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
 15e:	aa 39       	cpi	r26, 0x9A	; 154
 160:	b2 07       	cpc	r27, r18
 162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
 164:	0c d2       	rcall	.+1048   	; 0x57e <main>
 166:	25 c7       	rjmp	.+3658   	; 0xfb2 <_exit>

00000168 <__bad_interrupt>:
 168:	b9 c2       	rjmp	.+1394   	; 0x6dc <__vector_default>

0000016a <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
 16a:	ec e7       	ldi	r30, 0x7C	; 124
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	90 81       	ld	r25, Z
 170:	90 7e       	andi	r25, 0xE0	; 224
 172:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
 174:	90 81       	ld	r25, Z
 176:	89 2b       	or	r24, r25
 178:	80 83       	st	Z, r24
 17a:	08 95       	ret

0000017c <ADC_init>:
}

void ADC_init(void)
{
 17c:	cf 93       	push	r28
 17e:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
 180:	ec e7       	ldi	r30, 0x7C	; 124
 182:	f0 e0       	ldi	r31, 0x00	; 0
 184:	80 81       	ld	r24, Z
 186:	80 64       	ori	r24, 0x40	; 64
 188:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
 18a:	ca e7       	ldi	r28, 0x7A	; 122
 18c:	d0 e0       	ldi	r29, 0x00	; 0
 18e:	88 81       	ld	r24, Y
 190:	81 60       	ori	r24, 0x01	; 1
 192:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
 194:	88 81       	ld	r24, Y
 196:	82 60       	ori	r24, 0x02	; 2
 198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
 19a:	88 81       	ld	r24, Y
 19c:	84 60       	ori	r24, 0x04	; 4
 19e:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
 1a0:	a4 e6       	ldi	r26, 0x64	; 100
 1a2:	b0 e0       	ldi	r27, 0x00	; 0
 1a4:	8c 91       	ld	r24, X
 1a6:	8e 7f       	andi	r24, 0xFE	; 254
 1a8:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
 1aa:	80 81       	ld	r24, Z
 1ac:	8f 7d       	andi	r24, 0xDF	; 223
 1ae:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
 1b0:	8f e3       	ldi	r24, 0x3F	; 63
 1b2:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
 1b6:	88 81       	ld	r24, Y
 1b8:	80 68       	ori	r24, 0x80	; 128
 1ba:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
 1bc:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
 1c0:	8f e1       	ldi	r24, 0x1F	; 31
 1c2:	d3 df       	rcall	.-90     	; 0x16a <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
 1c4:	88 81       	ld	r24, Y
 1c6:	80 64       	ori	r24, 0x40	; 64
 1c8:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
 1ca:	ea e7       	ldi	r30, 0x7A	; 122
 1cc:	f0 e0       	ldi	r31, 0x00	; 0
 1ce:	80 81       	ld	r24, Z
 1d0:	84 ff       	sbrs	r24, 4
 1d2:	fd cf       	rjmp	.-6      	; 0x1ce <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
 1d4:	ea e7       	ldi	r30, 0x7A	; 122
 1d6:	f0 e0       	ldi	r31, 0x00	; 0
 1d8:	80 81       	ld	r24, Z
 1da:	80 64       	ori	r24, 0x40	; 64
 1dc:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
 1de:	80 81       	ld	r24, Z
 1e0:	84 ff       	sbrs	r24, 4
 1e2:	fd cf       	rjmp	.-6      	; 0x1de <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
 1e4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 1e8:	90 e0       	ldi	r25, 0x00	; 0
 1ea:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <__data_end+0x1>
 1ee:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
 1f2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 1f6:	20 91 96 01 	lds	r18, 0x0196	; 0x800196 <__data_end>
 1fa:	30 91 97 01 	lds	r19, 0x0197	; 0x800197 <__data_end+0x1>
 1fe:	89 2f       	mov	r24, r25
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	98 2f       	mov	r25, r24
 204:	88 27       	eor	r24, r24
 206:	82 0f       	add	r24, r18
 208:	93 1f       	adc	r25, r19
 20a:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <__data_end+0x1>
 20e:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
 212:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <__data_end>
 216:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <__data_end+0x1>
 21a:	99 23       	and	r25, r25
 21c:	1c f4       	brge	.+6      	; 0x224 <ADC_init+0xa8>
 21e:	91 95       	neg	r25
 220:	81 95       	neg	r24
 222:	91 09       	sbc	r25, r1
 224:	05 97       	sbiw	r24, 0x05	; 5
 226:	2c f0       	brlt	.+10     	; 0x232 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
 228:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <gas_sensor_initialization_errors>
 22c:	81 60       	ori	r24, 0x01	; 1
 22e:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
 232:	8e e1       	ldi	r24, 0x1E	; 30
 234:	9a df       	rcall	.-204    	; 0x16a <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
 236:	ea e7       	ldi	r30, 0x7A	; 122
 238:	f0 e0       	ldi	r31, 0x00	; 0
 23a:	80 81       	ld	r24, Z
 23c:	80 64       	ori	r24, 0x40	; 64
 23e:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
 240:	80 81       	ld	r24, Z
 242:	84 ff       	sbrs	r24, 4
 244:	fd cf       	rjmp	.-6      	; 0x240 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
 246:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <__data_end+0x1>
 250:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
 254:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 258:	20 91 96 01 	lds	r18, 0x0196	; 0x800196 <__data_end>
 25c:	30 91 97 01 	lds	r19, 0x0197	; 0x800197 <__data_end+0x1>
 260:	89 2f       	mov	r24, r25
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	98 2f       	mov	r25, r24
 266:	88 27       	eor	r24, r24
 268:	82 0f       	add	r24, r18
 26a:	93 1f       	adc	r25, r19
 26c:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <__data_end+0x1>
 270:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
 274:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <__data_end>
 278:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <__data_end+0x1>
 27c:	81 5e       	subi	r24, 0xE1	; 225
 27e:	91 09       	sbc	r25, r1
 280:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <__data_end+0x1>
 284:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
 288:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <__data_end>
 28c:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <__data_end+0x1>
 290:	99 23       	and	r25, r25
 292:	1c f4       	brge	.+6      	; 0x29a <ADC_init+0x11e>
 294:	91 95       	neg	r25
 296:	81 95       	neg	r24
 298:	91 09       	sbc	r25, r1
 29a:	05 97       	sbiw	r24, 0x05	; 5
 29c:	2c f0       	brlt	.+10     	; 0x2a8 <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
 29e:	80 91 f4 02 	lds	r24, 0x02F4	; 0x8002f4 <gas_sensor_initialization_errors>
 2a2:	82 60       	ori	r24, 0x02	; 2
 2a4:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
 2a8:	ea e7       	ldi	r30, 0x7A	; 122
 2aa:	f0 e0       	ldi	r31, 0x00	; 0
 2ac:	80 81       	ld	r24, Z
 2ae:	8f 77       	andi	r24, 0x7F	; 127
 2b0:	80 83       	st	Z, r24
 2b2:	df 91       	pop	r29
 2b4:	cf 91       	pop	r28
 2b6:	08 95       	ret

000002b8 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
 2b8:	87 e0       	ldi	r24, 0x07	; 7
 2ba:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
 2bc:	85 b1       	in	r24, 0x05	; 5
 2be:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
 2c0:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
 2c2:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
 2c4:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
 2c6:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
 2c8:	41 9a       	sbi	0x08, 1	; 8
 2ca:	08 95       	ret

000002cc <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
 2cc:	80 e0       	ldi	r24, 0x00	; 0
 2ce:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
 2d0:	2f ef       	ldi	r18, 0xFF	; 255
 2d2:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
 2d4:	fc 01       	movw	r30, r24
 2d6:	ee 0f       	add	r30, r30
 2d8:	ff 1f       	adc	r31, r31
 2da:	ee 0f       	add	r30, r30
 2dc:	ff 1f       	adc	r31, r31
 2de:	e7 53       	subi	r30, 0x37	; 55
 2e0:	fd 4f       	sbci	r31, 0xFD	; 253
 2e2:	11 82       	std	Z+1, r1	; 0x01
 2e4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
 2e6:	33 83       	std	Z+3, r19	; 0x03
 2e8:	22 83       	std	Z+2, r18	; 0x02
 2ea:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
 2ec:	85 30       	cpi	r24, 0x05	; 5
 2ee:	91 05       	cpc	r25, r1
 2f0:	89 f7       	brne	.-30     	; 0x2d4 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
 2f2:	08 95       	ret

000002f4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
 2f4:	ef 92       	push	r14
 2f6:	ff 92       	push	r15
 2f8:	0f 93       	push	r16
 2fa:	1f 93       	push	r17
 2fc:	cf 93       	push	r28
 2fe:	df 93       	push	r29
 300:	0f 2e       	mov	r0, r31
 302:	f3 eb       	ldi	r31, 0xB3	; 179
 304:	ef 2e       	mov	r14, r31
 306:	f2 e0       	ldi	r31, 0x02	; 2
 308:	ff 2e       	mov	r15, r31
 30a:	f0 2d       	mov	r31, r0
 30c:	00 e0       	ldi	r16, 0x00	; 0
 30e:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
 310:	c7 01       	movw	r24, r14
 312:	3a d6       	rcall	.+3188   	; 0xf88 <eeprom_read_word>
 314:	e8 01       	movw	r28, r16
 316:	cc 0f       	add	r28, r28
 318:	dd 1f       	adc	r29, r29
 31a:	cc 0f       	add	r28, r28
 31c:	dd 1f       	adc	r29, r29
 31e:	c7 53       	subi	r28, 0x37	; 55
 320:	dd 4f       	sbci	r29, 0xFD	; 253
 322:	99 83       	std	Y+1, r25	; 0x01
 324:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
 326:	c7 01       	movw	r24, r14
 328:	02 96       	adiw	r24, 0x02	; 2
 32a:	2e d6       	rcall	.+3164   	; 0xf88 <eeprom_read_word>
 32c:	9b 83       	std	Y+3, r25	; 0x03
 32e:	8a 83       	std	Y+2, r24	; 0x02
 330:	0f 5f       	subi	r16, 0xFF	; 255
 332:	1f 4f       	sbci	r17, 0xFF	; 255
 334:	84 e0       	ldi	r24, 0x04	; 4
 336:	e8 0e       	add	r14, r24
 338:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
 33a:	05 30       	cpi	r16, 0x05	; 5
 33c:	11 05       	cpc	r17, r1
 33e:	41 f7       	brne	.-48     	; 0x310 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
 340:	df 91       	pop	r29
 342:	cf 91       	pop	r28
 344:	1f 91       	pop	r17
 346:	0f 91       	pop	r16
 348:	ff 90       	pop	r15
 34a:	ef 90       	pop	r14
 34c:	08 95       	ret

0000034e <gas_sensors_init>:

void gas_sensors_init(void)
{
 34e:	af 92       	push	r10
 350:	bf 92       	push	r11
 352:	cf 92       	push	r12
 354:	df 92       	push	r13
 356:	ef 92       	push	r14
 358:	ff 92       	push	r15
 35a:	0f 93       	push	r16
 35c:	1f 93       	push	r17
 35e:	cf 93       	push	r28
 360:	df 93       	push	r29
 362:	1f 92       	push	r1
 364:	cd b7       	in	r28, 0x3d	; 61
 366:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
 368:	10 92 f4 02 	sts	0x02F4, r1	; 0x8002f4 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
 36c:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
 370:	c1 df       	rcall	.-126    	; 0x2f4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
 372:	ac df       	rcall	.-168    	; 0x2cc <get_gas_sensor_limits>
 374:	ea e7       	ldi	r30, 0x7A	; 122
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
 376:	f0 e0       	ldi	r31, 0x00	; 0
 378:	80 81       	ld	r24, Z
 37a:	80 68       	ori	r24, 0x80	; 128
 37c:	80 83       	st	Z, r24
 37e:	19 82       	std	Y+1, r1	; 0x01
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
 380:	89 81       	ldd	r24, Y+1	; 0x01
 382:	85 30       	cpi	r24, 0x05	; 5
 384:	08 f0       	brcs	.+2      	; 0x388 <gas_sensors_init+0x3a>
 386:	51 c0       	rjmp	.+162    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 388:	0a e7       	ldi	r16, 0x7A	; 122
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
 38a:	10 e0       	ldi	r17, 0x00	; 0
 38c:	0f 2e       	mov	r0, r31
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
 38e:	f8 e7       	ldi	r31, 0x78	; 120
 390:	ef 2e       	mov	r14, r31
 392:	f1 2c       	mov	r15, r1
 394:	f0 2d       	mov	r31, r0
 396:	bb 24       	eor	r11, r11
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
 398:	b3 94       	inc	r11
 39a:	a1 2c       	mov	r10, r1
 39c:	cc 24       	eor	r12, r12
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
 39e:	c3 94       	inc	r12
 3a0:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
 3a2:	89 81       	ldd	r24, Y+1	; 0x01
 3a4:	e2 de       	rcall	.-572    	; 0x16a <ADC_SetMux>
 3a6:	f8 01       	movw	r30, r16
		// Start conversion
		SetBit(ADCSRA, ADSC);
 3a8:	80 81       	ld	r24, Z
 3aa:	80 64       	ori	r24, 0x40	; 64
 3ac:	80 83       	st	Z, r24
 3ae:	f8 01       	movw	r30, r16
		while (BitIsClear(ADCSRA, ADIF))
 3b0:	80 81       	ld	r24, Z
 3b2:	84 ff       	sbrs	r24, 4
 3b4:	fc cf       	rjmp	.-8      	; 0x3ae <gas_sensors_init+0x60>
 3b6:	f7 01       	movw	r30, r14
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
 3b8:	80 81       	ld	r24, Z
 3ba:	91 81       	ldd	r25, Z+1	; 0x01
 3bc:	e9 81       	ldd	r30, Y+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
 3be:	f0 e0       	ldi	r31, 0x00	; 0
 3c0:	ee 0f       	add	r30, r30
 3c2:	ff 1f       	adc	r31, r31
 3c4:	ee 0f       	add	r30, r30
 3c6:	ff 1f       	adc	r31, r31
 3c8:	e7 53       	subi	r30, 0x37	; 55
 3ca:	fd 4f       	sbci	r31, 0xFD	; 253
 3cc:	20 81       	ld	r18, Z
 3ce:	31 81       	ldd	r19, Z+1	; 0x01
 3d0:	e9 81       	ldd	r30, Y+1	; 0x01
 3d2:	f0 e0       	ldi	r31, 0x00	; 0
 3d4:	ee 0f       	add	r30, r30
 3d6:	ff 1f       	adc	r31, r31
 3d8:	ee 0f       	add	r30, r30
 3da:	ff 1f       	adc	r31, r31
 3dc:	e7 53       	subi	r30, 0x37	; 55
 3de:	fd 4f       	sbci	r31, 0xFD	; 253
 3e0:	62 81       	ldd	r22, Z+2	; 0x02
 3e2:	73 81       	ldd	r23, Z+3	; 0x03
 3e4:	4b 2d       	mov	r20, r11
 3e6:	82 17       	cp	r24, r18
 3e8:	93 07       	cpc	r25, r19
 3ea:	08 f0       	brcs	.+2      	; 0x3ee <gas_sensors_init+0xa0>
 3ec:	4a 2d       	mov	r20, r10
 3ee:	41 11       	cpse	r20, r1
 3f0:	07 c0       	rjmp	.+14     	; 0x400 <__LOCK_REGION_LENGTH__>
 3f2:	2b 2d       	mov	r18, r11
 3f4:	68 17       	cp	r22, r24
 3f6:	79 07       	cpc	r23, r25
 3f8:	08 f0       	brcs	.+2      	; 0x3fc <gas_sensors_init+0xae>
 3fa:	2a 2d       	mov	r18, r10
 3fc:	22 23       	and	r18, r18
 3fe:	71 f0       	breq	.+28     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
 400:	99 81       	ldd	r25, Y+1	; 0x01
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
 402:	20 91 f4 02 	lds	r18, 0x02F4	; 0x8002f4 <gas_sensor_initialization_errors>
 406:	9d 5f       	subi	r25, 0xFD	; 253
 408:	a6 01       	movw	r20, r12
 40a:	02 c0       	rjmp	.+4      	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
 40c:	44 0f       	add	r20, r20
 40e:	55 1f       	adc	r21, r21
 410:	9a 95       	dec	r25
 412:	e2 f7       	brpl	.-8      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
 414:	ca 01       	movw	r24, r20
 416:	82 2b       	or	r24, r18
 418:	80 93 f4 02 	sts	0x02F4, r24	; 0x8002f4 <gas_sensor_initialization_errors>
 41c:	89 81       	ldd	r24, Y+1	; 0x01
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
 41e:	8f 5f       	subi	r24, 0xFF	; 255
 420:	89 83       	std	Y+1, r24	; 0x01
 422:	89 81       	ldd	r24, Y+1	; 0x01
 424:	85 30       	cpi	r24, 0x05	; 5
 426:	08 f4       	brcc	.+2      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 428:	bc cf       	rjmp	.-136    	; 0x3a2 <gas_sensors_init+0x54>
 42a:	ea e7       	ldi	r30, 0x7A	; 122
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
 42c:	f0 e0       	ldi	r31, 0x00	; 0
 42e:	80 81       	ld	r24, Z
 430:	8f 77       	andi	r24, 0x7F	; 127
 432:	80 83       	st	Z, r24
 434:	0f 90       	pop	r0
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
 436:	df 91       	pop	r29
 438:	cf 91       	pop	r28
 43a:	1f 91       	pop	r17
 43c:	0f 91       	pop	r16
 43e:	ff 90       	pop	r15
 440:	ef 90       	pop	r14
 442:	df 90       	pop	r13
 444:	cf 90       	pop	r12
 446:	bf 90       	pop	r11
 448:	af 90       	pop	r10
 44a:	08 95       	ret

0000044c <start_gas_sensor_read>:
 44c:	af 92       	push	r10

void start_gas_sensor_read(void)
{
 44e:	bf 92       	push	r11
 450:	cf 92       	push	r12
 452:	df 92       	push	r13
 454:	ef 92       	push	r14
 456:	ff 92       	push	r15
 458:	0f 93       	push	r16
 45a:	1f 93       	push	r17
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
 460:	00 d0       	rcall	.+0      	; 0x462 <start_gas_sensor_read+0x16>
 462:	1f 92       	push	r1
 464:	cd b7       	in	r28, 0x3d	; 61
 466:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
 468:	ea e7       	ldi	r30, 0x7A	; 122
 46a:	f0 e0       	ldi	r31, 0x00	; 0
 46c:	80 81       	ld	r24, Z
 46e:	80 68       	ori	r24, 0x80	; 128
 470:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
 472:	19 82       	std	Y+1, r1	; 0x01
 474:	89 81       	ldd	r24, Y+1	; 0x01
 476:	85 30       	cpi	r24, 0x05	; 5
 478:	08 f0       	brcs	.+2      	; 0x47c <start_gas_sensor_read+0x30>
 47a:	73 c0       	rjmp	.+230    	; 0x562 <start_gas_sensor_read+0x116>
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
 47c:	0a e7       	ldi	r16, 0x7A	; 122
 47e:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
 480:	0f 2e       	mov	r0, r31
 482:	f8 e7       	ldi	r31, 0x78	; 120
 484:	ef 2e       	mov	r14, r31
 486:	f1 2c       	mov	r15, r1
 488:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
 48a:	cc 24       	eor	r12, r12
 48c:	c3 94       	inc	r12
 48e:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
 490:	bb 24       	eor	r11, r11
 492:	b3 94       	inc	r11
 494:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
 496:	89 81       	ldd	r24, Y+1	; 0x01
 498:	68 de       	rcall	.-816    	; 0x16a <ADC_SetMux>
		total = 0;	// re-zero the average
 49a:	1b 82       	std	Y+3, r1	; 0x03
 49c:	1a 82       	std	Y+2, r1	; 0x02
 49e:	24 e0       	ldi	r18, 0x04	; 4
 4a0:	30 e0       	ldi	r19, 0x00	; 0
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
 4a2:	f8 01       	movw	r30, r16
 4a4:	80 81       	ld	r24, Z
 4a6:	80 64       	ori	r24, 0x40	; 64
 4a8:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
 4aa:	f8 01       	movw	r30, r16
 4ac:	80 81       	ld	r24, Z
 4ae:	84 ff       	sbrs	r24, 4
 4b0:	fc cf       	rjmp	.-8      	; 0x4aa <start_gas_sensor_read+0x5e>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
 4b2:	f7 01       	movw	r30, r14
 4b4:	80 81       	ld	r24, Z
 4b6:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
 4b8:	e9 81       	ldd	r30, Y+1	; 0x01
 4ba:	f0 e0       	ldi	r31, 0x00	; 0
 4bc:	ee 0f       	add	r30, r30
 4be:	ff 1f       	adc	r31, r31
 4c0:	ee 0f       	add	r30, r30
 4c2:	ff 1f       	adc	r31, r31
 4c4:	e7 53       	subi	r30, 0x37	; 55
 4c6:	fd 4f       	sbci	r31, 0xFD	; 253
 4c8:	40 81       	ld	r20, Z
 4ca:	51 81       	ldd	r21, Z+1	; 0x01
 4cc:	e9 81       	ldd	r30, Y+1	; 0x01
 4ce:	f0 e0       	ldi	r31, 0x00	; 0
 4d0:	ee 0f       	add	r30, r30
 4d2:	ff 1f       	adc	r31, r31
 4d4:	ee 0f       	add	r30, r30
 4d6:	ff 1f       	adc	r31, r31
 4d8:	e7 53       	subi	r30, 0x37	; 55
 4da:	fd 4f       	sbci	r31, 0xFD	; 253
 4dc:	02 80       	ldd	r0, Z+2	; 0x02
 4de:	f3 81       	ldd	r31, Z+3	; 0x03
 4e0:	e0 2d       	mov	r30, r0
 4e2:	6b 2d       	mov	r22, r11
 4e4:	84 17       	cp	r24, r20
 4e6:	95 07       	cpc	r25, r21
 4e8:	08 f0       	brcs	.+2      	; 0x4ec <start_gas_sensor_read+0xa0>
 4ea:	6a 2d       	mov	r22, r10
 4ec:	61 11       	cpse	r22, r1
 4ee:	07 c0       	rjmp	.+14     	; 0x4fe <start_gas_sensor_read+0xb2>
 4f0:	4b 2d       	mov	r20, r11
 4f2:	e8 17       	cp	r30, r24
 4f4:	f9 07       	cpc	r31, r25
 4f6:	08 f0       	brcs	.+2      	; 0x4fa <start_gas_sensor_read+0xae>
 4f8:	4a 2d       	mov	r20, r10
 4fa:	44 23       	and	r20, r20
 4fc:	71 f0       	breq	.+28     	; 0x51a <start_gas_sensor_read+0xce>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
 4fe:	59 81       	ldd	r21, Y+1	; 0x01
 500:	60 91 f4 02 	lds	r22, 0x02F4	; 0x8002f4 <gas_sensor_initialization_errors>
 504:	5d 5f       	subi	r21, 0xFD	; 253
 506:	f6 01       	movw	r30, r12
 508:	02 c0       	rjmp	.+4      	; 0x50e <start_gas_sensor_read+0xc2>
 50a:	ee 0f       	add	r30, r30
 50c:	ff 1f       	adc	r31, r31
 50e:	5a 95       	dec	r21
 510:	e2 f7       	brpl	.-8      	; 0x50a <start_gas_sensor_read+0xbe>
 512:	af 01       	movw	r20, r30
 514:	46 2b       	or	r20, r22
 516:	40 93 f4 02 	sts	0x02F4, r20	; 0x8002f4 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
 51a:	4a 81       	ldd	r20, Y+2	; 0x02
 51c:	5b 81       	ldd	r21, Y+3	; 0x03
 51e:	84 0f       	add	r24, r20
 520:	95 1f       	adc	r25, r21
 522:	9b 83       	std	Y+3, r25	; 0x03
 524:	8a 83       	std	Y+2, r24	; 0x02
 526:	21 50       	subi	r18, 0x01	; 1
 528:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
 52a:	09 f0       	breq	.+2      	; 0x52e <start_gas_sensor_read+0xe2>
 52c:	ba cf       	rjmp	.-140    	; 0x4a2 <start_gas_sensor_read+0x56>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
 52e:	8a 81       	ldd	r24, Y+2	; 0x02
 530:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
 532:	e9 81       	ldd	r30, Y+1	; 0x01
 534:	f0 e0       	ldi	r31, 0x00	; 0
 536:	ee 0f       	add	r30, r30
 538:	ff 1f       	adc	r31, r31
 53a:	e8 51       	subi	r30, 0x18	; 24
 53c:	fd 4f       	sbci	r31, 0xFD	; 253
 53e:	9c 01       	movw	r18, r24
 540:	99 23       	and	r25, r25
 542:	14 f4       	brge	.+4      	; 0x548 <start_gas_sensor_read+0xfc>
 544:	2d 5f       	subi	r18, 0xFD	; 253
 546:	3f 4f       	sbci	r19, 0xFF	; 255
 548:	35 95       	asr	r19
 54a:	27 95       	ror	r18
 54c:	35 95       	asr	r19
 54e:	27 95       	ror	r18
 550:	31 83       	std	Z+1, r19	; 0x01
 552:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
 554:	89 81       	ldd	r24, Y+1	; 0x01
 556:	8f 5f       	subi	r24, 0xFF	; 255
 558:	89 83       	std	Y+1, r24	; 0x01
 55a:	89 81       	ldd	r24, Y+1	; 0x01
 55c:	85 30       	cpi	r24, 0x05	; 5
 55e:	08 f4       	brcc	.+2      	; 0x562 <start_gas_sensor_read+0x116>
 560:	9a cf       	rjmp	.-204    	; 0x496 <start_gas_sensor_read+0x4a>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
 562:	0f 90       	pop	r0
 564:	0f 90       	pop	r0
 566:	0f 90       	pop	r0
 568:	df 91       	pop	r29
 56a:	cf 91       	pop	r28
 56c:	1f 91       	pop	r17
 56e:	0f 91       	pop	r16
 570:	ff 90       	pop	r15
 572:	ef 90       	pop	r14
 574:	df 90       	pop	r13
 576:	cf 90       	pop	r12
 578:	bf 90       	pop	r11
 57a:	af 90       	pop	r10
 57c:	08 95       	ret

0000057e <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
 57e:	9c de       	rcall	.-712    	; 0x2b8 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
 580:	10 92 7d 03 	sts	0x037D, r1	; 0x80037d <seconds+0x1>
 584:	10 92 7c 03 	sts	0x037C, r1	; 0x80037c <seconds>
	ItsTime=0;
 588:	10 92 c8 02 	sts	0x02C8, r1	; 0x8002c8 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
 58c:	8a e2       	ldi	r24, 0x2A	; 42
 58e:	91 e0       	ldi	r25, 0x01	; 1
 590:	90 93 97 05 	sts	0x0597, r25	; 0x800597 <__iob+0x3>
 594:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
 598:	ac d0       	rcall	.+344    	; 0x6f2 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
 59a:	81 e8       	ldi	r24, 0x81	; 129
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	4d d1       	rcall	.+666    	; 0x83a <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
 5a0:	81 e8       	ldi	r24, 0x81	; 129
 5a2:	90 e0       	ldi	r25, 0x00	; 0
	//
	// Initialize the TWI peripheral
//	TWI_Master_Initialise();
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
 5a4:	c2 d1       	rcall	.+900    	; 0x92a <USART1_init>
 5a6:	ea dd       	rcall	.-1068   	; 0x17c <ADC_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
 5a8:	d2 de       	rcall	.-604    	; 0x34e <gas_sensors_init>
 5aa:	2a 9a       	sbi	0x05, 2	; 5
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
 5ac:	2f e7       	ldi	r18, 0x7F	; 127
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5ae:	84 e8       	ldi	r24, 0x84	; 132
 5b0:	9e e1       	ldi	r25, 0x1E	; 30
 5b2:	21 50       	subi	r18, 0x01	; 1
 5b4:	80 40       	sbci	r24, 0x00	; 0
 5b6:	90 40       	sbci	r25, 0x00	; 0
 5b8:	e1 f7       	brne	.-8      	; 0x5b2 <main+0x34>
 5ba:	00 c0       	rjmp	.+0      	; 0x5bc <main+0x3e>
 5bc:	00 00       	nop
 5be:	2a 98       	cbi	0x05, 2	; 5
	_delay_ms(500);
	ClearBit(PORTB, PORTB2);
 5c0:	ef e7       	ldi	r30, 0x7F	; 127
 5c2:	f4 e8       	ldi	r31, 0x84	; 132
 5c4:	2e e1       	ldi	r18, 0x1E	; 30
 5c6:	e1 50       	subi	r30, 0x01	; 1
 5c8:	f0 40       	sbci	r31, 0x00	; 0
 5ca:	20 40       	sbci	r18, 0x00	; 0
 5cc:	e1 f7       	brne	.-8      	; 0x5c6 <main+0x48>
 5ce:	00 c0       	rjmp	.+0      	; 0x5d0 <main+0x52>
 5d0:	00 00       	nop
	_delay_ms(500);
	// 
	// Start all interrupts
	sei();
 5d2:	78 94       	sei
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
 5d4:	80 e0       	ldi	r24, 0x00	; 0
 5d6:	91 e0       	ldi	r25, 0x01	; 1
 5d8:	6d d1       	rcall	.+730    	; 0x8b4 <USART0_putstring>
 5da:	0f 2e       	mov	r0, r31
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
 5dc:	f9 e3       	ldi	r31, 0x39	; 57
 5de:	ef 2e       	mov	r14, r31
 5e0:	f1 e0       	ldi	r31, 0x01	; 1
 5e2:	ff 2e       	mov	r15, r31
 5e4:	f0 2d       	mov	r31, r0
 5e6:	0f 2e       	mov	r0, r31
 5e8:	fc ed       	ldi	r31, 0xDC	; 220
 5ea:	8f 2e       	mov	r8, r31
 5ec:	f4 e0       	ldi	r31, 0x04	; 4
 5ee:	9f 2e       	mov	r9, r31
 5f0:	f0 2d       	mov	r31, r0
 5f2:	08 ee       	ldi	r16, 0xE8	; 232
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
 5f4:	12 e0       	ldi	r17, 0x02	; 2
 5f6:	0f 2e       	mov	r0, r31
 5f8:	f7 e4       	ldi	r31, 0x47	; 71
 5fa:	af 2e       	mov	r10, r31
 5fc:	f1 e0       	ldi	r31, 0x01	; 1
 5fe:	bf 2e       	mov	r11, r31
 600:	f0 2d       	mov	r31, r0
 602:	0f 2e       	mov	r0, r31
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
 604:	fd e5       	ldi	r31, 0x5D	; 93
 606:	cf 2e       	mov	r12, r31
 608:	f1 e0       	ldi	r31, 0x01	; 1
 60a:	df 2e       	mov	r13, r31
 60c:	f0 2d       	mov	r31, r0
 60e:	0f 2e       	mov	r0, r31
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
 610:	fc e6       	ldi	r31, 0x6C	; 108
 612:	6f 2e       	mov	r6, r31
 614:	f1 e0       	ldi	r31, 0x01	; 1
 616:	7f 2e       	mov	r7, r31
 618:	f0 2d       	mov	r31, r0
 61a:	0f 2e       	mov	r0, r31
 			printf("\nMethane = %u", raw_gas_vector[3]);
 61c:	fa e7       	ldi	r31, 0x7A	; 122
 61e:	4f 2e       	mov	r4, r31
 620:	f1 e0       	ldi	r31, 0x01	; 1
 622:	5f 2e       	mov	r5, r31
 624:	f0 2d       	mov	r31, r0
 626:	0f 2e       	mov	r0, r31
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
 628:	f8 e8       	ldi	r31, 0x88	; 136
 62a:	2f 2e       	mov	r2, r31
 62c:	f1 e0       	ldi	r31, 0x01	; 1
 62e:	3f 2e       	mov	r3, r31
 630:	f0 2d       	mov	r31, r0
 632:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <ItsTime>
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag
 636:	81 30       	cpi	r24, 0x01	; 1
 638:	e1 f7       	brne	.-8      	; 0x632 <main+0xb4>
 63a:	10 92 c8 02 	sts	0x02C8, r1	; 0x8002c8 <ItsTime>
			ItsTime = 0; 
 63e:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <seconds>
			seconds++;
 642:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <seconds+0x1>
 646:	01 96       	adiw	r24, 0x01	; 1
 648:	90 93 7d 03 	sts	0x037D, r25	; 0x80037d <seconds+0x1>
 64c:	80 93 7c 03 	sts	0x037C, r24	; 0x80037c <seconds>
 650:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <seconds>
			printf("\nSeconds = %u", seconds);
 654:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <seconds+0x1>
 658:	9f 93       	push	r25
 65a:	8f 93       	push	r24
 65c:	ff 92       	push	r15
 65e:	ef 92       	push	r14
 660:	d3 d1       	rcall	.+934    	; 0xa08 <printf>
 662:	c4 e9       	ldi	r28, 0x94	; 148
 664:	d4 e0       	ldi	r29, 0x04	; 4
 666:	0f 90       	pop	r0
 668:	0f 90       	pop	r0
 66a:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
 			for (uint8_t i = 0; i<= 71; i++)
 			{
 				USART0_TransmitByte(messageWant[i]);
 66c:	0f 90       	pop	r0
 66e:	89 91       	ld	r24, Y+
 670:	f7 d0       	rcall	.+494    	; 0x860 <USART0_TransmitByte>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
 			for (uint8_t i = 0; i<= 71; i++)
 672:	c8 15       	cp	r28, r8
 674:	d9 05       	cpc	r29, r9
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
 676:	d9 f7       	brne	.-10     	; 0x66e <main+0xf0>
 678:	e9 de       	rcall	.-558    	; 0x44c <start_gas_sensor_read>
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
 67a:	f8 01       	movw	r30, r16
 67c:	81 81       	ldd	r24, Z+1	; 0x01
 67e:	8f 93       	push	r24
 680:	80 81       	ld	r24, Z
 682:	8f 93       	push	r24
 684:	bf 92       	push	r11
 686:	af 92       	push	r10
 688:	bf d1       	rcall	.+894    	; 0xa08 <printf>
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
 68a:	f8 01       	movw	r30, r16
 68c:	83 81       	ldd	r24, Z+3	; 0x03
 68e:	8f 93       	push	r24
 690:	82 81       	ldd	r24, Z+2	; 0x02
 692:	8f 93       	push	r24
 694:	df 92       	push	r13
 696:	cf 92       	push	r12
 698:	b7 d1       	rcall	.+878    	; 0xa08 <printf>
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
 69a:	f8 01       	movw	r30, r16
 69c:	85 81       	ldd	r24, Z+5	; 0x05
 69e:	8f 93       	push	r24
 6a0:	84 81       	ldd	r24, Z+4	; 0x04
 6a2:	8f 93       	push	r24
 6a4:	7f 92       	push	r7
 6a6:	6f 92       	push	r6
 6a8:	af d1       	rcall	.+862    	; 0xa08 <printf>
 			printf("\nMethane = %u", raw_gas_vector[3]);
 6aa:	f8 01       	movw	r30, r16
 6ac:	87 81       	ldd	r24, Z+7	; 0x07
 6ae:	8f 93       	push	r24
 6b0:	86 81       	ldd	r24, Z+6	; 0x06
 6b2:	8f 93       	push	r24
 6b4:	5f 92       	push	r5
 6b6:	4f 92       	push	r4
 6b8:	a7 d1       	rcall	.+846    	; 0xa08 <printf>
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
 6ba:	f8 01       	movw	r30, r16
 6bc:	81 85       	ldd	r24, Z+9	; 0x09
 6be:	8f 93       	push	r24
 6c0:	80 85       	ldd	r24, Z+8	; 0x08
 6c2:	8f 93       	push	r24
 6c4:	3f 92       	push	r3
 6c6:	2f 92       	push	r2
 6c8:	9f d1       	rcall	.+830    	; 0xa08 <printf>
 6ca:	8d b7       	in	r24, 0x3d	; 61
 6cc:	9e b7       	in	r25, 0x3e	; 62
 6ce:	44 96       	adiw	r24, 0x14	; 20
 6d0:	0f b6       	in	r0, 0x3f	; 63
 6d2:	f8 94       	cli
 6d4:	9e bf       	out	0x3e, r25	; 62
 6d6:	0f be       	out	0x3f, r0	; 63
 6d8:	8d bf       	out	0x3d, r24	; 61
 6da:	ab cf       	rjmp	.-170    	; 0x632 <main+0xb4>

000006dc <__vector_default>:
 6dc:	1f 92       	push	r1
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
 6de:	0f 92       	push	r0
 6e0:	0f b6       	in	r0, 0x3f	; 63
 6e2:	0f 92       	push	r0
 6e4:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
 6e6:	2a 9a       	sbi	0x05, 2	; 5
 6e8:	0f 90       	pop	r0
 6ea:	0f be       	out	0x3f, r0	; 63
 6ec:	0f 90       	pop	r0
 6ee:	1f 90       	pop	r1
 6f0:	18 95       	reti

000006f2 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
 6f2:	8d e0       	ldi	r24, 0x0D	; 13
 6f4:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
 6f8:	8a e4       	ldi	r24, 0x4A	; 74
 6fa:	9c e4       	ldi	r25, 0x4C	; 76
 6fc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 700:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 704:	08 95       	ret

00000706 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
 706:	18 95       	reti

00000708 <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
 708:	1f 92       	push	r1
 70a:	0f 92       	push	r0
 70c:	0f b6       	in	r0, 0x3f	; 63
 70e:	0f 92       	push	r0
 710:	11 24       	eor	r1, r1
 712:	8f 93       	push	r24
 714:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
 716:	95 b1       	in	r25, 0x05	; 5
 718:	82 e0       	ldi	r24, 0x02	; 2
 71a:	89 27       	eor	r24, r25
 71c:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
 71e:	81 e0       	ldi	r24, 0x01	; 1
 720:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <ItsTime>
}
 724:	9f 91       	pop	r25
 726:	8f 91       	pop	r24
 728:	0f 90       	pop	r0
 72a:	0f be       	out	0x3f, r0	; 63
 72c:	0f 90       	pop	r0
 72e:	1f 90       	pop	r1
 730:	18 95       	reti

00000732 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 732:	1f 92       	push	r1
 734:	0f 92       	push	r0
 736:	0f b6       	in	r0, 0x3f	; 63
 738:	0f 92       	push	r0
 73a:	11 24       	eor	r1, r1
 73c:	0b b6       	in	r0, 0x3b	; 59
 73e:	0f 92       	push	r0
 740:	2f 93       	push	r18
 742:	3f 93       	push	r19
 744:	8f 93       	push	r24
 746:	9f 93       	push	r25
 748:	af 93       	push	r26
 74a:	bf 93       	push	r27
 74c:	ef 93       	push	r30
 74e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 750:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 754:	8e 2f       	mov	r24, r30
 756:	90 e0       	ldi	r25, 0x00	; 0
 758:	fc 01       	movw	r30, r24
 75a:	38 97       	sbiw	r30, 0x08	; 8
 75c:	e1 35       	cpi	r30, 0x51	; 81
 75e:	f1 05       	cpc	r31, r1
 760:	08 f0       	brcs	.+2      	; 0x764 <__vector_26+0x32>
 762:	55 c0       	rjmp	.+170    	; 0x80e <__vector_26+0xdc>
 764:	ea 5b       	subi	r30, 0xBA	; 186
 766:	ff 4f       	sbci	r31, 0xFF	; 255
 768:	46 c1       	rjmp	.+652    	; 0x9f6 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 76a:	10 92 98 01 	sts	0x0198, r1	; 0x800198 <TWI_bufPtr.1674>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 76e:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <TWI_bufPtr.1674>
 772:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <TWI_msgSize>
 776:	e8 17       	cp	r30, r24
 778:	70 f4       	brcc	.+28     	; 0x796 <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 77a:	81 e0       	ldi	r24, 0x01	; 1
 77c:	8e 0f       	add	r24, r30
 77e:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <TWI_bufPtr.1674>
 782:	f0 e0       	ldi	r31, 0x00	; 0
 784:	e5 56       	subi	r30, 0x65	; 101
 786:	fe 4f       	sbci	r31, 0xFE	; 254
 788:	80 81       	ld	r24, Z
 78a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 78e:	85 e8       	ldi	r24, 0x85	; 133
 790:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 794:	43 c0       	rjmp	.+134    	; 0x81c <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 796:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <TWI_statusReg>
 79a:	81 60       	ori	r24, 0x01	; 1
 79c:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7a0:	84 e9       	ldi	r24, 0x94	; 148
 7a2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 7a6:	3a c0       	rjmp	.+116    	; 0x81c <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 7a8:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <TWI_bufPtr.1674>
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	8e 0f       	add	r24, r30
 7b0:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <TWI_bufPtr.1674>
 7b4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 7b8:	f0 e0       	ldi	r31, 0x00	; 0
 7ba:	e5 56       	subi	r30, 0x65	; 101
 7bc:	fe 4f       	sbci	r31, 0xFE	; 254
 7be:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 7c0:	20 91 98 01 	lds	r18, 0x0198	; 0x800198 <TWI_bufPtr.1674>
 7c4:	30 e0       	ldi	r19, 0x00	; 0
 7c6:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <TWI_msgSize>
 7ca:	90 e0       	ldi	r25, 0x00	; 0
 7cc:	01 97       	sbiw	r24, 0x01	; 1
 7ce:	28 17       	cp	r18, r24
 7d0:	39 07       	cpc	r19, r25
 7d2:	24 f4       	brge	.+8      	; 0x7dc <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7d4:	85 ec       	ldi	r24, 0xC5	; 197
 7d6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 7da:	20 c0       	rjmp	.+64     	; 0x81c <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7dc:	85 e8       	ldi	r24, 0x85	; 133
 7de:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 7e2:	1c c0       	rjmp	.+56     	; 0x81c <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 7e4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 7e8:	e0 91 98 01 	lds	r30, 0x0198	; 0x800198 <TWI_bufPtr.1674>
 7ec:	f0 e0       	ldi	r31, 0x00	; 0
 7ee:	e5 56       	subi	r30, 0x65	; 101
 7f0:	fe 4f       	sbci	r31, 0xFE	; 254
 7f2:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 7f4:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <TWI_statusReg>
 7f8:	81 60       	ori	r24, 0x01	; 1
 7fa:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 7fe:	84 e9       	ldi	r24, 0x94	; 148
 800:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 804:	0b c0       	rjmp	.+22     	; 0x81c <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 806:	85 ea       	ldi	r24, 0xA5	; 165
 808:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 80c:	07 c0       	rjmp	.+14     	; 0x81c <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 80e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 812:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 816:	84 e0       	ldi	r24, 0x04	; 4
 818:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 81c:	ff 91       	pop	r31
 81e:	ef 91       	pop	r30
 820:	bf 91       	pop	r27
 822:	af 91       	pop	r26
 824:	9f 91       	pop	r25
 826:	8f 91       	pop	r24
 828:	3f 91       	pop	r19
 82a:	2f 91       	pop	r18
 82c:	0f 90       	pop	r0
 82e:	0b be       	out	0x3b, r0	; 59
 830:	0f 90       	pop	r0
 832:	0f be       	out	0x3f, r0	; 63
 834:	0f 90       	pop	r0
 836:	1f 90       	pop	r1
 838:	18 95       	reti

0000083a <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
 83a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 83e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 842:	88 e0       	ldi	r24, 0x08	; 8
 844:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 848:	86 e0       	ldi	r24, 0x06	; 6
 84a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 84e:	10 92 ad 02 	sts	0x02AD, r1	; 0x8002ad <UART0_RxTail>
 852:	10 92 ae 02 	sts	0x02AE, r1	; 0x8002ae <UART0_RxHead>
 856:	10 92 ab 01 	sts	0x01AB, r1	; 0x8001ab <UART0_TxTail>
 85a:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <UART0_TxHead>
 85e:	08 95       	ret

00000860 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
 860:	20 91 ac 01 	lds	r18, 0x01AC	; 0x8001ac <UART0_TxHead>
 864:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
 866:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <UART0_TxTail>
 86a:	29 17       	cp	r18, r25
 86c:	e1 f3       	breq	.-8      	; 0x866 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
 86e:	e2 2f       	mov	r30, r18
 870:	f0 e0       	ldi	r31, 0x00	; 0
 872:	e3 55       	subi	r30, 0x53	; 83
 874:	fe 4f       	sbci	r31, 0xFE	; 254
 876:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
 878:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
 87c:	e1 ec       	ldi	r30, 0xC1	; 193
 87e:	f0 e0       	ldi	r31, 0x00	; 0
 880:	80 81       	ld	r24, Z
 882:	80 62       	ori	r24, 0x20	; 32
 884:	80 83       	st	Z, r24
 886:	08 95       	ret

00000888 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
 888:	20 91 ac 01 	lds	r18, 0x01AC	; 0x8001ac <UART0_TxHead>
 88c:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
 88e:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <UART0_TxTail>
 892:	29 17       	cp	r18, r25
 894:	e1 f3       	breq	.-8      	; 0x88e <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
 896:	e2 2f       	mov	r30, r18
 898:	f0 e0       	ldi	r31, 0x00	; 0
 89a:	e3 55       	subi	r30, 0x53	; 83
 89c:	fe 4f       	sbci	r31, 0xFE	; 254
 89e:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
 8a0:	20 93 ac 01 	sts	0x01AC, r18	; 0x8001ac <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
 8a4:	e1 ec       	ldi	r30, 0xC1	; 193
 8a6:	f0 e0       	ldi	r31, 0x00	; 0
 8a8:	80 81       	ld	r24, Z
 8aa:	80 62       	ori	r24, 0x20	; 32
 8ac:	80 83       	st	Z, r24
	return(0);
}
 8ae:	80 e0       	ldi	r24, 0x00	; 0
 8b0:	90 e0       	ldi	r25, 0x00	; 0
 8b2:	08 95       	ret

000008b4 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
 8b4:	cf 93       	push	r28
 8b6:	df 93       	push	r29
 8b8:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
 8ba:	88 81       	ld	r24, Y
 8bc:	88 23       	and	r24, r24
 8be:	29 f0       	breq	.+10     	; 0x8ca <USART0_putstring+0x16>
 8c0:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
 8c2:	ce df       	rcall	.-100    	; 0x860 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
 8c4:	89 91       	ld	r24, Y+
 8c6:	81 11       	cpse	r24, r1
 8c8:	fc cf       	rjmp	.-8      	; 0x8c2 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
 8ca:	df 91       	pop	r29
 8cc:	cf 91       	pop	r28
 8ce:	08 95       	ret

000008d0 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
 8d0:	1f 92       	push	r1
 8d2:	0f 92       	push	r0
 8d4:	0f b6       	in	r0, 0x3f	; 63
 8d6:	0f 92       	push	r0
 8d8:	11 24       	eor	r1, r1
 8da:	0b b6       	in	r0, 0x3b	; 59
 8dc:	0f 92       	push	r0
 8de:	8f 93       	push	r24
 8e0:	9f 93       	push	r25
 8e2:	ef 93       	push	r30
 8e4:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
 8e6:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <UART0_TxHead>
 8ea:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <UART0_TxTail>
 8ee:	98 17       	cp	r25, r24
 8f0:	61 f0       	breq	.+24     	; 0x90a <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
 8f2:	e0 91 ab 01 	lds	r30, 0x01AB	; 0x8001ab <UART0_TxTail>
 8f6:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
 8f8:	e0 93 ab 01 	sts	0x01AB, r30	; 0x8001ab <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
 8fc:	f0 e0       	ldi	r31, 0x00	; 0
 8fe:	e3 55       	subi	r30, 0x53	; 83
 900:	fe 4f       	sbci	r31, 0xFE	; 254
 902:	80 81       	ld	r24, Z
 904:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 908:	05 c0       	rjmp	.+10     	; 0x914 <__vector_21+0x44>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
 90a:	e1 ec       	ldi	r30, 0xC1	; 193
 90c:	f0 e0       	ldi	r31, 0x00	; 0
 90e:	80 81       	ld	r24, Z
 910:	8f 7d       	andi	r24, 0xDF	; 223
 912:	80 83       	st	Z, r24
	}
 914:	ff 91       	pop	r31
 916:	ef 91       	pop	r30
 918:	9f 91       	pop	r25
 91a:	8f 91       	pop	r24
 91c:	0f 90       	pop	r0
 91e:	0b be       	out	0x3b, r0	; 59
 920:	0f 90       	pop	r0
 922:	0f be       	out	0x3f, r0	; 63
 924:	0f 90       	pop	r0
 926:	1f 90       	pop	r1
 928:	18 95       	reti

0000092a <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
 92a:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
 92e:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
 932:	80 e9       	ldi	r24, 0x90	; 144
 934:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
 938:	86 e0       	ldi	r24, 0x06	; 6
 93a:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
 93e:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <UART1_RxTail>
 942:	10 92 b2 02 	sts	0x02B2, r1	; 0x8002b2 <UART1_RxHead>
 946:	10 92 af 02 	sts	0x02AF, r1	; 0x8002af <UART1_TxTail>
 94a:	10 92 b0 02 	sts	0x02B0, r1	; 0x8002b0 <UART1_TxHead>
 94e:	08 95       	ret

00000950 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
 950:	1f 92       	push	r1
 952:	0f 92       	push	r0
 954:	0f b6       	in	r0, 0x3f	; 63
 956:	0f 92       	push	r0
 958:	11 24       	eor	r1, r1
 95a:	0b b6       	in	r0, 0x3b	; 59
 95c:	0f 92       	push	r0
 95e:	2f 93       	push	r18
 960:	3f 93       	push	r19
 962:	8f 93       	push	r24
 964:	9f 93       	push	r25
 966:	af 93       	push	r26
 968:	bf 93       	push	r27
 96a:	cf 93       	push	r28
 96c:	df 93       	push	r29
 96e:	ef 93       	push	r30
 970:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
 972:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
 976:	80 91 b2 02 	lds	r24, 0x02B2	; 0x8002b2 <UART1_RxHead>
 97a:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
 97c:	80 93 b2 02 	sts	0x02B2, r24	; 0x8002b2 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
 980:	20 91 b1 02 	lds	r18, 0x02B1	; 0x8002b1 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
 984:	e8 2f       	mov	r30, r24
 986:	f0 e0       	ldi	r31, 0x00	; 0
 988:	ec 56       	subi	r30, 0x6C	; 108
 98a:	fc 4f       	sbci	r31, 0xFC	; 252
 98c:	90 83       	st	Z, r25
	
	if (data == 10)
 98e:	9a 30       	cpi	r25, 0x0A	; 10
 990:	09 f5       	brne	.+66     	; 0x9d4 <__vector_28+0x84>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
 992:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <UART1_RxBuf+0x5>
 996:	97 34       	cpi	r25, 0x47	; 71
 998:	c9 f4       	brne	.+50     	; 0x9cc <__vector_28+0x7c>
 99a:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
 99c:	2e 2f       	mov	r18, r30
 99e:	30 e0       	ldi	r19, 0x00	; 0
 9a0:	d9 01       	movw	r26, r18
 9a2:	ac 56       	subi	r26, 0x6C	; 108
 9a4:	bb 4f       	sbci	r27, 0xFB	; 251
 9a6:	e9 01       	movw	r28, r18
 9a8:	cc 56       	subi	r28, 0x6C	; 108
 9aa:	dc 4f       	sbci	r29, 0xFC	; 252
 9ac:	98 81       	ld	r25, Y
 9ae:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
 9b0:	ef 5f       	subi	r30, 0xFF	; 255
 9b2:	8e 17       	cp	r24, r30
 9b4:	98 f7       	brcc	.-26     	; 0x99c <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
 9b6:	f0 e0       	ldi	r31, 0x00	; 0
 9b8:	ec 56       	subi	r30, 0x6C	; 108
 9ba:	fb 4f       	sbci	r31, 0xFB	; 251
 9bc:	11 82       	std	Z+1, r1	; 0x01
// 			UCSR1B &= !(1<<RXCIE1);  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
 			ItsTime = 1;
 9be:	81 e0       	ldi	r24, 0x01	; 1
 9c0:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <ItsTime>
 			ToggleBit(PORTB, PORTB1);
 9c4:	95 b1       	in	r25, 0x05	; 5
 9c6:	82 e0       	ldi	r24, 0x02	; 2
 9c8:	89 27       	eor	r24, r25
 9ca:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
 9cc:	10 92 b1 02 	sts	0x02B1, r1	; 0x8002b1 <UART1_RxTail>
		UART1_RxHead = 0;
 9d0:	10 92 b2 02 	sts	0x02B2, r1	; 0x8002b2 <UART1_RxHead>
	}
}
 9d4:	ff 91       	pop	r31
 9d6:	ef 91       	pop	r30
 9d8:	df 91       	pop	r29
 9da:	cf 91       	pop	r28
 9dc:	bf 91       	pop	r27
 9de:	af 91       	pop	r26
 9e0:	9f 91       	pop	r25
 9e2:	8f 91       	pop	r24
 9e4:	3f 91       	pop	r19
 9e6:	2f 91       	pop	r18
 9e8:	0f 90       	pop	r0
 9ea:	0b be       	out	0x3b, r0	; 59
 9ec:	0f 90       	pop	r0
 9ee:	0f be       	out	0x3f, r0	; 63
 9f0:	0f 90       	pop	r0
 9f2:	1f 90       	pop	r1
 9f4:	18 95       	reti

000009f6 <__tablejump2__>:
 9f6:	ee 0f       	add	r30, r30
 9f8:	ff 1f       	adc	r31, r31
 9fa:	00 24       	eor	r0, r0
 9fc:	00 1c       	adc	r0, r0
 9fe:	0b be       	out	0x3b, r0	; 59
 a00:	07 90       	elpm	r0, Z+
 a02:	f6 91       	elpm	r31, Z
 a04:	e0 2d       	mov	r30, r0
 a06:	09 94       	ijmp

00000a08 <printf>:
 a08:	cf 93       	push	r28
 a0a:	df 93       	push	r29
 a0c:	cd b7       	in	r28, 0x3d	; 61
 a0e:	de b7       	in	r29, 0x3e	; 62
 a10:	ae 01       	movw	r20, r28
 a12:	4b 5f       	subi	r20, 0xFB	; 251
 a14:	5f 4f       	sbci	r21, 0xFF	; 255
 a16:	fa 01       	movw	r30, r20
 a18:	61 91       	ld	r22, Z+
 a1a:	71 91       	ld	r23, Z+
 a1c:	af 01       	movw	r20, r30
 a1e:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <__iob+0x2>
 a22:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <__iob+0x3>
 a26:	03 d0       	rcall	.+6      	; 0xa2e <vfprintf>
 a28:	df 91       	pop	r29
 a2a:	cf 91       	pop	r28
 a2c:	08 95       	ret

00000a2e <vfprintf>:
 a2e:	2f 92       	push	r2
 a30:	3f 92       	push	r3
 a32:	4f 92       	push	r4
 a34:	5f 92       	push	r5
 a36:	6f 92       	push	r6
 a38:	7f 92       	push	r7
 a3a:	8f 92       	push	r8
 a3c:	9f 92       	push	r9
 a3e:	af 92       	push	r10
 a40:	bf 92       	push	r11
 a42:	cf 92       	push	r12
 a44:	df 92       	push	r13
 a46:	ef 92       	push	r14
 a48:	ff 92       	push	r15
 a4a:	0f 93       	push	r16
 a4c:	1f 93       	push	r17
 a4e:	cf 93       	push	r28
 a50:	df 93       	push	r29
 a52:	cd b7       	in	r28, 0x3d	; 61
 a54:	de b7       	in	r29, 0x3e	; 62
 a56:	2b 97       	sbiw	r28, 0x0b	; 11
 a58:	0f b6       	in	r0, 0x3f	; 63
 a5a:	f8 94       	cli
 a5c:	de bf       	out	0x3e, r29	; 62
 a5e:	0f be       	out	0x3f, r0	; 63
 a60:	cd bf       	out	0x3d, r28	; 61
 a62:	6c 01       	movw	r12, r24
 a64:	7b 01       	movw	r14, r22
 a66:	8a 01       	movw	r16, r20
 a68:	fc 01       	movw	r30, r24
 a6a:	17 82       	std	Z+7, r1	; 0x07
 a6c:	16 82       	std	Z+6, r1	; 0x06
 a6e:	83 81       	ldd	r24, Z+3	; 0x03
 a70:	81 ff       	sbrs	r24, 1
 a72:	bf c1       	rjmp	.+894    	; 0xdf2 <vfprintf+0x3c4>
 a74:	ce 01       	movw	r24, r28
 a76:	01 96       	adiw	r24, 0x01	; 1
 a78:	3c 01       	movw	r6, r24
 a7a:	f6 01       	movw	r30, r12
 a7c:	93 81       	ldd	r25, Z+3	; 0x03
 a7e:	f7 01       	movw	r30, r14
 a80:	93 fd       	sbrc	r25, 3
 a82:	85 91       	lpm	r24, Z+
 a84:	93 ff       	sbrs	r25, 3
 a86:	81 91       	ld	r24, Z+
 a88:	7f 01       	movw	r14, r30
 a8a:	88 23       	and	r24, r24
 a8c:	09 f4       	brne	.+2      	; 0xa90 <vfprintf+0x62>
 a8e:	ad c1       	rjmp	.+858    	; 0xdea <vfprintf+0x3bc>
 a90:	85 32       	cpi	r24, 0x25	; 37
 a92:	39 f4       	brne	.+14     	; 0xaa2 <vfprintf+0x74>
 a94:	93 fd       	sbrc	r25, 3
 a96:	85 91       	lpm	r24, Z+
 a98:	93 ff       	sbrs	r25, 3
 a9a:	81 91       	ld	r24, Z+
 a9c:	7f 01       	movw	r14, r30
 a9e:	85 32       	cpi	r24, 0x25	; 37
 aa0:	21 f4       	brne	.+8      	; 0xaaa <vfprintf+0x7c>
 aa2:	b6 01       	movw	r22, r12
 aa4:	90 e0       	ldi	r25, 0x00	; 0
 aa6:	d6 d1       	rcall	.+940    	; 0xe54 <fputc>
 aa8:	e8 cf       	rjmp	.-48     	; 0xa7a <vfprintf+0x4c>
 aaa:	91 2c       	mov	r9, r1
 aac:	21 2c       	mov	r2, r1
 aae:	31 2c       	mov	r3, r1
 ab0:	ff e1       	ldi	r31, 0x1F	; 31
 ab2:	f3 15       	cp	r31, r3
 ab4:	d8 f0       	brcs	.+54     	; 0xaec <vfprintf+0xbe>
 ab6:	8b 32       	cpi	r24, 0x2B	; 43
 ab8:	79 f0       	breq	.+30     	; 0xad8 <vfprintf+0xaa>
 aba:	38 f4       	brcc	.+14     	; 0xaca <vfprintf+0x9c>
 abc:	80 32       	cpi	r24, 0x20	; 32
 abe:	79 f0       	breq	.+30     	; 0xade <vfprintf+0xb0>
 ac0:	83 32       	cpi	r24, 0x23	; 35
 ac2:	a1 f4       	brne	.+40     	; 0xaec <vfprintf+0xbe>
 ac4:	23 2d       	mov	r18, r3
 ac6:	20 61       	ori	r18, 0x10	; 16
 ac8:	1d c0       	rjmp	.+58     	; 0xb04 <vfprintf+0xd6>
 aca:	8d 32       	cpi	r24, 0x2D	; 45
 acc:	61 f0       	breq	.+24     	; 0xae6 <vfprintf+0xb8>
 ace:	80 33       	cpi	r24, 0x30	; 48
 ad0:	69 f4       	brne	.+26     	; 0xaec <vfprintf+0xbe>
 ad2:	23 2d       	mov	r18, r3
 ad4:	21 60       	ori	r18, 0x01	; 1
 ad6:	16 c0       	rjmp	.+44     	; 0xb04 <vfprintf+0xd6>
 ad8:	83 2d       	mov	r24, r3
 ada:	82 60       	ori	r24, 0x02	; 2
 adc:	38 2e       	mov	r3, r24
 ade:	e3 2d       	mov	r30, r3
 ae0:	e4 60       	ori	r30, 0x04	; 4
 ae2:	3e 2e       	mov	r3, r30
 ae4:	2a c0       	rjmp	.+84     	; 0xb3a <vfprintf+0x10c>
 ae6:	f3 2d       	mov	r31, r3
 ae8:	f8 60       	ori	r31, 0x08	; 8
 aea:	1d c0       	rjmp	.+58     	; 0xb26 <vfprintf+0xf8>
 aec:	37 fc       	sbrc	r3, 7
 aee:	2d c0       	rjmp	.+90     	; 0xb4a <vfprintf+0x11c>
 af0:	20 ed       	ldi	r18, 0xD0	; 208
 af2:	28 0f       	add	r18, r24
 af4:	2a 30       	cpi	r18, 0x0A	; 10
 af6:	40 f0       	brcs	.+16     	; 0xb08 <vfprintf+0xda>
 af8:	8e 32       	cpi	r24, 0x2E	; 46
 afa:	b9 f4       	brne	.+46     	; 0xb2a <vfprintf+0xfc>
 afc:	36 fc       	sbrc	r3, 6
 afe:	75 c1       	rjmp	.+746    	; 0xdea <vfprintf+0x3bc>
 b00:	23 2d       	mov	r18, r3
 b02:	20 64       	ori	r18, 0x40	; 64
 b04:	32 2e       	mov	r3, r18
 b06:	19 c0       	rjmp	.+50     	; 0xb3a <vfprintf+0x10c>
 b08:	36 fe       	sbrs	r3, 6
 b0a:	06 c0       	rjmp	.+12     	; 0xb18 <vfprintf+0xea>
 b0c:	8a e0       	ldi	r24, 0x0A	; 10
 b0e:	98 9e       	mul	r9, r24
 b10:	20 0d       	add	r18, r0
 b12:	11 24       	eor	r1, r1
 b14:	92 2e       	mov	r9, r18
 b16:	11 c0       	rjmp	.+34     	; 0xb3a <vfprintf+0x10c>
 b18:	ea e0       	ldi	r30, 0x0A	; 10
 b1a:	2e 9e       	mul	r2, r30
 b1c:	20 0d       	add	r18, r0
 b1e:	11 24       	eor	r1, r1
 b20:	22 2e       	mov	r2, r18
 b22:	f3 2d       	mov	r31, r3
 b24:	f0 62       	ori	r31, 0x20	; 32
 b26:	3f 2e       	mov	r3, r31
 b28:	08 c0       	rjmp	.+16     	; 0xb3a <vfprintf+0x10c>
 b2a:	8c 36       	cpi	r24, 0x6C	; 108
 b2c:	21 f4       	brne	.+8      	; 0xb36 <vfprintf+0x108>
 b2e:	83 2d       	mov	r24, r3
 b30:	80 68       	ori	r24, 0x80	; 128
 b32:	38 2e       	mov	r3, r24
 b34:	02 c0       	rjmp	.+4      	; 0xb3a <vfprintf+0x10c>
 b36:	88 36       	cpi	r24, 0x68	; 104
 b38:	41 f4       	brne	.+16     	; 0xb4a <vfprintf+0x11c>
 b3a:	f7 01       	movw	r30, r14
 b3c:	93 fd       	sbrc	r25, 3
 b3e:	85 91       	lpm	r24, Z+
 b40:	93 ff       	sbrs	r25, 3
 b42:	81 91       	ld	r24, Z+
 b44:	7f 01       	movw	r14, r30
 b46:	81 11       	cpse	r24, r1
 b48:	b3 cf       	rjmp	.-154    	; 0xab0 <vfprintf+0x82>
 b4a:	98 2f       	mov	r25, r24
 b4c:	9f 7d       	andi	r25, 0xDF	; 223
 b4e:	95 54       	subi	r25, 0x45	; 69
 b50:	93 30       	cpi	r25, 0x03	; 3
 b52:	28 f4       	brcc	.+10     	; 0xb5e <vfprintf+0x130>
 b54:	0c 5f       	subi	r16, 0xFC	; 252
 b56:	1f 4f       	sbci	r17, 0xFF	; 255
 b58:	9f e3       	ldi	r25, 0x3F	; 63
 b5a:	99 83       	std	Y+1, r25	; 0x01
 b5c:	0d c0       	rjmp	.+26     	; 0xb78 <vfprintf+0x14a>
 b5e:	83 36       	cpi	r24, 0x63	; 99
 b60:	31 f0       	breq	.+12     	; 0xb6e <vfprintf+0x140>
 b62:	83 37       	cpi	r24, 0x73	; 115
 b64:	71 f0       	breq	.+28     	; 0xb82 <vfprintf+0x154>
 b66:	83 35       	cpi	r24, 0x53	; 83
 b68:	09 f0       	breq	.+2      	; 0xb6c <vfprintf+0x13e>
 b6a:	55 c0       	rjmp	.+170    	; 0xc16 <vfprintf+0x1e8>
 b6c:	20 c0       	rjmp	.+64     	; 0xbae <vfprintf+0x180>
 b6e:	f8 01       	movw	r30, r16
 b70:	80 81       	ld	r24, Z
 b72:	89 83       	std	Y+1, r24	; 0x01
 b74:	0e 5f       	subi	r16, 0xFE	; 254
 b76:	1f 4f       	sbci	r17, 0xFF	; 255
 b78:	88 24       	eor	r8, r8
 b7a:	83 94       	inc	r8
 b7c:	91 2c       	mov	r9, r1
 b7e:	53 01       	movw	r10, r6
 b80:	12 c0       	rjmp	.+36     	; 0xba6 <vfprintf+0x178>
 b82:	28 01       	movw	r4, r16
 b84:	f2 e0       	ldi	r31, 0x02	; 2
 b86:	4f 0e       	add	r4, r31
 b88:	51 1c       	adc	r5, r1
 b8a:	f8 01       	movw	r30, r16
 b8c:	a0 80       	ld	r10, Z
 b8e:	b1 80       	ldd	r11, Z+1	; 0x01
 b90:	36 fe       	sbrs	r3, 6
 b92:	03 c0       	rjmp	.+6      	; 0xb9a <vfprintf+0x16c>
 b94:	69 2d       	mov	r22, r9
 b96:	70 e0       	ldi	r23, 0x00	; 0
 b98:	02 c0       	rjmp	.+4      	; 0xb9e <vfprintf+0x170>
 b9a:	6f ef       	ldi	r22, 0xFF	; 255
 b9c:	7f ef       	ldi	r23, 0xFF	; 255
 b9e:	c5 01       	movw	r24, r10
 ba0:	4e d1       	rcall	.+668    	; 0xe3e <strnlen>
 ba2:	4c 01       	movw	r8, r24
 ba4:	82 01       	movw	r16, r4
 ba6:	f3 2d       	mov	r31, r3
 ba8:	ff 77       	andi	r31, 0x7F	; 127
 baa:	3f 2e       	mov	r3, r31
 bac:	15 c0       	rjmp	.+42     	; 0xbd8 <vfprintf+0x1aa>
 bae:	28 01       	movw	r4, r16
 bb0:	22 e0       	ldi	r18, 0x02	; 2
 bb2:	42 0e       	add	r4, r18
 bb4:	51 1c       	adc	r5, r1
 bb6:	f8 01       	movw	r30, r16
 bb8:	a0 80       	ld	r10, Z
 bba:	b1 80       	ldd	r11, Z+1	; 0x01
 bbc:	36 fe       	sbrs	r3, 6
 bbe:	03 c0       	rjmp	.+6      	; 0xbc6 <vfprintf+0x198>
 bc0:	69 2d       	mov	r22, r9
 bc2:	70 e0       	ldi	r23, 0x00	; 0
 bc4:	02 c0       	rjmp	.+4      	; 0xbca <vfprintf+0x19c>
 bc6:	6f ef       	ldi	r22, 0xFF	; 255
 bc8:	7f ef       	ldi	r23, 0xFF	; 255
 bca:	c5 01       	movw	r24, r10
 bcc:	2d d1       	rcall	.+602    	; 0xe28 <strnlen_P>
 bce:	4c 01       	movw	r8, r24
 bd0:	f3 2d       	mov	r31, r3
 bd2:	f0 68       	ori	r31, 0x80	; 128
 bd4:	3f 2e       	mov	r3, r31
 bd6:	82 01       	movw	r16, r4
 bd8:	33 fc       	sbrc	r3, 3
 bda:	19 c0       	rjmp	.+50     	; 0xc0e <vfprintf+0x1e0>
 bdc:	82 2d       	mov	r24, r2
 bde:	90 e0       	ldi	r25, 0x00	; 0
 be0:	88 16       	cp	r8, r24
 be2:	99 06       	cpc	r9, r25
 be4:	a0 f4       	brcc	.+40     	; 0xc0e <vfprintf+0x1e0>
 be6:	b6 01       	movw	r22, r12
 be8:	80 e2       	ldi	r24, 0x20	; 32
 bea:	90 e0       	ldi	r25, 0x00	; 0
 bec:	33 d1       	rcall	.+614    	; 0xe54 <fputc>
 bee:	2a 94       	dec	r2
 bf0:	f5 cf       	rjmp	.-22     	; 0xbdc <vfprintf+0x1ae>
 bf2:	f5 01       	movw	r30, r10
 bf4:	37 fc       	sbrc	r3, 7
 bf6:	85 91       	lpm	r24, Z+
 bf8:	37 fe       	sbrs	r3, 7
 bfa:	81 91       	ld	r24, Z+
 bfc:	5f 01       	movw	r10, r30
 bfe:	b6 01       	movw	r22, r12
 c00:	90 e0       	ldi	r25, 0x00	; 0
 c02:	28 d1       	rcall	.+592    	; 0xe54 <fputc>
 c04:	21 10       	cpse	r2, r1
 c06:	2a 94       	dec	r2
 c08:	21 e0       	ldi	r18, 0x01	; 1
 c0a:	82 1a       	sub	r8, r18
 c0c:	91 08       	sbc	r9, r1
 c0e:	81 14       	cp	r8, r1
 c10:	91 04       	cpc	r9, r1
 c12:	79 f7       	brne	.-34     	; 0xbf2 <vfprintf+0x1c4>
 c14:	e1 c0       	rjmp	.+450    	; 0xdd8 <vfprintf+0x3aa>
 c16:	84 36       	cpi	r24, 0x64	; 100
 c18:	11 f0       	breq	.+4      	; 0xc1e <vfprintf+0x1f0>
 c1a:	89 36       	cpi	r24, 0x69	; 105
 c1c:	39 f5       	brne	.+78     	; 0xc6c <vfprintf+0x23e>
 c1e:	f8 01       	movw	r30, r16
 c20:	37 fe       	sbrs	r3, 7
 c22:	07 c0       	rjmp	.+14     	; 0xc32 <vfprintf+0x204>
 c24:	60 81       	ld	r22, Z
 c26:	71 81       	ldd	r23, Z+1	; 0x01
 c28:	82 81       	ldd	r24, Z+2	; 0x02
 c2a:	93 81       	ldd	r25, Z+3	; 0x03
 c2c:	0c 5f       	subi	r16, 0xFC	; 252
 c2e:	1f 4f       	sbci	r17, 0xFF	; 255
 c30:	08 c0       	rjmp	.+16     	; 0xc42 <vfprintf+0x214>
 c32:	60 81       	ld	r22, Z
 c34:	71 81       	ldd	r23, Z+1	; 0x01
 c36:	07 2e       	mov	r0, r23
 c38:	00 0c       	add	r0, r0
 c3a:	88 0b       	sbc	r24, r24
 c3c:	99 0b       	sbc	r25, r25
 c3e:	0e 5f       	subi	r16, 0xFE	; 254
 c40:	1f 4f       	sbci	r17, 0xFF	; 255
 c42:	f3 2d       	mov	r31, r3
 c44:	ff 76       	andi	r31, 0x6F	; 111
 c46:	3f 2e       	mov	r3, r31
 c48:	97 ff       	sbrs	r25, 7
 c4a:	09 c0       	rjmp	.+18     	; 0xc5e <vfprintf+0x230>
 c4c:	90 95       	com	r25
 c4e:	80 95       	com	r24
 c50:	70 95       	com	r23
 c52:	61 95       	neg	r22
 c54:	7f 4f       	sbci	r23, 0xFF	; 255
 c56:	8f 4f       	sbci	r24, 0xFF	; 255
 c58:	9f 4f       	sbci	r25, 0xFF	; 255
 c5a:	f0 68       	ori	r31, 0x80	; 128
 c5c:	3f 2e       	mov	r3, r31
 c5e:	2a e0       	ldi	r18, 0x0A	; 10
 c60:	30 e0       	ldi	r19, 0x00	; 0
 c62:	a3 01       	movw	r20, r6
 c64:	33 d1       	rcall	.+614    	; 0xecc <__ultoa_invert>
 c66:	88 2e       	mov	r8, r24
 c68:	86 18       	sub	r8, r6
 c6a:	44 c0       	rjmp	.+136    	; 0xcf4 <vfprintf+0x2c6>
 c6c:	85 37       	cpi	r24, 0x75	; 117
 c6e:	31 f4       	brne	.+12     	; 0xc7c <vfprintf+0x24e>
 c70:	23 2d       	mov	r18, r3
 c72:	2f 7e       	andi	r18, 0xEF	; 239
 c74:	b2 2e       	mov	r11, r18
 c76:	2a e0       	ldi	r18, 0x0A	; 10
 c78:	30 e0       	ldi	r19, 0x00	; 0
 c7a:	25 c0       	rjmp	.+74     	; 0xcc6 <vfprintf+0x298>
 c7c:	93 2d       	mov	r25, r3
 c7e:	99 7f       	andi	r25, 0xF9	; 249
 c80:	b9 2e       	mov	r11, r25
 c82:	8f 36       	cpi	r24, 0x6F	; 111
 c84:	c1 f0       	breq	.+48     	; 0xcb6 <vfprintf+0x288>
 c86:	18 f4       	brcc	.+6      	; 0xc8e <vfprintf+0x260>
 c88:	88 35       	cpi	r24, 0x58	; 88
 c8a:	79 f0       	breq	.+30     	; 0xcaa <vfprintf+0x27c>
 c8c:	ae c0       	rjmp	.+348    	; 0xdea <vfprintf+0x3bc>
 c8e:	80 37       	cpi	r24, 0x70	; 112
 c90:	19 f0       	breq	.+6      	; 0xc98 <vfprintf+0x26a>
 c92:	88 37       	cpi	r24, 0x78	; 120
 c94:	21 f0       	breq	.+8      	; 0xc9e <vfprintf+0x270>
 c96:	a9 c0       	rjmp	.+338    	; 0xdea <vfprintf+0x3bc>
 c98:	e9 2f       	mov	r30, r25
 c9a:	e0 61       	ori	r30, 0x10	; 16
 c9c:	be 2e       	mov	r11, r30
 c9e:	b4 fe       	sbrs	r11, 4
 ca0:	0d c0       	rjmp	.+26     	; 0xcbc <vfprintf+0x28e>
 ca2:	fb 2d       	mov	r31, r11
 ca4:	f4 60       	ori	r31, 0x04	; 4
 ca6:	bf 2e       	mov	r11, r31
 ca8:	09 c0       	rjmp	.+18     	; 0xcbc <vfprintf+0x28e>
 caa:	34 fe       	sbrs	r3, 4
 cac:	0a c0       	rjmp	.+20     	; 0xcc2 <vfprintf+0x294>
 cae:	29 2f       	mov	r18, r25
 cb0:	26 60       	ori	r18, 0x06	; 6
 cb2:	b2 2e       	mov	r11, r18
 cb4:	06 c0       	rjmp	.+12     	; 0xcc2 <vfprintf+0x294>
 cb6:	28 e0       	ldi	r18, 0x08	; 8
 cb8:	30 e0       	ldi	r19, 0x00	; 0
 cba:	05 c0       	rjmp	.+10     	; 0xcc6 <vfprintf+0x298>
 cbc:	20 e1       	ldi	r18, 0x10	; 16
 cbe:	30 e0       	ldi	r19, 0x00	; 0
 cc0:	02 c0       	rjmp	.+4      	; 0xcc6 <vfprintf+0x298>
 cc2:	20 e1       	ldi	r18, 0x10	; 16
 cc4:	32 e0       	ldi	r19, 0x02	; 2
 cc6:	f8 01       	movw	r30, r16
 cc8:	b7 fe       	sbrs	r11, 7
 cca:	07 c0       	rjmp	.+14     	; 0xcda <vfprintf+0x2ac>
 ccc:	60 81       	ld	r22, Z
 cce:	71 81       	ldd	r23, Z+1	; 0x01
 cd0:	82 81       	ldd	r24, Z+2	; 0x02
 cd2:	93 81       	ldd	r25, Z+3	; 0x03
 cd4:	0c 5f       	subi	r16, 0xFC	; 252
 cd6:	1f 4f       	sbci	r17, 0xFF	; 255
 cd8:	06 c0       	rjmp	.+12     	; 0xce6 <vfprintf+0x2b8>
 cda:	60 81       	ld	r22, Z
 cdc:	71 81       	ldd	r23, Z+1	; 0x01
 cde:	80 e0       	ldi	r24, 0x00	; 0
 ce0:	90 e0       	ldi	r25, 0x00	; 0
 ce2:	0e 5f       	subi	r16, 0xFE	; 254
 ce4:	1f 4f       	sbci	r17, 0xFF	; 255
 ce6:	a3 01       	movw	r20, r6
 ce8:	f1 d0       	rcall	.+482    	; 0xecc <__ultoa_invert>
 cea:	88 2e       	mov	r8, r24
 cec:	86 18       	sub	r8, r6
 cee:	fb 2d       	mov	r31, r11
 cf0:	ff 77       	andi	r31, 0x7F	; 127
 cf2:	3f 2e       	mov	r3, r31
 cf4:	36 fe       	sbrs	r3, 6
 cf6:	0d c0       	rjmp	.+26     	; 0xd12 <vfprintf+0x2e4>
 cf8:	23 2d       	mov	r18, r3
 cfa:	2e 7f       	andi	r18, 0xFE	; 254
 cfc:	a2 2e       	mov	r10, r18
 cfe:	89 14       	cp	r8, r9
 d00:	58 f4       	brcc	.+22     	; 0xd18 <vfprintf+0x2ea>
 d02:	34 fe       	sbrs	r3, 4
 d04:	0b c0       	rjmp	.+22     	; 0xd1c <vfprintf+0x2ee>
 d06:	32 fc       	sbrc	r3, 2
 d08:	09 c0       	rjmp	.+18     	; 0xd1c <vfprintf+0x2ee>
 d0a:	83 2d       	mov	r24, r3
 d0c:	8e 7e       	andi	r24, 0xEE	; 238
 d0e:	a8 2e       	mov	r10, r24
 d10:	05 c0       	rjmp	.+10     	; 0xd1c <vfprintf+0x2ee>
 d12:	b8 2c       	mov	r11, r8
 d14:	a3 2c       	mov	r10, r3
 d16:	03 c0       	rjmp	.+6      	; 0xd1e <vfprintf+0x2f0>
 d18:	b8 2c       	mov	r11, r8
 d1a:	01 c0       	rjmp	.+2      	; 0xd1e <vfprintf+0x2f0>
 d1c:	b9 2c       	mov	r11, r9
 d1e:	a4 fe       	sbrs	r10, 4
 d20:	0f c0       	rjmp	.+30     	; 0xd40 <vfprintf+0x312>
 d22:	fe 01       	movw	r30, r28
 d24:	e8 0d       	add	r30, r8
 d26:	f1 1d       	adc	r31, r1
 d28:	80 81       	ld	r24, Z
 d2a:	80 33       	cpi	r24, 0x30	; 48
 d2c:	21 f4       	brne	.+8      	; 0xd36 <vfprintf+0x308>
 d2e:	9a 2d       	mov	r25, r10
 d30:	99 7e       	andi	r25, 0xE9	; 233
 d32:	a9 2e       	mov	r10, r25
 d34:	09 c0       	rjmp	.+18     	; 0xd48 <vfprintf+0x31a>
 d36:	a2 fe       	sbrs	r10, 2
 d38:	06 c0       	rjmp	.+12     	; 0xd46 <vfprintf+0x318>
 d3a:	b3 94       	inc	r11
 d3c:	b3 94       	inc	r11
 d3e:	04 c0       	rjmp	.+8      	; 0xd48 <vfprintf+0x31a>
 d40:	8a 2d       	mov	r24, r10
 d42:	86 78       	andi	r24, 0x86	; 134
 d44:	09 f0       	breq	.+2      	; 0xd48 <vfprintf+0x31a>
 d46:	b3 94       	inc	r11
 d48:	a3 fc       	sbrc	r10, 3
 d4a:	10 c0       	rjmp	.+32     	; 0xd6c <vfprintf+0x33e>
 d4c:	a0 fe       	sbrs	r10, 0
 d4e:	06 c0       	rjmp	.+12     	; 0xd5c <vfprintf+0x32e>
 d50:	b2 14       	cp	r11, r2
 d52:	80 f4       	brcc	.+32     	; 0xd74 <vfprintf+0x346>
 d54:	28 0c       	add	r2, r8
 d56:	92 2c       	mov	r9, r2
 d58:	9b 18       	sub	r9, r11
 d5a:	0d c0       	rjmp	.+26     	; 0xd76 <vfprintf+0x348>
 d5c:	b2 14       	cp	r11, r2
 d5e:	58 f4       	brcc	.+22     	; 0xd76 <vfprintf+0x348>
 d60:	b6 01       	movw	r22, r12
 d62:	80 e2       	ldi	r24, 0x20	; 32
 d64:	90 e0       	ldi	r25, 0x00	; 0
 d66:	76 d0       	rcall	.+236    	; 0xe54 <fputc>
 d68:	b3 94       	inc	r11
 d6a:	f8 cf       	rjmp	.-16     	; 0xd5c <vfprintf+0x32e>
 d6c:	b2 14       	cp	r11, r2
 d6e:	18 f4       	brcc	.+6      	; 0xd76 <vfprintf+0x348>
 d70:	2b 18       	sub	r2, r11
 d72:	02 c0       	rjmp	.+4      	; 0xd78 <vfprintf+0x34a>
 d74:	98 2c       	mov	r9, r8
 d76:	21 2c       	mov	r2, r1
 d78:	a4 fe       	sbrs	r10, 4
 d7a:	0f c0       	rjmp	.+30     	; 0xd9a <vfprintf+0x36c>
 d7c:	b6 01       	movw	r22, r12
 d7e:	80 e3       	ldi	r24, 0x30	; 48
 d80:	90 e0       	ldi	r25, 0x00	; 0
 d82:	68 d0       	rcall	.+208    	; 0xe54 <fputc>
 d84:	a2 fe       	sbrs	r10, 2
 d86:	16 c0       	rjmp	.+44     	; 0xdb4 <vfprintf+0x386>
 d88:	a1 fc       	sbrc	r10, 1
 d8a:	03 c0       	rjmp	.+6      	; 0xd92 <vfprintf+0x364>
 d8c:	88 e7       	ldi	r24, 0x78	; 120
 d8e:	90 e0       	ldi	r25, 0x00	; 0
 d90:	02 c0       	rjmp	.+4      	; 0xd96 <vfprintf+0x368>
 d92:	88 e5       	ldi	r24, 0x58	; 88
 d94:	90 e0       	ldi	r25, 0x00	; 0
 d96:	b6 01       	movw	r22, r12
 d98:	0c c0       	rjmp	.+24     	; 0xdb2 <vfprintf+0x384>
 d9a:	8a 2d       	mov	r24, r10
 d9c:	86 78       	andi	r24, 0x86	; 134
 d9e:	51 f0       	breq	.+20     	; 0xdb4 <vfprintf+0x386>
 da0:	a1 fe       	sbrs	r10, 1
 da2:	02 c0       	rjmp	.+4      	; 0xda8 <vfprintf+0x37a>
 da4:	8b e2       	ldi	r24, 0x2B	; 43
 da6:	01 c0       	rjmp	.+2      	; 0xdaa <vfprintf+0x37c>
 da8:	80 e2       	ldi	r24, 0x20	; 32
 daa:	a7 fc       	sbrc	r10, 7
 dac:	8d e2       	ldi	r24, 0x2D	; 45
 dae:	b6 01       	movw	r22, r12
 db0:	90 e0       	ldi	r25, 0x00	; 0
 db2:	50 d0       	rcall	.+160    	; 0xe54 <fputc>
 db4:	89 14       	cp	r8, r9
 db6:	30 f4       	brcc	.+12     	; 0xdc4 <vfprintf+0x396>
 db8:	b6 01       	movw	r22, r12
 dba:	80 e3       	ldi	r24, 0x30	; 48
 dbc:	90 e0       	ldi	r25, 0x00	; 0
 dbe:	4a d0       	rcall	.+148    	; 0xe54 <fputc>
 dc0:	9a 94       	dec	r9
 dc2:	f8 cf       	rjmp	.-16     	; 0xdb4 <vfprintf+0x386>
 dc4:	8a 94       	dec	r8
 dc6:	f3 01       	movw	r30, r6
 dc8:	e8 0d       	add	r30, r8
 dca:	f1 1d       	adc	r31, r1
 dcc:	80 81       	ld	r24, Z
 dce:	b6 01       	movw	r22, r12
 dd0:	90 e0       	ldi	r25, 0x00	; 0
 dd2:	40 d0       	rcall	.+128    	; 0xe54 <fputc>
 dd4:	81 10       	cpse	r8, r1
 dd6:	f6 cf       	rjmp	.-20     	; 0xdc4 <vfprintf+0x396>
 dd8:	22 20       	and	r2, r2
 dda:	09 f4       	brne	.+2      	; 0xdde <vfprintf+0x3b0>
 ddc:	4e ce       	rjmp	.-868    	; 0xa7a <vfprintf+0x4c>
 dde:	b6 01       	movw	r22, r12
 de0:	80 e2       	ldi	r24, 0x20	; 32
 de2:	90 e0       	ldi	r25, 0x00	; 0
 de4:	37 d0       	rcall	.+110    	; 0xe54 <fputc>
 de6:	2a 94       	dec	r2
 de8:	f7 cf       	rjmp	.-18     	; 0xdd8 <vfprintf+0x3aa>
 dea:	f6 01       	movw	r30, r12
 dec:	86 81       	ldd	r24, Z+6	; 0x06
 dee:	97 81       	ldd	r25, Z+7	; 0x07
 df0:	02 c0       	rjmp	.+4      	; 0xdf6 <vfprintf+0x3c8>
 df2:	8f ef       	ldi	r24, 0xFF	; 255
 df4:	9f ef       	ldi	r25, 0xFF	; 255
 df6:	2b 96       	adiw	r28, 0x0b	; 11
 df8:	0f b6       	in	r0, 0x3f	; 63
 dfa:	f8 94       	cli
 dfc:	de bf       	out	0x3e, r29	; 62
 dfe:	0f be       	out	0x3f, r0	; 63
 e00:	cd bf       	out	0x3d, r28	; 61
 e02:	df 91       	pop	r29
 e04:	cf 91       	pop	r28
 e06:	1f 91       	pop	r17
 e08:	0f 91       	pop	r16
 e0a:	ff 90       	pop	r15
 e0c:	ef 90       	pop	r14
 e0e:	df 90       	pop	r13
 e10:	cf 90       	pop	r12
 e12:	bf 90       	pop	r11
 e14:	af 90       	pop	r10
 e16:	9f 90       	pop	r9
 e18:	8f 90       	pop	r8
 e1a:	7f 90       	pop	r7
 e1c:	6f 90       	pop	r6
 e1e:	5f 90       	pop	r5
 e20:	4f 90       	pop	r4
 e22:	3f 90       	pop	r3
 e24:	2f 90       	pop	r2
 e26:	08 95       	ret

00000e28 <strnlen_P>:
 e28:	fc 01       	movw	r30, r24
 e2a:	05 90       	lpm	r0, Z+
 e2c:	61 50       	subi	r22, 0x01	; 1
 e2e:	70 40       	sbci	r23, 0x00	; 0
 e30:	01 10       	cpse	r0, r1
 e32:	d8 f7       	brcc	.-10     	; 0xe2a <strnlen_P+0x2>
 e34:	80 95       	com	r24
 e36:	90 95       	com	r25
 e38:	8e 0f       	add	r24, r30
 e3a:	9f 1f       	adc	r25, r31
 e3c:	08 95       	ret

00000e3e <strnlen>:
 e3e:	fc 01       	movw	r30, r24
 e40:	61 50       	subi	r22, 0x01	; 1
 e42:	70 40       	sbci	r23, 0x00	; 0
 e44:	01 90       	ld	r0, Z+
 e46:	01 10       	cpse	r0, r1
 e48:	d8 f7       	brcc	.-10     	; 0xe40 <strnlen+0x2>
 e4a:	80 95       	com	r24
 e4c:	90 95       	com	r25
 e4e:	8e 0f       	add	r24, r30
 e50:	9f 1f       	adc	r25, r31
 e52:	08 95       	ret

00000e54 <fputc>:
 e54:	0f 93       	push	r16
 e56:	1f 93       	push	r17
 e58:	cf 93       	push	r28
 e5a:	df 93       	push	r29
 e5c:	fb 01       	movw	r30, r22
 e5e:	23 81       	ldd	r18, Z+3	; 0x03
 e60:	21 fd       	sbrc	r18, 1
 e62:	03 c0       	rjmp	.+6      	; 0xe6a <fputc+0x16>
 e64:	8f ef       	ldi	r24, 0xFF	; 255
 e66:	9f ef       	ldi	r25, 0xFF	; 255
 e68:	2c c0       	rjmp	.+88     	; 0xec2 <fputc+0x6e>
 e6a:	22 ff       	sbrs	r18, 2
 e6c:	16 c0       	rjmp	.+44     	; 0xe9a <fputc+0x46>
 e6e:	46 81       	ldd	r20, Z+6	; 0x06
 e70:	57 81       	ldd	r21, Z+7	; 0x07
 e72:	24 81       	ldd	r18, Z+4	; 0x04
 e74:	35 81       	ldd	r19, Z+5	; 0x05
 e76:	42 17       	cp	r20, r18
 e78:	53 07       	cpc	r21, r19
 e7a:	44 f4       	brge	.+16     	; 0xe8c <fputc+0x38>
 e7c:	a0 81       	ld	r26, Z
 e7e:	b1 81       	ldd	r27, Z+1	; 0x01
 e80:	9d 01       	movw	r18, r26
 e82:	2f 5f       	subi	r18, 0xFF	; 255
 e84:	3f 4f       	sbci	r19, 0xFF	; 255
 e86:	31 83       	std	Z+1, r19	; 0x01
 e88:	20 83       	st	Z, r18
 e8a:	8c 93       	st	X, r24
 e8c:	26 81       	ldd	r18, Z+6	; 0x06
 e8e:	37 81       	ldd	r19, Z+7	; 0x07
 e90:	2f 5f       	subi	r18, 0xFF	; 255
 e92:	3f 4f       	sbci	r19, 0xFF	; 255
 e94:	37 83       	std	Z+7, r19	; 0x07
 e96:	26 83       	std	Z+6, r18	; 0x06
 e98:	14 c0       	rjmp	.+40     	; 0xec2 <fputc+0x6e>
 e9a:	8b 01       	movw	r16, r22
 e9c:	ec 01       	movw	r28, r24
 e9e:	fb 01       	movw	r30, r22
 ea0:	00 84       	ldd	r0, Z+8	; 0x08
 ea2:	f1 85       	ldd	r31, Z+9	; 0x09
 ea4:	e0 2d       	mov	r30, r0
 ea6:	09 95       	icall
 ea8:	89 2b       	or	r24, r25
 eaa:	e1 f6       	brne	.-72     	; 0xe64 <fputc+0x10>
 eac:	d8 01       	movw	r26, r16
 eae:	16 96       	adiw	r26, 0x06	; 6
 eb0:	8d 91       	ld	r24, X+
 eb2:	9c 91       	ld	r25, X
 eb4:	17 97       	sbiw	r26, 0x07	; 7
 eb6:	01 96       	adiw	r24, 0x01	; 1
 eb8:	17 96       	adiw	r26, 0x07	; 7
 eba:	9c 93       	st	X, r25
 ebc:	8e 93       	st	-X, r24
 ebe:	16 97       	sbiw	r26, 0x06	; 6
 ec0:	ce 01       	movw	r24, r28
 ec2:	df 91       	pop	r29
 ec4:	cf 91       	pop	r28
 ec6:	1f 91       	pop	r17
 ec8:	0f 91       	pop	r16
 eca:	08 95       	ret

00000ecc <__ultoa_invert>:
 ecc:	fa 01       	movw	r30, r20
 ece:	aa 27       	eor	r26, r26
 ed0:	28 30       	cpi	r18, 0x08	; 8
 ed2:	51 f1       	breq	.+84     	; 0xf28 <__ultoa_invert+0x5c>
 ed4:	20 31       	cpi	r18, 0x10	; 16
 ed6:	81 f1       	breq	.+96     	; 0xf38 <__ultoa_invert+0x6c>
 ed8:	e8 94       	clt
 eda:	6f 93       	push	r22
 edc:	6e 7f       	andi	r22, 0xFE	; 254
 ede:	6e 5f       	subi	r22, 0xFE	; 254
 ee0:	7f 4f       	sbci	r23, 0xFF	; 255
 ee2:	8f 4f       	sbci	r24, 0xFF	; 255
 ee4:	9f 4f       	sbci	r25, 0xFF	; 255
 ee6:	af 4f       	sbci	r26, 0xFF	; 255
 ee8:	b1 e0       	ldi	r27, 0x01	; 1
 eea:	3e d0       	rcall	.+124    	; 0xf68 <__ultoa_invert+0x9c>
 eec:	b4 e0       	ldi	r27, 0x04	; 4
 eee:	3c d0       	rcall	.+120    	; 0xf68 <__ultoa_invert+0x9c>
 ef0:	67 0f       	add	r22, r23
 ef2:	78 1f       	adc	r23, r24
 ef4:	89 1f       	adc	r24, r25
 ef6:	9a 1f       	adc	r25, r26
 ef8:	a1 1d       	adc	r26, r1
 efa:	68 0f       	add	r22, r24
 efc:	79 1f       	adc	r23, r25
 efe:	8a 1f       	adc	r24, r26
 f00:	91 1d       	adc	r25, r1
 f02:	a1 1d       	adc	r26, r1
 f04:	6a 0f       	add	r22, r26
 f06:	71 1d       	adc	r23, r1
 f08:	81 1d       	adc	r24, r1
 f0a:	91 1d       	adc	r25, r1
 f0c:	a1 1d       	adc	r26, r1
 f0e:	20 d0       	rcall	.+64     	; 0xf50 <__ultoa_invert+0x84>
 f10:	09 f4       	brne	.+2      	; 0xf14 <__ultoa_invert+0x48>
 f12:	68 94       	set
 f14:	3f 91       	pop	r19
 f16:	2a e0       	ldi	r18, 0x0A	; 10
 f18:	26 9f       	mul	r18, r22
 f1a:	11 24       	eor	r1, r1
 f1c:	30 19       	sub	r19, r0
 f1e:	30 5d       	subi	r19, 0xD0	; 208
 f20:	31 93       	st	Z+, r19
 f22:	de f6       	brtc	.-74     	; 0xeda <__ultoa_invert+0xe>
 f24:	cf 01       	movw	r24, r30
 f26:	08 95       	ret
 f28:	46 2f       	mov	r20, r22
 f2a:	47 70       	andi	r20, 0x07	; 7
 f2c:	40 5d       	subi	r20, 0xD0	; 208
 f2e:	41 93       	st	Z+, r20
 f30:	b3 e0       	ldi	r27, 0x03	; 3
 f32:	0f d0       	rcall	.+30     	; 0xf52 <__ultoa_invert+0x86>
 f34:	c9 f7       	brne	.-14     	; 0xf28 <__ultoa_invert+0x5c>
 f36:	f6 cf       	rjmp	.-20     	; 0xf24 <__ultoa_invert+0x58>
 f38:	46 2f       	mov	r20, r22
 f3a:	4f 70       	andi	r20, 0x0F	; 15
 f3c:	40 5d       	subi	r20, 0xD0	; 208
 f3e:	4a 33       	cpi	r20, 0x3A	; 58
 f40:	18 f0       	brcs	.+6      	; 0xf48 <__ultoa_invert+0x7c>
 f42:	49 5d       	subi	r20, 0xD9	; 217
 f44:	31 fd       	sbrc	r19, 1
 f46:	40 52       	subi	r20, 0x20	; 32
 f48:	41 93       	st	Z+, r20
 f4a:	02 d0       	rcall	.+4      	; 0xf50 <__ultoa_invert+0x84>
 f4c:	a9 f7       	brne	.-22     	; 0xf38 <__ultoa_invert+0x6c>
 f4e:	ea cf       	rjmp	.-44     	; 0xf24 <__ultoa_invert+0x58>
 f50:	b4 e0       	ldi	r27, 0x04	; 4
 f52:	a6 95       	lsr	r26
 f54:	97 95       	ror	r25
 f56:	87 95       	ror	r24
 f58:	77 95       	ror	r23
 f5a:	67 95       	ror	r22
 f5c:	ba 95       	dec	r27
 f5e:	c9 f7       	brne	.-14     	; 0xf52 <__ultoa_invert+0x86>
 f60:	00 97       	sbiw	r24, 0x00	; 0
 f62:	61 05       	cpc	r22, r1
 f64:	71 05       	cpc	r23, r1
 f66:	08 95       	ret
 f68:	9b 01       	movw	r18, r22
 f6a:	ac 01       	movw	r20, r24
 f6c:	0a 2e       	mov	r0, r26
 f6e:	06 94       	lsr	r0
 f70:	57 95       	ror	r21
 f72:	47 95       	ror	r20
 f74:	37 95       	ror	r19
 f76:	27 95       	ror	r18
 f78:	ba 95       	dec	r27
 f7a:	c9 f7       	brne	.-14     	; 0xf6e <__ultoa_invert+0xa2>
 f7c:	62 0f       	add	r22, r18
 f7e:	73 1f       	adc	r23, r19
 f80:	84 1f       	adc	r24, r20
 f82:	95 1f       	adc	r25, r21
 f84:	a0 1d       	adc	r26, r0
 f86:	08 95       	ret

00000f88 <eeprom_read_word>:
 f88:	a8 e1       	ldi	r26, 0x18	; 24
 f8a:	b0 e0       	ldi	r27, 0x00	; 0
 f8c:	42 e0       	ldi	r20, 0x02	; 2
 f8e:	50 e0       	ldi	r21, 0x00	; 0
 f90:	02 c0       	rjmp	.+4      	; 0xf96 <eeprom_read_blraw>

00000f92 <eeprom_read_block>:
 f92:	dc 01       	movw	r26, r24
 f94:	cb 01       	movw	r24, r22

00000f96 <eeprom_read_blraw>:
 f96:	fc 01       	movw	r30, r24
 f98:	f9 99       	sbic	0x1f, 1	; 31
 f9a:	fe cf       	rjmp	.-4      	; 0xf98 <eeprom_read_blraw+0x2>
 f9c:	06 c0       	rjmp	.+12     	; 0xfaa <eeprom_read_blraw+0x14>
 f9e:	f2 bd       	out	0x22, r31	; 34
 fa0:	e1 bd       	out	0x21, r30	; 33
 fa2:	f8 9a       	sbi	0x1f, 0	; 31
 fa4:	31 96       	adiw	r30, 0x01	; 1
 fa6:	00 b4       	in	r0, 0x20	; 32
 fa8:	0d 92       	st	X+, r0
 faa:	41 50       	subi	r20, 0x01	; 1
 fac:	50 40       	sbci	r21, 0x00	; 0
 fae:	b8 f7       	brcc	.-18     	; 0xf9e <eeprom_read_blraw+0x8>
 fb0:	08 95       	ret

00000fb2 <_exit>:
 fb2:	f8 94       	cli

00000fb4 <__stop_program>:
 fb4:	ff cf       	rjmp	.-2      	; 0xfb4 <__stop_program>
