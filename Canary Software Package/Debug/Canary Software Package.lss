
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ca  00800100  0000240a  0000249e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000240a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000418  008001ca  008001ca  00002568  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002568  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000025c4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000278  00000000  00000000  00002608  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004c40  00000000  00000000  00002880  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017c4  00000000  00000000  000074c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001c0f  00000000  00000000  00008c84  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006b0  00000000  00000000  0000a894  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000bf4  00000000  00000000  0000af44  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001949  00000000  00000000  0000bb38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001b0  00000000  00000000  0000d481  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 bb 0b 	jmp	0x1776	; 0x1776 <__vector_13>
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 ba 0b 	jmp	0x1774	; 0x1774 <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 fb 0c 	jmp	0x19f6	; 0x19f6 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 29 0c 	jmp	0x1852	; 0x1852 <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 3d 0d 	jmp	0x1a7a	; 0x1a7a <__vector_28>
      74:	7b c0       	rjmp	.+246    	; 0x16c <__bad_interrupt>
      76:	00 00       	nop
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	45 0c       	add	r4, r5
      8e:	97 0c       	add	r9, r7
      90:	97 0c       	add	r9, r7
      92:	97 0c       	add	r9, r7
      94:	97 0c       	add	r9, r7
      96:	97 0c       	add	r9, r7
      98:	97 0c       	add	r9, r7
      9a:	97 0c       	add	r9, r7
      9c:	45 0c       	add	r4, r5
      9e:	97 0c       	add	r9, r7
      a0:	97 0c       	add	r9, r7
      a2:	97 0c       	add	r9, r7
      a4:	97 0c       	add	r9, r7
      a6:	97 0c       	add	r9, r7
      a8:	97 0c       	add	r9, r7
      aa:	97 0c       	add	r9, r7
      ac:	47 0c       	add	r4, r7
      ae:	97 0c       	add	r9, r7
      b0:	97 0c       	add	r9, r7
      b2:	97 0c       	add	r9, r7
      b4:	97 0c       	add	r9, r7
      b6:	97 0c       	add	r9, r7
      b8:	97 0c       	add	r9, r7
      ba:	97 0c       	add	r9, r7
      bc:	97 0c       	add	r9, r7
      be:	97 0c       	add	r9, r7
      c0:	97 0c       	add	r9, r7
      c2:	97 0c       	add	r9, r7
      c4:	97 0c       	add	r9, r7
      c6:	97 0c       	add	r9, r7
      c8:	97 0c       	add	r9, r7
      ca:	97 0c       	add	r9, r7
      cc:	47 0c       	add	r4, r7
      ce:	97 0c       	add	r9, r7
      d0:	97 0c       	add	r9, r7
      d2:	97 0c       	add	r9, r7
      d4:	97 0c       	add	r9, r7
      d6:	97 0c       	add	r9, r7
      d8:	97 0c       	add	r9, r7
      da:	97 0c       	add	r9, r7
      dc:	97 0c       	add	r9, r7
      de:	97 0c       	add	r9, r7
      e0:	97 0c       	add	r9, r7
      e2:	97 0c       	add	r9, r7
      e4:	97 0c       	add	r9, r7
      e6:	97 0c       	add	r9, r7
      e8:	97 0c       	add	r9, r7
      ea:	97 0c       	add	r9, r7
      ec:	93 0c       	add	r9, r3
      ee:	97 0c       	add	r9, r7
      f0:	97 0c       	add	r9, r7
      f2:	97 0c       	add	r9, r7
      f4:	97 0c       	add	r9, r7
      f6:	97 0c       	add	r9, r7
      f8:	97 0c       	add	r9, r7
      fa:	97 0c       	add	r9, r7
      fc:	70 0c       	add	r7, r0
      fe:	97 0c       	add	r9, r7
     100:	97 0c       	add	r9, r7
     102:	97 0c       	add	r9, r7
     104:	97 0c       	add	r9, r7
     106:	97 0c       	add	r9, r7
     108:	97 0c       	add	r9, r7
     10a:	97 0c       	add	r9, r7
     10c:	97 0c       	add	r9, r7
     10e:	97 0c       	add	r9, r7
     110:	97 0c       	add	r9, r7
     112:	97 0c       	add	r9, r7
     114:	97 0c       	add	r9, r7
     116:	97 0c       	add	r9, r7
     118:	97 0c       	add	r9, r7
     11a:	97 0c       	add	r9, r7
     11c:	64 0c       	add	r6, r4
     11e:	97 0c       	add	r9, r7
     120:	97 0c       	add	r9, r7
     122:	97 0c       	add	r9, r7
     124:	97 0c       	add	r9, r7
     126:	97 0c       	add	r9, r7
     128:	97 0c       	add	r9, r7
     12a:	97 0c       	add	r9, r7
     12c:	82 0c       	add	r8, r2

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ea e0       	ldi	r30, 0x0A	; 10
     142:	f4 e2       	ldi	r31, 0x24	; 36
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	aa 3c       	cpi	r26, 0xCA	; 202
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	25 e0       	ldi	r18, 0x05	; 5
     156:	aa ec       	ldi	r26, 0xCA	; 202
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a2 3e       	cpi	r26, 0xE2	; 226
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 86 0a 	call	0x150c	; 0x150c <main>
     168:	0c 94 03 12 	jmp	0x2406	; 0x2406 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 a5 0b 	jmp	0x174a	; 0x174a <__vector_default>

00000170 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	90 81       	ld	r25, Z
     176:	90 7e       	andi	r25, 0xE0	; 224
     178:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     17a:	90 81       	ld	r25, Z
     17c:	89 2b       	or	r24, r25
     17e:	80 83       	st	Z, r24
     180:	08 95       	ret

00000182 <ADC_init>:
}

void ADC_init(void)
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     186:	ec e7       	ldi	r30, 0x7C	; 124
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	80 64       	ori	r24, 0x40	; 64
     18e:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     190:	ca e7       	ldi	r28, 0x7A	; 122
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	88 81       	ld	r24, Y
     196:	81 60       	ori	r24, 0x01	; 1
     198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     19a:	88 81       	ld	r24, Y
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     1a0:	88 81       	ld	r24, Y
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a6:	a4 e6       	ldi	r26, 0x64	; 100
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	8c 91       	ld	r24, X
     1ac:	8e 7f       	andi	r24, 0xFE	; 254
     1ae:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 7d       	andi	r24, 0xDF	; 223
     1b4:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b6:	8f e3       	ldi	r24, 0x3F	; 63
     1b8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1bc:	88 81       	ld	r24, Y
     1be:	80 68       	ori	r24, 0x80	; 128
     1c0:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c2:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c6:	8f e1       	ldi	r24, 0x1F	; 31
     1c8:	d3 df       	rcall	.-90     	; 0x170 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1ca:	88 81       	ld	r24, Y
     1cc:	80 64       	ori	r24, 0x40	; 64
     1ce:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1d0:	ea e7       	ldi	r30, 0x7A	; 122
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	84 ff       	sbrs	r24, 4
     1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1da:	ea e7       	ldi	r30, 0x7A	; 122
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	80 64       	ori	r24, 0x40	; 64
     1e2:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e4:	80 81       	ld	r24, Z
     1e6:	84 ff       	sbrs	r24, 4
     1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1ea:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     1f4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fc:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     200:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     204:	89 2f       	mov	r24, r25
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	98 2f       	mov	r25, r24
     20a:	88 27       	eor	r24, r24
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     214:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     218:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     21c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     220:	99 23       	and	r25, r25
     222:	1c f4       	brge	.+6      	; 0x22a <ADC_init+0xa8>
     224:	91 95       	neg	r25
     226:	81 95       	neg	r24
     228:	91 09       	sbc	r25, r1
     22a:	05 97       	sbiw	r24, 0x05	; 5
     22c:	2c f0       	brlt	.+10     	; 0x238 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22e:	80 91 a8 03 	lds	r24, 0x03A8	; 0x8003a8 <gas_sensor_initialization_errors>
     232:	81 60       	ori	r24, 0x01	; 1
     234:	80 93 a8 03 	sts	0x03A8, r24	; 0x8003a8 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     238:	8e e1       	ldi	r24, 0x1E	; 30
     23a:	9a df       	rcall	.-204    	; 0x170 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23c:	ea e7       	ldi	r30, 0x7A	; 122
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	80 64       	ori	r24, 0x40	; 64
     244:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     246:	80 81       	ld	r24, Z
     248:	84 ff       	sbrs	r24, 4
     24a:	fd cf       	rjmp	.-6      	; 0x246 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     256:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     25a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25e:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     262:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     266:	89 2f       	mov	r24, r25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	98 2f       	mov	r25, r24
     26c:	88 27       	eor	r24, r24
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     276:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     27a:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     27e:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     282:	81 5e       	subi	r24, 0xE1	; 225
     284:	91 09       	sbc	r25, r1
     286:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     28a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     292:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     296:	99 23       	and	r25, r25
     298:	1c f4       	brge	.+6      	; 0x2a0 <ADC_init+0x11e>
     29a:	91 95       	neg	r25
     29c:	81 95       	neg	r24
     29e:	91 09       	sbc	r25, r1
     2a0:	05 97       	sbiw	r24, 0x05	; 5
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a4:	80 91 a8 03 	lds	r24, 0x03A8	; 0x8003a8 <gas_sensor_initialization_errors>
     2a8:	82 60       	ori	r24, 0x02	; 2
     2aa:	80 93 a8 03 	sts	0x03A8, r24	; 0x8003a8 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ae:	ea e7       	ldi	r30, 0x7A	; 122
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8f 77       	andi	r24, 0x7F	; 127
     2b6:	80 83       	st	Z, r24
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <BME_read_correction_coefficients>:
********************************************************************************/

/********************************************************************************
						Functions
********************************************************************************/
void BME_read_correction_coefficients(void) {
     2be:	ff 92       	push	r15
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     2c8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     2cc:	88 23       	and	r24, r24
     2ce:	59 f1       	breq	.+86     	; 0x326 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2d0:	c3 e0       	ldi	r28, 0x03	; 3
     2d2:	d3 e0       	ldi	r29, 0x03	; 3
     2d4:	0f 2e       	mov	r0, r31
     2d6:	fc ee       	ldi	r31, 0xEC	; 236
     2d8:	ff 2e       	mov	r15, r31
     2da:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2dc:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2de:	1d ee       	ldi	r17, 0xED	; 237
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2e0:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2e2:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     2e4:	62 e0       	ldi	r22, 0x02	; 2
     2e6:	ce 01       	movw	r24, r28
     2e8:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2ec:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     2f0:	81 11       	cpse	r24, r1
     2f2:	fc cf       	rjmp	.-8      	; 0x2ec <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2f4:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     2f6:	6a e1       	ldi	r22, 0x1A	; 26
     2f8:	ce 01       	movw	r24, r28
     2fa:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2fe:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     302:	81 11       	cpse	r24, r1
     304:	fc cf       	rjmp	.-8      	; 0x2fe <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     306:	6a e1       	ldi	r22, 0x1A	; 26
     308:	ce 01       	movw	r24, r28
     30a:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     30e:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     312:	89 81       	ldd	r24, Y+1	; 0x01
     314:	83 fb       	bst	r24, 3
     316:	88 27       	eor	r24, r24
     318:	80 f9       	bld	r24, 0
     31a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     31e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     322:	81 11       	cpse	r24, r1
     324:	dd cf       	rjmp	.-70     	; 0x2e0 <BME_read_correction_coefficients+0x22>
	// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     326:	e3 e0       	ldi	r30, 0x03	; 3
     328:	f3 e0       	ldi	r31, 0x03	; 3
     32a:	8c ee       	ldi	r24, 0xEC	; 236
     32c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
     32e:	88 e8       	ldi	r24, 0x88	; 136
     330:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     332:	62 e0       	ldi	r22, 0x02	; 2
     334:	cf 01       	movw	r24, r30
     336:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     33a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     33e:	81 11       	cpse	r24, r1
     340:	fc cf       	rjmp	.-8      	; 0x33a <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     342:	8d ee       	ldi	r24, 0xED	; 237
     344:	80 93 03 03 	sts	0x0303, r24	; 0x800303 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     348:	6b e1       	ldi	r22, 0x1B	; 27
     34a:	83 e0       	ldi	r24, 0x03	; 3
     34c:	93 e0       	ldi	r25, 0x03	; 3
     34e:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     352:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     356:	81 11       	cpse	r24, r1
     358:	fc cf       	rjmp	.-8      	; 0x352 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     35a:	6b e1       	ldi	r22, 0x1B	; 27
     35c:	83 e0       	ldi	r24, 0x03	; 3
     35e:	93 e0       	ldi	r25, 0x03	; 3
     360:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     364:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
     368:	c4 e0       	ldi	r28, 0x04	; 4
     36a:	d3 e0       	ldi	r29, 0x03	; 3
     36c:	0f e2       	ldi	r16, 0x2F	; 47
     36e:	13 e0       	ldi	r17, 0x03	; 3
     370:	2f e1       	ldi	r18, 0x1F	; 31
     372:	33 e0       	ldi	r19, 0x03	; 3
     374:	d8 01       	movw	r26, r16
     376:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     378:	81 91       	ld	r24, Z+
     37a:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     37c:	e2 17       	cp	r30, r18
     37e:	f3 07       	cpc	r31, r19
     380:	d9 f7       	brne	.-10     	; 0x378 <BME_read_correction_coefficients+0xba>
     382:	8b e1       	ldi	r24, 0x1B	; 27
     384:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2313>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     388:	ef e2       	ldi	r30, 0x2F	; 47
     38a:	f3 e0       	ldi	r31, 0x03	; 3
     38c:	81 81       	ldd	r24, Z+1	; 0x01
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	98 2f       	mov	r25, r24
     392:	88 27       	eor	r24, r24
     394:	20 81       	ld	r18, Z
     396:	82 2b       	or	r24, r18
     398:	90 93 02 03 	sts	0x0302, r25	; 0x800302 <dig_T1+0x1>
     39c:	80 93 01 03 	sts	0x0301, r24	; 0x800301 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     3a0:	83 81       	ldd	r24, Z+3	; 0x03
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	98 2f       	mov	r25, r24
     3a6:	88 27       	eor	r24, r24
     3a8:	22 81       	ldd	r18, Z+2	; 0x02
     3aa:	82 2b       	or	r24, r18
     3ac:	90 93 2e 03 	sts	0x032E, r25	; 0x80032e <dig_T2+0x1>
     3b0:	80 93 2d 03 	sts	0x032D, r24	; 0x80032d <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     3b4:	85 81       	ldd	r24, Z+5	; 0x05
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	98 2f       	mov	r25, r24
     3ba:	88 27       	eor	r24, r24
     3bc:	24 81       	ldd	r18, Z+4	; 0x04
     3be:	82 2b       	or	r24, r18
     3c0:	90 93 bc 03 	sts	0x03BC, r25	; 0x8003bc <dig_T3+0x1>
     3c4:	80 93 bb 03 	sts	0x03BB, r24	; 0x8003bb <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     3c8:	87 81       	ldd	r24, Z+7	; 0x07
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	98 2f       	mov	r25, r24
     3ce:	88 27       	eor	r24, r24
     3d0:	26 81       	ldd	r18, Z+6	; 0x06
     3d2:	82 2b       	or	r24, r18
     3d4:	90 93 aa 03 	sts	0x03AA, r25	; 0x8003aa <dig_P1+0x1>
     3d8:	80 93 a9 03 	sts	0x03A9, r24	; 0x8003a9 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     3dc:	81 85       	ldd	r24, Z+9	; 0x09
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	98 2f       	mov	r25, r24
     3e2:	88 27       	eor	r24, r24
     3e4:	20 85       	ldd	r18, Z+8	; 0x08
     3e6:	82 2b       	or	r24, r18
     3e8:	90 93 67 03 	sts	0x0367, r25	; 0x800367 <dig_P2+0x1>
     3ec:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     3f0:	83 85       	ldd	r24, Z+11	; 0x0b
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	98 2f       	mov	r25, r24
     3f6:	88 27       	eor	r24, r24
     3f8:	22 85       	ldd	r18, Z+10	; 0x0a
     3fa:	82 2b       	or	r24, r18
     3fc:	90 93 ac 03 	sts	0x03AC, r25	; 0x8003ac <dig_P3+0x1>
     400:	80 93 ab 03 	sts	0x03AB, r24	; 0x8003ab <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     404:	85 85       	ldd	r24, Z+13	; 0x0d
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	98 2f       	mov	r25, r24
     40a:	88 27       	eor	r24, r24
     40c:	24 85       	ldd	r18, Z+12	; 0x0c
     40e:	82 2b       	or	r24, r18
     410:	90 93 69 03 	sts	0x0369, r25	; 0x800369 <dig_P4+0x1>
     414:	80 93 68 03 	sts	0x0368, r24	; 0x800368 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     418:	87 85       	ldd	r24, Z+15	; 0x0f
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	98 2f       	mov	r25, r24
     41e:	88 27       	eor	r24, r24
     420:	26 85       	ldd	r18, Z+14	; 0x0e
     422:	82 2b       	or	r24, r18
     424:	90 93 85 03 	sts	0x0385, r25	; 0x800385 <dig_P5+0x1>
     428:	80 93 84 03 	sts	0x0384, r24	; 0x800384 <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     42c:	81 89       	ldd	r24, Z+17	; 0x11
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	98 2f       	mov	r25, r24
     432:	88 27       	eor	r24, r24
     434:	20 89       	ldd	r18, Z+16	; 0x10
     436:	82 2b       	or	r24, r18
     438:	90 93 be 03 	sts	0x03BE, r25	; 0x8003be <dig_P6+0x1>
     43c:	80 93 bd 03 	sts	0x03BD, r24	; 0x8003bd <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     440:	83 89       	ldd	r24, Z+19	; 0x13
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	98 2f       	mov	r25, r24
     446:	88 27       	eor	r24, r24
     448:	22 89       	ldd	r18, Z+18	; 0x12
     44a:	82 2b       	or	r24, r18
     44c:	90 93 00 03 	sts	0x0300, r25	; 0x800300 <dig_P7+0x1>
     450:	80 93 ff 02 	sts	0x02FF, r24	; 0x8002ff <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     454:	85 89       	ldd	r24, Z+21	; 0x15
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	98 2f       	mov	r25, r24
     45a:	88 27       	eor	r24, r24
     45c:	24 89       	ldd	r18, Z+20	; 0x14
     45e:	82 2b       	or	r24, r18
     460:	90 93 ae 03 	sts	0x03AE, r25	; 0x8003ae <dig_P8+0x1>
     464:	80 93 ad 03 	sts	0x03AD, r24	; 0x8003ad <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     468:	87 89       	ldd	r24, Z+23	; 0x17
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	98 2f       	mov	r25, r24
     46e:	88 27       	eor	r24, r24
     470:	26 89       	ldd	r18, Z+22	; 0x16
     472:	82 2b       	or	r24, r18
     474:	90 93 ba 03 	sts	0x03BA, r25	; 0x8003ba <dig_P9+0x1>
     478:	80 93 b9 03 	sts	0x03B9, r24	; 0x8003b9 <dig_P9>
	dig_H1 = RawBMEdata[25];
     47c:	81 8d       	ldd	r24, Z+25	; 0x19
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	90 93 5c 03 	sts	0x035C, r25	; 0x80035c <dig_H1+0x1>
     484:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     488:	e3 e0       	ldi	r30, 0x03	; 3
     48a:	f3 e0       	ldi	r31, 0x03	; 3
     48c:	8c ee       	ldi	r24, 0xEC	; 236
     48e:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     490:	81 ee       	ldi	r24, 0xE1	; 225
     492:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     494:	62 e0       	ldi	r22, 0x02	; 2
     496:	cf 01       	movw	r24, r30
     498:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     49c:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     4a0:	81 11       	cpse	r24, r1
     4a2:	fc cf       	rjmp	.-8      	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     4a4:	8d ee       	ldi	r24, 0xED	; 237
     4a6:	80 93 03 03 	sts	0x0303, r24	; 0x800303 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     4aa:	68 e0       	ldi	r22, 0x08	; 8
     4ac:	83 e0       	ldi	r24, 0x03	; 3
     4ae:	93 e0       	ldi	r25, 0x03	; 3
     4b0:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     4b4:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     4b8:	81 11       	cpse	r24, r1
     4ba:	fc cf       	rjmp	.-8      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     4bc:	68 e0       	ldi	r22, 0x08	; 8
     4be:	83 e0       	ldi	r24, 0x03	; 3
     4c0:	93 e0       	ldi	r25, 0x03	; 3
     4c2:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     4c6:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
     4ca:	2b e0       	ldi	r18, 0x0B	; 11
     4cc:	33 e0       	ldi	r19, 0x03	; 3
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     4ce:	89 91       	ld	r24, Y+
     4d0:	f8 01       	movw	r30, r16
     4d2:	81 93       	st	Z+, r24
     4d4:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     4d6:	c2 17       	cp	r28, r18
     4d8:	d3 07       	cpc	r29, r19
     4da:	c9 f7       	brne	.-14     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
     4dc:	87 e0       	ldi	r24, 0x07	; 7
     4de:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2313>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8);
     4e2:	ef e2       	ldi	r30, 0x2F	; 47
     4e4:	f3 e0       	ldi	r31, 0x03	; 3
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	98 2f       	mov	r25, r24
     4ec:	88 27       	eor	r24, r24
     4ee:	21 81       	ldd	r18, Z+1	; 0x01
     4f0:	82 2b       	or	r24, r18
     4f2:	90 93 c0 03 	sts	0x03C0, r25	; 0x8003c0 <dig_H2+0x1>
     4f6:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <dig_H2>
	dig_H3 = RawBMEdata[3];
     4fa:	83 81       	ldd	r24, Z+3	; 0x03
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	90 93 b4 03 	sts	0x03B4, r25	; 0x8003b4 <dig_H3+0x1>
     502:	80 93 b3 03 	sts	0x03B3, r24	; 0x8003b3 <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     506:	85 81       	ldd	r24, Z+5	; 0x05
     508:	82 95       	swap	r24
     50a:	86 95       	lsr	r24
     50c:	87 70       	andi	r24, 0x07	; 7
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	24 81       	ldd	r18, Z+4	; 0x04
     512:	40 e1       	ldi	r20, 0x10	; 16
     514:	24 9f       	mul	r18, r20
     516:	90 01       	movw	r18, r0
     518:	11 24       	eor	r1, r1
     51a:	28 2b       	or	r18, r24
     51c:	39 2b       	or	r19, r25
     51e:	30 93 2c 03 	sts	0x032C, r19	; 0x80032c <dig_H4+0x1>
     522:	20 93 2b 03 	sts	0x032B, r18	; 0x80032b <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     526:	26 81       	ldd	r18, Z+6	; 0x06
     528:	40 e1       	ldi	r20, 0x10	; 16
     52a:	24 9f       	mul	r18, r20
     52c:	90 01       	movw	r18, r0
     52e:	11 24       	eor	r1, r1
     530:	82 2b       	or	r24, r18
     532:	93 2b       	or	r25, r19
     534:	90 93 b1 03 	sts	0x03B1, r25	; 0x8003b1 <dig_H5+0x1>
     538:	80 93 b0 03 	sts	0x03B0, r24	; 0x8003b0 <dig_H5>
	dig_H6 = RawBMEdata[7];
     53c:	87 81       	ldd	r24, Z+7	; 0x07
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	90 93 72 03 	sts	0x0372, r25	; 0x800372 <dig_H6+0x1>
     544:	80 93 71 03 	sts	0x0371, r24	; 0x800371 <dig_H6>
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	1f 91       	pop	r17
     54e:	0f 91       	pop	r16
     550:	ff 90       	pop	r15
     552:	08 95       	ret

00000554 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     554:	e3 e0       	ldi	r30, 0x03	; 3
     556:	f3 e0       	ldi	r31, 0x03	; 3
     558:	8c ee       	ldi	r24, 0xEC	; 236
     55a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     55c:	80 ee       	ldi	r24, 0xE0	; 224
     55e:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     560:	86 eb       	ldi	r24, 0xB6	; 182
     562:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     564:	63 e0       	ldi	r22, 0x03	; 3
     566:	cf 01       	movw	r24, r30
     568:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     56c:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     570:	81 11       	cpse	r24, r1
     572:	fc cf       	rjmp	.-8      	; 0x56c <bme280basic_init+0x18>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     574:	e3 e0       	ldi	r30, 0x03	; 3
     576:	f3 e0       	ldi	r31, 0x03	; 3
     578:	8c ee       	ldi	r24, 0xEC	; 236
     57a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     57c:	80 ed       	ldi	r24, 0xD0	; 208
     57e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     580:	62 e0       	ldi	r22, 0x02	; 2
     582:	cf 01       	movw	r24, r30
     584:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     588:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     58c:	81 11       	cpse	r24, r1
     58e:	fc cf       	rjmp	.-8      	; 0x588 <bme280basic_init+0x34>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     590:	8d ee       	ldi	r24, 0xED	; 237
     592:	80 93 03 03 	sts	0x0303, r24	; 0x800303 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     596:	62 e0       	ldi	r22, 0x02	; 2
     598:	83 e0       	ldi	r24, 0x03	; 3
     59a:	93 e0       	ldi	r25, 0x03	; 3
     59c:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5a0:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     5a4:	81 11       	cpse	r24, r1
     5a6:	fc cf       	rjmp	.-8      	; 0x5a0 <bme280basic_init+0x4c>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     5a8:	62 e0       	ldi	r22, 0x02	; 2
     5aa:	83 e0       	ldi	r24, 0x03	; 3
     5ac:	93 e0       	ldi	r25, 0x03	; 3
     5ae:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     5b2:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) {
     5b6:	80 91 04 03 	lds	r24, 0x0304	; 0x800304 <BMEmessageBuf+0x1>
     5ba:	80 36       	cpi	r24, 0x60	; 96
     5bc:	99 f5       	brne	.+102    	; 0x624 <bme280basic_init+0xd0>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5be:	e3 e0       	ldi	r30, 0x03	; 3
     5c0:	f3 e0       	ldi	r31, 0x03	; 3
     5c2:	8c ee       	ldi	r24, 0xEC	; 236
     5c4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     5c6:	82 ef       	ldi	r24, 0xF2	; 242
     5c8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ce:	63 e0       	ldi	r22, 0x03	; 3
     5d0:	cf 01       	movw	r24, r30
     5d2:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5d6:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     5da:	81 11       	cpse	r24, r1
     5dc:	fc cf       	rjmp	.-8      	; 0x5d6 <bme280basic_init+0x82>
		//
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5de:	e3 e0       	ldi	r30, 0x03	; 3
     5e0:	f3 e0       	ldi	r31, 0x03	; 3
     5e2:	8c ee       	ldi	r24, 0xEC	; 236
     5e4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     5e6:	85 ef       	ldi	r24, 0xF5	; 245
     5e8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     5ea:	80 e1       	ldi	r24, 0x10	; 16
     5ec:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ee:	63 e0       	ldi	r22, 0x03	; 3
     5f0:	cf 01       	movw	r24, r30
     5f2:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5f6:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     5fa:	81 11       	cpse	r24, r1
     5fc:	fc cf       	rjmp	.-8      	; 0x5f6 <bme280basic_init+0xa2>
		//
		BME_read_correction_coefficients();
     5fe:	5f de       	rcall	.-834    	; 0x2be <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     600:	81 e3       	ldi	r24, 0x31	; 49
     602:	80 93 6a 03 	sts	0x036A, r24	; 0x80036a <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     606:	e3 e0       	ldi	r30, 0x03	; 3
     608:	f3 e0       	ldi	r31, 0x03	; 3
     60a:	9c ee       	ldi	r25, 0xEC	; 236
     60c:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     60e:	94 ef       	ldi	r25, 0xF4	; 244
     610:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     612:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     614:	63 e0       	ldi	r22, 0x03	; 3
     616:	cf 01       	movw	r24, r30
     618:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     61c:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     620:	81 11       	cpse	r24, r1
     622:	fc cf       	rjmp	.-8      	; 0x61c <bme280basic_init+0xc8>
     624:	08 95       	ret

00000626 <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     626:	ff 92       	push	r15
     628:	0f 93       	push	r16
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     630:	81 e0       	ldi	r24, 0x01	; 1
     632:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2367>
	while (BMEbusy) {
     636:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2367>
     63a:	88 23       	and	r24, r24
     63c:	59 f1       	breq	.+86     	; 0x694 <bme280basic_bulk_data_read+0x6e>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     63e:	c3 e0       	ldi	r28, 0x03	; 3
     640:	d3 e0       	ldi	r29, 0x03	; 3
     642:	0f 2e       	mov	r0, r31
     644:	fc ee       	ldi	r31, 0xEC	; 236
     646:	ff 2e       	mov	r15, r31
     648:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     64a:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     64c:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     64e:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     650:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     652:	62 e0       	ldi	r22, 0x02	; 2
     654:	ce 01       	movw	r24, r28
     656:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     65a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     65e:	81 11       	cpse	r24, r1
     660:	fc cf       	rjmp	.-8      	; 0x65a <bme280basic_bulk_data_read+0x34>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     662:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     664:	62 e0       	ldi	r22, 0x02	; 2
     666:	ce 01       	movw	r24, r28
     668:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     66c:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     670:	81 11       	cpse	r24, r1
     672:	fc cf       	rjmp	.-8      	; 0x66c <bme280basic_bulk_data_read+0x46>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     674:	62 e0       	ldi	r22, 0x02	; 2
     676:	ce 01       	movw	r24, r28
     678:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     67c:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     680:	89 81       	ldd	r24, Y+1	; 0x01
     682:	83 fb       	bst	r24, 3
     684:	88 27       	eor	r24, r24
     686:	80 f9       	bld	r24, 0
     688:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2367>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     68c:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2367>
     690:	81 11       	cpse	r24, r1
     692:	dd cf       	rjmp	.-70     	; 0x64e <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     694:	e3 e0       	ldi	r30, 0x03	; 3
     696:	f3 e0       	ldi	r31, 0x03	; 3
     698:	8c ee       	ldi	r24, 0xEC	; 236
     69a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from
     69c:	87 ef       	ldi	r24, 0xF7	; 247
     69e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6a0:	62 e0       	ldi	r22, 0x02	; 2
     6a2:	cf 01       	movw	r24, r30
     6a4:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6a8:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     6ac:	81 11       	cpse	r24, r1
     6ae:	fc cf       	rjmp	.-8      	; 0x6a8 <bme280basic_bulk_data_read+0x82>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6b0:	8d ee       	ldi	r24, 0xED	; 237
     6b2:	80 93 03 03 	sts	0x0303, r24	; 0x800303 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     6b6:	69 e0       	ldi	r22, 0x09	; 9
     6b8:	83 e0       	ldi	r24, 0x03	; 3
     6ba:	93 e0       	ldi	r25, 0x03	; 3
     6bc:	0e 94 de 0b 	call	0x17bc	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6c0:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <TWI_Transceiver_Busy>
     6c4:	81 11       	cpse	r24, r1
     6c6:	fc cf       	rjmp	.-8      	; 0x6c0 <bme280basic_bulk_data_read+0x9a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     6c8:	69 e0       	ldi	r22, 0x09	; 9
     6ca:	83 e0       	ldi	r24, 0x03	; 3
     6cc:	93 e0       	ldi	r25, 0x03	; 3
     6ce:	0e 94 0a 0c 	call	0x1814	; 0x1814 <TWI_Get_Data_From_Transceiver>
     6d2:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
     6d6:	e4 e0       	ldi	r30, 0x04	; 4
     6d8:	f3 e0       	ldi	r31, 0x03	; 3
     6da:	af e2       	ldi	r26, 0x2F	; 47
     6dc:	b3 e0       	ldi	r27, 0x03	; 3
     6de:	2c e0       	ldi	r18, 0x0C	; 12
     6e0:	33 e0       	ldi	r19, 0x03	; 3
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     6e2:	81 91       	ld	r24, Z+
     6e4:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     6e6:	e2 17       	cp	r30, r18
     6e8:	f3 07       	cpc	r31, r19
     6ea:	d9 f7       	brne	.-10     	; 0x6e2 <bme280basic_bulk_data_read+0xbc>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     6ec:	ef e2       	ldi	r30, 0x2F	; 47
     6ee:	f3 e0       	ldi	r31, 0x03	; 3
     6f0:	81 81       	ldd	r24, Z+1	; 0x01
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	a0 e0       	ldi	r26, 0x00	; 0
     6f6:	b0 e0       	ldi	r27, 0x00	; 0
     6f8:	88 0f       	add	r24, r24
     6fa:	99 1f       	adc	r25, r25
     6fc:	aa 1f       	adc	r26, r26
     6fe:	bb 1f       	adc	r27, r27
     700:	88 0f       	add	r24, r24
     702:	99 1f       	adc	r25, r25
     704:	aa 1f       	adc	r26, r26
     706:	bb 1f       	adc	r27, r27
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	aa 1f       	adc	r26, r26
     70e:	bb 1f       	adc	r27, r27
     710:	88 0f       	add	r24, r24
     712:	99 1f       	adc	r25, r25
     714:	aa 1f       	adc	r26, r26
     716:	bb 1f       	adc	r27, r27
     718:	40 81       	ld	r20, Z
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	60 e0       	ldi	r22, 0x00	; 0
     71e:	70 e0       	ldi	r23, 0x00	; 0
     720:	03 2e       	mov	r0, r19
     722:	3c e0       	ldi	r19, 0x0C	; 12
     724:	44 0f       	add	r20, r20
     726:	55 1f       	adc	r21, r21
     728:	66 1f       	adc	r22, r22
     72a:	77 1f       	adc	r23, r23
     72c:	3a 95       	dec	r19
     72e:	d1 f7       	brne	.-12     	; 0x724 <bme280basic_bulk_data_read+0xfe>
     730:	30 2d       	mov	r19, r0
     732:	84 2b       	or	r24, r20
     734:	95 2b       	or	r25, r21
     736:	a6 2b       	or	r26, r22
     738:	b7 2b       	or	r27, r23
     73a:	22 81       	ldd	r18, Z+2	; 0x02
     73c:	22 95       	swap	r18
     73e:	2f 70       	andi	r18, 0x0F	; 15
     740:	82 2b       	or	r24, r18
     742:	80 93 86 03 	sts	0x0386, r24	; 0x800386 <rawPress>
     746:	90 93 87 03 	sts	0x0387, r25	; 0x800387 <rawPress+0x1>
     74a:	a0 93 88 03 	sts	0x0388, r26	; 0x800388 <rawPress+0x2>
     74e:	b0 93 89 03 	sts	0x0389, r27	; 0x800389 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     752:	84 81       	ldd	r24, Z+4	; 0x04
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	a0 e0       	ldi	r26, 0x00	; 0
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	88 0f       	add	r24, r24
     75c:	99 1f       	adc	r25, r25
     75e:	aa 1f       	adc	r26, r26
     760:	bb 1f       	adc	r27, r27
     762:	88 0f       	add	r24, r24
     764:	99 1f       	adc	r25, r25
     766:	aa 1f       	adc	r26, r26
     768:	bb 1f       	adc	r27, r27
     76a:	88 0f       	add	r24, r24
     76c:	99 1f       	adc	r25, r25
     76e:	aa 1f       	adc	r26, r26
     770:	bb 1f       	adc	r27, r27
     772:	88 0f       	add	r24, r24
     774:	99 1f       	adc	r25, r25
     776:	aa 1f       	adc	r26, r26
     778:	bb 1f       	adc	r27, r27
     77a:	43 81       	ldd	r20, Z+3	; 0x03
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	60 e0       	ldi	r22, 0x00	; 0
     780:	70 e0       	ldi	r23, 0x00	; 0
     782:	03 2e       	mov	r0, r19
     784:	3c e0       	ldi	r19, 0x0C	; 12
     786:	44 0f       	add	r20, r20
     788:	55 1f       	adc	r21, r21
     78a:	66 1f       	adc	r22, r22
     78c:	77 1f       	adc	r23, r23
     78e:	3a 95       	dec	r19
     790:	d1 f7       	brne	.-12     	; 0x786 <bme280basic_bulk_data_read+0x160>
     792:	30 2d       	mov	r19, r0
     794:	84 2b       	or	r24, r20
     796:	95 2b       	or	r25, r21
     798:	a6 2b       	or	r26, r22
     79a:	b7 2b       	or	r27, r23
     79c:	25 81       	ldd	r18, Z+5	; 0x05
     79e:	22 95       	swap	r18
     7a0:	2f 70       	andi	r18, 0x0F	; 15
     7a2:	82 2b       	or	r24, r18
     7a4:	80 93 5e 03 	sts	0x035E, r24	; 0x80035e <rawTemp>
     7a8:	90 93 5f 03 	sts	0x035F, r25	; 0x80035f <rawTemp+0x1>
     7ac:	a0 93 60 03 	sts	0x0360, r26	; 0x800360 <rawTemp+0x2>
     7b0:	b0 93 61 03 	sts	0x0361, r27	; 0x800361 <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     7b4:	86 81       	ldd	r24, Z+6	; 0x06
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	a0 e0       	ldi	r26, 0x00	; 0
     7ba:	b0 e0       	ldi	r27, 0x00	; 0
     7bc:	ba 2f       	mov	r27, r26
     7be:	a9 2f       	mov	r26, r25
     7c0:	98 2f       	mov	r25, r24
     7c2:	88 27       	eor	r24, r24
     7c4:	27 81       	ldd	r18, Z+7	; 0x07
     7c6:	82 2b       	or	r24, r18
     7c8:	80 93 8a 03 	sts	0x038A, r24	; 0x80038a <rawHum>
     7cc:	90 93 8b 03 	sts	0x038B, r25	; 0x80038b <rawHum+0x1>
     7d0:	a0 93 8c 03 	sts	0x038C, r26	; 0x80038c <rawHum+0x2>
     7d4:	b0 93 8d 03 	sts	0x038D, r27	; 0x80038d <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     7d8:	e3 e0       	ldi	r30, 0x03	; 3
     7da:	f3 e0       	ldi	r31, 0x03	; 3
     7dc:	8c ee       	ldi	r24, 0xEC	; 236
     7de:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     7e0:	84 ef       	ldi	r24, 0xF4	; 244
     7e2:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     7e4:	81 e3       	ldi	r24, 0x31	; 49
     7e6:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     7e8:	63 e0       	ldi	r22, 0x03	; 3
     7ea:	cf 01       	movw	r24, r30
     7ec:	e7 d7       	rcall	.+4046   	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     7ee:	e2 d7       	rcall	.+4036   	; 0x17b4 <TWI_Transceiver_Busy>
     7f0:	81 11       	cpse	r24, r1
     7f2:	fd cf       	rjmp	.-6      	; 0x7ee <bme280basic_bulk_data_read+0x1c8>
	//  All done - and the next measurement cycle has  been kicked off!
}
     7f4:	df 91       	pop	r29
     7f6:	cf 91       	pop	r28
     7f8:	1f 91       	pop	r17
     7fa:	0f 91       	pop	r16
     7fc:	ff 90       	pop	r15
     7fe:	08 95       	ret

00000800 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     800:	8f 92       	push	r8
     802:	9f 92       	push	r9
     804:	af 92       	push	r10
     806:	bf 92       	push	r11
     808:	cf 92       	push	r12
     80a:	df 92       	push	r13
     80c:	ef 92       	push	r14
     80e:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     810:	20 91 01 03 	lds	r18, 0x0301	; 0x800301 <dig_T1>
     814:	30 91 02 03 	lds	r19, 0x0302	; 0x800302 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     818:	6b 01       	movw	r12, r22
     81a:	7c 01       	movw	r14, r24
     81c:	68 94       	set
     81e:	13 f8       	bld	r1, 3
     820:	f5 94       	asr	r15
     822:	e7 94       	ror	r14
     824:	d7 94       	ror	r13
     826:	c7 94       	ror	r12
     828:	16 94       	lsr	r1
     82a:	d1 f7       	brne	.-12     	; 0x820 <BME280_compensate_T_int32+0x20>
     82c:	c2 1a       	sub	r12, r18
     82e:	d3 0a       	sbc	r13, r19
     830:	e1 08       	sbc	r14, r1
     832:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     834:	dc 01       	movw	r26, r24
     836:	cb 01       	movw	r24, r22
     838:	68 94       	set
     83a:	12 f8       	bld	r1, 2
     83c:	b5 95       	asr	r27
     83e:	a7 95       	ror	r26
     840:	97 95       	ror	r25
     842:	87 95       	ror	r24
     844:	16 94       	lsr	r1
     846:	d1 f7       	brne	.-12     	; 0x83c <BME280_compensate_T_int32+0x3c>
     848:	22 0f       	add	r18, r18
     84a:	33 1f       	adc	r19, r19
     84c:	4c 01       	movw	r8, r24
     84e:	5d 01       	movw	r10, r26
     850:	82 1a       	sub	r8, r18
     852:	93 0a       	sbc	r9, r19
     854:	a1 08       	sbc	r10, r1
     856:	b1 08       	sbc	r11, r1
     858:	a5 01       	movw	r20, r10
     85a:	94 01       	movw	r18, r8
     85c:	a0 91 2d 03 	lds	r26, 0x032D	; 0x80032d <dig_T2>
     860:	b0 91 2e 03 	lds	r27, 0x032E	; 0x80032e <dig_T2+0x1>
     864:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__mulshisi3>
     868:	4b 01       	movw	r8, r22
     86a:	5c 01       	movw	r10, r24
     86c:	07 2e       	mov	r0, r23
     86e:	7b e0       	ldi	r23, 0x0B	; 11
     870:	b5 94       	asr	r11
     872:	a7 94       	ror	r10
     874:	97 94       	ror	r9
     876:	87 94       	ror	r8
     878:	7a 95       	dec	r23
     87a:	d1 f7       	brne	.-12     	; 0x870 <BME280_compensate_T_int32+0x70>
     87c:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     87e:	a7 01       	movw	r20, r14
     880:	96 01       	movw	r18, r12
     882:	c7 01       	movw	r24, r14
     884:	b6 01       	movw	r22, r12
     886:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <__mulsi3>
     88a:	9b 01       	movw	r18, r22
     88c:	ac 01       	movw	r20, r24
     88e:	01 2e       	mov	r0, r17
     890:	1c e0       	ldi	r17, 0x0C	; 12
     892:	55 95       	asr	r21
     894:	47 95       	ror	r20
     896:	37 95       	ror	r19
     898:	27 95       	ror	r18
     89a:	1a 95       	dec	r17
     89c:	d1 f7       	brne	.-12     	; 0x892 <BME280_compensate_T_int32+0x92>
     89e:	10 2d       	mov	r17, r0
     8a0:	a0 91 bb 03 	lds	r26, 0x03BB	; 0x8003bb <dig_T3>
     8a4:	b0 91 bc 03 	lds	r27, 0x03BC	; 0x8003bc <dig_T3+0x1>
     8a8:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__mulshisi3>
     8ac:	dc 01       	movw	r26, r24
     8ae:	cb 01       	movw	r24, r22
     8b0:	07 2e       	mov	r0, r23
     8b2:	7e e0       	ldi	r23, 0x0E	; 14
     8b4:	b5 95       	asr	r27
     8b6:	a7 95       	ror	r26
     8b8:	97 95       	ror	r25
     8ba:	87 95       	ror	r24
     8bc:	7a 95       	dec	r23
     8be:	d1 f7       	brne	.-12     	; 0x8b4 <BME280_compensate_T_int32+0xb4>
     8c0:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     8c2:	88 0d       	add	r24, r8
     8c4:	99 1d       	adc	r25, r9
     8c6:	aa 1d       	adc	r26, r10
     8c8:	bb 1d       	adc	r27, r11
     8ca:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <t_fine>
     8ce:	90 93 c2 03 	sts	0x03C2, r25	; 0x8003c2 <t_fine+0x1>
     8d2:	a0 93 c3 03 	sts	0x03C3, r26	; 0x8003c3 <t_fine+0x2>
     8d6:	b0 93 c4 03 	sts	0x03C4, r27	; 0x8003c4 <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     8da:	6c 01       	movw	r12, r24
     8dc:	7d 01       	movw	r14, r26
     8de:	cc 0c       	add	r12, r12
     8e0:	dd 1c       	adc	r13, r13
     8e2:	ee 1c       	adc	r14, r14
     8e4:	ff 1c       	adc	r15, r15
     8e6:	cc 0c       	add	r12, r12
     8e8:	dd 1c       	adc	r13, r13
     8ea:	ee 1c       	adc	r14, r14
     8ec:	ff 1c       	adc	r15, r15
     8ee:	8c 0d       	add	r24, r12
     8f0:	9d 1d       	adc	r25, r13
     8f2:	ae 1d       	adc	r26, r14
     8f4:	bf 1d       	adc	r27, r15
     8f6:	80 58       	subi	r24, 0x80	; 128
     8f8:	9f 4f       	sbci	r25, 0xFF	; 255
     8fa:	af 4f       	sbci	r26, 0xFF	; 255
     8fc:	bf 4f       	sbci	r27, 0xFF	; 255
     8fe:	69 2f       	mov	r22, r25
     900:	7a 2f       	mov	r23, r26
     902:	8b 2f       	mov	r24, r27
     904:	99 27       	eor	r25, r25
     906:	87 fd       	sbrc	r24, 7
     908:	9a 95       	dec	r25
	return T;
}
     90a:	ff 90       	pop	r15
     90c:	ef 90       	pop	r14
     90e:	df 90       	pop	r13
     910:	cf 90       	pop	r12
     912:	bf 90       	pop	r11
     914:	af 90       	pop	r10
     916:	9f 90       	pop	r9
     918:	8f 90       	pop	r8
     91a:	08 95       	ret

0000091c <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     91c:	2f 92       	push	r2
     91e:	3f 92       	push	r3
     920:	4f 92       	push	r4
     922:	5f 92       	push	r5
     924:	6f 92       	push	r6
     926:	7f 92       	push	r7
     928:	8f 92       	push	r8
     92a:	9f 92       	push	r9
     92c:	af 92       	push	r10
     92e:	bf 92       	push	r11
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	cd b7       	in	r28, 0x3d	; 61
     942:	de b7       	in	r29, 0x3e	; 62
     944:	6e 97       	sbiw	r28, 0x1e	; 30
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	de bf       	out	0x3e, r29	; 62
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	6e 8b       	std	Y+22, r22	; 0x16
     952:	7f 8b       	std	Y+23, r23	; 0x17
     954:	88 8f       	std	Y+24, r24	; 0x18
     956:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     958:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <t_fine>
     95c:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <t_fine+0x1>
     960:	a0 91 c3 03 	lds	r26, 0x03C3	; 0x8003c3 <t_fine+0x2>
     964:	b0 91 c4 03 	lds	r27, 0x03C4	; 0x8003c4 <t_fine+0x3>
     968:	8c 01       	movw	r16, r24
     96a:	9d 01       	movw	r18, r26
     96c:	14 5f       	subi	r17, 0xF4	; 244
     96e:	21 40       	sbci	r18, 0x01	; 1
     970:	31 09       	sbc	r19, r1
     972:	09 83       	std	Y+1, r16	; 0x01
     974:	1a 83       	std	Y+2, r17	; 0x02
     976:	2b 83       	std	Y+3, r18	; 0x03
     978:	3c 83       	std	Y+4, r19	; 0x04
     97a:	33 0f       	add	r19, r19
     97c:	00 0b       	sbc	r16, r16
     97e:	10 2f       	mov	r17, r16
     980:	98 01       	movw	r18, r16
     982:	0d 83       	std	Y+5, r16	; 0x05
     984:	1e 83       	std	Y+6, r17	; 0x06
     986:	2f 83       	std	Y+7, r18	; 0x07
     988:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     98a:	a9 80       	ldd	r10, Y+1	; 0x01
     98c:	ba 80       	ldd	r11, Y+2	; 0x02
     98e:	cb 80       	ldd	r12, Y+3	; 0x03
     990:	dc 80       	ldd	r13, Y+4	; 0x04
     992:	ed 80       	ldd	r14, Y+5	; 0x05
     994:	fe 2c       	mov	r15, r14
     996:	0e 2d       	mov	r16, r14
     998:	1e 2d       	mov	r17, r14
     99a:	2a 2d       	mov	r18, r10
     99c:	3b 2d       	mov	r19, r11
     99e:	4c 2d       	mov	r20, r12
     9a0:	5d 2d       	mov	r21, r13
     9a2:	60 2f       	mov	r22, r16
     9a4:	70 2f       	mov	r23, r16
     9a6:	80 2f       	mov	r24, r16
     9a8:	9e 2d       	mov	r25, r14
     9aa:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     9ae:	2d 87       	std	Y+13, r18	; 0x0d
     9b0:	3e 87       	std	Y+14, r19	; 0x0e
     9b2:	4f 87       	std	Y+15, r20	; 0x0f
     9b4:	58 8b       	std	Y+16, r21	; 0x10
     9b6:	69 8b       	std	Y+17, r22	; 0x11
     9b8:	7a 8b       	std	Y+18, r23	; 0x12
     9ba:	8b 8b       	std	Y+19, r24	; 0x13
     9bc:	9c 8b       	std	Y+20, r25	; 0x14
     9be:	10 91 bd 03 	lds	r17, 0x03BD	; 0x8003bd <dig_P6>
     9c2:	1a 8f       	std	Y+26, r17	; 0x1a
     9c4:	20 91 be 03 	lds	r18, 0x03BE	; 0x8003be <dig_P6+0x1>
     9c8:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     9ca:	30 91 84 03 	lds	r19, 0x0384	; 0x800384 <dig_P5>
     9ce:	3b 8f       	std	Y+27, r19	; 0x1b
     9d0:	40 91 85 03 	lds	r20, 0x0385	; 0x800385 <dig_P5+0x1>
     9d4:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     9d6:	50 91 68 03 	lds	r21, 0x0368	; 0x800368 <dig_P4>
     9da:	5c 8f       	std	Y+28, r21	; 0x1c
     9dc:	80 91 69 03 	lds	r24, 0x0369	; 0x800369 <dig_P4+0x1>
     9e0:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     9e2:	30 91 67 03 	lds	r19, 0x0367	; 0x800367 <dig_P2+0x1>
     9e6:	20 91 66 03 	lds	r18, 0x0366	; 0x800366 <dig_P2>
     9ea:	93 2f       	mov	r25, r19
     9ec:	99 0f       	add	r25, r25
     9ee:	99 0b       	sbc	r25, r25
     9f0:	fe 2c       	mov	r15, r14
     9f2:	0e 2d       	mov	r16, r14
     9f4:	1e 2d       	mov	r17, r14
     9f6:	49 2f       	mov	r20, r25
     9f8:	59 2f       	mov	r21, r25
     9fa:	69 2f       	mov	r22, r25
     9fc:	79 2f       	mov	r23, r25
     9fe:	89 2f       	mov	r24, r25
     a00:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     a04:	0c e0       	ldi	r16, 0x0C	; 12
     a06:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     a0a:	42 2e       	mov	r4, r18
     a0c:	53 2e       	mov	r5, r19
     a0e:	64 2e       	mov	r6, r20
     a10:	75 2e       	mov	r7, r21
     a12:	86 2e       	mov	r8, r22
     a14:	97 2e       	mov	r9, r23
     a16:	28 2e       	mov	r2, r24
     a18:	39 2e       	mov	r3, r25
     a1a:	b0 90 ac 03 	lds	r11, 0x03AC	; 0x8003ac <dig_P3+0x1>
     a1e:	a0 90 ab 03 	lds	r10, 0x03AB	; 0x8003ab <dig_P3>
     a22:	1b 2d       	mov	r17, r11
     a24:	11 0f       	add	r17, r17
     a26:	11 0b       	sbc	r17, r17
     a28:	c1 2e       	mov	r12, r17
     a2a:	d1 2e       	mov	r13, r17
     a2c:	e1 2e       	mov	r14, r17
     a2e:	f1 2e       	mov	r15, r17
     a30:	01 2f       	mov	r16, r17
     a32:	2d 85       	ldd	r18, Y+13	; 0x0d
     a34:	3e 85       	ldd	r19, Y+14	; 0x0e
     a36:	4f 85       	ldd	r20, Y+15	; 0x0f
     a38:	58 89       	ldd	r21, Y+16	; 0x10
     a3a:	69 89       	ldd	r22, Y+17	; 0x11
     a3c:	7a 89       	ldd	r23, Y+18	; 0x12
     a3e:	8b 89       	ldd	r24, Y+19	; 0x13
     a40:	9c 89       	ldd	r25, Y+20	; 0x14
     a42:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     a46:	08 e0       	ldi	r16, 0x08	; 8
     a48:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     a4c:	a4 2c       	mov	r10, r4
     a4e:	b5 2c       	mov	r11, r5
     a50:	c6 2c       	mov	r12, r6
     a52:	d7 2c       	mov	r13, r7
     a54:	e8 2c       	mov	r14, r8
     a56:	f9 2c       	mov	r15, r9
     a58:	02 2d       	mov	r16, r2
     a5a:	13 2d       	mov	r17, r3
     a5c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     a60:	70 58       	subi	r23, 0x80	; 128
     a62:	8f 4f       	sbci	r24, 0xFF	; 255
     a64:	9f 4f       	sbci	r25, 0xFF	; 255
     a66:	20 90 a9 03 	lds	r2, 0x03A9	; 0x8003a9 <dig_P1>
     a6a:	30 90 aa 03 	lds	r3, 0x03AA	; 0x8003aa <dig_P1+0x1>
     a6e:	a2 2c       	mov	r10, r2
     a70:	b3 2c       	mov	r11, r3
     a72:	c1 2c       	mov	r12, r1
     a74:	d1 2c       	mov	r13, r1
     a76:	e1 2c       	mov	r14, r1
     a78:	f1 2c       	mov	r15, r1
     a7a:	00 e0       	ldi	r16, 0x00	; 0
     a7c:	10 e0       	ldi	r17, 0x00	; 0
     a7e:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     a82:	01 e2       	ldi	r16, 0x21	; 33
     a84:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     a88:	29 87       	std	Y+9, r18	; 0x09
     a8a:	3a 87       	std	Y+10, r19	; 0x0a
     a8c:	4b 87       	std	Y+11, r20	; 0x0b
     a8e:	45 2e       	mov	r4, r21
     a90:	56 2e       	mov	r5, r22
     a92:	7c 87       	std	Y+12, r23	; 0x0c
     a94:	38 2e       	mov	r3, r24
     a96:	29 2e       	mov	r2, r25
	if (var1 == 0)
     a98:	65 2d       	mov	r22, r5
     a9a:	83 2d       	mov	r24, r3
     a9c:	92 2d       	mov	r25, r2
     a9e:	a0 e0       	ldi	r26, 0x00	; 0
     aa0:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <__cmpdi2_s8>
     aa4:	09 f4       	brne	.+2      	; 0xaa8 <BME280_compensate_P_int64+0x18c>
     aa6:	85 c1       	rjmp	.+778    	; 0xdb2 <BME280_compensate_P_int64+0x496>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     aa8:	aa 8c       	ldd	r10, Y+26	; 0x1a
     aaa:	1e 8d       	ldd	r17, Y+30	; 0x1e
     aac:	11 0f       	add	r17, r17
     aae:	11 0b       	sbc	r17, r17
     ab0:	be 8c       	ldd	r11, Y+30	; 0x1e
     ab2:	c1 2e       	mov	r12, r17
     ab4:	d1 2e       	mov	r13, r17
     ab6:	e1 2e       	mov	r14, r17
     ab8:	f1 2e       	mov	r15, r17
     aba:	01 2f       	mov	r16, r17
     abc:	2d 85       	ldd	r18, Y+13	; 0x0d
     abe:	3e 85       	ldd	r19, Y+14	; 0x0e
     ac0:	4f 85       	ldd	r20, Y+15	; 0x0f
     ac2:	58 89       	ldd	r21, Y+16	; 0x10
     ac4:	69 89       	ldd	r22, Y+17	; 0x11
     ac6:	7a 89       	ldd	r23, Y+18	; 0x12
     ac8:	8b 89       	ldd	r24, Y+19	; 0x13
     aca:	9c 89       	ldd	r25, Y+20	; 0x14
     acc:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     ad0:	2d 87       	std	Y+13, r18	; 0x0d
     ad2:	3e 87       	std	Y+14, r19	; 0x0e
     ad4:	64 2e       	mov	r6, r20
     ad6:	75 2e       	mov	r7, r21
     ad8:	86 2e       	mov	r8, r22
     ada:	97 2e       	mov	r9, r23
     adc:	88 8b       	std	Y+16, r24	; 0x10
     ade:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     ae0:	2b 8d       	ldd	r18, Y+27	; 0x1b
     ae2:	9d 8d       	ldd	r25, Y+29	; 0x1d
     ae4:	99 0f       	add	r25, r25
     ae6:	99 0b       	sbc	r25, r25
     ae8:	a9 80       	ldd	r10, Y+1	; 0x01
     aea:	ba 80       	ldd	r11, Y+2	; 0x02
     aec:	cb 80       	ldd	r12, Y+3	; 0x03
     aee:	dc 80       	ldd	r13, Y+4	; 0x04
     af0:	ed 80       	ldd	r14, Y+5	; 0x05
     af2:	fe 2c       	mov	r15, r14
     af4:	0e 2d       	mov	r16, r14
     af6:	1e 2d       	mov	r17, r14
     af8:	3d 8d       	ldd	r19, Y+29	; 0x1d
     afa:	49 2f       	mov	r20, r25
     afc:	59 2f       	mov	r21, r25
     afe:	69 2f       	mov	r22, r25
     b00:	79 2f       	mov	r23, r25
     b02:	89 2f       	mov	r24, r25
     b04:	0e 94 bc 0d 	call	0x1b78	; 0x1b78 <__muldi3>
     b08:	01 e1       	ldi	r16, 0x11	; 17
     b0a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     b0e:	ad 84       	ldd	r10, Y+13	; 0x0d
     b10:	be 84       	ldd	r11, Y+14	; 0x0e
     b12:	c6 2c       	mov	r12, r6
     b14:	d7 2c       	mov	r13, r7
     b16:	e8 2c       	mov	r14, r8
     b18:	f9 2c       	mov	r15, r9
     b1a:	08 89       	ldd	r16, Y+16	; 0x10
     b1c:	1f 85       	ldd	r17, Y+15	; 0x0f
     b1e:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
     b22:	a2 2e       	mov	r10, r18
     b24:	b3 2e       	mov	r11, r19
     b26:	c4 2e       	mov	r12, r20
     b28:	d5 2e       	mov	r13, r21
     b2a:	e6 2e       	mov	r14, r22
     b2c:	f7 2e       	mov	r15, r23
     b2e:	e8 2f       	mov	r30, r24
     b30:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	a0 e1       	ldi	r26, 0x10	; 16
     b38:	b0 e0       	ldi	r27, 0x00	; 0
     b3a:	2e 89       	ldd	r18, Y+22	; 0x16
     b3c:	3f 89       	ldd	r19, Y+23	; 0x17
     b3e:	48 8d       	ldd	r20, Y+24	; 0x18
     b40:	59 8d       	ldd	r21, Y+25	; 0x19
     b42:	82 1b       	sub	r24, r18
     b44:	93 0b       	sbc	r25, r19
     b46:	a4 0b       	sbc	r26, r20
     b48:	b5 0b       	sbc	r27, r21
     b4a:	3c 01       	movw	r6, r24
     b4c:	4d 01       	movw	r8, r26
     b4e:	99 0c       	add	r9, r9
     b50:	66 08       	sbc	r6, r6
     b52:	76 2c       	mov	r7, r6
     b54:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     b56:	28 2f       	mov	r18, r24
     b58:	39 2f       	mov	r19, r25
     b5a:	4a 2f       	mov	r20, r26
     b5c:	5b 2f       	mov	r21, r27
     b5e:	66 2d       	mov	r22, r6
     b60:	76 2d       	mov	r23, r6
     b62:	86 2d       	mov	r24, r6
     b64:	96 2d       	mov	r25, r6
     b66:	0f e1       	ldi	r16, 0x1F	; 31
     b68:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     b6c:	82 2e       	mov	r8, r18
     b6e:	93 2e       	mov	r9, r19
     b70:	f4 2f       	mov	r31, r20
     b72:	75 2e       	mov	r7, r21
     b74:	b6 2f       	mov	r27, r22
     b76:	a7 2f       	mov	r26, r23
     b78:	68 2e       	mov	r6, r24
     b7a:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     b7c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	99 0f       	add	r25, r25
     b82:	99 0b       	sbc	r25, r25
     b84:	3d 89       	ldd	r19, Y+21	; 0x15
     b86:	49 2f       	mov	r20, r25
     b88:	59 2f       	mov	r21, r25
     b8a:	69 2f       	mov	r22, r25
     b8c:	79 2f       	mov	r23, r25
     b8e:	89 2f       	mov	r24, r25
     b90:	03 e2       	ldi	r16, 0x23	; 35
     b92:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     b96:	0e 2f       	mov	r16, r30
     b98:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
     b9c:	a2 2e       	mov	r10, r18
     b9e:	b3 2e       	mov	r11, r19
     ba0:	c4 2e       	mov	r12, r20
     ba2:	d5 2e       	mov	r13, r21
     ba4:	e6 2e       	mov	r14, r22
     ba6:	f7 2e       	mov	r15, r23
     ba8:	08 2f       	mov	r16, r24
     baa:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     bac:	28 2d       	mov	r18, r8
     bae:	39 2d       	mov	r19, r9
     bb0:	4f 2f       	mov	r20, r31
     bb2:	57 2d       	mov	r21, r7
     bb4:	6b 2f       	mov	r22, r27
     bb6:	7a 2f       	mov	r23, r26
     bb8:	86 2d       	mov	r24, r6
     bba:	9d 81       	ldd	r25, Y+5	; 0x05
     bbc:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     bc0:	82 2e       	mov	r8, r18
     bc2:	93 2e       	mov	r9, r19
     bc4:	49 83       	std	Y+1, r20	; 0x01
     bc6:	65 2e       	mov	r6, r21
     bc8:	b6 2f       	mov	r27, r22
     bca:	a7 2f       	mov	r26, r23
     bcc:	f8 2f       	mov	r31, r24
     bce:	e9 2f       	mov	r30, r25
     bd0:	03 e0       	ldi	r16, 0x03	; 3
     bd2:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     bd6:	a8 2c       	mov	r10, r8
     bd8:	b9 2c       	mov	r11, r9
     bda:	c9 80       	ldd	r12, Y+1	; 0x01
     bdc:	d6 2c       	mov	r13, r6
     bde:	eb 2e       	mov	r14, r27
     be0:	fa 2e       	mov	r15, r26
     be2:	0f 2f       	mov	r16, r31
     be4:	1e 2f       	mov	r17, r30
     be6:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     bea:	a2 2e       	mov	r10, r18
     bec:	b3 2e       	mov	r11, r19
     bee:	c4 2e       	mov	r12, r20
     bf0:	d5 2e       	mov	r13, r21
     bf2:	e6 2e       	mov	r14, r22
     bf4:	f7 2e       	mov	r15, r23
     bf6:	78 2e       	mov	r7, r24
     bf8:	19 2f       	mov	r17, r25
     bfa:	03 e0       	ldi	r16, 0x03	; 3
     bfc:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     c00:	07 2d       	mov	r16, r7
     c02:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     c06:	03 e0       	ldi	r16, 0x03	; 3
     c08:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     c0c:	a8 2c       	mov	r10, r8
     c0e:	b9 2c       	mov	r11, r9
     c10:	c9 80       	ldd	r12, Y+1	; 0x01
     c12:	d6 2c       	mov	r13, r6
     c14:	eb 2e       	mov	r14, r27
     c16:	fa 2e       	mov	r15, r26
     c18:	0f 2f       	mov	r16, r31
     c1a:	1e 2f       	mov	r17, r30
     c1c:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     c20:	02 e0       	ldi	r16, 0x02	; 2
     c22:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     c26:	0f 2f       	mov	r16, r31
     c28:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     c2c:	01 e0       	ldi	r16, 0x01	; 1
     c2e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__ashldi3>
     c32:	0f 2f       	mov	r16, r31
     c34:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__subdi3>
     c38:	a9 84       	ldd	r10, Y+9	; 0x09
     c3a:	ba 84       	ldd	r11, Y+10	; 0x0a
     c3c:	cb 84       	ldd	r12, Y+11	; 0x0b
     c3e:	d4 2c       	mov	r13, r4
     c40:	e5 2c       	mov	r14, r5
     c42:	fc 84       	ldd	r15, Y+12	; 0x0c
     c44:	03 2d       	mov	r16, r3
     c46:	12 2d       	mov	r17, r2
     c48:	ea d7       	rcall	.+4052   	; 0x1c1e <__divdi3>
     c4a:	2e 87       	std	Y+14, r18	; 0x0e
     c4c:	3d 87       	std	Y+13, r19	; 0x0d
     c4e:	49 83       	std	Y+1, r20	; 0x01
     c50:	5d 83       	std	Y+5, r21	; 0x05
     c52:	69 87       	std	Y+9, r22	; 0x09
     c54:	7a 87       	std	Y+10, r23	; 0x0a
     c56:	8b 87       	std	Y+11, r24	; 0x0b
     c58:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     c5a:	0d e0       	ldi	r16, 0x0D	; 13
     c5c:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     c60:	82 2e       	mov	r8, r18
     c62:	93 2e       	mov	r9, r19
     c64:	74 2e       	mov	r7, r20
     c66:	65 2e       	mov	r6, r21
     c68:	56 2e       	mov	r5, r22
     c6a:	47 2e       	mov	r4, r23
     c6c:	38 2e       	mov	r3, r24
     c6e:	29 2e       	mov	r2, r25
     c70:	30 91 ba 03 	lds	r19, 0x03BA	; 0x8003ba <dig_P9+0x1>
     c74:	20 91 b9 03 	lds	r18, 0x03B9	; 0x8003b9 <dig_P9>
     c78:	93 2f       	mov	r25, r19
     c7a:	99 0f       	add	r25, r25
     c7c:	99 0b       	sbc	r25, r25
     c7e:	a8 2c       	mov	r10, r8
     c80:	b9 2c       	mov	r11, r9
     c82:	c7 2c       	mov	r12, r7
     c84:	d6 2c       	mov	r13, r6
     c86:	e5 2c       	mov	r14, r5
     c88:	f4 2c       	mov	r15, r4
     c8a:	03 2d       	mov	r16, r3
     c8c:	12 2d       	mov	r17, r2
     c8e:	49 2f       	mov	r20, r25
     c90:	59 2f       	mov	r21, r25
     c92:	69 2f       	mov	r22, r25
     c94:	79 2f       	mov	r23, r25
     c96:	89 2f       	mov	r24, r25
     c98:	6f d7       	rcall	.+3806   	; 0x1b78 <__muldi3>
     c9a:	a2 2e       	mov	r10, r18
     c9c:	b3 2e       	mov	r11, r19
     c9e:	c4 2e       	mov	r12, r20
     ca0:	d5 2e       	mov	r13, r21
     ca2:	e6 2e       	mov	r14, r22
     ca4:	f7 2e       	mov	r15, r23
     ca6:	08 2f       	mov	r16, r24
     ca8:	19 2f       	mov	r17, r25
     caa:	28 2d       	mov	r18, r8
     cac:	39 2d       	mov	r19, r9
     cae:	47 2d       	mov	r20, r7
     cb0:	56 2d       	mov	r21, r6
     cb2:	65 2d       	mov	r22, r5
     cb4:	74 2d       	mov	r23, r4
     cb6:	83 2d       	mov	r24, r3
     cb8:	92 2d       	mov	r25, r2
     cba:	5e d7       	rcall	.+3772   	; 0x1b78 <__muldi3>
     cbc:	09 e1       	ldi	r16, 0x19	; 25
     cbe:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     cc2:	a2 2e       	mov	r10, r18
     cc4:	b3 2e       	mov	r11, r19
     cc6:	c4 2e       	mov	r12, r20
     cc8:	d5 2e       	mov	r13, r21
     cca:	e6 2e       	mov	r14, r22
     ccc:	f7 2e       	mov	r15, r23
     cce:	08 2f       	mov	r16, r24
     cd0:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     cd2:	2e 85       	ldd	r18, Y+14	; 0x0e
     cd4:	3d 85       	ldd	r19, Y+13	; 0x0d
     cd6:	49 81       	ldd	r20, Y+1	; 0x01
     cd8:	5d 81       	ldd	r21, Y+5	; 0x05
     cda:	69 85       	ldd	r22, Y+9	; 0x09
     cdc:	7a 85       	ldd	r23, Y+10	; 0x0a
     cde:	8b 85       	ldd	r24, Y+11	; 0x0b
     ce0:	9c 85       	ldd	r25, Y+12	; 0x0c
     ce2:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
     ce6:	22 2e       	mov	r2, r18
     ce8:	33 2e       	mov	r3, r19
     cea:	44 2e       	mov	r4, r20
     cec:	55 2e       	mov	r5, r21
     cee:	66 2e       	mov	r6, r22
     cf0:	77 2e       	mov	r7, r23
     cf2:	88 2e       	mov	r8, r24
     cf4:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
     cf6:	30 91 ae 03 	lds	r19, 0x03AE	; 0x8003ae <dig_P8+0x1>
     cfa:	20 91 ad 03 	lds	r18, 0x03AD	; 0x8003ad <dig_P8>
     cfe:	93 2f       	mov	r25, r19
     d00:	99 0f       	add	r25, r25
     d02:	99 0b       	sbc	r25, r25
     d04:	ae 84       	ldd	r10, Y+14	; 0x0e
     d06:	bd 84       	ldd	r11, Y+13	; 0x0d
     d08:	c9 80       	ldd	r12, Y+1	; 0x01
     d0a:	dd 80       	ldd	r13, Y+5	; 0x05
     d0c:	e9 84       	ldd	r14, Y+9	; 0x09
     d0e:	fa 84       	ldd	r15, Y+10	; 0x0a
     d10:	0b 85       	ldd	r16, Y+11	; 0x0b
     d12:	1c 85       	ldd	r17, Y+12	; 0x0c
     d14:	49 2f       	mov	r20, r25
     d16:	59 2f       	mov	r21, r25
     d18:	69 2f       	mov	r22, r25
     d1a:	79 2f       	mov	r23, r25
     d1c:	89 2f       	mov	r24, r25
     d1e:	2c d7       	rcall	.+3672   	; 0x1b78 <__muldi3>
     d20:	03 e1       	ldi	r16, 0x13	; 19
     d22:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     d26:	a2 2e       	mov	r10, r18
     d28:	b3 2e       	mov	r11, r19
     d2a:	c4 2e       	mov	r12, r20
     d2c:	d5 2e       	mov	r13, r21
     d2e:	e6 2e       	mov	r14, r22
     d30:	f7 2e       	mov	r15, r23
     d32:	08 2f       	mov	r16, r24
     d34:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     d36:	22 2d       	mov	r18, r2
     d38:	33 2d       	mov	r19, r3
     d3a:	44 2d       	mov	r20, r4
     d3c:	55 2d       	mov	r21, r5
     d3e:	66 2d       	mov	r22, r6
     d40:	77 2d       	mov	r23, r7
     d42:	88 2d       	mov	r24, r8
     d44:	99 2d       	mov	r25, r9
     d46:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
     d4a:	08 e0       	ldi	r16, 0x08	; 8
     d4c:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <__ashrdi3>
     d50:	40 90 ff 02 	lds	r4, 0x02FF	; 0x8002ff <dig_P7>
     d54:	50 90 00 03 	lds	r5, 0x0300	; 0x800300 <dig_P7+0x1>
     d58:	05 2c       	mov	r0, r5
     d5a:	00 0c       	add	r0, r0
     d5c:	66 08       	sbc	r6, r6
     d5e:	77 08       	sbc	r7, r7
     d60:	44 0c       	add	r4, r4
     d62:	55 1c       	adc	r5, r5
     d64:	66 1c       	adc	r6, r6
     d66:	77 1c       	adc	r7, r7
     d68:	44 0c       	add	r4, r4
     d6a:	55 1c       	adc	r5, r5
     d6c:	66 1c       	adc	r6, r6
     d6e:	77 1c       	adc	r7, r7
     d70:	44 0c       	add	r4, r4
     d72:	55 1c       	adc	r5, r5
     d74:	66 1c       	adc	r6, r6
     d76:	77 1c       	adc	r7, r7
     d78:	44 0c       	add	r4, r4
     d7a:	55 1c       	adc	r5, r5
     d7c:	66 1c       	adc	r6, r6
     d7e:	77 1c       	adc	r7, r7
     d80:	83 01       	movw	r16, r6
     d82:	72 01       	movw	r14, r4
     d84:	11 0f       	add	r17, r17
     d86:	ee 08       	sbc	r14, r14
     d88:	fe 2c       	mov	r15, r14
     d8a:	87 01       	movw	r16, r14
     d8c:	e9 82       	std	Y+1, r14	; 0x01
     d8e:	fa 82       	std	Y+2, r15	; 0x02
     d90:	0b 83       	std	Y+3, r16	; 0x03
     d92:	1c 83       	std	Y+4, r17	; 0x04
     d94:	a4 2c       	mov	r10, r4
     d96:	b5 2c       	mov	r11, r5
     d98:	c6 2c       	mov	r12, r6
     d9a:	d7 2c       	mov	r13, r7
     d9c:	e9 80       	ldd	r14, Y+1	; 0x01
     d9e:	fe 2c       	mov	r15, r14
     da0:	0e 2d       	mov	r16, r14
     da2:	1e 2d       	mov	r17, r14
     da4:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <__adddi3>
	return(long)p;
     da8:	62 2f       	mov	r22, r18
     daa:	73 2f       	mov	r23, r19
     dac:	84 2f       	mov	r24, r20
     dae:	95 2f       	mov	r25, r21
     db0:	04 c0       	rjmp	.+8      	; 0xdba <BME280_compensate_P_int64+0x49e>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
     db2:	60 e0       	ldi	r22, 0x00	; 0
     db4:	70 e0       	ldi	r23, 0x00	; 0
     db6:	80 e0       	ldi	r24, 0x00	; 0
     db8:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
     dba:	6e 96       	adiw	r28, 0x1e	; 30
     dbc:	0f b6       	in	r0, 0x3f	; 63
     dbe:	f8 94       	cli
     dc0:	de bf       	out	0x3e, r29	; 62
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	cd bf       	out	0x3d, r28	; 61
     dc6:	df 91       	pop	r29
     dc8:	cf 91       	pop	r28
     dca:	1f 91       	pop	r17
     dcc:	0f 91       	pop	r16
     dce:	ff 90       	pop	r15
     dd0:	ef 90       	pop	r14
     dd2:	df 90       	pop	r13
     dd4:	cf 90       	pop	r12
     dd6:	bf 90       	pop	r11
     dd8:	af 90       	pop	r10
     dda:	9f 90       	pop	r9
     ddc:	8f 90       	pop	r8
     dde:	7f 90       	pop	r7
     de0:	6f 90       	pop	r6
     de2:	5f 90       	pop	r5
     de4:	4f 90       	pop	r4
     de6:	3f 90       	pop	r3
     de8:	2f 90       	pop	r2
     dea:	08 95       	ret

00000dec <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
     dec:	2f 92       	push	r2
     dee:	3f 92       	push	r3
     df0:	4f 92       	push	r4
     df2:	5f 92       	push	r5
     df4:	6f 92       	push	r6
     df6:	7f 92       	push	r7
     df8:	8f 92       	push	r8
     dfa:	9f 92       	push	r9
     dfc:	af 92       	push	r10
     dfe:	bf 92       	push	r11
     e00:	cf 92       	push	r12
     e02:	df 92       	push	r13
     e04:	ef 92       	push	r14
     e06:	ff 92       	push	r15
     e08:	0f 93       	push	r16
     e0a:	1f 93       	push	r17
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	cd b7       	in	r28, 0x3d	; 61
     e12:	de b7       	in	r29, 0x3e	; 62
     e14:	67 97       	sbiw	r28, 0x17	; 23
     e16:	0f b6       	in	r0, 0x3f	; 63
     e18:	f8 94       	cli
     e1a:	de bf       	out	0x3e, r29	; 62
     e1c:	0f be       	out	0x3f, r0	; 63
     e1e:	cd bf       	out	0x3d, r28	; 61
     e20:	2b 01       	movw	r4, r22
     e22:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
     e24:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <t_fine>
     e28:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <t_fine+0x1>
     e2c:	a0 91 c3 03 	lds	r26, 0x03C3	; 0x8003c3 <t_fine+0x2>
     e30:	b0 91 c4 03 	lds	r27, 0x03C4	; 0x8003c4 <t_fine+0x3>
     e34:	6c 01       	movw	r12, r24
     e36:	7d 01       	movw	r14, r26
     e38:	ff 0c       	add	r15, r15
     e3a:	cc 08       	sbc	r12, r12
     e3c:	dc 2c       	mov	r13, r12
     e3e:	76 01       	movw	r14, r12
     e40:	28 2f       	mov	r18, r24
     e42:	39 2f       	mov	r19, r25
     e44:	4a 2f       	mov	r20, r26
     e46:	5b 2f       	mov	r21, r27
     e48:	6c 2d       	mov	r22, r12
     e4a:	7c 2d       	mov	r23, r12
     e4c:	8c 2d       	mov	r24, r12
     e4e:	9c 2d       	mov	r25, r12
     e50:	3c 52       	subi	r19, 0x2C	; 44
     e52:	41 40       	sbci	r20, 0x01	; 1
     e54:	51 09       	sbc	r21, r1
     e56:	61 09       	sbc	r22, r1
     e58:	71 09       	sbc	r23, r1
     e5a:	81 09       	sbc	r24, r1
     e5c:	91 09       	sbc	r25, r1
     e5e:	2f 8b       	std	Y+23, r18	; 0x17
     e60:	3e 8b       	std	Y+22, r19	; 0x16
     e62:	49 83       	std	Y+1, r20	; 0x01
     e64:	59 87       	std	Y+9, r21	; 0x09
     e66:	6a 87       	std	Y+10, r22	; 0x0a
     e68:	7b 87       	std	Y+11, r23	; 0x0b
     e6a:	8c 87       	std	Y+12, r24	; 0x0c
     e6c:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
     e6e:	03 2e       	mov	r0, r19
     e70:	3e e0       	ldi	r19, 0x0E	; 14
     e72:	44 0c       	add	r4, r4
     e74:	55 1c       	adc	r5, r5
     e76:	66 1c       	adc	r6, r6
     e78:	77 1c       	adc	r7, r7
     e7a:	3a 95       	dec	r19
     e7c:	d1 f7       	brne	.-12     	; 0xe72 <bme280_compensate_H_int32+0x86>
     e7e:	30 2d       	mov	r19, r0
     e80:	53 01       	movw	r10, r6
     e82:	42 01       	movw	r8, r4
     e84:	bb 0c       	add	r11, r11
     e86:	88 08       	sbc	r8, r8
     e88:	98 2c       	mov	r9, r8
     e8a:	54 01       	movw	r10, r8
     e8c:	30 91 2c 03 	lds	r19, 0x032C	; 0x80032c <dig_H4+0x1>
     e90:	20 91 2b 03 	lds	r18, 0x032B	; 0x80032b <dig_H4>
     e94:	93 2f       	mov	r25, r19
     e96:	99 0f       	add	r25, r25
     e98:	99 0b       	sbc	r25, r25
     e9a:	49 2f       	mov	r20, r25
     e9c:	59 2f       	mov	r21, r25
     e9e:	69 2f       	mov	r22, r25
     ea0:	79 2f       	mov	r23, r25
     ea2:	89 2f       	mov	r24, r25
     ea4:	04 e1       	ldi	r16, 0x14	; 20
     ea6:	89 d7       	rcall	.+3858   	; 0x1dba <__ashldi3>
     ea8:	f2 2f       	mov	r31, r18
     eaa:	e3 2f       	mov	r30, r19
     eac:	c4 2e       	mov	r12, r20
     eae:	d5 2e       	mov	r13, r21
     eb0:	e6 2e       	mov	r14, r22
     eb2:	f7 2e       	mov	r15, r23
     eb4:	08 2f       	mov	r16, r24
     eb6:	19 2f       	mov	r17, r25
     eb8:	24 2d       	mov	r18, r4
     eba:	35 2d       	mov	r19, r5
     ebc:	46 2d       	mov	r20, r6
     ebe:	57 2d       	mov	r21, r7
     ec0:	68 2d       	mov	r22, r8
     ec2:	78 2d       	mov	r23, r8
     ec4:	88 2d       	mov	r24, r8
     ec6:	98 2d       	mov	r25, r8
     ec8:	af 2e       	mov	r10, r31
     eca:	be 2e       	mov	r11, r30
     ecc:	b6 d7       	rcall	.+3948   	; 0x1e3a <__subdi3>
     ece:	22 2e       	mov	r2, r18
     ed0:	33 2e       	mov	r3, r19
     ed2:	44 2e       	mov	r4, r20
     ed4:	55 2e       	mov	r5, r21
     ed6:	66 2e       	mov	r6, r22
     ed8:	77 2e       	mov	r7, r23
     eda:	88 2e       	mov	r8, r24
     edc:	99 2e       	mov	r9, r25
     ede:	30 91 b1 03 	lds	r19, 0x03B1	; 0x8003b1 <dig_H5+0x1>
     ee2:	20 91 b0 03 	lds	r18, 0x03B0	; 0x8003b0 <dig_H5>
     ee6:	93 2f       	mov	r25, r19
     ee8:	99 0f       	add	r25, r25
     eea:	99 0b       	sbc	r25, r25
     eec:	af 88       	ldd	r10, Y+23	; 0x17
     eee:	be 88       	ldd	r11, Y+22	; 0x16
     ef0:	c9 80       	ldd	r12, Y+1	; 0x01
     ef2:	d9 84       	ldd	r13, Y+9	; 0x09
     ef4:	ea 84       	ldd	r14, Y+10	; 0x0a
     ef6:	fb 84       	ldd	r15, Y+11	; 0x0b
     ef8:	0c 85       	ldd	r16, Y+12	; 0x0c
     efa:	1d 85       	ldd	r17, Y+13	; 0x0d
     efc:	49 2f       	mov	r20, r25
     efe:	59 2f       	mov	r21, r25
     f00:	69 2f       	mov	r22, r25
     f02:	79 2f       	mov	r23, r25
     f04:	89 2f       	mov	r24, r25
     f06:	38 d6       	rcall	.+3184   	; 0x1b78 <__muldi3>
     f08:	a2 2e       	mov	r10, r18
     f0a:	b3 2e       	mov	r11, r19
     f0c:	c4 2e       	mov	r12, r20
     f0e:	d5 2e       	mov	r13, r21
     f10:	e6 2e       	mov	r14, r22
     f12:	f7 2e       	mov	r15, r23
     f14:	08 2f       	mov	r16, r24
     f16:	19 2f       	mov	r17, r25
     f18:	22 2d       	mov	r18, r2
     f1a:	33 2d       	mov	r19, r3
     f1c:	44 2d       	mov	r20, r4
     f1e:	55 2d       	mov	r21, r5
     f20:	66 2d       	mov	r22, r6
     f22:	77 2d       	mov	r23, r7
     f24:	88 2d       	mov	r24, r8
     f26:	99 2d       	mov	r25, r9
     f28:	88 d7       	rcall	.+3856   	; 0x1e3a <__subdi3>
     f2a:	30 5c       	subi	r19, 0xC0	; 192
     f2c:	4f 4f       	sbci	r20, 0xFF	; 255
     f2e:	5f 4f       	sbci	r21, 0xFF	; 255
     f30:	6f 4f       	sbci	r22, 0xFF	; 255
     f32:	7f 4f       	sbci	r23, 0xFF	; 255
     f34:	8f 4f       	sbci	r24, 0xFF	; 255
     f36:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     f38:	0f e0       	ldi	r16, 0x0F	; 15
     f3a:	58 d7       	rcall	.+3760   	; 0x1dec <__ashrdi3>
     f3c:	2e 87       	std	Y+14, r18	; 0x0e
     f3e:	3f 87       	std	Y+15, r19	; 0x0f
     f40:	48 8b       	std	Y+16, r20	; 0x10
     f42:	59 8b       	std	Y+17, r21	; 0x11
     f44:	6a 8b       	std	Y+18, r22	; 0x12
     f46:	7b 8b       	std	Y+19, r23	; 0x13
     f48:	8c 8b       	std	Y+20, r24	; 0x14
     f4a:	9d 8b       	std	Y+21, r25	; 0x15
     f4c:	30 91 72 03 	lds	r19, 0x0372	; 0x800372 <dig_H6+0x1>
     f50:	20 91 71 03 	lds	r18, 0x0371	; 0x800371 <dig_H6>
     f54:	93 2f       	mov	r25, r19
     f56:	99 0f       	add	r25, r25
     f58:	99 0b       	sbc	r25, r25
     f5a:	af 88       	ldd	r10, Y+23	; 0x17
     f5c:	be 88       	ldd	r11, Y+22	; 0x16
     f5e:	c9 80       	ldd	r12, Y+1	; 0x01
     f60:	d9 84       	ldd	r13, Y+9	; 0x09
     f62:	ea 84       	ldd	r14, Y+10	; 0x0a
     f64:	fb 84       	ldd	r15, Y+11	; 0x0b
     f66:	0c 85       	ldd	r16, Y+12	; 0x0c
     f68:	1d 85       	ldd	r17, Y+13	; 0x0d
     f6a:	49 2f       	mov	r20, r25
     f6c:	59 2f       	mov	r21, r25
     f6e:	69 2f       	mov	r22, r25
     f70:	79 2f       	mov	r23, r25
     f72:	89 2f       	mov	r24, r25
     f74:	01 d6       	rcall	.+3074   	; 0x1b78 <__muldi3>
     f76:	0a e0       	ldi	r16, 0x0A	; 10
     f78:	39 d7       	rcall	.+3698   	; 0x1dec <__ashrdi3>
     f7a:	82 2e       	mov	r8, r18
     f7c:	93 2e       	mov	r9, r19
     f7e:	74 2e       	mov	r7, r20
     f80:	65 2e       	mov	r6, r21
     f82:	56 2e       	mov	r5, r22
     f84:	47 2e       	mov	r4, r23
     f86:	38 2e       	mov	r3, r24
     f88:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     f8a:	40 91 b3 03 	lds	r20, 0x03B3	; 0x8003b3 <dig_H3>
     f8e:	50 91 b4 03 	lds	r21, 0x03B4	; 0x8003b4 <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     f92:	0c 85       	ldd	r16, Y+12	; 0x0c
     f94:	24 2f       	mov	r18, r20
     f96:	35 2f       	mov	r19, r21
     f98:	40 e0       	ldi	r20, 0x00	; 0
     f9a:	50 e0       	ldi	r21, 0x00	; 0
     f9c:	60 e0       	ldi	r22, 0x00	; 0
     f9e:	70 e0       	ldi	r23, 0x00	; 0
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	e9 d5       	rcall	.+3026   	; 0x1b78 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     fa6:	0b e0       	ldi	r16, 0x0B	; 11
     fa8:	21 d7       	rcall	.+3650   	; 0x1dec <__ashrdi3>
     faa:	30 58       	subi	r19, 0x80	; 128
     fac:	4f 4f       	sbci	r20, 0xFF	; 255
     fae:	5f 4f       	sbci	r21, 0xFF	; 255
     fb0:	6f 4f       	sbci	r22, 0xFF	; 255
     fb2:	7f 4f       	sbci	r23, 0xFF	; 255
     fb4:	8f 4f       	sbci	r24, 0xFF	; 255
     fb6:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     fb8:	a2 2e       	mov	r10, r18
     fba:	b3 2e       	mov	r11, r19
     fbc:	c4 2e       	mov	r12, r20
     fbe:	d5 2e       	mov	r13, r21
     fc0:	e6 2e       	mov	r14, r22
     fc2:	f7 2e       	mov	r15, r23
     fc4:	08 2f       	mov	r16, r24
     fc6:	19 2f       	mov	r17, r25
     fc8:	28 2d       	mov	r18, r8
     fca:	39 2d       	mov	r19, r9
     fcc:	47 2d       	mov	r20, r7
     fce:	56 2d       	mov	r21, r6
     fd0:	65 2d       	mov	r22, r5
     fd2:	74 2d       	mov	r23, r4
     fd4:	83 2d       	mov	r24, r3
     fd6:	92 2d       	mov	r25, r2
     fd8:	cf d5       	rcall	.+2974   	; 0x1b78 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     fda:	0a e0       	ldi	r16, 0x0A	; 10
     fdc:	07 d7       	rcall	.+3598   	; 0x1dec <__ashrdi3>
     fde:	40 5e       	subi	r20, 0xE0	; 224
     fe0:	5f 4f       	sbci	r21, 0xFF	; 255
     fe2:	6f 4f       	sbci	r22, 0xFF	; 255
     fe4:	7f 4f       	sbci	r23, 0xFF	; 255
     fe6:	8f 4f       	sbci	r24, 0xFF	; 255
     fe8:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
     fea:	b0 90 c0 03 	lds	r11, 0x03C0	; 0x8003c0 <dig_H2+0x1>
     fee:	a0 90 bf 03 	lds	r10, 0x03BF	; 0x8003bf <dig_H2>
     ff2:	1b 2d       	mov	r17, r11
     ff4:	11 0f       	add	r17, r17
     ff6:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     ff8:	c1 2e       	mov	r12, r17
     ffa:	d1 2e       	mov	r13, r17
     ffc:	e1 2e       	mov	r14, r17
     ffe:	f1 2e       	mov	r15, r17
    1000:	01 2f       	mov	r16, r17
    1002:	ba d5       	rcall	.+2932   	; 0x1b78 <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    1004:	30 5e       	subi	r19, 0xE0	; 224
    1006:	4f 4f       	sbci	r20, 0xFF	; 255
    1008:	5f 4f       	sbci	r21, 0xFF	; 255
    100a:	6f 4f       	sbci	r22, 0xFF	; 255
    100c:	7f 4f       	sbci	r23, 0xFF	; 255
    100e:	8f 4f       	sbci	r24, 0xFF	; 255
    1010:	9f 4f       	sbci	r25, 0xFF	; 255
    1012:	0e e0       	ldi	r16, 0x0E	; 14
    1014:	eb d6       	rcall	.+3542   	; 0x1dec <__ashrdi3>
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1016:	a2 2e       	mov	r10, r18
    1018:	b3 2e       	mov	r11, r19
    101a:	c4 2e       	mov	r12, r20
    101c:	d5 2e       	mov	r13, r21
    101e:	e6 2e       	mov	r14, r22
    1020:	f7 2e       	mov	r15, r23
    1022:	08 2f       	mov	r16, r24
    1024:	19 2f       	mov	r17, r25
    1026:	2e 85       	ldd	r18, Y+14	; 0x0e
    1028:	3f 85       	ldd	r19, Y+15	; 0x0f
    102a:	48 89       	ldd	r20, Y+16	; 0x10
    102c:	59 89       	ldd	r21, Y+17	; 0x11
    102e:	6a 89       	ldd	r22, Y+18	; 0x12
    1030:	7b 89       	ldd	r23, Y+19	; 0x13
    1032:	8c 89       	ldd	r24, Y+20	; 0x14
    1034:	9d 89       	ldd	r25, Y+21	; 0x15
    1036:	a0 d5       	rcall	.+2880   	; 0x1b78 <__muldi3>
    1038:	42 2e       	mov	r4, r18
    103a:	53 2e       	mov	r5, r19
    103c:	64 2e       	mov	r6, r20
    103e:	75 2e       	mov	r7, r21
    1040:	86 2e       	mov	r8, r22
    1042:	97 2e       	mov	r9, r23
    1044:	28 2e       	mov	r2, r24
    1046:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1048:	0f e0       	ldi	r16, 0x0F	; 15
    104a:	d0 d6       	rcall	.+3488   	; 0x1dec <__ashrdi3>
    104c:	a2 2e       	mov	r10, r18
    104e:	b3 2e       	mov	r11, r19
    1050:	c4 2e       	mov	r12, r20
    1052:	d5 2e       	mov	r13, r21
    1054:	e6 2e       	mov	r14, r22
    1056:	f7 2e       	mov	r15, r23
    1058:	08 2f       	mov	r16, r24
    105a:	19 2f       	mov	r17, r25
    105c:	8d d5       	rcall	.+2842   	; 0x1b78 <__muldi3>
    105e:	07 e0       	ldi	r16, 0x07	; 7
    1060:	c5 d6       	rcall	.+3466   	; 0x1dec <__ashrdi3>
    1062:	e0 91 5b 03 	lds	r30, 0x035B	; 0x80035b <dig_H1>
    1066:	f0 91 5c 03 	lds	r31, 0x035C	; 0x80035c <dig_H1+0x1>
    106a:	5f 01       	movw	r10, r30
    106c:	c1 2c       	mov	r12, r1
    106e:	d1 2c       	mov	r13, r1
    1070:	e1 2c       	mov	r14, r1
    1072:	f1 2c       	mov	r15, r1
    1074:	87 01       	movw	r16, r14
    1076:	e9 83       	std	Y+1, r30	; 0x01
    1078:	ba 82       	std	Y+2, r11	; 0x02
    107a:	cb 82       	std	Y+3, r12	; 0x03
    107c:	dc 82       	std	Y+4, r13	; 0x04
    107e:	ed 82       	std	Y+5, r14	; 0x05
    1080:	fe 82       	std	Y+6, r15	; 0x06
    1082:	0f 83       	std	Y+7, r16	; 0x07
    1084:	18 87       	std	Y+8, r17	; 0x08
    1086:	c1 2c       	mov	r12, r1
    1088:	d1 2c       	mov	r13, r1
    108a:	e1 2c       	mov	r14, r1
    108c:	f1 2c       	mov	r15, r1
    108e:	00 e0       	ldi	r16, 0x00	; 0
    1090:	10 e0       	ldi	r17, 0x00	; 0
    1092:	72 d5       	rcall	.+2788   	; 0x1b78 <__muldi3>
    1094:	04 e0       	ldi	r16, 0x04	; 4
    1096:	aa d6       	rcall	.+3412   	; 0x1dec <__ashrdi3>
    1098:	a2 2e       	mov	r10, r18
    109a:	b3 2e       	mov	r11, r19
    109c:	c4 2e       	mov	r12, r20
    109e:	d5 2e       	mov	r13, r21
    10a0:	e6 2e       	mov	r14, r22
    10a2:	f7 2e       	mov	r15, r23
    10a4:	08 2f       	mov	r16, r24
    10a6:	19 2f       	mov	r17, r25
    10a8:	24 2d       	mov	r18, r4
    10aa:	35 2d       	mov	r19, r5
    10ac:	46 2d       	mov	r20, r6
    10ae:	57 2d       	mov	r21, r7
    10b0:	68 2d       	mov	r22, r8
    10b2:	79 2d       	mov	r23, r9
    10b4:	82 2d       	mov	r24, r2
    10b6:	93 2d       	mov	r25, r3
    10b8:	c0 d6       	rcall	.+3456   	; 0x1e3a <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    10ba:	f2 2e       	mov	r15, r18
    10bc:	03 2f       	mov	r16, r19
    10be:	14 2f       	mov	r17, r20
    10c0:	65 2e       	mov	r6, r21
    10c2:	76 2e       	mov	r7, r22
    10c4:	b7 2f       	mov	r27, r23
    10c6:	f8 2f       	mov	r31, r24
    10c8:	e9 2f       	mov	r30, r25
    10ca:	a0 e0       	ldi	r26, 0x00	; 0
    10cc:	bf d6       	rcall	.+3454   	; 0x1e4c <__cmpdi2_s8>
    10ce:	44 f4       	brge	.+16     	; 0x10e0 <bme280_compensate_H_int32+0x2f4>
    10d0:	f1 2c       	mov	r15, r1
    10d2:	00 e0       	ldi	r16, 0x00	; 0
    10d4:	10 e0       	ldi	r17, 0x00	; 0
    10d6:	61 2c       	mov	r6, r1
    10d8:	71 2c       	mov	r7, r1
    10da:	b0 e0       	ldi	r27, 0x00	; 0
    10dc:	f0 e0       	ldi	r31, 0x00	; 0
    10de:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    10e0:	8f 2c       	mov	r8, r15
    10e2:	90 2e       	mov	r9, r16
    10e4:	a1 2e       	mov	r10, r17
    10e6:	b6 2c       	mov	r11, r6
    10e8:	c7 2c       	mov	r12, r7
    10ea:	db 2e       	mov	r13, r27
    10ec:	ef 2e       	mov	r14, r31
    10ee:	ae 2f       	mov	r26, r30
    10f0:	2f 2d       	mov	r18, r15
    10f2:	30 2f       	mov	r19, r16
    10f4:	41 2f       	mov	r20, r17
    10f6:	56 2d       	mov	r21, r6
    10f8:	67 2d       	mov	r22, r7
    10fa:	7b 2f       	mov	r23, r27
    10fc:	8f 2f       	mov	r24, r31
    10fe:	9e 2f       	mov	r25, r30
    1100:	21 15       	cp	r18, r1
    1102:	31 05       	cpc	r19, r1
    1104:	41 05       	cpc	r20, r1
    1106:	59 41       	sbci	r21, 0x19	; 25
    1108:	61 05       	cpc	r22, r1
    110a:	71 05       	cpc	r23, r1
    110c:	81 05       	cpc	r24, r1
    110e:	91 05       	cpc	r25, r1
    1110:	61 f0       	breq	.+24     	; 0x112a <bme280_compensate_H_int32+0x33e>
    1112:	5c f0       	brlt	.+22     	; 0x112a <bme280_compensate_H_int32+0x33e>
    1114:	81 2c       	mov	r8, r1
    1116:	91 2c       	mov	r9, r1
    1118:	a1 2c       	mov	r10, r1
    111a:	0f 2e       	mov	r0, r31
    111c:	f9 e1       	ldi	r31, 0x19	; 25
    111e:	bf 2e       	mov	r11, r31
    1120:	f0 2d       	mov	r31, r0
    1122:	c1 2c       	mov	r12, r1
    1124:	d1 2c       	mov	r13, r1
    1126:	e1 2c       	mov	r14, r1
    1128:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    112a:	28 2d       	mov	r18, r8
    112c:	39 2d       	mov	r19, r9
    112e:	4a 2d       	mov	r20, r10
    1130:	5b 2d       	mov	r21, r11
    1132:	6c 2d       	mov	r22, r12
    1134:	7d 2d       	mov	r23, r13
    1136:	8e 2d       	mov	r24, r14
    1138:	9a 2f       	mov	r25, r26
    113a:	0c e0       	ldi	r16, 0x0C	; 12
    113c:	57 d6       	rcall	.+3246   	; 0x1dec <__ashrdi3>
    113e:	62 2f       	mov	r22, r18
    1140:	73 2f       	mov	r23, r19
    1142:	84 2f       	mov	r24, r20
    1144:	95 2f       	mov	r25, r21
}
    1146:	67 96       	adiw	r28, 0x17	; 23
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	f8 94       	cli
    114c:	de bf       	out	0x3e, r29	; 62
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	cd bf       	out	0x3d, r28	; 61
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	1f 91       	pop	r17
    1158:	0f 91       	pop	r16
    115a:	ff 90       	pop	r15
    115c:	ef 90       	pop	r14
    115e:	df 90       	pop	r13
    1160:	cf 90       	pop	r12
    1162:	bf 90       	pop	r11
    1164:	af 90       	pop	r10
    1166:	9f 90       	pop	r9
    1168:	8f 90       	pop	r8
    116a:	7f 90       	pop	r7
    116c:	6f 90       	pop	r6
    116e:	5f 90       	pop	r5
    1170:	4f 90       	pop	r4
    1172:	3f 90       	pop	r3
    1174:	2f 90       	pop	r2
    1176:	08 95       	ret

00001178 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
    1178:	87 e0       	ldi	r24, 0x07	; 7
    117a:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
    117c:	85 b1       	in	r24, 0x05	; 5
    117e:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
    1180:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
    1182:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
    1184:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
    1186:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
    1188:	41 9a       	sbi	0x08, 1	; 8
    118a:	08 95       	ret

0000118c <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
    1190:	2f ef       	ldi	r18, 0xFF	; 255
    1192:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
    1194:	fc 01       	movw	r30, r24
    1196:	ee 0f       	add	r30, r30
    1198:	ff 1f       	adc	r31, r31
    119a:	ee 0f       	add	r30, r30
    119c:	ff 1f       	adc	r31, r31
    119e:	ec 5e       	subi	r30, 0xEC	; 236
    11a0:	fc 4f       	sbci	r31, 0xFC	; 252
    11a2:	11 82       	std	Z+1, r1	; 0x01
    11a4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
    11a6:	33 83       	std	Z+3, r19	; 0x03
    11a8:	22 83       	std	Z+2, r18	; 0x02
    11aa:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
    11ac:	85 30       	cpi	r24, 0x05	; 5
    11ae:	91 05       	cpc	r25, r1
    11b0:	89 f7       	brne	.-30     	; 0x1194 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
    11b2:	08 95       	ret

000011b4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
    11b4:	ef 92       	push	r14
    11b6:	ff 92       	push	r15
    11b8:	0f 93       	push	r16
    11ba:	1f 93       	push	r17
    11bc:	cf 93       	push	r28
    11be:	df 93       	push	r29
    11c0:	0f 2e       	mov	r0, r31
    11c2:	fa ee       	ldi	r31, 0xEA	; 234
    11c4:	ef 2e       	mov	r14, r31
    11c6:	f2 e0       	ldi	r31, 0x02	; 2
    11c8:	ff 2e       	mov	r15, r31
    11ca:	f0 2d       	mov	r31, r0
    11cc:	00 e0       	ldi	r16, 0x00	; 0
    11ce:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
    11d0:	c7 01       	movw	r24, r14
    11d2:	0e 94 ee 11 	call	0x23dc	; 0x23dc <eeprom_read_word>
    11d6:	e8 01       	movw	r28, r16
    11d8:	cc 0f       	add	r28, r28
    11da:	dd 1f       	adc	r29, r29
    11dc:	cc 0f       	add	r28, r28
    11de:	dd 1f       	adc	r29, r29
    11e0:	cc 5e       	subi	r28, 0xEC	; 236
    11e2:	dc 4f       	sbci	r29, 0xFC	; 252
    11e4:	99 83       	std	Y+1, r25	; 0x01
    11e6:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
    11e8:	c7 01       	movw	r24, r14
    11ea:	02 96       	adiw	r24, 0x02	; 2
    11ec:	0e 94 ee 11 	call	0x23dc	; 0x23dc <eeprom_read_word>
    11f0:	9b 83       	std	Y+3, r25	; 0x03
    11f2:	8a 83       	std	Y+2, r24	; 0x02
    11f4:	0f 5f       	subi	r16, 0xFF	; 255
    11f6:	1f 4f       	sbci	r17, 0xFF	; 255
    11f8:	84 e0       	ldi	r24, 0x04	; 4
    11fa:	e8 0e       	add	r14, r24
    11fc:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
    11fe:	05 30       	cpi	r16, 0x05	; 5
    1200:	11 05       	cpc	r17, r1
    1202:	31 f7       	brne	.-52     	; 0x11d0 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	1f 91       	pop	r17
    120a:	0f 91       	pop	r16
    120c:	ff 90       	pop	r15
    120e:	ef 90       	pop	r14
    1210:	08 95       	ret

00001212 <gas_sensors_init>:

void gas_sensors_init(void)
{
    1212:	af 92       	push	r10
    1214:	bf 92       	push	r11
    1216:	cf 92       	push	r12
    1218:	df 92       	push	r13
    121a:	ef 92       	push	r14
    121c:	ff 92       	push	r15
    121e:	0f 93       	push	r16
    1220:	1f 93       	push	r17
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	1f 92       	push	r1
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
    122c:	10 92 a8 03 	sts	0x03A8, r1	; 0x8003a8 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
    1230:	10 92 77 03 	sts	0x0377, r1	; 0x800377 <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
    1234:	bf df       	rcall	.-130    	; 0x11b4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
    1236:	aa df       	rcall	.-172    	; 0x118c <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    1238:	ea e7       	ldi	r30, 0x7A	; 122
    123a:	f0 e0       	ldi	r31, 0x00	; 0
    123c:	80 81       	ld	r24, Z
    123e:	80 68       	ori	r24, 0x80	; 128
    1240:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1242:	19 82       	std	Y+1, r1	; 0x01
    1244:	89 81       	ldd	r24, Y+1	; 0x01
    1246:	85 30       	cpi	r24, 0x05	; 5
    1248:	08 f0       	brcs	.+2      	; 0x124c <gas_sensors_init+0x3a>
    124a:	52 c0       	rjmp	.+164    	; 0x12f0 <gas_sensors_init+0xde>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
    124c:	0a e7       	ldi	r16, 0x7A	; 122
    124e:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    1250:	0f 2e       	mov	r0, r31
    1252:	f8 e7       	ldi	r31, 0x78	; 120
    1254:	ef 2e       	mov	r14, r31
    1256:	f1 2c       	mov	r15, r1
    1258:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    125a:	bb 24       	eor	r11, r11
    125c:	b3 94       	inc	r11
    125e:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    1260:	cc 24       	eor	r12, r12
    1262:	c3 94       	inc	r12
    1264:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
    126c:	f8 01       	movw	r30, r16
    126e:	80 81       	ld	r24, Z
    1270:	80 64       	ori	r24, 0x40	; 64
    1272:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
    1274:	f8 01       	movw	r30, r16
    1276:	80 81       	ld	r24, Z
    1278:	84 ff       	sbrs	r24, 4
    127a:	fc cf       	rjmp	.-8      	; 0x1274 <gas_sensors_init+0x62>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    127c:	f7 01       	movw	r30, r14
    127e:	80 81       	ld	r24, Z
    1280:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    1282:	e9 81       	ldd	r30, Y+1	; 0x01
    1284:	f0 e0       	ldi	r31, 0x00	; 0
    1286:	ee 0f       	add	r30, r30
    1288:	ff 1f       	adc	r31, r31
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	ec 5e       	subi	r30, 0xEC	; 236
    1290:	fc 4f       	sbci	r31, 0xFC	; 252
    1292:	20 81       	ld	r18, Z
    1294:	31 81       	ldd	r19, Z+1	; 0x01
    1296:	e9 81       	ldd	r30, Y+1	; 0x01
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	ee 0f       	add	r30, r30
    129c:	ff 1f       	adc	r31, r31
    129e:	ee 0f       	add	r30, r30
    12a0:	ff 1f       	adc	r31, r31
    12a2:	ec 5e       	subi	r30, 0xEC	; 236
    12a4:	fc 4f       	sbci	r31, 0xFC	; 252
    12a6:	62 81       	ldd	r22, Z+2	; 0x02
    12a8:	73 81       	ldd	r23, Z+3	; 0x03
    12aa:	4b 2d       	mov	r20, r11
    12ac:	68 17       	cp	r22, r24
    12ae:	79 07       	cpc	r23, r25
    12b0:	08 f0       	brcs	.+2      	; 0x12b4 <gas_sensors_init+0xa2>
    12b2:	4a 2d       	mov	r20, r10
    12b4:	41 11       	cpse	r20, r1
    12b6:	07 c0       	rjmp	.+14     	; 0x12c6 <gas_sensors_init+0xb4>
    12b8:	4b 2d       	mov	r20, r11
    12ba:	82 17       	cp	r24, r18
    12bc:	93 07       	cpc	r25, r19
    12be:	08 f0       	brcs	.+2      	; 0x12c2 <gas_sensors_init+0xb0>
    12c0:	4a 2d       	mov	r20, r10
    12c2:	44 23       	and	r20, r20
    12c4:	71 f0       	breq	.+28     	; 0x12e2 <gas_sensors_init+0xd0>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    12c6:	99 81       	ldd	r25, Y+1	; 0x01
    12c8:	20 91 a8 03 	lds	r18, 0x03A8	; 0x8003a8 <gas_sensor_initialization_errors>
    12cc:	9d 5f       	subi	r25, 0xFD	; 253
    12ce:	a6 01       	movw	r20, r12
    12d0:	02 c0       	rjmp	.+4      	; 0x12d6 <gas_sensors_init+0xc4>
    12d2:	44 0f       	add	r20, r20
    12d4:	55 1f       	adc	r21, r21
    12d6:	9a 95       	dec	r25
    12d8:	e2 f7       	brpl	.-8      	; 0x12d2 <gas_sensors_init+0xc0>
    12da:	ca 01       	movw	r24, r20
    12dc:	82 2b       	or	r24, r18
    12de:	80 93 a8 03 	sts	0x03A8, r24	; 0x8003a8 <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    12e2:	89 81       	ldd	r24, Y+1	; 0x01
    12e4:	8f 5f       	subi	r24, 0xFF	; 255
    12e6:	89 83       	std	Y+1, r24	; 0x01
    12e8:	89 81       	ldd	r24, Y+1	; 0x01
    12ea:	85 30       	cpi	r24, 0x05	; 5
    12ec:	08 f4       	brcc	.+2      	; 0x12f0 <gas_sensors_init+0xde>
    12ee:	bb cf       	rjmp	.-138    	; 0x1266 <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
    12f0:	ea e7       	ldi	r30, 0x7A	; 122
    12f2:	f0 e0       	ldi	r31, 0x00	; 0
    12f4:	80 81       	ld	r24, Z
    12f6:	8f 77       	andi	r24, 0x7F	; 127
    12f8:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
    12fa:	0f 90       	pop	r0
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	df 90       	pop	r13
    130a:	cf 90       	pop	r12
    130c:	bf 90       	pop	r11
    130e:	af 90       	pop	r10
    1310:	08 95       	ret

00001312 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
    1312:	8f 92       	push	r8
    1314:	9f 92       	push	r9
    1316:	af 92       	push	r10
    1318:	bf 92       	push	r11
    131a:	cf 92       	push	r12
    131c:	df 92       	push	r13
    131e:	ef 92       	push	r14
    1320:	ff 92       	push	r15
    1322:	0f 93       	push	r16
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	00 d0       	rcall	.+0      	; 0x132c <start_gas_sensor_read+0x1a>
    132c:	1f 92       	push	r1
    132e:	cd b7       	in	r28, 0x3d	; 61
    1330:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    1332:	ea e7       	ldi	r30, 0x7A	; 122
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	80 81       	ld	r24, Z
    1338:	80 68       	ori	r24, 0x80	; 128
    133a:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    133c:	19 82       	std	Y+1, r1	; 0x01
    133e:	89 81       	ldd	r24, Y+1	; 0x01
    1340:	85 30       	cpi	r24, 0x05	; 5
    1342:	08 f0       	brcs	.+2      	; 0x1346 <start_gas_sensor_read+0x34>
    1344:	77 c0       	rjmp	.+238    	; 0x1434 <start_gas_sensor_read+0x122>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
    1346:	68 94       	set
    1348:	88 24       	eor	r8, r8
    134a:	82 f8       	bld	r8, 2
    134c:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    134e:	0a e7       	ldi	r16, 0x7A	; 122
    1350:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    1352:	0f 2e       	mov	r0, r31
    1354:	f8 e7       	ldi	r31, 0x78	; 120
    1356:	ef 2e       	mov	r14, r31
    1358:	f1 2c       	mov	r15, r1
    135a:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    135c:	cc 24       	eor	r12, r12
    135e:	c3 94       	inc	r12
    1360:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    1362:	bb 24       	eor	r11, r11
    1364:	b3 94       	inc	r11
    1366:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    1368:	89 81       	ldd	r24, Y+1	; 0x01
    136a:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
		total = 0;	// re-zero the average
    136e:	1b 82       	std	Y+3, r1	; 0x03
    1370:	1a 82       	std	Y+2, r1	; 0x02
    1372:	28 2d       	mov	r18, r8
    1374:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    1376:	f8 01       	movw	r30, r16
    1378:	80 81       	ld	r24, Z
    137a:	80 64       	ori	r24, 0x40	; 64
    137c:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
    137e:	f8 01       	movw	r30, r16
    1380:	80 81       	ld	r24, Z
    1382:	84 ff       	sbrs	r24, 4
    1384:	fc cf       	rjmp	.-8      	; 0x137e <start_gas_sensor_read+0x6c>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    1386:	f7 01       	movw	r30, r14
    1388:	80 81       	ld	r24, Z
    138a:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    138c:	e9 81       	ldd	r30, Y+1	; 0x01
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	ee 0f       	add	r30, r30
    1392:	ff 1f       	adc	r31, r31
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	ec 5e       	subi	r30, 0xEC	; 236
    139a:	fc 4f       	sbci	r31, 0xFC	; 252
    139c:	40 81       	ld	r20, Z
    139e:	51 81       	ldd	r21, Z+1	; 0x01
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	f0 e0       	ldi	r31, 0x00	; 0
    13a4:	ee 0f       	add	r30, r30
    13a6:	ff 1f       	adc	r31, r31
    13a8:	ee 0f       	add	r30, r30
    13aa:	ff 1f       	adc	r31, r31
    13ac:	ec 5e       	subi	r30, 0xEC	; 236
    13ae:	fc 4f       	sbci	r31, 0xFC	; 252
    13b0:	62 81       	ldd	r22, Z+2	; 0x02
    13b2:	73 81       	ldd	r23, Z+3	; 0x03
    13b4:	eb 2d       	mov	r30, r11
    13b6:	68 17       	cp	r22, r24
    13b8:	79 07       	cpc	r23, r25
    13ba:	08 f0       	brcs	.+2      	; 0x13be <start_gas_sensor_read+0xac>
    13bc:	ea 2d       	mov	r30, r10
    13be:	e1 11       	cpse	r30, r1
    13c0:	07 c0       	rjmp	.+14     	; 0x13d0 <start_gas_sensor_read+0xbe>
    13c2:	6b 2d       	mov	r22, r11
    13c4:	84 17       	cp	r24, r20
    13c6:	95 07       	cpc	r25, r21
    13c8:	08 f0       	brcs	.+2      	; 0x13cc <start_gas_sensor_read+0xba>
    13ca:	6a 2d       	mov	r22, r10
    13cc:	66 23       	and	r22, r22
    13ce:	71 f0       	breq	.+28     	; 0x13ec <start_gas_sensor_read+0xda>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    13d0:	59 81       	ldd	r21, Y+1	; 0x01
    13d2:	60 91 a8 03 	lds	r22, 0x03A8	; 0x8003a8 <gas_sensor_initialization_errors>
    13d6:	5d 5f       	subi	r21, 0xFD	; 253
    13d8:	f6 01       	movw	r30, r12
    13da:	02 c0       	rjmp	.+4      	; 0x13e0 <start_gas_sensor_read+0xce>
    13dc:	ee 0f       	add	r30, r30
    13de:	ff 1f       	adc	r31, r31
    13e0:	5a 95       	dec	r21
    13e2:	e2 f7       	brpl	.-8      	; 0x13dc <start_gas_sensor_read+0xca>
    13e4:	af 01       	movw	r20, r30
    13e6:	46 2b       	or	r20, r22
    13e8:	40 93 a8 03 	sts	0x03A8, r20	; 0x8003a8 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
    13ec:	4a 81       	ldd	r20, Y+2	; 0x02
    13ee:	5b 81       	ldd	r21, Y+3	; 0x03
    13f0:	84 0f       	add	r24, r20
    13f2:	95 1f       	adc	r25, r21
    13f4:	9b 83       	std	Y+3, r25	; 0x03
    13f6:	8a 83       	std	Y+2, r24	; 0x02
    13f8:	21 50       	subi	r18, 0x01	; 1
    13fa:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
    13fc:	09 f0       	breq	.+2      	; 0x1400 <start_gas_sensor_read+0xee>
    13fe:	bb cf       	rjmp	.-138    	; 0x1376 <start_gas_sensor_read+0x64>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
    1400:	8a 81       	ldd	r24, Y+2	; 0x02
    1402:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
    1404:	e9 81       	ldd	r30, Y+1	; 0x01
    1406:	f0 e0       	ldi	r31, 0x00	; 0
    1408:	ee 0f       	add	r30, r30
    140a:	ff 1f       	adc	r31, r31
    140c:	e8 58       	subi	r30, 0x88	; 136
    140e:	fc 4f       	sbci	r31, 0xFC	; 252
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
    1410:	9c 01       	movw	r18, r24
    1412:	99 23       	and	r25, r25
    1414:	14 f4       	brge	.+4      	; 0x141a <start_gas_sensor_read+0x108>
    1416:	2d 5f       	subi	r18, 0xFD	; 253
    1418:	3f 4f       	sbci	r19, 0xFF	; 255
    141a:	35 95       	asr	r19
    141c:	27 95       	ror	r18
    141e:	35 95       	asr	r19
    1420:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
    1422:	31 83       	std	Z+1, r19	; 0x01
    1424:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1426:	89 81       	ldd	r24, Y+1	; 0x01
    1428:	8f 5f       	subi	r24, 0xFF	; 255
    142a:	89 83       	std	Y+1, r24	; 0x01
    142c:	89 81       	ldd	r24, Y+1	; 0x01
    142e:	85 30       	cpi	r24, 0x05	; 5
    1430:	08 f4       	brcc	.+2      	; 0x1434 <start_gas_sensor_read+0x122>
    1432:	9a cf       	rjmp	.-204    	; 0x1368 <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
    1434:	0f 90       	pop	r0
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	df 91       	pop	r29
    143c:	cf 91       	pop	r28
    143e:	1f 91       	pop	r17
    1440:	0f 91       	pop	r16
    1442:	ff 90       	pop	r15
    1444:	ef 90       	pop	r14
    1446:	df 90       	pop	r13
    1448:	cf 90       	pop	r12
    144a:	bf 90       	pop	r11
    144c:	af 90       	pop	r10
    144e:	9f 90       	pop	r9
    1450:	8f 90       	pop	r8
    1452:	08 95       	ret

00001454 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
    1454:	1f 93       	push	r17
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
    145a:	e5 ec       	ldi	r30, 0xC5	; 197
    145c:	f3 e0       	ldi	r31, 0x03	; 3
    145e:	84 ec       	ldi	r24, 0xC4	; 196
    1460:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
    1462:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
    1464:	84 e0       	ldi	r24, 0x04	; 4
    1466:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
    1468:	63 e0       	ldi	r22, 0x03	; 3
    146a:	cf 01       	movw	r24, r30
    146c:	a7 d1       	rcall	.+846    	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
    146e:	a2 d1       	rcall	.+836    	; 0x17b4 <TWI_Transceiver_Busy>
    1470:	81 11       	cpse	r24, r1
    1472:	fd cf       	rjmp	.-6      	; 0x146e <LIDAR_distance+0x1a>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
    1474:	e5 ec       	ldi	r30, 0xC5	; 197
    1476:	f3 e0       	ldi	r31, 0x03	; 3
    1478:	84 ec       	ldi	r24, 0xC4	; 196
    147a:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
    147c:	81 e0       	ldi	r24, 0x01	; 1
    147e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
    1480:	62 e0       	ldi	r22, 0x02	; 2
    1482:	cf 01       	movw	r24, r30
    1484:	9b d1       	rcall	.+822    	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
    1486:	96 d1       	rcall	.+812    	; 0x17b4 <TWI_Transceiver_Busy>
    1488:	81 11       	cpse	r24, r1
    148a:	fd cf       	rjmp	.-6      	; 0x1486 <LIDAR_distance+0x32>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
    148c:	c5 ec       	ldi	r28, 0xC5	; 197
    148e:	d3 e0       	ldi	r29, 0x03	; 3
    1490:	15 ec       	ldi	r17, 0xC5	; 197
    1492:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
    1494:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
    1496:	62 e0       	ldi	r22, 0x02	; 2
    1498:	ce 01       	movw	r24, r28
    149a:	90 d1       	rcall	.+800    	; 0x17bc <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
    149c:	8b d1       	rcall	.+790    	; 0x17b4 <TWI_Transceiver_Busy>
    149e:	81 11       	cpse	r24, r1
    14a0:	fd cf       	rjmp	.-6      	; 0x149c <LIDAR_distance+0x48>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
    14a2:	62 e0       	ldi	r22, 0x02	; 2
    14a4:	ce 01       	movw	r24, r28
    14a6:	b6 d1       	rcall	.+876    	; 0x1814 <TWI_Get_Data_From_Transceiver>
    14a8:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
    14ac:	89 81       	ldd	r24, Y+1	; 0x01
    14ae:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
    14b2:	80 fd       	sbrc	r24, 0
    14b4:	ee cf       	rjmp	.-36     	; 0x1492 <LIDAR_distance+0x3e>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
    14b6:	e5 ec       	ldi	r30, 0xC5	; 197
    14b8:	f3 e0       	ldi	r31, 0x03	; 3
    14ba:	84 ec       	ldi	r24, 0xC4	; 196
    14bc:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
    14be:	8f e8       	ldi	r24, 0x8F	; 143
    14c0:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
    14c2:	62 e0       	ldi	r22, 0x02	; 2
    14c4:	cf 01       	movw	r24, r30
    14c6:	7a d1       	rcall	.+756    	; 0x17bc <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
    14c8:	75 d1       	rcall	.+746    	; 0x17b4 <TWI_Transceiver_Busy>
    14ca:	81 11       	cpse	r24, r1
    14cc:	fd cf       	rjmp	.-6      	; 0x14c8 <LIDAR_distance+0x74>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
    14ce:	e5 ec       	ldi	r30, 0xC5	; 197
    14d0:	f3 e0       	ldi	r31, 0x03	; 3
    14d2:	85 ec       	ldi	r24, 0xC5	; 197
    14d4:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
    14d6:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
    14d8:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
    14da:	63 e0       	ldi	r22, 0x03	; 3
    14dc:	cf 01       	movw	r24, r30
    14de:	6e d1       	rcall	.+732    	; 0x17bc <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
    14e0:	69 d1       	rcall	.+722    	; 0x17b4 <TWI_Transceiver_Busy>
    14e2:	81 11       	cpse	r24, r1
    14e4:	fd cf       	rjmp	.-6      	; 0x14e0 <LIDAR_distance+0x8c>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
    14e6:	63 e0       	ldi	r22, 0x03	; 3
    14e8:	85 ec       	ldi	r24, 0xC5	; 197
    14ea:	93 e0       	ldi	r25, 0x03	; 3
    14ec:	93 d1       	rcall	.+806    	; 0x1814 <TWI_Get_Data_From_Transceiver>
    14ee:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
    14f2:	e5 ec       	ldi	r30, 0xC5	; 197
    14f4:	f3 e0       	ldi	r31, 0x03	; 3
    14f6:	81 81       	ldd	r24, Z+1	; 0x01
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	98 2f       	mov	r25, r24
    14fc:	88 27       	eor	r24, r24
    14fe:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
    1500:	82 0f       	add	r24, r18
    1502:	91 1d       	adc	r25, r1
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	1f 91       	pop	r17
    150a:	08 95       	ret

0000150c <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    150c:	35 de       	rcall	.-918    	; 0x1178 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    150e:	10 92 db 03 	sts	0x03DB, r1	; 0x8003db <seconds+0x1>
    1512:	10 92 da 03 	sts	0x03DA, r1	; 0x8003da <seconds>
	ItsTime=0;
    1516:	10 92 13 03 	sts	0x0313, r1	; 0x800313 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
    151a:	8b e2       	ldi	r24, 0x2B	; 43
    151c:	91 e0       	ldi	r25, 0x01	; 1
    151e:	90 93 df 05 	sts	0x05DF, r25	; 0x8005df <__iob+0x3>
    1522:	80 93 de 05 	sts	0x05DE, r24	; 0x8005de <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
    1526:	1c d1       	rcall	.+568    	; 0x1760 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    1528:	81 e8       	ldi	r24, 0x81	; 129
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	16 d2       	rcall	.+1068   	; 0x195a <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
    152e:	81 e8       	ldi	r24, 0x81	; 129
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	90 d2       	rcall	.+1312   	; 0x1a54 <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    1534:	35 d1       	rcall	.+618    	; 0x17a0 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    1536:	0e 94 c1 00 	call	0x182	; 0x182 <ADC_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
    153a:	6b de       	rcall	.-810    	; 0x1212 <gas_sensors_init>
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
    153c:	2a 9a       	sbi	0x05, 2	; 5
	ClearBit(PORTB, PORTB2);
    153e:	2a 98       	cbi	0x05, 2	; 5
	// 
	// Start all interrupts
	sei();
    1540:	78 94       	sei
	//
	// Initialize and check the BME interface...
	bme280basic_init();
    1542:	08 d8       	rcall	.-4080   	; 0x554 <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	91 e0       	ldi	r25, 0x01	; 1
    1548:	48 d2       	rcall	.+1168   	; 0x19da <USART0_putstring>
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
    154a:	0f 2e       	mov	r0, r31
    154c:	fa e3       	ldi	r31, 0x3A	; 58
    154e:	af 2e       	mov	r10, r31
    1550:	f1 e0       	ldi	r31, 0x01	; 1
    1552:	bf 2e       	mov	r11, r31
    1554:	f0 2d       	mov	r31, r0
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    1556:	0f 2e       	mov	r0, r31
    1558:	fc ed       	ldi	r31, 0xDC	; 220
    155a:	cf 2e       	mov	r12, r31
    155c:	f4 e0       	ldi	r31, 0x04	; 4
    155e:	df 2e       	mov	r13, r31
    1560:	f0 2d       	mov	r31, r0
    1562:	0f 2e       	mov	r0, r31
    1564:	f8 e4       	ldi	r31, 0x48	; 72
    1566:	ef 2e       	mov	r14, r31
    1568:	f1 e0       	ldi	r31, 0x01	; 1
    156a:	ff 2e       	mov	r15, r31
    156c:	f0 2d       	mov	r31, r0
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
 			printf("LIDAR distance = %u", distance);
    156e:	0c e4       	ldi	r16, 0x4C	; 76
    1570:	11 e0       	ldi	r17, 0x01	; 1
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1572:	c8 e7       	ldi	r28, 0x78	; 120
    1574:	d3 e0       	ldi	r29, 0x03	; 3
    1576:	0f 2e       	mov	r0, r31
    1578:	f0 e6       	ldi	r31, 0x60	; 96
    157a:	8f 2e       	mov	r8, r31
    157c:	f1 e0       	ldi	r31, 0x01	; 1
    157e:	9f 2e       	mov	r9, r31
    1580:	f0 2d       	mov	r31, r0
			while(UART0TransmitCompleteFlag != 0) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    1582:	0f 2e       	mov	r0, r31
    1584:	f9 e6       	ldi	r31, 0x69	; 105
    1586:	2f 2e       	mov	r2, r31
    1588:	f1 e0       	ldi	r31, 0x01	; 1
    158a:	3f 2e       	mov	r3, r31
    158c:	f0 2d       	mov	r31, r0
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
    158e:	80 91 13 03 	lds	r24, 0x0313	; 0x800313 <ItsTime>
    1592:	81 30       	cpi	r24, 0x01	; 1
    1594:	e1 f7       	brne	.-8      	; 0x158e <main+0x82>
			ItsTime = 0; 
    1596:	10 92 13 03 	sts	0x0313, r1	; 0x800313 <ItsTime>
			seconds++;
    159a:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <seconds>
    159e:	90 91 db 03 	lds	r25, 0x03DB	; 0x8003db <seconds+0x1>
    15a2:	01 96       	adiw	r24, 0x01	; 1
    15a4:	90 93 db 03 	sts	0x03DB, r25	; 0x8003db <seconds+0x1>
    15a8:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <seconds>
			printf("\nSeconds = %u", seconds);
    15ac:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <seconds>
    15b0:	90 91 db 03 	lds	r25, 0x03DB	; 0x8003db <seconds+0x1>
    15b4:	9f 93       	push	r25
    15b6:	8f 93       	push	r24
    15b8:	bf 92       	push	r11
    15ba:	af 92       	push	r10
    15bc:	62 d4       	rcall	.+2244   	; 0x1e82 <printf>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    15be:	df 92       	push	r13
    15c0:	cf 92       	push	r12
    15c2:	ff 92       	push	r15
    15c4:	ef 92       	push	r14
    15c6:	5d d4       	rcall	.+2234   	; 0x1e82 <printf>
			// Now we want to read each sensor - and send out the data,
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
    15c8:	45 df       	rcall	.-374    	; 0x1454 <LIDAR_distance>
    15ca:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <distance>
    15ce:	90 93 65 03 	sts	0x0365, r25	; 0x800365 <distance+0x1>
 			printf("LIDAR distance = %u", distance);
    15d2:	9f 93       	push	r25
    15d4:	8f 93       	push	r24
    15d6:	1f 93       	push	r17
    15d8:	0f 93       	push	r16
    15da:	53 d4       	rcall	.+2214   	; 0x1e82 <printf>
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    15dc:	9a de       	rcall	.-716    	; 0x1312 <start_gas_sensor_read>
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    15de:	89 81       	ldd	r24, Y+1	; 0x01
    15e0:	8f 93       	push	r24
    15e2:	88 81       	ld	r24, Y
    15e4:	8f 93       	push	r24
    15e6:	9f 92       	push	r9
    15e8:	8f 92       	push	r8
    15ea:	4b d4       	rcall	.+2198   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    15ec:	8b 81       	ldd	r24, Y+3	; 0x03
    15ee:	8f 93       	push	r24
    15f0:	8a 81       	ldd	r24, Y+2	; 0x02
    15f2:	8f 93       	push	r24
    15f4:	3f 92       	push	r3
    15f6:	2f 92       	push	r2
    15f8:	44 d4       	rcall	.+2184   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
 			printf("\nNA = %u", raw_gas_vector[2]);
    15fa:	8d 81       	ldd	r24, Y+5	; 0x05
    15fc:	8f 93       	push	r24
    15fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1600:	8f 93       	push	r24
    1602:	a1 e7       	ldi	r26, 0x71	; 113
    1604:	b1 e0       	ldi	r27, 0x01	; 1
    1606:	bf 93       	push	r27
    1608:	af 93       	push	r26
    160a:	3b d4       	rcall	.+2166   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {} 
 			printf("\nCH4 = %u", raw_gas_vector[3]);
    160c:	8f 81       	ldd	r24, Y+7	; 0x07
    160e:	8f 93       	push	r24
    1610:	8e 81       	ldd	r24, Y+6	; 0x06
    1612:	8f 93       	push	r24
    1614:	aa e7       	ldi	r26, 0x7A	; 122
    1616:	b1 e0       	ldi	r27, 0x01	; 1
    1618:	bf 93       	push	r27
    161a:	af 93       	push	r26
    161c:	32 d4       	rcall	.+2148   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
 			printf("\nO3 = %u", raw_gas_vector[4]);
    161e:	89 85       	ldd	r24, Y+9	; 0x09
    1620:	8f 93       	push	r24
    1622:	88 85       	ldd	r24, Y+8	; 0x08
    1624:	8f 93       	push	r24
    1626:	a4 e8       	ldi	r26, 0x84	; 132
    1628:	b1 e0       	ldi	r27, 0x01	; 1
    162a:	bf 93       	push	r27
    162c:	af 93       	push	r26
    162e:	29 d4       	rcall	.+2130   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
			//
			//============================
			// Now read the BME interface...
 			bme280basic_bulk_data_read();
    1630:	ad b7       	in	r26, 0x3d	; 61
    1632:	be b7       	in	r27, 0x3e	; 62
    1634:	90 96       	adiw	r26, 0x20	; 32
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	be bf       	out	0x3e, r27	; 62
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	ad bf       	out	0x3d, r26	; 61
    1640:	0e 94 13 03 	call	0x626	; 0x626 <bme280basic_bulk_data_read>
 			tempCelsius = BME280_compensate_T_int32(rawTemp);
    1644:	60 91 5e 03 	lds	r22, 0x035E	; 0x80035e <rawTemp>
    1648:	70 91 5f 03 	lds	r23, 0x035F	; 0x80035f <rawTemp+0x1>
    164c:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <rawTemp+0x2>
    1650:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <rawTemp+0x3>
    1654:	d5 d8       	rcall	.-3670   	; 0x800 <BME280_compensate_T_int32>
    1656:	60 93 57 03 	sts	0x0357, r22	; 0x800357 <tempCelsius>
    165a:	70 93 58 03 	sts	0x0358, r23	; 0x800358 <tempCelsius+0x1>
    165e:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <tempCelsius+0x2>
    1662:	90 93 5a 03 	sts	0x035A, r25	; 0x80035a <tempCelsius+0x3>
// 			sprintf(temperatureBuf, "%lu", tempCelsius);
  			printf("\nCelsius = %lu", tempCelsius);
    1666:	9f 93       	push	r25
    1668:	8f 93       	push	r24
    166a:	7f 93       	push	r23
    166c:	6f 93       	push	r22
    166e:	ad e8       	ldi	r26, 0x8D	; 141
    1670:	b1 e0       	ldi	r27, 0x01	; 1
    1672:	bf 93       	push	r27
    1674:	af 93       	push	r26
    1676:	05 d4       	rcall	.+2058   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
 			pressure = BME280_compensate_P_int64(rawPress);
    1678:	60 91 86 03 	lds	r22, 0x0386	; 0x800386 <rawPress>
    167c:	70 91 87 03 	lds	r23, 0x0387	; 0x800387 <rawPress+0x1>
    1680:	80 91 88 03 	lds	r24, 0x0388	; 0x800388 <rawPress+0x2>
    1684:	90 91 89 03 	lds	r25, 0x0389	; 0x800389 <rawPress+0x3>
    1688:	49 d9       	rcall	.-3438   	; 0x91c <BME280_compensate_P_int64>
    168a:	60 93 6b 03 	sts	0x036B, r22	; 0x80036b <pressure>
    168e:	70 93 6c 03 	sts	0x036C, r23	; 0x80036c <pressure+0x1>
    1692:	80 93 6d 03 	sts	0x036D, r24	; 0x80036d <pressure+0x2>
    1696:	90 93 6e 03 	sts	0x036E, r25	; 0x80036e <pressure+0x3>
 			printf("\nPressure in Pa = %lu", pressure>>8);
    169a:	bb 27       	eor	r27, r27
    169c:	97 fd       	sbrc	r25, 7
    169e:	ba 95       	dec	r27
    16a0:	a9 2f       	mov	r26, r25
    16a2:	98 2f       	mov	r25, r24
    16a4:	87 2f       	mov	r24, r23
    16a6:	bf 93       	push	r27
    16a8:	af 93       	push	r26
    16aa:	9f 93       	push	r25
    16ac:	8f 93       	push	r24
    16ae:	ac e9       	ldi	r26, 0x9C	; 156
    16b0:	b1 e0       	ldi	r27, 0x01	; 1
    16b2:	bf 93       	push	r27
    16b4:	af 93       	push	r26
    16b6:	e5 d3       	rcall	.+1994   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
 			humidity = bme280_compensate_H_int32(rawHum);
    16b8:	60 91 8a 03 	lds	r22, 0x038A	; 0x80038a <rawHum>
    16bc:	70 91 8b 03 	lds	r23, 0x038B	; 0x80038b <rawHum+0x1>
    16c0:	80 91 8c 03 	lds	r24, 0x038C	; 0x80038c <rawHum+0x2>
    16c4:	90 91 8d 03 	lds	r25, 0x038D	; 0x80038d <rawHum+0x3>
    16c8:	91 db       	rcall	.-2270   	; 0xdec <bme280_compensate_H_int32>
    16ca:	2b 01       	movw	r4, r22
    16cc:	3c 01       	movw	r6, r24
    16ce:	60 93 73 03 	sts	0x0373, r22	; 0x800373 <humidity>
    16d2:	70 93 74 03 	sts	0x0374, r23	; 0x800374 <humidity+0x1>
    16d6:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <humidity+0x2>
    16da:	90 93 76 03 	sts	0x0376, r25	; 0x800376 <humidity+0x3>
 			printf("\nHumidity%% = %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    16de:	a8 ee       	ldi	r26, 0xE8	; 232
    16e0:	b3 e0       	ldi	r27, 0x03	; 3
    16e2:	9b 01       	movw	r18, r22
    16e4:	ac 01       	movw	r20, r24
    16e6:	38 d2       	rcall	.+1136   	; 0x1b58 <__muluhisi3>
    16e8:	dc 01       	movw	r26, r24
    16ea:	cb 01       	movw	r24, r22
    16ec:	07 2e       	mov	r0, r23
    16ee:	7a e0       	ldi	r23, 0x0A	; 10
    16f0:	b5 95       	asr	r27
    16f2:	a7 95       	ror	r26
    16f4:	97 95       	ror	r25
    16f6:	87 95       	ror	r24
    16f8:	7a 95       	dec	r23
    16fa:	d1 f7       	brne	.-12     	; 0x16f0 <main+0x1e4>
    16fc:	70 2d       	mov	r23, r0
    16fe:	bf 93       	push	r27
    1700:	af 93       	push	r26
    1702:	9f 93       	push	r25
    1704:	8f 93       	push	r24
    1706:	d3 01       	movw	r26, r6
    1708:	c2 01       	movw	r24, r4
    170a:	07 2e       	mov	r0, r23
    170c:	7a e0       	ldi	r23, 0x0A	; 10
    170e:	b5 95       	asr	r27
    1710:	a7 95       	ror	r26
    1712:	97 95       	ror	r25
    1714:	87 95       	ror	r24
    1716:	7a 95       	dec	r23
    1718:	d1 f7       	brne	.-12     	; 0x170e <main+0x202>
    171a:	70 2d       	mov	r23, r0
    171c:	bf 93       	push	r27
    171e:	af 93       	push	r26
    1720:	9f 93       	push	r25
    1722:	8f 93       	push	r24
    1724:	a2 eb       	ldi	r26, 0xB2	; 178
    1726:	b1 e0       	ldi	r27, 0x01	; 1
    1728:	bf 93       	push	r27
    172a:	af 93       	push	r26
    172c:	aa d3       	rcall	.+1876   	; 0x1e82 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
    172e:	ad b7       	in	r26, 0x3d	; 61
    1730:	be b7       	in	r27, 0x3e	; 62
    1732:	56 96       	adiw	r26, 0x16	; 22
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	be bf       	out	0x3e, r27	; 62
    173a:	0f be       	out	0x3f, r0	; 63
    173c:	ad bf       	out	0x3d, r26	; 61
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
    173e:	e9 ec       	ldi	r30, 0xC9	; 201
    1740:	f0 e0       	ldi	r31, 0x00	; 0
    1742:	80 81       	ld	r24, Z
    1744:	80 69       	ori	r24, 0x90	; 144
    1746:	80 83       	st	Z, r24
    1748:	22 cf       	rjmp	.-444    	; 0x158e <main+0x82>

0000174a <__vector_default>:
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
    174a:	1f 92       	push	r1
    174c:	0f 92       	push	r0
    174e:	0f b6       	in	r0, 0x3f	; 63
    1750:	0f 92       	push	r0
    1752:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
    1754:	2a 9a       	sbi	0x05, 2	; 5
    1756:	0f 90       	pop	r0
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	0f 90       	pop	r0
    175c:	1f 90       	pop	r1
    175e:	18 95       	reti

00001760 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    1760:	8d e0       	ldi	r24, 0x0D	; 13
    1762:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    1766:	8a e4       	ldi	r24, 0x4A	; 74
    1768:	9c e4       	ldi	r25, 0x4C	; 76
    176a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    176e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    1772:	08 95       	ret

00001774 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    1774:	18 95       	reti

00001776 <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
    1776:	1f 92       	push	r1
    1778:	0f 92       	push	r0
    177a:	0f b6       	in	r0, 0x3f	; 63
    177c:	0f 92       	push	r0
    177e:	11 24       	eor	r1, r1
    1780:	8f 93       	push	r24
    1782:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    1784:	95 b1       	in	r25, 0x05	; 5
    1786:	82 e0       	ldi	r24, 0x02	; 2
    1788:	89 27       	eor	r24, r25
    178a:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    178c:	81 e0       	ldi	r24, 0x01	; 1
    178e:	80 93 13 03 	sts	0x0313, r24	; 0x800313 <ItsTime>
}
    1792:	9f 91       	pop	r25
    1794:	8f 91       	pop	r24
    1796:	0f 90       	pop	r0
    1798:	0f be       	out	0x3f, r0	; 63
    179a:	0f 90       	pop	r0
    179c:	1f 90       	pop	r1
    179e:	18 95       	reti

000017a0 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    17a0:	81 e1       	ldi	r24, 0x11	; 17
    17a2:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    17ac:	84 e0       	ldi	r24, 0x04	; 4
    17ae:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17b2:	08 95       	ret

000017b4 <TWI_Transceiver_Busy>:
    17b4:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17b8:	81 78       	andi	r24, 0x81	; 129
    17ba:	08 95       	ret

000017bc <TWI_Start_Transceiver_With_Data>:
    17bc:	cf 93       	push	r28
    17be:	df 93       	push	r29
    17c0:	ec 01       	movw	r28, r24
    17c2:	ec eb       	ldi	r30, 0xBC	; 188
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	90 81       	ld	r25, Z
    17c8:	91 78       	andi	r25, 0x81	; 129
    17ca:	e9 f7       	brne	.-6      	; 0x17c6 <TWI_Start_Transceiver_With_Data+0xa>
    17cc:	60 93 d0 01 	sts	0x01D0, r22	; 0x8001d0 <TWI_msgSize>
    17d0:	88 81       	ld	r24, Y
    17d2:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <TWI_buf>
    17d6:	80 fd       	sbrc	r24, 0
    17d8:	12 c0       	rjmp	.+36     	; 0x17fe <TWI_Start_Transceiver_With_Data+0x42>
    17da:	62 30       	cpi	r22, 0x02	; 2
    17dc:	80 f0       	brcs	.+32     	; 0x17fe <TWI_Start_Transceiver_With_Data+0x42>
    17de:	fe 01       	movw	r30, r28
    17e0:	31 96       	adiw	r30, 0x01	; 1
    17e2:	a2 ed       	ldi	r26, 0xD2	; 210
    17e4:	b1 e0       	ldi	r27, 0x01	; 1
    17e6:	62 50       	subi	r22, 0x02	; 2
    17e8:	26 2f       	mov	r18, r22
    17ea:	30 e0       	ldi	r19, 0x00	; 0
    17ec:	2e 5f       	subi	r18, 0xFE	; 254
    17ee:	3f 4f       	sbci	r19, 0xFF	; 255
    17f0:	2c 0f       	add	r18, r28
    17f2:	3d 1f       	adc	r19, r29
    17f4:	91 91       	ld	r25, Z+
    17f6:	9d 93       	st	X+, r25
    17f8:	e2 17       	cp	r30, r18
    17fa:	f3 07       	cpc	r31, r19
    17fc:	d9 f7       	brne	.-10     	; 0x17f4 <TWI_Start_Transceiver_With_Data+0x38>
    17fe:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <TWI_statusReg>
    1802:	88 ef       	ldi	r24, 0xF8	; 248
    1804:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    1808:	85 ea       	ldi	r24, 0xA5	; 165
    180a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	08 95       	ret

00001814 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1814:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1816:	ec eb       	ldi	r30, 0xBC	; 188
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	90 81       	ld	r25, Z
    181c:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    181e:	e9 f7       	brne	.-6      	; 0x181a <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1820:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    1824:	80 ff       	sbrs	r24, 0
    1826:	11 c0       	rjmp	.+34     	; 0x184a <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1828:	66 23       	and	r22, r22
    182a:	79 f0       	breq	.+30     	; 0x184a <TWI_Get_Data_From_Transceiver+0x36>
    182c:	a1 ed       	ldi	r26, 0xD1	; 209
    182e:	b1 e0       	ldi	r27, 0x01	; 1
    1830:	fa 01       	movw	r30, r20
    1832:	61 50       	subi	r22, 0x01	; 1
    1834:	26 2f       	mov	r18, r22
    1836:	30 e0       	ldi	r19, 0x00	; 0
    1838:	2f 5f       	subi	r18, 0xFF	; 255
    183a:	3f 4f       	sbci	r19, 0xFF	; 255
    183c:	24 0f       	add	r18, r20
    183e:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    1840:	9d 91       	ld	r25, X+
    1842:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1844:	e2 17       	cp	r30, r18
    1846:	f3 07       	cpc	r31, r19
    1848:	d9 f7       	brne	.-10     	; 0x1840 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    184a:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
}
    184e:	81 70       	andi	r24, 0x01	; 1
    1850:	08 95       	ret

00001852 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    1852:	1f 92       	push	r1
    1854:	0f 92       	push	r0
    1856:	0f b6       	in	r0, 0x3f	; 63
    1858:	0f 92       	push	r0
    185a:	11 24       	eor	r1, r1
    185c:	0b b6       	in	r0, 0x3b	; 59
    185e:	0f 92       	push	r0
    1860:	2f 93       	push	r18
    1862:	3f 93       	push	r19
    1864:	8f 93       	push	r24
    1866:	9f 93       	push	r25
    1868:	af 93       	push	r26
    186a:	bf 93       	push	r27
    186c:	ef 93       	push	r30
    186e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1870:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1874:	8e 2f       	mov	r24, r30
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	fc 01       	movw	r30, r24
    187a:	38 97       	sbiw	r30, 0x08	; 8
    187c:	e1 35       	cpi	r30, 0x51	; 81
    187e:	f1 05       	cpc	r31, r1
    1880:	08 f0       	brcs	.+2      	; 0x1884 <__vector_26+0x32>
    1882:	55 c0       	rjmp	.+170    	; 0x192e <__vector_26+0xdc>
    1884:	ea 5b       	subi	r30, 0xBA	; 186
    1886:	ff 4f       	sbci	r31, 0xFF	; 255
    1888:	5e c1       	rjmp	.+700    	; 0x1b46 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    188a:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    188e:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    1892:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    1896:	e8 17       	cp	r30, r24
    1898:	70 f4       	brcc	.+28     	; 0x18b6 <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    189a:	81 e0       	ldi	r24, 0x01	; 1
    189c:	8e 0f       	add	r24, r30
    189e:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1555>
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	ef 52       	subi	r30, 0x2F	; 47
    18a6:	fe 4f       	sbci	r31, 0xFE	; 254
    18a8:	80 81       	ld	r24, Z
    18aa:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18ae:	85 e8       	ldi	r24, 0x85	; 133
    18b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18b4:	43 c0       	rjmp	.+134    	; 0x193c <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    18b6:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    18ba:	81 60       	ori	r24, 0x01	; 1
    18bc:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18c0:	84 e9       	ldi	r24, 0x94	; 148
    18c2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18c6:	3a c0       	rjmp	.+116    	; 0x193c <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    18c8:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	8e 0f       	add	r24, r30
    18d0:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1555>
    18d4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    18d8:	f0 e0       	ldi	r31, 0x00	; 0
    18da:	ef 52       	subi	r30, 0x2F	; 47
    18dc:	fe 4f       	sbci	r31, 0xFE	; 254
    18de:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    18e0:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	28 17       	cp	r18, r24
    18f0:	39 07       	cpc	r19, r25
    18f2:	24 f4       	brge	.+8      	; 0x18fc <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18f4:	85 ec       	ldi	r24, 0xC5	; 197
    18f6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18fa:	20 c0       	rjmp	.+64     	; 0x193c <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18fc:	85 e8       	ldi	r24, 0x85	; 133
    18fe:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1902:	1c c0       	rjmp	.+56     	; 0x193c <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    1904:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1908:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    190c:	f0 e0       	ldi	r31, 0x00	; 0
    190e:	ef 52       	subi	r30, 0x2F	; 47
    1910:	fe 4f       	sbci	r31, 0xFE	; 254
    1912:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1914:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    1918:	81 60       	ori	r24, 0x01	; 1
    191a:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    191e:	84 e9       	ldi	r24, 0x94	; 148
    1920:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    1924:	0b c0       	rjmp	.+22     	; 0x193c <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1926:	85 ea       	ldi	r24, 0xA5	; 165
    1928:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    192c:	07 c0       	rjmp	.+14     	; 0x193c <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    192e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1932:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1936:	84 e0       	ldi	r24, 0x04	; 4
    1938:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    193c:	ff 91       	pop	r31
    193e:	ef 91       	pop	r30
    1940:	bf 91       	pop	r27
    1942:	af 91       	pop	r26
    1944:	9f 91       	pop	r25
    1946:	8f 91       	pop	r24
    1948:	3f 91       	pop	r19
    194a:	2f 91       	pop	r18
    194c:	0f 90       	pop	r0
    194e:	0b be       	out	0x3b, r0	; 59
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	0f 90       	pop	r0
    1956:	1f 90       	pop	r1
    1958:	18 95       	reti

0000195a <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    195a:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    195e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    1962:	88 e0       	ldi	r24, 0x08	; 8
    1964:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1968:	86 e0       	ldi	r24, 0x06	; 6
    196a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    196e:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <UART0_RxTail>
    1972:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <UART0_RxHead>
    1976:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <UART0_TxTail>
    197a:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <UART0_TxHead>
    197e:	08 95       	ret

00001980 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1980:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    1984:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1986:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    198a:	29 17       	cp	r18, r25
    198c:	e1 f3       	breq	.-8      	; 0x1986 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    198e:	e2 2f       	mov	r30, r18
    1990:	f0 e0       	ldi	r31, 0x00	; 0
    1992:	ed 51       	subi	r30, 0x1D	; 29
    1994:	fe 4f       	sbci	r31, 0xFE	; 254
    1996:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    1998:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    199c:	e1 ec       	ldi	r30, 0xC1	; 193
    199e:	f0 e0       	ldi	r31, 0x00	; 0
    19a0:	80 81       	ld	r24, Z
    19a2:	80 62       	ori	r24, 0x20	; 32
    19a4:	80 83       	st	Z, r24
    19a6:	08 95       	ret

000019a8 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	//Flag that the transmitting is not done yet
	UART0TransmitCompleteFlag = 1;
    19a8:	91 e0       	ldi	r25, 0x01	; 1
    19aa:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <UART0TransmitCompleteFlag>
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    19ae:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    19b2:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    19b4:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    19b8:	29 17       	cp	r18, r25
    19ba:	e1 f3       	breq	.-8      	; 0x19b4 <USART0_Transmit_IO+0xc>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    19bc:	e2 2f       	mov	r30, r18
    19be:	f0 e0       	ldi	r31, 0x00	; 0
    19c0:	ed 51       	subi	r30, 0x1D	; 29
    19c2:	fe 4f       	sbci	r31, 0xFE	; 254
    19c4:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    19c6:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    19ca:	e1 ec       	ldi	r30, 0xC1	; 193
    19cc:	f0 e0       	ldi	r31, 0x00	; 0
    19ce:	80 81       	ld	r24, Z
    19d0:	80 62       	ori	r24, 0x20	; 32
    19d2:	80 83       	st	Z, r24
	return(0);
}
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	08 95       	ret

000019da <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
    19de:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    19e0:	88 81       	ld	r24, Y
    19e2:	88 23       	and	r24, r24
    19e4:	29 f0       	breq	.+10     	; 0x19f0 <USART0_putstring+0x16>
    19e6:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    19e8:	cb df       	rcall	.-106    	; 0x1980 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    19ea:	89 91       	ld	r24, Y+
    19ec:	81 11       	cpse	r24, r1
    19ee:	fc cf       	rjmp	.-8      	; 0x19e8 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    19f0:	df 91       	pop	r29
    19f2:	cf 91       	pop	r28
    19f4:	08 95       	ret

000019f6 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    19f6:	1f 92       	push	r1
    19f8:	0f 92       	push	r0
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	0f 92       	push	r0
    19fe:	11 24       	eor	r1, r1
    1a00:	0b b6       	in	r0, 0x3b	; 59
    1a02:	0f 92       	push	r0
    1a04:	8f 93       	push	r24
    1a06:	9f 93       	push	r25
    1a08:	ef 93       	push	r30
    1a0a:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1a0c:	90 91 e2 01 	lds	r25, 0x01E2	; 0x8001e2 <UART0_TxHead>
    1a10:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1a14:	98 17       	cp	r25, r24
    1a16:	61 f0       	breq	.+24     	; 0x1a30 <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1a18:	e0 91 e1 01 	lds	r30, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1a1c:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1a1e:	e0 93 e1 01 	sts	0x01E1, r30	; 0x8001e1 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1a22:	f0 e0       	ldi	r31, 0x00	; 0
    1a24:	ed 51       	subi	r30, 0x1D	; 29
    1a26:	fe 4f       	sbci	r31, 0xFE	; 254
    1a28:	80 81       	ld	r24, Z
    1a2a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1a2e:	07 c0       	rjmp	.+14     	; 0x1a3e <__vector_21+0x48>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1a30:	e1 ec       	ldi	r30, 0xC1	; 193
    1a32:	f0 e0       	ldi	r31, 0x00	; 0
    1a34:	80 81       	ld	r24, Z
    1a36:	8f 7d       	andi	r24, 0xDF	; 223
    1a38:	80 83       	st	Z, r24
		//indicate transmission is complete
		UART0TransmitCompleteFlag = 0;
    1a3a:	10 92 e5 02 	sts	0x02E5, r1	; 0x8002e5 <UART0TransmitCompleteFlag>
	}
    1a3e:	ff 91       	pop	r31
    1a40:	ef 91       	pop	r30
    1a42:	9f 91       	pop	r25
    1a44:	8f 91       	pop	r24
    1a46:	0f 90       	pop	r0
    1a48:	0b be       	out	0x3b, r0	; 59
    1a4a:	0f 90       	pop	r0
    1a4c:	0f be       	out	0x3f, r0	; 63
    1a4e:	0f 90       	pop	r0
    1a50:	1f 90       	pop	r1
    1a52:	18 95       	reti

00001a54 <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1a54:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1a58:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1a5c:	80 e9       	ldi	r24, 0x90	; 144
    1a5e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1a62:	86 e0       	ldi	r24, 0x06	; 6
    1a64:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1a68:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxTail>
    1a6c:	10 92 e9 02 	sts	0x02E9, r1	; 0x8002e9 <UART1_RxHead>
    1a70:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <UART1_TxTail>
    1a74:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_TxHead>
    1a78:	08 95       	ret

00001a7a <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1a7a:	1f 92       	push	r1
    1a7c:	0f 92       	push	r0
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	0f 92       	push	r0
    1a82:	11 24       	eor	r1, r1
    1a84:	0b b6       	in	r0, 0x3b	; 59
    1a86:	0f 92       	push	r0
    1a88:	2f 93       	push	r18
    1a8a:	3f 93       	push	r19
    1a8c:	8f 93       	push	r24
    1a8e:	9f 93       	push	r25
    1a90:	af 93       	push	r26
    1a92:	bf 93       	push	r27
    1a94:	cf 93       	push	r28
    1a96:	df 93       	push	r29
    1a98:	ef 93       	push	r30
    1a9a:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1a9c:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1aa0:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <UART1_RxHead>
    1aa4:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1aa6:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1aaa:	20 91 e8 02 	lds	r18, 0x02E8	; 0x8002e8 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1aae:	e8 2f       	mov	r30, r24
    1ab0:	f0 e0       	ldi	r31, 0x00	; 0
    1ab2:	e4 52       	subi	r30, 0x24	; 36
    1ab4:	fc 4f       	sbci	r31, 0xFC	; 252
    1ab6:	90 83       	st	Z, r25
	
	if (data == 10)
    1ab8:	9a 30       	cpi	r25, 0x0A	; 10
    1aba:	29 f5       	brne	.+74     	; 0x1b06 <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1abc:	90 91 e1 03 	lds	r25, 0x03E1	; 0x8003e1 <UART1_RxBuf+0x5>
    1ac0:	97 34       	cpi	r25, 0x47	; 71
    1ac2:	e9 f4       	brne	.+58     	; 0x1afe <__vector_28+0x84>
    1ac4:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
    1ac6:	2e 2f       	mov	r18, r30
    1ac8:	30 e0       	ldi	r19, 0x00	; 0
    1aca:	d9 01       	movw	r26, r18
    1acc:	a4 52       	subi	r26, 0x24	; 36
    1ace:	bb 4f       	sbci	r27, 0xFB	; 251
    1ad0:	e9 01       	movw	r28, r18
    1ad2:	c4 52       	subi	r28, 0x24	; 36
    1ad4:	dc 4f       	sbci	r29, 0xFC	; 252
    1ad6:	99 81       	ldd	r25, Y+1	; 0x01
    1ad8:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1ada:	ef 5f       	subi	r30, 0xFF	; 255
    1adc:	8e 17       	cp	r24, r30
    1ade:	98 f7       	brcc	.-26     	; 0x1ac6 <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i]=0x00; //messageWant[i+1]=0x00;
    1ae0:	f0 e0       	ldi	r31, 0x00	; 0
    1ae2:	e4 52       	subi	r30, 0x24	; 36
    1ae4:	fb 4f       	sbci	r31, 0xFB	; 251
    1ae6:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1ae8:	e9 ec       	ldi	r30, 0xC9	; 201
    1aea:	f0 e0       	ldi	r31, 0x00	; 0
    1aec:	80 81       	ld	r24, Z
    1aee:	10 82       	st	Z, r1
 			ItsTime = 1;
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	80 93 13 03 	sts	0x0313, r24	; 0x800313 <ItsTime>
 			ToggleBit(PORTB, PORTB1);
    1af6:	95 b1       	in	r25, 0x05	; 5
    1af8:	82 e0       	ldi	r24, 0x02	; 2
    1afa:	89 27       	eor	r24, r25
    1afc:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1afe:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxTail>
		UART1_RxHead = 0;
    1b02:	10 92 e9 02 	sts	0x02E9, r1	; 0x8002e9 <UART1_RxHead>
	}
}
    1b06:	ff 91       	pop	r31
    1b08:	ef 91       	pop	r30
    1b0a:	df 91       	pop	r29
    1b0c:	cf 91       	pop	r28
    1b0e:	bf 91       	pop	r27
    1b10:	af 91       	pop	r26
    1b12:	9f 91       	pop	r25
    1b14:	8f 91       	pop	r24
    1b16:	3f 91       	pop	r19
    1b18:	2f 91       	pop	r18
    1b1a:	0f 90       	pop	r0
    1b1c:	0b be       	out	0x3b, r0	; 59
    1b1e:	0f 90       	pop	r0
    1b20:	0f be       	out	0x3f, r0	; 63
    1b22:	0f 90       	pop	r0
    1b24:	1f 90       	pop	r1
    1b26:	18 95       	reti

00001b28 <__mulsi3>:
    1b28:	db 01       	movw	r26, r22
    1b2a:	8f 93       	push	r24
    1b2c:	9f 93       	push	r25
    1b2e:	14 d0       	rcall	.+40     	; 0x1b58 <__muluhisi3>
    1b30:	bf 91       	pop	r27
    1b32:	af 91       	pop	r26
    1b34:	a2 9f       	mul	r26, r18
    1b36:	80 0d       	add	r24, r0
    1b38:	91 1d       	adc	r25, r1
    1b3a:	a3 9f       	mul	r26, r19
    1b3c:	90 0d       	add	r25, r0
    1b3e:	b2 9f       	mul	r27, r18
    1b40:	90 0d       	add	r25, r0
    1b42:	11 24       	eor	r1, r1
    1b44:	08 95       	ret

00001b46 <__tablejump2__>:
    1b46:	ee 0f       	add	r30, r30
    1b48:	ff 1f       	adc	r31, r31
    1b4a:	00 24       	eor	r0, r0
    1b4c:	00 1c       	adc	r0, r0
    1b4e:	0b be       	out	0x3b, r0	; 59
    1b50:	07 90       	elpm	r0, Z+
    1b52:	f6 91       	elpm	r31, Z
    1b54:	e0 2d       	mov	r30, r0
    1b56:	09 94       	ijmp

00001b58 <__muluhisi3>:
    1b58:	85 d1       	rcall	.+778    	; 0x1e64 <__umulhisi3>
    1b5a:	a5 9f       	mul	r26, r21
    1b5c:	90 0d       	add	r25, r0
    1b5e:	b4 9f       	mul	r27, r20
    1b60:	90 0d       	add	r25, r0
    1b62:	a4 9f       	mul	r26, r20
    1b64:	80 0d       	add	r24, r0
    1b66:	91 1d       	adc	r25, r1
    1b68:	11 24       	eor	r1, r1
    1b6a:	08 95       	ret

00001b6c <__mulshisi3>:
    1b6c:	b7 ff       	sbrs	r27, 7
    1b6e:	f4 cf       	rjmp	.-24     	; 0x1b58 <__muluhisi3>

00001b70 <__mulohisi3>:
    1b70:	f3 df       	rcall	.-26     	; 0x1b58 <__muluhisi3>
    1b72:	82 1b       	sub	r24, r18
    1b74:	93 0b       	sbc	r25, r19
    1b76:	08 95       	ret

00001b78 <__muldi3>:
    1b78:	df 93       	push	r29
    1b7a:	cf 93       	push	r28
    1b7c:	1f 93       	push	r17
    1b7e:	0f 93       	push	r16
    1b80:	9a 9d       	mul	r25, r10
    1b82:	f0 2d       	mov	r31, r0
    1b84:	21 9f       	mul	r18, r17
    1b86:	f0 0d       	add	r31, r0
    1b88:	8b 9d       	mul	r24, r11
    1b8a:	f0 0d       	add	r31, r0
    1b8c:	8a 9d       	mul	r24, r10
    1b8e:	e0 2d       	mov	r30, r0
    1b90:	f1 0d       	add	r31, r1
    1b92:	03 9f       	mul	r16, r19
    1b94:	f0 0d       	add	r31, r0
    1b96:	02 9f       	mul	r16, r18
    1b98:	e0 0d       	add	r30, r0
    1b9a:	f1 1d       	adc	r31, r1
    1b9c:	4e 9d       	mul	r20, r14
    1b9e:	e0 0d       	add	r30, r0
    1ba0:	f1 1d       	adc	r31, r1
    1ba2:	5e 9d       	mul	r21, r14
    1ba4:	f0 0d       	add	r31, r0
    1ba6:	4f 9d       	mul	r20, r15
    1ba8:	f0 0d       	add	r31, r0
    1baa:	7f 93       	push	r23
    1bac:	6f 93       	push	r22
    1bae:	bf 92       	push	r11
    1bb0:	af 92       	push	r10
    1bb2:	5f 93       	push	r21
    1bb4:	4f 93       	push	r20
    1bb6:	d5 01       	movw	r26, r10
    1bb8:	55 d1       	rcall	.+682    	; 0x1e64 <__umulhisi3>
    1bba:	8b 01       	movw	r16, r22
    1bbc:	ac 01       	movw	r20, r24
    1bbe:	d7 01       	movw	r26, r14
    1bc0:	51 d1       	rcall	.+674    	; 0x1e64 <__umulhisi3>
    1bc2:	eb 01       	movw	r28, r22
    1bc4:	e8 0f       	add	r30, r24
    1bc6:	f9 1f       	adc	r31, r25
    1bc8:	d6 01       	movw	r26, r12
    1bca:	1f d0       	rcall	.+62     	; 0x1c0a <__muldi3_6>
    1bcc:	2f 91       	pop	r18
    1bce:	3f 91       	pop	r19
    1bd0:	d6 01       	movw	r26, r12
    1bd2:	48 d1       	rcall	.+656    	; 0x1e64 <__umulhisi3>
    1bd4:	c6 0f       	add	r28, r22
    1bd6:	d7 1f       	adc	r29, r23
    1bd8:	e8 1f       	adc	r30, r24
    1bda:	f9 1f       	adc	r31, r25
    1bdc:	af 91       	pop	r26
    1bde:	bf 91       	pop	r27
    1be0:	14 d0       	rcall	.+40     	; 0x1c0a <__muldi3_6>
    1be2:	2f 91       	pop	r18
    1be4:	3f 91       	pop	r19
    1be6:	3e d1       	rcall	.+636    	; 0x1e64 <__umulhisi3>
    1be8:	c6 0f       	add	r28, r22
    1bea:	d7 1f       	adc	r29, r23
    1bec:	e8 1f       	adc	r30, r24
    1bee:	f9 1f       	adc	r31, r25
    1bf0:	d6 01       	movw	r26, r12
    1bf2:	38 d1       	rcall	.+624    	; 0x1e64 <__umulhisi3>
    1bf4:	e6 0f       	add	r30, r22
    1bf6:	f7 1f       	adc	r31, r23
    1bf8:	98 01       	movw	r18, r16
    1bfa:	be 01       	movw	r22, r28
    1bfc:	cf 01       	movw	r24, r30
    1bfe:	11 24       	eor	r1, r1
    1c00:	0f 91       	pop	r16
    1c02:	1f 91       	pop	r17
    1c04:	cf 91       	pop	r28
    1c06:	df 91       	pop	r29
    1c08:	08 95       	ret

00001c0a <__muldi3_6>:
    1c0a:	2c d1       	rcall	.+600    	; 0x1e64 <__umulhisi3>
    1c0c:	46 0f       	add	r20, r22
    1c0e:	57 1f       	adc	r21, r23
    1c10:	c8 1f       	adc	r28, r24
    1c12:	d9 1f       	adc	r29, r25
    1c14:	08 f4       	brcc	.+2      	; 0x1c18 <__muldi3_6+0xe>
    1c16:	31 96       	adiw	r30, 0x01	; 1
    1c18:	08 95       	ret

00001c1a <__moddi3>:
    1c1a:	68 94       	set
    1c1c:	01 c0       	rjmp	.+2      	; 0x1c20 <__divdi3_moddi3>

00001c1e <__divdi3>:
    1c1e:	e8 94       	clt

00001c20 <__divdi3_moddi3>:
    1c20:	f9 2f       	mov	r31, r25
    1c22:	f1 2b       	or	r31, r17
    1c24:	0a f0       	brmi	.+2      	; 0x1c28 <__divdi3_moddi3+0x8>
    1c26:	27 c0       	rjmp	.+78     	; 0x1c76 <__udivdi3_umoddi3>
    1c28:	a0 e0       	ldi	r26, 0x00	; 0
    1c2a:	b0 e0       	ldi	r27, 0x00	; 0
    1c2c:	e9 e1       	ldi	r30, 0x19	; 25
    1c2e:	fe e0       	ldi	r31, 0x0E	; 14
    1c30:	93 c0       	rjmp	.+294    	; 0x1d58 <__prologue_saves__+0xc>
    1c32:	09 2e       	mov	r0, r25
    1c34:	05 94       	asr	r0
    1c36:	1a f4       	brpl	.+6      	; 0x1c3e <__divdi3_moddi3+0x1e>
    1c38:	79 d0       	rcall	.+242    	; 0x1d2c <__negdi2>
    1c3a:	11 23       	and	r17, r17
    1c3c:	92 f4       	brpl	.+36     	; 0x1c62 <__divdi3_moddi3+0x42>
    1c3e:	f0 e8       	ldi	r31, 0x80	; 128
    1c40:	0f 26       	eor	r0, r31
    1c42:	ff ef       	ldi	r31, 0xFF	; 255
    1c44:	e0 94       	com	r14
    1c46:	f0 94       	com	r15
    1c48:	00 95       	com	r16
    1c4a:	10 95       	com	r17
    1c4c:	b0 94       	com	r11
    1c4e:	c0 94       	com	r12
    1c50:	d0 94       	com	r13
    1c52:	a1 94       	neg	r10
    1c54:	bf 0a       	sbc	r11, r31
    1c56:	cf 0a       	sbc	r12, r31
    1c58:	df 0a       	sbc	r13, r31
    1c5a:	ef 0a       	sbc	r14, r31
    1c5c:	ff 0a       	sbc	r15, r31
    1c5e:	0f 0b       	sbc	r16, r31
    1c60:	1f 0b       	sbc	r17, r31
    1c62:	13 d0       	rcall	.+38     	; 0x1c8a <__udivmod64>
    1c64:	07 fc       	sbrc	r0, 7
    1c66:	62 d0       	rcall	.+196    	; 0x1d2c <__negdi2>
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	ec e0       	ldi	r30, 0x0C	; 12
    1c6e:	90 c0       	rjmp	.+288    	; 0x1d90 <__epilogue_restores__+0xc>

00001c70 <__umoddi3>:
    1c70:	68 94       	set
    1c72:	01 c0       	rjmp	.+2      	; 0x1c76 <__udivdi3_umoddi3>

00001c74 <__udivdi3>:
    1c74:	e8 94       	clt

00001c76 <__udivdi3_umoddi3>:
    1c76:	8f 92       	push	r8
    1c78:	9f 92       	push	r9
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	05 d0       	rcall	.+10     	; 0x1c8a <__udivmod64>
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	9f 90       	pop	r9
    1c86:	8f 90       	pop	r8
    1c88:	08 95       	ret

00001c8a <__udivmod64>:
    1c8a:	88 24       	eor	r8, r8
    1c8c:	99 24       	eor	r9, r9
    1c8e:	f4 01       	movw	r30, r8
    1c90:	e4 01       	movw	r28, r8
    1c92:	b0 e4       	ldi	r27, 0x40	; 64
    1c94:	9f 93       	push	r25
    1c96:	aa 27       	eor	r26, r26
    1c98:	9a 15       	cp	r25, r10
    1c9a:	8b 04       	cpc	r8, r11
    1c9c:	9c 04       	cpc	r9, r12
    1c9e:	ed 05       	cpc	r30, r13
    1ca0:	fe 05       	cpc	r31, r14
    1ca2:	cf 05       	cpc	r28, r15
    1ca4:	d0 07       	cpc	r29, r16
    1ca6:	a1 07       	cpc	r26, r17
    1ca8:	98 f4       	brcc	.+38     	; 0x1cd0 <__udivmod64+0x46>
    1caa:	ad 2f       	mov	r26, r29
    1cac:	dc 2f       	mov	r29, r28
    1cae:	cf 2f       	mov	r28, r31
    1cb0:	fe 2f       	mov	r31, r30
    1cb2:	e9 2d       	mov	r30, r9
    1cb4:	98 2c       	mov	r9, r8
    1cb6:	89 2e       	mov	r8, r25
    1cb8:	98 2f       	mov	r25, r24
    1cba:	87 2f       	mov	r24, r23
    1cbc:	76 2f       	mov	r23, r22
    1cbe:	65 2f       	mov	r22, r21
    1cc0:	54 2f       	mov	r21, r20
    1cc2:	43 2f       	mov	r20, r19
    1cc4:	32 2f       	mov	r19, r18
    1cc6:	22 27       	eor	r18, r18
    1cc8:	b8 50       	subi	r27, 0x08	; 8
    1cca:	31 f7       	brne	.-52     	; 0x1c98 <__udivmod64+0xe>
    1ccc:	bf 91       	pop	r27
    1cce:	27 c0       	rjmp	.+78     	; 0x1d1e <__udivmod64+0x94>
    1cd0:	1b 2e       	mov	r1, r27
    1cd2:	bf 91       	pop	r27
    1cd4:	bb 27       	eor	r27, r27
    1cd6:	22 0f       	add	r18, r18
    1cd8:	33 1f       	adc	r19, r19
    1cda:	44 1f       	adc	r20, r20
    1cdc:	55 1f       	adc	r21, r21
    1cde:	66 1f       	adc	r22, r22
    1ce0:	77 1f       	adc	r23, r23
    1ce2:	88 1f       	adc	r24, r24
    1ce4:	99 1f       	adc	r25, r25
    1ce6:	88 1c       	adc	r8, r8
    1ce8:	99 1c       	adc	r9, r9
    1cea:	ee 1f       	adc	r30, r30
    1cec:	ff 1f       	adc	r31, r31
    1cee:	cc 1f       	adc	r28, r28
    1cf0:	dd 1f       	adc	r29, r29
    1cf2:	aa 1f       	adc	r26, r26
    1cf4:	bb 1f       	adc	r27, r27
    1cf6:	8a 14       	cp	r8, r10
    1cf8:	9b 04       	cpc	r9, r11
    1cfa:	ec 05       	cpc	r30, r12
    1cfc:	fd 05       	cpc	r31, r13
    1cfe:	ce 05       	cpc	r28, r14
    1d00:	df 05       	cpc	r29, r15
    1d02:	a0 07       	cpc	r26, r16
    1d04:	b1 07       	cpc	r27, r17
    1d06:	48 f0       	brcs	.+18     	; 0x1d1a <__udivmod64+0x90>
    1d08:	8a 18       	sub	r8, r10
    1d0a:	9b 08       	sbc	r9, r11
    1d0c:	ec 09       	sbc	r30, r12
    1d0e:	fd 09       	sbc	r31, r13
    1d10:	ce 09       	sbc	r28, r14
    1d12:	df 09       	sbc	r29, r15
    1d14:	a0 0b       	sbc	r26, r16
    1d16:	b1 0b       	sbc	r27, r17
    1d18:	21 60       	ori	r18, 0x01	; 1
    1d1a:	1a 94       	dec	r1
    1d1c:	e1 f6       	brne	.-72     	; 0x1cd6 <__udivmod64+0x4c>
    1d1e:	2e f4       	brtc	.+10     	; 0x1d2a <__udivmod64+0xa0>
    1d20:	94 01       	movw	r18, r8
    1d22:	af 01       	movw	r20, r30
    1d24:	be 01       	movw	r22, r28
    1d26:	cd 01       	movw	r24, r26
    1d28:	00 0c       	add	r0, r0
    1d2a:	08 95       	ret

00001d2c <__negdi2>:
    1d2c:	60 95       	com	r22
    1d2e:	70 95       	com	r23
    1d30:	80 95       	com	r24
    1d32:	90 95       	com	r25
    1d34:	30 95       	com	r19
    1d36:	40 95       	com	r20
    1d38:	50 95       	com	r21
    1d3a:	21 95       	neg	r18
    1d3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d3e:	4f 4f       	sbci	r20, 0xFF	; 255
    1d40:	5f 4f       	sbci	r21, 0xFF	; 255
    1d42:	6f 4f       	sbci	r22, 0xFF	; 255
    1d44:	7f 4f       	sbci	r23, 0xFF	; 255
    1d46:	8f 4f       	sbci	r24, 0xFF	; 255
    1d48:	9f 4f       	sbci	r25, 0xFF	; 255
    1d4a:	08 95       	ret

00001d4c <__prologue_saves__>:
    1d4c:	2f 92       	push	r2
    1d4e:	3f 92       	push	r3
    1d50:	4f 92       	push	r4
    1d52:	5f 92       	push	r5
    1d54:	6f 92       	push	r6
    1d56:	7f 92       	push	r7
    1d58:	8f 92       	push	r8
    1d5a:	9f 92       	push	r9
    1d5c:	af 92       	push	r10
    1d5e:	bf 92       	push	r11
    1d60:	cf 92       	push	r12
    1d62:	df 92       	push	r13
    1d64:	ef 92       	push	r14
    1d66:	ff 92       	push	r15
    1d68:	0f 93       	push	r16
    1d6a:	1f 93       	push	r17
    1d6c:	cf 93       	push	r28
    1d6e:	df 93       	push	r29
    1d70:	cd b7       	in	r28, 0x3d	; 61
    1d72:	de b7       	in	r29, 0x3e	; 62
    1d74:	ca 1b       	sub	r28, r26
    1d76:	db 0b       	sbc	r29, r27
    1d78:	0f b6       	in	r0, 0x3f	; 63
    1d7a:	f8 94       	cli
    1d7c:	de bf       	out	0x3e, r29	; 62
    1d7e:	0f be       	out	0x3f, r0	; 63
    1d80:	cd bf       	out	0x3d, r28	; 61
    1d82:	09 94       	ijmp

00001d84 <__epilogue_restores__>:
    1d84:	2a 88       	ldd	r2, Y+18	; 0x12
    1d86:	39 88       	ldd	r3, Y+17	; 0x11
    1d88:	48 88       	ldd	r4, Y+16	; 0x10
    1d8a:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d8c:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d8e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d90:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d92:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d94:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d96:	b9 84       	ldd	r11, Y+9	; 0x09
    1d98:	c8 84       	ldd	r12, Y+8	; 0x08
    1d9a:	df 80       	ldd	r13, Y+7	; 0x07
    1d9c:	ee 80       	ldd	r14, Y+6	; 0x06
    1d9e:	fd 80       	ldd	r15, Y+5	; 0x05
    1da0:	0c 81       	ldd	r16, Y+4	; 0x04
    1da2:	1b 81       	ldd	r17, Y+3	; 0x03
    1da4:	aa 81       	ldd	r26, Y+2	; 0x02
    1da6:	b9 81       	ldd	r27, Y+1	; 0x01
    1da8:	ce 0f       	add	r28, r30
    1daa:	d1 1d       	adc	r29, r1
    1dac:	0f b6       	in	r0, 0x3f	; 63
    1dae:	f8 94       	cli
    1db0:	de bf       	out	0x3e, r29	; 62
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	cd bf       	out	0x3d, r28	; 61
    1db6:	ed 01       	movw	r28, r26
    1db8:	08 95       	ret

00001dba <__ashldi3>:
    1dba:	0f 93       	push	r16
    1dbc:	08 30       	cpi	r16, 0x08	; 8
    1dbe:	90 f0       	brcs	.+36     	; 0x1de4 <__ashldi3+0x2a>
    1dc0:	98 2f       	mov	r25, r24
    1dc2:	87 2f       	mov	r24, r23
    1dc4:	76 2f       	mov	r23, r22
    1dc6:	65 2f       	mov	r22, r21
    1dc8:	54 2f       	mov	r21, r20
    1dca:	43 2f       	mov	r20, r19
    1dcc:	32 2f       	mov	r19, r18
    1dce:	22 27       	eor	r18, r18
    1dd0:	08 50       	subi	r16, 0x08	; 8
    1dd2:	f4 cf       	rjmp	.-24     	; 0x1dbc <__ashldi3+0x2>
    1dd4:	22 0f       	add	r18, r18
    1dd6:	33 1f       	adc	r19, r19
    1dd8:	44 1f       	adc	r20, r20
    1dda:	55 1f       	adc	r21, r21
    1ddc:	66 1f       	adc	r22, r22
    1dde:	77 1f       	adc	r23, r23
    1de0:	88 1f       	adc	r24, r24
    1de2:	99 1f       	adc	r25, r25
    1de4:	0a 95       	dec	r16
    1de6:	b2 f7       	brpl	.-20     	; 0x1dd4 <__ashldi3+0x1a>
    1de8:	0f 91       	pop	r16
    1dea:	08 95       	ret

00001dec <__ashrdi3>:
    1dec:	97 fb       	bst	r25, 7
    1dee:	10 f8       	bld	r1, 0

00001df0 <__lshrdi3>:
    1df0:	16 94       	lsr	r1
    1df2:	00 08       	sbc	r0, r0
    1df4:	0f 93       	push	r16
    1df6:	08 30       	cpi	r16, 0x08	; 8
    1df8:	98 f0       	brcs	.+38     	; 0x1e20 <__lshrdi3+0x30>
    1dfa:	08 50       	subi	r16, 0x08	; 8
    1dfc:	23 2f       	mov	r18, r19
    1dfe:	34 2f       	mov	r19, r20
    1e00:	45 2f       	mov	r20, r21
    1e02:	56 2f       	mov	r21, r22
    1e04:	67 2f       	mov	r22, r23
    1e06:	78 2f       	mov	r23, r24
    1e08:	89 2f       	mov	r24, r25
    1e0a:	90 2d       	mov	r25, r0
    1e0c:	f4 cf       	rjmp	.-24     	; 0x1df6 <__lshrdi3+0x6>
    1e0e:	05 94       	asr	r0
    1e10:	97 95       	ror	r25
    1e12:	87 95       	ror	r24
    1e14:	77 95       	ror	r23
    1e16:	67 95       	ror	r22
    1e18:	57 95       	ror	r21
    1e1a:	47 95       	ror	r20
    1e1c:	37 95       	ror	r19
    1e1e:	27 95       	ror	r18
    1e20:	0a 95       	dec	r16
    1e22:	aa f7       	brpl	.-22     	; 0x1e0e <__lshrdi3+0x1e>
    1e24:	0f 91       	pop	r16
    1e26:	08 95       	ret

00001e28 <__adddi3>:
    1e28:	2a 0d       	add	r18, r10
    1e2a:	3b 1d       	adc	r19, r11
    1e2c:	4c 1d       	adc	r20, r12
    1e2e:	5d 1d       	adc	r21, r13
    1e30:	6e 1d       	adc	r22, r14
    1e32:	7f 1d       	adc	r23, r15
    1e34:	80 1f       	adc	r24, r16
    1e36:	91 1f       	adc	r25, r17
    1e38:	08 95       	ret

00001e3a <__subdi3>:
    1e3a:	2a 19       	sub	r18, r10
    1e3c:	3b 09       	sbc	r19, r11
    1e3e:	4c 09       	sbc	r20, r12
    1e40:	5d 09       	sbc	r21, r13
    1e42:	6e 09       	sbc	r22, r14
    1e44:	7f 09       	sbc	r23, r15
    1e46:	80 0b       	sbc	r24, r16
    1e48:	91 0b       	sbc	r25, r17
    1e4a:	08 95       	ret

00001e4c <__cmpdi2_s8>:
    1e4c:	00 24       	eor	r0, r0
    1e4e:	a7 fd       	sbrc	r26, 7
    1e50:	00 94       	com	r0
    1e52:	2a 17       	cp	r18, r26
    1e54:	30 05       	cpc	r19, r0
    1e56:	40 05       	cpc	r20, r0
    1e58:	50 05       	cpc	r21, r0
    1e5a:	60 05       	cpc	r22, r0
    1e5c:	70 05       	cpc	r23, r0
    1e5e:	80 05       	cpc	r24, r0
    1e60:	90 05       	cpc	r25, r0
    1e62:	08 95       	ret

00001e64 <__umulhisi3>:
    1e64:	a2 9f       	mul	r26, r18
    1e66:	b0 01       	movw	r22, r0
    1e68:	b3 9f       	mul	r27, r19
    1e6a:	c0 01       	movw	r24, r0
    1e6c:	a3 9f       	mul	r26, r19
    1e6e:	70 0d       	add	r23, r0
    1e70:	81 1d       	adc	r24, r1
    1e72:	11 24       	eor	r1, r1
    1e74:	91 1d       	adc	r25, r1
    1e76:	b2 9f       	mul	r27, r18
    1e78:	70 0d       	add	r23, r0
    1e7a:	81 1d       	adc	r24, r1
    1e7c:	11 24       	eor	r1, r1
    1e7e:	91 1d       	adc	r25, r1
    1e80:	08 95       	ret

00001e82 <printf>:
    1e82:	cf 93       	push	r28
    1e84:	df 93       	push	r29
    1e86:	cd b7       	in	r28, 0x3d	; 61
    1e88:	de b7       	in	r29, 0x3e	; 62
    1e8a:	ae 01       	movw	r20, r28
    1e8c:	4b 5f       	subi	r20, 0xFB	; 251
    1e8e:	5f 4f       	sbci	r21, 0xFF	; 255
    1e90:	fa 01       	movw	r30, r20
    1e92:	61 91       	ld	r22, Z+
    1e94:	71 91       	ld	r23, Z+
    1e96:	af 01       	movw	r20, r30
    1e98:	80 91 de 05 	lds	r24, 0x05DE	; 0x8005de <__iob+0x2>
    1e9c:	90 91 df 05 	lds	r25, 0x05DF	; 0x8005df <__iob+0x3>
    1ea0:	03 d0       	rcall	.+6      	; 0x1ea8 <vfprintf>
    1ea2:	df 91       	pop	r29
    1ea4:	cf 91       	pop	r28
    1ea6:	08 95       	ret

00001ea8 <vfprintf>:
    1ea8:	2f 92       	push	r2
    1eaa:	3f 92       	push	r3
    1eac:	4f 92       	push	r4
    1eae:	5f 92       	push	r5
    1eb0:	6f 92       	push	r6
    1eb2:	7f 92       	push	r7
    1eb4:	8f 92       	push	r8
    1eb6:	9f 92       	push	r9
    1eb8:	af 92       	push	r10
    1eba:	bf 92       	push	r11
    1ebc:	cf 92       	push	r12
    1ebe:	df 92       	push	r13
    1ec0:	ef 92       	push	r14
    1ec2:	ff 92       	push	r15
    1ec4:	0f 93       	push	r16
    1ec6:	1f 93       	push	r17
    1ec8:	cf 93       	push	r28
    1eca:	df 93       	push	r29
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	2c 97       	sbiw	r28, 0x0c	; 12
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	de bf       	out	0x3e, r29	; 62
    1ed8:	0f be       	out	0x3f, r0	; 63
    1eda:	cd bf       	out	0x3d, r28	; 61
    1edc:	7c 01       	movw	r14, r24
    1ede:	6b 01       	movw	r12, r22
    1ee0:	8a 01       	movw	r16, r20
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	17 82       	std	Z+7, r1	; 0x07
    1ee6:	16 82       	std	Z+6, r1	; 0x06
    1ee8:	83 81       	ldd	r24, Z+3	; 0x03
    1eea:	81 ff       	sbrs	r24, 1
    1eec:	b0 c1       	rjmp	.+864    	; 0x224e <vfprintf+0x3a6>
    1eee:	ce 01       	movw	r24, r28
    1ef0:	01 96       	adiw	r24, 0x01	; 1
    1ef2:	4c 01       	movw	r8, r24
    1ef4:	f7 01       	movw	r30, r14
    1ef6:	93 81       	ldd	r25, Z+3	; 0x03
    1ef8:	f6 01       	movw	r30, r12
    1efa:	93 fd       	sbrc	r25, 3
    1efc:	85 91       	lpm	r24, Z+
    1efe:	93 ff       	sbrs	r25, 3
    1f00:	81 91       	ld	r24, Z+
    1f02:	6f 01       	movw	r12, r30
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <vfprintf+0x62>
    1f08:	9e c1       	rjmp	.+828    	; 0x2246 <vfprintf+0x39e>
    1f0a:	85 32       	cpi	r24, 0x25	; 37
    1f0c:	39 f4       	brne	.+14     	; 0x1f1c <vfprintf+0x74>
    1f0e:	93 fd       	sbrc	r25, 3
    1f10:	85 91       	lpm	r24, Z+
    1f12:	93 ff       	sbrs	r25, 3
    1f14:	81 91       	ld	r24, Z+
    1f16:	6f 01       	movw	r12, r30
    1f18:	85 32       	cpi	r24, 0x25	; 37
    1f1a:	21 f4       	brne	.+8      	; 0x1f24 <vfprintf+0x7c>
    1f1c:	b7 01       	movw	r22, r14
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	c7 d1       	rcall	.+910    	; 0x22b0 <fputc>
    1f22:	e8 cf       	rjmp	.-48     	; 0x1ef4 <vfprintf+0x4c>
    1f24:	51 2c       	mov	r5, r1
    1f26:	31 2c       	mov	r3, r1
    1f28:	20 e0       	ldi	r18, 0x00	; 0
    1f2a:	20 32       	cpi	r18, 0x20	; 32
    1f2c:	a0 f4       	brcc	.+40     	; 0x1f56 <vfprintf+0xae>
    1f2e:	8b 32       	cpi	r24, 0x2B	; 43
    1f30:	69 f0       	breq	.+26     	; 0x1f4c <vfprintf+0xa4>
    1f32:	30 f4       	brcc	.+12     	; 0x1f40 <vfprintf+0x98>
    1f34:	80 32       	cpi	r24, 0x20	; 32
    1f36:	59 f0       	breq	.+22     	; 0x1f4e <vfprintf+0xa6>
    1f38:	83 32       	cpi	r24, 0x23	; 35
    1f3a:	69 f4       	brne	.+26     	; 0x1f56 <vfprintf+0xae>
    1f3c:	20 61       	ori	r18, 0x10	; 16
    1f3e:	2c c0       	rjmp	.+88     	; 0x1f98 <vfprintf+0xf0>
    1f40:	8d 32       	cpi	r24, 0x2D	; 45
    1f42:	39 f0       	breq	.+14     	; 0x1f52 <vfprintf+0xaa>
    1f44:	80 33       	cpi	r24, 0x30	; 48
    1f46:	39 f4       	brne	.+14     	; 0x1f56 <vfprintf+0xae>
    1f48:	21 60       	ori	r18, 0x01	; 1
    1f4a:	26 c0       	rjmp	.+76     	; 0x1f98 <vfprintf+0xf0>
    1f4c:	22 60       	ori	r18, 0x02	; 2
    1f4e:	24 60       	ori	r18, 0x04	; 4
    1f50:	23 c0       	rjmp	.+70     	; 0x1f98 <vfprintf+0xf0>
    1f52:	28 60       	ori	r18, 0x08	; 8
    1f54:	21 c0       	rjmp	.+66     	; 0x1f98 <vfprintf+0xf0>
    1f56:	27 fd       	sbrc	r18, 7
    1f58:	27 c0       	rjmp	.+78     	; 0x1fa8 <vfprintf+0x100>
    1f5a:	30 ed       	ldi	r19, 0xD0	; 208
    1f5c:	38 0f       	add	r19, r24
    1f5e:	3a 30       	cpi	r19, 0x0A	; 10
    1f60:	78 f4       	brcc	.+30     	; 0x1f80 <vfprintf+0xd8>
    1f62:	26 ff       	sbrs	r18, 6
    1f64:	06 c0       	rjmp	.+12     	; 0x1f72 <vfprintf+0xca>
    1f66:	fa e0       	ldi	r31, 0x0A	; 10
    1f68:	5f 9e       	mul	r5, r31
    1f6a:	30 0d       	add	r19, r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	53 2e       	mov	r5, r19
    1f70:	13 c0       	rjmp	.+38     	; 0x1f98 <vfprintf+0xf0>
    1f72:	8a e0       	ldi	r24, 0x0A	; 10
    1f74:	38 9e       	mul	r3, r24
    1f76:	30 0d       	add	r19, r0
    1f78:	11 24       	eor	r1, r1
    1f7a:	33 2e       	mov	r3, r19
    1f7c:	20 62       	ori	r18, 0x20	; 32
    1f7e:	0c c0       	rjmp	.+24     	; 0x1f98 <vfprintf+0xf0>
    1f80:	8e 32       	cpi	r24, 0x2E	; 46
    1f82:	21 f4       	brne	.+8      	; 0x1f8c <vfprintf+0xe4>
    1f84:	26 fd       	sbrc	r18, 6
    1f86:	5f c1       	rjmp	.+702    	; 0x2246 <vfprintf+0x39e>
    1f88:	20 64       	ori	r18, 0x40	; 64
    1f8a:	06 c0       	rjmp	.+12     	; 0x1f98 <vfprintf+0xf0>
    1f8c:	8c 36       	cpi	r24, 0x6C	; 108
    1f8e:	11 f4       	brne	.+4      	; 0x1f94 <vfprintf+0xec>
    1f90:	20 68       	ori	r18, 0x80	; 128
    1f92:	02 c0       	rjmp	.+4      	; 0x1f98 <vfprintf+0xf0>
    1f94:	88 36       	cpi	r24, 0x68	; 104
    1f96:	41 f4       	brne	.+16     	; 0x1fa8 <vfprintf+0x100>
    1f98:	f6 01       	movw	r30, r12
    1f9a:	93 fd       	sbrc	r25, 3
    1f9c:	85 91       	lpm	r24, Z+
    1f9e:	93 ff       	sbrs	r25, 3
    1fa0:	81 91       	ld	r24, Z+
    1fa2:	6f 01       	movw	r12, r30
    1fa4:	81 11       	cpse	r24, r1
    1fa6:	c1 cf       	rjmp	.-126    	; 0x1f2a <vfprintf+0x82>
    1fa8:	98 2f       	mov	r25, r24
    1faa:	9f 7d       	andi	r25, 0xDF	; 223
    1fac:	95 54       	subi	r25, 0x45	; 69
    1fae:	93 30       	cpi	r25, 0x03	; 3
    1fb0:	28 f4       	brcc	.+10     	; 0x1fbc <vfprintf+0x114>
    1fb2:	0c 5f       	subi	r16, 0xFC	; 252
    1fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb6:	ff e3       	ldi	r31, 0x3F	; 63
    1fb8:	f9 83       	std	Y+1, r31	; 0x01
    1fba:	0d c0       	rjmp	.+26     	; 0x1fd6 <vfprintf+0x12e>
    1fbc:	83 36       	cpi	r24, 0x63	; 99
    1fbe:	31 f0       	breq	.+12     	; 0x1fcc <vfprintf+0x124>
    1fc0:	83 37       	cpi	r24, 0x73	; 115
    1fc2:	71 f0       	breq	.+28     	; 0x1fe0 <vfprintf+0x138>
    1fc4:	83 35       	cpi	r24, 0x53	; 83
    1fc6:	09 f0       	breq	.+2      	; 0x1fca <vfprintf+0x122>
    1fc8:	57 c0       	rjmp	.+174    	; 0x2078 <vfprintf+0x1d0>
    1fca:	21 c0       	rjmp	.+66     	; 0x200e <vfprintf+0x166>
    1fcc:	f8 01       	movw	r30, r16
    1fce:	80 81       	ld	r24, Z
    1fd0:	89 83       	std	Y+1, r24	; 0x01
    1fd2:	0e 5f       	subi	r16, 0xFE	; 254
    1fd4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd6:	44 24       	eor	r4, r4
    1fd8:	43 94       	inc	r4
    1fda:	51 2c       	mov	r5, r1
    1fdc:	54 01       	movw	r10, r8
    1fde:	14 c0       	rjmp	.+40     	; 0x2008 <vfprintf+0x160>
    1fe0:	38 01       	movw	r6, r16
    1fe2:	f2 e0       	ldi	r31, 0x02	; 2
    1fe4:	6f 0e       	add	r6, r31
    1fe6:	71 1c       	adc	r7, r1
    1fe8:	f8 01       	movw	r30, r16
    1fea:	a0 80       	ld	r10, Z
    1fec:	b1 80       	ldd	r11, Z+1	; 0x01
    1fee:	26 ff       	sbrs	r18, 6
    1ff0:	03 c0       	rjmp	.+6      	; 0x1ff8 <vfprintf+0x150>
    1ff2:	65 2d       	mov	r22, r5
    1ff4:	70 e0       	ldi	r23, 0x00	; 0
    1ff6:	02 c0       	rjmp	.+4      	; 0x1ffc <vfprintf+0x154>
    1ff8:	6f ef       	ldi	r22, 0xFF	; 255
    1ffa:	7f ef       	ldi	r23, 0xFF	; 255
    1ffc:	c5 01       	movw	r24, r10
    1ffe:	2c 87       	std	Y+12, r18	; 0x0c
    2000:	4c d1       	rcall	.+664    	; 0x229a <strnlen>
    2002:	2c 01       	movw	r4, r24
    2004:	83 01       	movw	r16, r6
    2006:	2c 85       	ldd	r18, Y+12	; 0x0c
    2008:	2f 77       	andi	r18, 0x7F	; 127
    200a:	22 2e       	mov	r2, r18
    200c:	16 c0       	rjmp	.+44     	; 0x203a <vfprintf+0x192>
    200e:	38 01       	movw	r6, r16
    2010:	f2 e0       	ldi	r31, 0x02	; 2
    2012:	6f 0e       	add	r6, r31
    2014:	71 1c       	adc	r7, r1
    2016:	f8 01       	movw	r30, r16
    2018:	a0 80       	ld	r10, Z
    201a:	b1 80       	ldd	r11, Z+1	; 0x01
    201c:	26 ff       	sbrs	r18, 6
    201e:	03 c0       	rjmp	.+6      	; 0x2026 <vfprintf+0x17e>
    2020:	65 2d       	mov	r22, r5
    2022:	70 e0       	ldi	r23, 0x00	; 0
    2024:	02 c0       	rjmp	.+4      	; 0x202a <vfprintf+0x182>
    2026:	6f ef       	ldi	r22, 0xFF	; 255
    2028:	7f ef       	ldi	r23, 0xFF	; 255
    202a:	c5 01       	movw	r24, r10
    202c:	2c 87       	std	Y+12, r18	; 0x0c
    202e:	2a d1       	rcall	.+596    	; 0x2284 <strnlen_P>
    2030:	2c 01       	movw	r4, r24
    2032:	2c 85       	ldd	r18, Y+12	; 0x0c
    2034:	20 68       	ori	r18, 0x80	; 128
    2036:	22 2e       	mov	r2, r18
    2038:	83 01       	movw	r16, r6
    203a:	23 fc       	sbrc	r2, 3
    203c:	19 c0       	rjmp	.+50     	; 0x2070 <vfprintf+0x1c8>
    203e:	83 2d       	mov	r24, r3
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	48 16       	cp	r4, r24
    2044:	59 06       	cpc	r5, r25
    2046:	a0 f4       	brcc	.+40     	; 0x2070 <vfprintf+0x1c8>
    2048:	b7 01       	movw	r22, r14
    204a:	80 e2       	ldi	r24, 0x20	; 32
    204c:	90 e0       	ldi	r25, 0x00	; 0
    204e:	30 d1       	rcall	.+608    	; 0x22b0 <fputc>
    2050:	3a 94       	dec	r3
    2052:	f5 cf       	rjmp	.-22     	; 0x203e <vfprintf+0x196>
    2054:	f5 01       	movw	r30, r10
    2056:	27 fc       	sbrc	r2, 7
    2058:	85 91       	lpm	r24, Z+
    205a:	27 fe       	sbrs	r2, 7
    205c:	81 91       	ld	r24, Z+
    205e:	5f 01       	movw	r10, r30
    2060:	b7 01       	movw	r22, r14
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	25 d1       	rcall	.+586    	; 0x22b0 <fputc>
    2066:	31 10       	cpse	r3, r1
    2068:	3a 94       	dec	r3
    206a:	f1 e0       	ldi	r31, 0x01	; 1
    206c:	4f 1a       	sub	r4, r31
    206e:	51 08       	sbc	r5, r1
    2070:	41 14       	cp	r4, r1
    2072:	51 04       	cpc	r5, r1
    2074:	79 f7       	brne	.-34     	; 0x2054 <vfprintf+0x1ac>
    2076:	de c0       	rjmp	.+444    	; 0x2234 <vfprintf+0x38c>
    2078:	84 36       	cpi	r24, 0x64	; 100
    207a:	11 f0       	breq	.+4      	; 0x2080 <vfprintf+0x1d8>
    207c:	89 36       	cpi	r24, 0x69	; 105
    207e:	31 f5       	brne	.+76     	; 0x20cc <vfprintf+0x224>
    2080:	f8 01       	movw	r30, r16
    2082:	27 ff       	sbrs	r18, 7
    2084:	07 c0       	rjmp	.+14     	; 0x2094 <vfprintf+0x1ec>
    2086:	60 81       	ld	r22, Z
    2088:	71 81       	ldd	r23, Z+1	; 0x01
    208a:	82 81       	ldd	r24, Z+2	; 0x02
    208c:	93 81       	ldd	r25, Z+3	; 0x03
    208e:	0c 5f       	subi	r16, 0xFC	; 252
    2090:	1f 4f       	sbci	r17, 0xFF	; 255
    2092:	08 c0       	rjmp	.+16     	; 0x20a4 <vfprintf+0x1fc>
    2094:	60 81       	ld	r22, Z
    2096:	71 81       	ldd	r23, Z+1	; 0x01
    2098:	07 2e       	mov	r0, r23
    209a:	00 0c       	add	r0, r0
    209c:	88 0b       	sbc	r24, r24
    209e:	99 0b       	sbc	r25, r25
    20a0:	0e 5f       	subi	r16, 0xFE	; 254
    20a2:	1f 4f       	sbci	r17, 0xFF	; 255
    20a4:	2f 76       	andi	r18, 0x6F	; 111
    20a6:	72 2e       	mov	r7, r18
    20a8:	97 ff       	sbrs	r25, 7
    20aa:	09 c0       	rjmp	.+18     	; 0x20be <vfprintf+0x216>
    20ac:	90 95       	com	r25
    20ae:	80 95       	com	r24
    20b0:	70 95       	com	r23
    20b2:	61 95       	neg	r22
    20b4:	7f 4f       	sbci	r23, 0xFF	; 255
    20b6:	8f 4f       	sbci	r24, 0xFF	; 255
    20b8:	9f 4f       	sbci	r25, 0xFF	; 255
    20ba:	20 68       	ori	r18, 0x80	; 128
    20bc:	72 2e       	mov	r7, r18
    20be:	2a e0       	ldi	r18, 0x0A	; 10
    20c0:	30 e0       	ldi	r19, 0x00	; 0
    20c2:	a4 01       	movw	r20, r8
    20c4:	2d d1       	rcall	.+602    	; 0x2320 <__ultoa_invert>
    20c6:	a8 2e       	mov	r10, r24
    20c8:	a8 18       	sub	r10, r8
    20ca:	43 c0       	rjmp	.+134    	; 0x2152 <vfprintf+0x2aa>
    20cc:	85 37       	cpi	r24, 0x75	; 117
    20ce:	29 f4       	brne	.+10     	; 0x20da <vfprintf+0x232>
    20d0:	2f 7e       	andi	r18, 0xEF	; 239
    20d2:	b2 2e       	mov	r11, r18
    20d4:	2a e0       	ldi	r18, 0x0A	; 10
    20d6:	30 e0       	ldi	r19, 0x00	; 0
    20d8:	25 c0       	rjmp	.+74     	; 0x2124 <vfprintf+0x27c>
    20da:	f2 2f       	mov	r31, r18
    20dc:	f9 7f       	andi	r31, 0xF9	; 249
    20de:	bf 2e       	mov	r11, r31
    20e0:	8f 36       	cpi	r24, 0x6F	; 111
    20e2:	c1 f0       	breq	.+48     	; 0x2114 <vfprintf+0x26c>
    20e4:	18 f4       	brcc	.+6      	; 0x20ec <vfprintf+0x244>
    20e6:	88 35       	cpi	r24, 0x58	; 88
    20e8:	79 f0       	breq	.+30     	; 0x2108 <vfprintf+0x260>
    20ea:	ad c0       	rjmp	.+346    	; 0x2246 <vfprintf+0x39e>
    20ec:	80 37       	cpi	r24, 0x70	; 112
    20ee:	19 f0       	breq	.+6      	; 0x20f6 <vfprintf+0x24e>
    20f0:	88 37       	cpi	r24, 0x78	; 120
    20f2:	21 f0       	breq	.+8      	; 0x20fc <vfprintf+0x254>
    20f4:	a8 c0       	rjmp	.+336    	; 0x2246 <vfprintf+0x39e>
    20f6:	2f 2f       	mov	r18, r31
    20f8:	20 61       	ori	r18, 0x10	; 16
    20fa:	b2 2e       	mov	r11, r18
    20fc:	b4 fe       	sbrs	r11, 4
    20fe:	0d c0       	rjmp	.+26     	; 0x211a <vfprintf+0x272>
    2100:	8b 2d       	mov	r24, r11
    2102:	84 60       	ori	r24, 0x04	; 4
    2104:	b8 2e       	mov	r11, r24
    2106:	09 c0       	rjmp	.+18     	; 0x211a <vfprintf+0x272>
    2108:	24 ff       	sbrs	r18, 4
    210a:	0a c0       	rjmp	.+20     	; 0x2120 <vfprintf+0x278>
    210c:	9f 2f       	mov	r25, r31
    210e:	96 60       	ori	r25, 0x06	; 6
    2110:	b9 2e       	mov	r11, r25
    2112:	06 c0       	rjmp	.+12     	; 0x2120 <vfprintf+0x278>
    2114:	28 e0       	ldi	r18, 0x08	; 8
    2116:	30 e0       	ldi	r19, 0x00	; 0
    2118:	05 c0       	rjmp	.+10     	; 0x2124 <vfprintf+0x27c>
    211a:	20 e1       	ldi	r18, 0x10	; 16
    211c:	30 e0       	ldi	r19, 0x00	; 0
    211e:	02 c0       	rjmp	.+4      	; 0x2124 <vfprintf+0x27c>
    2120:	20 e1       	ldi	r18, 0x10	; 16
    2122:	32 e0       	ldi	r19, 0x02	; 2
    2124:	f8 01       	movw	r30, r16
    2126:	b7 fe       	sbrs	r11, 7
    2128:	07 c0       	rjmp	.+14     	; 0x2138 <vfprintf+0x290>
    212a:	60 81       	ld	r22, Z
    212c:	71 81       	ldd	r23, Z+1	; 0x01
    212e:	82 81       	ldd	r24, Z+2	; 0x02
    2130:	93 81       	ldd	r25, Z+3	; 0x03
    2132:	0c 5f       	subi	r16, 0xFC	; 252
    2134:	1f 4f       	sbci	r17, 0xFF	; 255
    2136:	06 c0       	rjmp	.+12     	; 0x2144 <vfprintf+0x29c>
    2138:	60 81       	ld	r22, Z
    213a:	71 81       	ldd	r23, Z+1	; 0x01
    213c:	80 e0       	ldi	r24, 0x00	; 0
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	0e 5f       	subi	r16, 0xFE	; 254
    2142:	1f 4f       	sbci	r17, 0xFF	; 255
    2144:	a4 01       	movw	r20, r8
    2146:	ec d0       	rcall	.+472    	; 0x2320 <__ultoa_invert>
    2148:	a8 2e       	mov	r10, r24
    214a:	a8 18       	sub	r10, r8
    214c:	fb 2d       	mov	r31, r11
    214e:	ff 77       	andi	r31, 0x7F	; 127
    2150:	7f 2e       	mov	r7, r31
    2152:	76 fe       	sbrs	r7, 6
    2154:	0b c0       	rjmp	.+22     	; 0x216c <vfprintf+0x2c4>
    2156:	37 2d       	mov	r19, r7
    2158:	3e 7f       	andi	r19, 0xFE	; 254
    215a:	a5 14       	cp	r10, r5
    215c:	50 f4       	brcc	.+20     	; 0x2172 <vfprintf+0x2ca>
    215e:	74 fe       	sbrs	r7, 4
    2160:	0a c0       	rjmp	.+20     	; 0x2176 <vfprintf+0x2ce>
    2162:	72 fc       	sbrc	r7, 2
    2164:	08 c0       	rjmp	.+16     	; 0x2176 <vfprintf+0x2ce>
    2166:	37 2d       	mov	r19, r7
    2168:	3e 7e       	andi	r19, 0xEE	; 238
    216a:	05 c0       	rjmp	.+10     	; 0x2176 <vfprintf+0x2ce>
    216c:	ba 2c       	mov	r11, r10
    216e:	37 2d       	mov	r19, r7
    2170:	03 c0       	rjmp	.+6      	; 0x2178 <vfprintf+0x2d0>
    2172:	ba 2c       	mov	r11, r10
    2174:	01 c0       	rjmp	.+2      	; 0x2178 <vfprintf+0x2d0>
    2176:	b5 2c       	mov	r11, r5
    2178:	34 ff       	sbrs	r19, 4
    217a:	0d c0       	rjmp	.+26     	; 0x2196 <vfprintf+0x2ee>
    217c:	fe 01       	movw	r30, r28
    217e:	ea 0d       	add	r30, r10
    2180:	f1 1d       	adc	r31, r1
    2182:	80 81       	ld	r24, Z
    2184:	80 33       	cpi	r24, 0x30	; 48
    2186:	11 f4       	brne	.+4      	; 0x218c <vfprintf+0x2e4>
    2188:	39 7e       	andi	r19, 0xE9	; 233
    218a:	09 c0       	rjmp	.+18     	; 0x219e <vfprintf+0x2f6>
    218c:	32 ff       	sbrs	r19, 2
    218e:	06 c0       	rjmp	.+12     	; 0x219c <vfprintf+0x2f4>
    2190:	b3 94       	inc	r11
    2192:	b3 94       	inc	r11
    2194:	04 c0       	rjmp	.+8      	; 0x219e <vfprintf+0x2f6>
    2196:	83 2f       	mov	r24, r19
    2198:	86 78       	andi	r24, 0x86	; 134
    219a:	09 f0       	breq	.+2      	; 0x219e <vfprintf+0x2f6>
    219c:	b3 94       	inc	r11
    219e:	33 fd       	sbrc	r19, 3
    21a0:	12 c0       	rjmp	.+36     	; 0x21c6 <vfprintf+0x31e>
    21a2:	30 ff       	sbrs	r19, 0
    21a4:	06 c0       	rjmp	.+12     	; 0x21b2 <vfprintf+0x30a>
    21a6:	5a 2c       	mov	r5, r10
    21a8:	b3 14       	cp	r11, r3
    21aa:	18 f4       	brcc	.+6      	; 0x21b2 <vfprintf+0x30a>
    21ac:	53 0c       	add	r5, r3
    21ae:	5b 18       	sub	r5, r11
    21b0:	b3 2c       	mov	r11, r3
    21b2:	b3 14       	cp	r11, r3
    21b4:	60 f4       	brcc	.+24     	; 0x21ce <vfprintf+0x326>
    21b6:	b7 01       	movw	r22, r14
    21b8:	80 e2       	ldi	r24, 0x20	; 32
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	3c 87       	std	Y+12, r19	; 0x0c
    21be:	78 d0       	rcall	.+240    	; 0x22b0 <fputc>
    21c0:	b3 94       	inc	r11
    21c2:	3c 85       	ldd	r19, Y+12	; 0x0c
    21c4:	f6 cf       	rjmp	.-20     	; 0x21b2 <vfprintf+0x30a>
    21c6:	b3 14       	cp	r11, r3
    21c8:	10 f4       	brcc	.+4      	; 0x21ce <vfprintf+0x326>
    21ca:	3b 18       	sub	r3, r11
    21cc:	01 c0       	rjmp	.+2      	; 0x21d0 <vfprintf+0x328>
    21ce:	31 2c       	mov	r3, r1
    21d0:	34 ff       	sbrs	r19, 4
    21d2:	11 c0       	rjmp	.+34     	; 0x21f6 <vfprintf+0x34e>
    21d4:	b7 01       	movw	r22, r14
    21d6:	80 e3       	ldi	r24, 0x30	; 48
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	3c 87       	std	Y+12, r19	; 0x0c
    21dc:	69 d0       	rcall	.+210    	; 0x22b0 <fputc>
    21de:	3c 85       	ldd	r19, Y+12	; 0x0c
    21e0:	32 ff       	sbrs	r19, 2
    21e2:	16 c0       	rjmp	.+44     	; 0x2210 <vfprintf+0x368>
    21e4:	31 fd       	sbrc	r19, 1
    21e6:	03 c0       	rjmp	.+6      	; 0x21ee <vfprintf+0x346>
    21e8:	88 e7       	ldi	r24, 0x78	; 120
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	02 c0       	rjmp	.+4      	; 0x21f2 <vfprintf+0x34a>
    21ee:	88 e5       	ldi	r24, 0x58	; 88
    21f0:	90 e0       	ldi	r25, 0x00	; 0
    21f2:	b7 01       	movw	r22, r14
    21f4:	0c c0       	rjmp	.+24     	; 0x220e <vfprintf+0x366>
    21f6:	83 2f       	mov	r24, r19
    21f8:	86 78       	andi	r24, 0x86	; 134
    21fa:	51 f0       	breq	.+20     	; 0x2210 <vfprintf+0x368>
    21fc:	31 ff       	sbrs	r19, 1
    21fe:	02 c0       	rjmp	.+4      	; 0x2204 <vfprintf+0x35c>
    2200:	8b e2       	ldi	r24, 0x2B	; 43
    2202:	01 c0       	rjmp	.+2      	; 0x2206 <vfprintf+0x35e>
    2204:	80 e2       	ldi	r24, 0x20	; 32
    2206:	37 fd       	sbrc	r19, 7
    2208:	8d e2       	ldi	r24, 0x2D	; 45
    220a:	b7 01       	movw	r22, r14
    220c:	90 e0       	ldi	r25, 0x00	; 0
    220e:	50 d0       	rcall	.+160    	; 0x22b0 <fputc>
    2210:	a5 14       	cp	r10, r5
    2212:	30 f4       	brcc	.+12     	; 0x2220 <vfprintf+0x378>
    2214:	b7 01       	movw	r22, r14
    2216:	80 e3       	ldi	r24, 0x30	; 48
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	4a d0       	rcall	.+148    	; 0x22b0 <fputc>
    221c:	5a 94       	dec	r5
    221e:	f8 cf       	rjmp	.-16     	; 0x2210 <vfprintf+0x368>
    2220:	aa 94       	dec	r10
    2222:	f4 01       	movw	r30, r8
    2224:	ea 0d       	add	r30, r10
    2226:	f1 1d       	adc	r31, r1
    2228:	80 81       	ld	r24, Z
    222a:	b7 01       	movw	r22, r14
    222c:	90 e0       	ldi	r25, 0x00	; 0
    222e:	40 d0       	rcall	.+128    	; 0x22b0 <fputc>
    2230:	a1 10       	cpse	r10, r1
    2232:	f6 cf       	rjmp	.-20     	; 0x2220 <vfprintf+0x378>
    2234:	33 20       	and	r3, r3
    2236:	09 f4       	brne	.+2      	; 0x223a <vfprintf+0x392>
    2238:	5d ce       	rjmp	.-838    	; 0x1ef4 <vfprintf+0x4c>
    223a:	b7 01       	movw	r22, r14
    223c:	80 e2       	ldi	r24, 0x20	; 32
    223e:	90 e0       	ldi	r25, 0x00	; 0
    2240:	37 d0       	rcall	.+110    	; 0x22b0 <fputc>
    2242:	3a 94       	dec	r3
    2244:	f7 cf       	rjmp	.-18     	; 0x2234 <vfprintf+0x38c>
    2246:	f7 01       	movw	r30, r14
    2248:	86 81       	ldd	r24, Z+6	; 0x06
    224a:	97 81       	ldd	r25, Z+7	; 0x07
    224c:	02 c0       	rjmp	.+4      	; 0x2252 <vfprintf+0x3aa>
    224e:	8f ef       	ldi	r24, 0xFF	; 255
    2250:	9f ef       	ldi	r25, 0xFF	; 255
    2252:	2c 96       	adiw	r28, 0x0c	; 12
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	de bf       	out	0x3e, r29	; 62
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	cd bf       	out	0x3d, r28	; 61
    225e:	df 91       	pop	r29
    2260:	cf 91       	pop	r28
    2262:	1f 91       	pop	r17
    2264:	0f 91       	pop	r16
    2266:	ff 90       	pop	r15
    2268:	ef 90       	pop	r14
    226a:	df 90       	pop	r13
    226c:	cf 90       	pop	r12
    226e:	bf 90       	pop	r11
    2270:	af 90       	pop	r10
    2272:	9f 90       	pop	r9
    2274:	8f 90       	pop	r8
    2276:	7f 90       	pop	r7
    2278:	6f 90       	pop	r6
    227a:	5f 90       	pop	r5
    227c:	4f 90       	pop	r4
    227e:	3f 90       	pop	r3
    2280:	2f 90       	pop	r2
    2282:	08 95       	ret

00002284 <strnlen_P>:
    2284:	fc 01       	movw	r30, r24
    2286:	05 90       	lpm	r0, Z+
    2288:	61 50       	subi	r22, 0x01	; 1
    228a:	70 40       	sbci	r23, 0x00	; 0
    228c:	01 10       	cpse	r0, r1
    228e:	d8 f7       	brcc	.-10     	; 0x2286 <strnlen_P+0x2>
    2290:	80 95       	com	r24
    2292:	90 95       	com	r25
    2294:	8e 0f       	add	r24, r30
    2296:	9f 1f       	adc	r25, r31
    2298:	08 95       	ret

0000229a <strnlen>:
    229a:	fc 01       	movw	r30, r24
    229c:	61 50       	subi	r22, 0x01	; 1
    229e:	70 40       	sbci	r23, 0x00	; 0
    22a0:	01 90       	ld	r0, Z+
    22a2:	01 10       	cpse	r0, r1
    22a4:	d8 f7       	brcc	.-10     	; 0x229c <strnlen+0x2>
    22a6:	80 95       	com	r24
    22a8:	90 95       	com	r25
    22aa:	8e 0f       	add	r24, r30
    22ac:	9f 1f       	adc	r25, r31
    22ae:	08 95       	ret

000022b0 <fputc>:
    22b0:	0f 93       	push	r16
    22b2:	1f 93       	push	r17
    22b4:	cf 93       	push	r28
    22b6:	df 93       	push	r29
    22b8:	fb 01       	movw	r30, r22
    22ba:	23 81       	ldd	r18, Z+3	; 0x03
    22bc:	21 fd       	sbrc	r18, 1
    22be:	03 c0       	rjmp	.+6      	; 0x22c6 <fputc+0x16>
    22c0:	8f ef       	ldi	r24, 0xFF	; 255
    22c2:	9f ef       	ldi	r25, 0xFF	; 255
    22c4:	28 c0       	rjmp	.+80     	; 0x2316 <fputc+0x66>
    22c6:	22 ff       	sbrs	r18, 2
    22c8:	16 c0       	rjmp	.+44     	; 0x22f6 <fputc+0x46>
    22ca:	46 81       	ldd	r20, Z+6	; 0x06
    22cc:	57 81       	ldd	r21, Z+7	; 0x07
    22ce:	24 81       	ldd	r18, Z+4	; 0x04
    22d0:	35 81       	ldd	r19, Z+5	; 0x05
    22d2:	42 17       	cp	r20, r18
    22d4:	53 07       	cpc	r21, r19
    22d6:	44 f4       	brge	.+16     	; 0x22e8 <fputc+0x38>
    22d8:	a0 81       	ld	r26, Z
    22da:	b1 81       	ldd	r27, Z+1	; 0x01
    22dc:	9d 01       	movw	r18, r26
    22de:	2f 5f       	subi	r18, 0xFF	; 255
    22e0:	3f 4f       	sbci	r19, 0xFF	; 255
    22e2:	31 83       	std	Z+1, r19	; 0x01
    22e4:	20 83       	st	Z, r18
    22e6:	8c 93       	st	X, r24
    22e8:	26 81       	ldd	r18, Z+6	; 0x06
    22ea:	37 81       	ldd	r19, Z+7	; 0x07
    22ec:	2f 5f       	subi	r18, 0xFF	; 255
    22ee:	3f 4f       	sbci	r19, 0xFF	; 255
    22f0:	37 83       	std	Z+7, r19	; 0x07
    22f2:	26 83       	std	Z+6, r18	; 0x06
    22f4:	10 c0       	rjmp	.+32     	; 0x2316 <fputc+0x66>
    22f6:	eb 01       	movw	r28, r22
    22f8:	09 2f       	mov	r16, r25
    22fa:	18 2f       	mov	r17, r24
    22fc:	00 84       	ldd	r0, Z+8	; 0x08
    22fe:	f1 85       	ldd	r31, Z+9	; 0x09
    2300:	e0 2d       	mov	r30, r0
    2302:	09 95       	icall
    2304:	89 2b       	or	r24, r25
    2306:	e1 f6       	brne	.-72     	; 0x22c0 <fputc+0x10>
    2308:	8e 81       	ldd	r24, Y+6	; 0x06
    230a:	9f 81       	ldd	r25, Y+7	; 0x07
    230c:	01 96       	adiw	r24, 0x01	; 1
    230e:	9f 83       	std	Y+7, r25	; 0x07
    2310:	8e 83       	std	Y+6, r24	; 0x06
    2312:	81 2f       	mov	r24, r17
    2314:	90 2f       	mov	r25, r16
    2316:	df 91       	pop	r29
    2318:	cf 91       	pop	r28
    231a:	1f 91       	pop	r17
    231c:	0f 91       	pop	r16
    231e:	08 95       	ret

00002320 <__ultoa_invert>:
    2320:	fa 01       	movw	r30, r20
    2322:	aa 27       	eor	r26, r26
    2324:	28 30       	cpi	r18, 0x08	; 8
    2326:	51 f1       	breq	.+84     	; 0x237c <__ultoa_invert+0x5c>
    2328:	20 31       	cpi	r18, 0x10	; 16
    232a:	81 f1       	breq	.+96     	; 0x238c <__ultoa_invert+0x6c>
    232c:	e8 94       	clt
    232e:	6f 93       	push	r22
    2330:	6e 7f       	andi	r22, 0xFE	; 254
    2332:	6e 5f       	subi	r22, 0xFE	; 254
    2334:	7f 4f       	sbci	r23, 0xFF	; 255
    2336:	8f 4f       	sbci	r24, 0xFF	; 255
    2338:	9f 4f       	sbci	r25, 0xFF	; 255
    233a:	af 4f       	sbci	r26, 0xFF	; 255
    233c:	b1 e0       	ldi	r27, 0x01	; 1
    233e:	3e d0       	rcall	.+124    	; 0x23bc <__ultoa_invert+0x9c>
    2340:	b4 e0       	ldi	r27, 0x04	; 4
    2342:	3c d0       	rcall	.+120    	; 0x23bc <__ultoa_invert+0x9c>
    2344:	67 0f       	add	r22, r23
    2346:	78 1f       	adc	r23, r24
    2348:	89 1f       	adc	r24, r25
    234a:	9a 1f       	adc	r25, r26
    234c:	a1 1d       	adc	r26, r1
    234e:	68 0f       	add	r22, r24
    2350:	79 1f       	adc	r23, r25
    2352:	8a 1f       	adc	r24, r26
    2354:	91 1d       	adc	r25, r1
    2356:	a1 1d       	adc	r26, r1
    2358:	6a 0f       	add	r22, r26
    235a:	71 1d       	adc	r23, r1
    235c:	81 1d       	adc	r24, r1
    235e:	91 1d       	adc	r25, r1
    2360:	a1 1d       	adc	r26, r1
    2362:	20 d0       	rcall	.+64     	; 0x23a4 <__ultoa_invert+0x84>
    2364:	09 f4       	brne	.+2      	; 0x2368 <__ultoa_invert+0x48>
    2366:	68 94       	set
    2368:	3f 91       	pop	r19
    236a:	2a e0       	ldi	r18, 0x0A	; 10
    236c:	26 9f       	mul	r18, r22
    236e:	11 24       	eor	r1, r1
    2370:	30 19       	sub	r19, r0
    2372:	30 5d       	subi	r19, 0xD0	; 208
    2374:	31 93       	st	Z+, r19
    2376:	de f6       	brtc	.-74     	; 0x232e <__ultoa_invert+0xe>
    2378:	cf 01       	movw	r24, r30
    237a:	08 95       	ret
    237c:	46 2f       	mov	r20, r22
    237e:	47 70       	andi	r20, 0x07	; 7
    2380:	40 5d       	subi	r20, 0xD0	; 208
    2382:	41 93       	st	Z+, r20
    2384:	b3 e0       	ldi	r27, 0x03	; 3
    2386:	0f d0       	rcall	.+30     	; 0x23a6 <__ultoa_invert+0x86>
    2388:	c9 f7       	brne	.-14     	; 0x237c <__ultoa_invert+0x5c>
    238a:	f6 cf       	rjmp	.-20     	; 0x2378 <__ultoa_invert+0x58>
    238c:	46 2f       	mov	r20, r22
    238e:	4f 70       	andi	r20, 0x0F	; 15
    2390:	40 5d       	subi	r20, 0xD0	; 208
    2392:	4a 33       	cpi	r20, 0x3A	; 58
    2394:	18 f0       	brcs	.+6      	; 0x239c <__ultoa_invert+0x7c>
    2396:	49 5d       	subi	r20, 0xD9	; 217
    2398:	31 fd       	sbrc	r19, 1
    239a:	40 52       	subi	r20, 0x20	; 32
    239c:	41 93       	st	Z+, r20
    239e:	02 d0       	rcall	.+4      	; 0x23a4 <__ultoa_invert+0x84>
    23a0:	a9 f7       	brne	.-22     	; 0x238c <__ultoa_invert+0x6c>
    23a2:	ea cf       	rjmp	.-44     	; 0x2378 <__ultoa_invert+0x58>
    23a4:	b4 e0       	ldi	r27, 0x04	; 4
    23a6:	a6 95       	lsr	r26
    23a8:	97 95       	ror	r25
    23aa:	87 95       	ror	r24
    23ac:	77 95       	ror	r23
    23ae:	67 95       	ror	r22
    23b0:	ba 95       	dec	r27
    23b2:	c9 f7       	brne	.-14     	; 0x23a6 <__ultoa_invert+0x86>
    23b4:	00 97       	sbiw	r24, 0x00	; 0
    23b6:	61 05       	cpc	r22, r1
    23b8:	71 05       	cpc	r23, r1
    23ba:	08 95       	ret
    23bc:	9b 01       	movw	r18, r22
    23be:	ac 01       	movw	r20, r24
    23c0:	0a 2e       	mov	r0, r26
    23c2:	06 94       	lsr	r0
    23c4:	57 95       	ror	r21
    23c6:	47 95       	ror	r20
    23c8:	37 95       	ror	r19
    23ca:	27 95       	ror	r18
    23cc:	ba 95       	dec	r27
    23ce:	c9 f7       	brne	.-14     	; 0x23c2 <__ultoa_invert+0xa2>
    23d0:	62 0f       	add	r22, r18
    23d2:	73 1f       	adc	r23, r19
    23d4:	84 1f       	adc	r24, r20
    23d6:	95 1f       	adc	r25, r21
    23d8:	a0 1d       	adc	r26, r0
    23da:	08 95       	ret

000023dc <eeprom_read_word>:
    23dc:	a8 e1       	ldi	r26, 0x18	; 24
    23de:	b0 e0       	ldi	r27, 0x00	; 0
    23e0:	42 e0       	ldi	r20, 0x02	; 2
    23e2:	50 e0       	ldi	r21, 0x00	; 0
    23e4:	02 c0       	rjmp	.+4      	; 0x23ea <eeprom_read_blraw>

000023e6 <eeprom_read_block>:
    23e6:	dc 01       	movw	r26, r24
    23e8:	cb 01       	movw	r24, r22

000023ea <eeprom_read_blraw>:
    23ea:	fc 01       	movw	r30, r24
    23ec:	f9 99       	sbic	0x1f, 1	; 31
    23ee:	fe cf       	rjmp	.-4      	; 0x23ec <eeprom_read_blraw+0x2>
    23f0:	06 c0       	rjmp	.+12     	; 0x23fe <eeprom_read_blraw+0x14>
    23f2:	f2 bd       	out	0x22, r31	; 34
    23f4:	e1 bd       	out	0x21, r30	; 33
    23f6:	f8 9a       	sbi	0x1f, 0	; 31
    23f8:	31 96       	adiw	r30, 0x01	; 1
    23fa:	00 b4       	in	r0, 0x20	; 32
    23fc:	0d 92       	st	X+, r0
    23fe:	41 50       	subi	r20, 0x01	; 1
    2400:	50 40       	sbci	r21, 0x00	; 0
    2402:	b8 f7       	brcc	.-18     	; 0x23f2 <eeprom_read_blraw+0x8>
    2404:	08 95       	ret

00002406 <_exit>:
    2406:	f8 94       	cli

00002408 <__stop_program>:
    2408:	ff cf       	rjmp	.-2      	; 0x2408 <__stop_program>
