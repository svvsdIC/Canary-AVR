
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000022c  00800100  00002594  00002628  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002594  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005f7  0080032c  0080032c  00002854  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002854  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000028b0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000300  00000000  00000000  000028f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000054ea  00000000  00000000  00002bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001a28  00000000  00000000  000080da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000024bf  00000000  00000000  00009b02  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000958  00000000  00000000  0000bfc4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010fe  00000000  00000000  0000c91c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003821  00000000  00000000  0000da1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000250  00000000  00000000  0001123b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	9b c0       	rjmp	.+310    	; 0x16c <__bad_interrupt>
      36:	00 00       	nop
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 38 0c 	jmp	0x1870	; 0x1870 <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 61 0d 	jmp	0x1ac2	; 0x1ac2 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 92 0c 	jmp	0x1924	; 0x1924 <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__vector_28>
      74:	0c 94 f8 0d 	jmp	0x1bf0	; 0x1bf0 <__vector_29>
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	ae 0c       	add	r10, r14
      8e:	00 0d       	add	r16, r0
      90:	00 0d       	add	r16, r0
      92:	00 0d       	add	r16, r0
      94:	00 0d       	add	r16, r0
      96:	00 0d       	add	r16, r0
      98:	00 0d       	add	r16, r0
      9a:	00 0d       	add	r16, r0
      9c:	ae 0c       	add	r10, r14
      9e:	00 0d       	add	r16, r0
      a0:	00 0d       	add	r16, r0
      a2:	00 0d       	add	r16, r0
      a4:	00 0d       	add	r16, r0
      a6:	00 0d       	add	r16, r0
      a8:	00 0d       	add	r16, r0
      aa:	00 0d       	add	r16, r0
      ac:	b0 0c       	add	r11, r0
      ae:	00 0d       	add	r16, r0
      b0:	00 0d       	add	r16, r0
      b2:	00 0d       	add	r16, r0
      b4:	00 0d       	add	r16, r0
      b6:	00 0d       	add	r16, r0
      b8:	00 0d       	add	r16, r0
      ba:	00 0d       	add	r16, r0
      bc:	00 0d       	add	r16, r0
      be:	00 0d       	add	r16, r0
      c0:	00 0d       	add	r16, r0
      c2:	00 0d       	add	r16, r0
      c4:	00 0d       	add	r16, r0
      c6:	00 0d       	add	r16, r0
      c8:	00 0d       	add	r16, r0
      ca:	00 0d       	add	r16, r0
      cc:	b0 0c       	add	r11, r0
      ce:	00 0d       	add	r16, r0
      d0:	00 0d       	add	r16, r0
      d2:	00 0d       	add	r16, r0
      d4:	00 0d       	add	r16, r0
      d6:	00 0d       	add	r16, r0
      d8:	00 0d       	add	r16, r0
      da:	00 0d       	add	r16, r0
      dc:	00 0d       	add	r16, r0
      de:	00 0d       	add	r16, r0
      e0:	00 0d       	add	r16, r0
      e2:	00 0d       	add	r16, r0
      e4:	00 0d       	add	r16, r0
      e6:	00 0d       	add	r16, r0
      e8:	00 0d       	add	r16, r0
      ea:	00 0d       	add	r16, r0
      ec:	fc 0c       	add	r15, r12
      ee:	00 0d       	add	r16, r0
      f0:	00 0d       	add	r16, r0
      f2:	00 0d       	add	r16, r0
      f4:	00 0d       	add	r16, r0
      f6:	00 0d       	add	r16, r0
      f8:	00 0d       	add	r16, r0
      fa:	00 0d       	add	r16, r0
      fc:	d9 0c       	add	r13, r9
      fe:	00 0d       	add	r16, r0
     100:	00 0d       	add	r16, r0
     102:	00 0d       	add	r16, r0
     104:	00 0d       	add	r16, r0
     106:	00 0d       	add	r16, r0
     108:	00 0d       	add	r16, r0
     10a:	00 0d       	add	r16, r0
     10c:	00 0d       	add	r16, r0
     10e:	00 0d       	add	r16, r0
     110:	00 0d       	add	r16, r0
     112:	00 0d       	add	r16, r0
     114:	00 0d       	add	r16, r0
     116:	00 0d       	add	r16, r0
     118:	00 0d       	add	r16, r0
     11a:	00 0d       	add	r16, r0
     11c:	cd 0c       	add	r12, r13
     11e:	00 0d       	add	r16, r0
     120:	00 0d       	add	r16, r0
     122:	00 0d       	add	r16, r0
     124:	00 0d       	add	r16, r0
     126:	00 0d       	add	r16, r0
     128:	00 0d       	add	r16, r0
     12a:	00 0d       	add	r16, r0
     12c:	eb 0c       	add	r14, r11

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	13 e0       	ldi	r17, 0x03	; 3
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e4 e9       	ldi	r30, 0x94	; 148
     142:	f5 e2       	ldi	r31, 0x25	; 37
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	ac 32       	cpi	r26, 0x2C	; 44
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	29 e0       	ldi	r18, 0x09	; 9
     156:	ac e2       	ldi	r26, 0x2C	; 44
     158:	b3 e0       	ldi	r27, 0x03	; 3
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a3 32       	cpi	r26, 0x23	; 35
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 61 0a 	call	0x14c2	; 0x14c2 <main>
     168:	0c 94 c8 12 	jmp	0x2590	; 0x2590 <_exit>

0000016c <__bad_interrupt>:
     16c:	49 cf       	rjmp	.-366    	; 0x0 <__vectors>

0000016e <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     16e:	ec e7       	ldi	r30, 0x7C	; 124
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	90 81       	ld	r25, Z
     174:	90 7e       	andi	r25, 0xE0	; 224
     176:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     178:	90 81       	ld	r25, Z
     17a:	89 2b       	or	r24, r25
     17c:	80 83       	st	Z, r24
     17e:	08 95       	ret

00000180 <ADC_init>:
}

void ADC_init(void)
{
     180:	cf 93       	push	r28
     182:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     184:	ec e7       	ldi	r30, 0x7C	; 124
     186:	f0 e0       	ldi	r31, 0x00	; 0
     188:	80 81       	ld	r24, Z
     18a:	80 64       	ori	r24, 0x40	; 64
     18c:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     18e:	ca e7       	ldi	r28, 0x7A	; 122
     190:	d0 e0       	ldi	r29, 0x00	; 0
     192:	88 81       	ld	r24, Y
     194:	81 60       	ori	r24, 0x01	; 1
     196:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     198:	88 81       	ld	r24, Y
     19a:	82 60       	ori	r24, 0x02	; 2
     19c:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     19e:	88 81       	ld	r24, Y
     1a0:	84 60       	ori	r24, 0x04	; 4
     1a2:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a4:	a4 e6       	ldi	r26, 0x64	; 100
     1a6:	b0 e0       	ldi	r27, 0x00	; 0
     1a8:	8c 91       	ld	r24, X
     1aa:	8e 7f       	andi	r24, 0xFE	; 254
     1ac:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1ae:	80 81       	ld	r24, Z
     1b0:	8f 7d       	andi	r24, 0xDF	; 223
     1b2:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b4:	8f e3       	ldi	r24, 0x3F	; 63
     1b6:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1ba:	88 81       	ld	r24, Y
     1bc:	80 68       	ori	r24, 0x80	; 128
     1be:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c0:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c4:	8f e1       	ldi	r24, 0x1F	; 31
     1c6:	d3 df       	rcall	.-90     	; 0x16e <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1c8:	88 81       	ld	r24, Y
     1ca:	80 64       	ori	r24, 0x40	; 64
     1cc:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ce:	ea e7       	ldi	r30, 0x7A	; 122
     1d0:	f0 e0       	ldi	r31, 0x00	; 0
     1d2:	80 81       	ld	r24, Z
     1d4:	84 ff       	sbrs	r24, 4
     1d6:	fd cf       	rjmp	.-6      	; 0x1d2 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1d8:	ea e7       	ldi	r30, 0x7A	; 122
     1da:	f0 e0       	ldi	r31, 0x00	; 0
     1dc:	80 81       	ld	r24, Z
     1de:	80 64       	ori	r24, 0x40	; 64
     1e0:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e2:	80 81       	ld	r24, Z
     1e4:	84 ff       	sbrs	r24, 4
     1e6:	fd cf       	rjmp	.-6      	; 0x1e2 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1e8:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <__data_end+0x1>
     1f2:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f6:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fa:	20 91 2c 03 	lds	r18, 0x032C	; 0x80032c <__data_end>
     1fe:	30 91 2d 03 	lds	r19, 0x032D	; 0x80032d <__data_end+0x1>
     202:	89 2f       	mov	r24, r25
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	98 2f       	mov	r25, r24
     208:	88 27       	eor	r24, r24
     20a:	82 0f       	add	r24, r18
     20c:	93 1f       	adc	r25, r19
     20e:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <__data_end+0x1>
     212:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     216:	80 91 2c 03 	lds	r24, 0x032C	; 0x80032c <__data_end>
     21a:	90 91 2d 03 	lds	r25, 0x032D	; 0x80032d <__data_end+0x1>
     21e:	99 23       	and	r25, r25
     220:	1c f4       	brge	.+6      	; 0x228 <ADC_init+0xa8>
     222:	91 95       	neg	r25
     224:	81 95       	neg	r24
     226:	91 09       	sbc	r25, r1
     228:	05 97       	sbiw	r24, 0x05	; 5
     22a:	2c f0       	brlt	.+10     	; 0x236 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22c:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <gas_sensor_initialization_errors>
     230:	81 60       	ori	r24, 0x01	; 1
     232:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     236:	8e e1       	ldi	r24, 0x1E	; 30
     238:	9a df       	rcall	.-204    	; 0x16e <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23a:	ea e7       	ldi	r30, 0x7A	; 122
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	80 81       	ld	r24, Z
     240:	80 64       	ori	r24, 0x40	; 64
     242:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     244:	80 81       	ld	r24, Z
     246:	84 ff       	sbrs	r24, 4
     248:	fd cf       	rjmp	.-6      	; 0x244 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <__data_end+0x1>
     254:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     258:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25c:	20 91 2c 03 	lds	r18, 0x032C	; 0x80032c <__data_end>
     260:	30 91 2d 03 	lds	r19, 0x032D	; 0x80032d <__data_end+0x1>
     264:	89 2f       	mov	r24, r25
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	98 2f       	mov	r25, r24
     26a:	88 27       	eor	r24, r24
     26c:	82 0f       	add	r24, r18
     26e:	93 1f       	adc	r25, r19
     270:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <__data_end+0x1>
     274:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     278:	80 91 2c 03 	lds	r24, 0x032C	; 0x80032c <__data_end>
     27c:	90 91 2d 03 	lds	r25, 0x032D	; 0x80032d <__data_end+0x1>
     280:	81 5e       	subi	r24, 0xE1	; 225
     282:	91 09       	sbc	r25, r1
     284:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <__data_end+0x1>
     288:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28c:	80 91 2c 03 	lds	r24, 0x032C	; 0x80032c <__data_end>
     290:	90 91 2d 03 	lds	r25, 0x032D	; 0x80032d <__data_end+0x1>
     294:	99 23       	and	r25, r25
     296:	1c f4       	brge	.+6      	; 0x29e <ADC_init+0x11e>
     298:	91 95       	neg	r25
     29a:	81 95       	neg	r24
     29c:	91 09       	sbc	r25, r1
     29e:	05 97       	sbiw	r24, 0x05	; 5
     2a0:	2c f0       	brlt	.+10     	; 0x2ac <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a2:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <gas_sensor_initialization_errors>
     2a6:	82 60       	ori	r24, 0x02	; 2
     2a8:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ac:	ea e7       	ldi	r30, 0x7A	; 122
     2ae:	f0 e0       	ldi	r31, 0x00	; 0
     2b0:	80 81       	ld	r24, Z
     2b2:	8f 77       	andi	r24, 0x7F	; 127
     2b4:	80 83       	st	Z, r24
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2bc:	87 e0       	ldi	r24, 0x07	; 7
     2be:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2c0:	85 b1       	in	r24, 0x05	; 5
     2c2:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2c4:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2c6:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2c8:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2ca:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2cc:	41 9a       	sbi	0x08, 1	; 8
     2ce:	08 95       	ret

000002d0 <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2d0:	80 e0       	ldi	r24, 0x00	; 0
     2d2:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2d4:	2f ef       	ldi	r18, 0xFF	; 255
     2d6:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2d8:	fc 01       	movw	r30, r24
     2da:	ee 0f       	add	r30, r30
     2dc:	ff 1f       	adc	r31, r31
     2de:	ee 0f       	add	r30, r30
     2e0:	ff 1f       	adc	r31, r31
     2e2:	ef 59       	subi	r30, 0x9F	; 159
     2e4:	fa 4f       	sbci	r31, 0xFA	; 250
     2e6:	11 82       	std	Z+1, r1	; 0x01
     2e8:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2ea:	33 83       	std	Z+3, r19	; 0x03
     2ec:	22 83       	std	Z+2, r18	; 0x02
     2ee:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2f0:	85 30       	cpi	r24, 0x05	; 5
     2f2:	91 05       	cpc	r25, r1
     2f4:	89 f7       	brne	.-30     	; 0x2d8 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2f6:	08 95       	ret

000002f8 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2f8:	ef 92       	push	r14
     2fa:	ff 92       	push	r15
     2fc:	0f 93       	push	r16
     2fe:	1f 93       	push	r17
     300:	cf 93       	push	r28
     302:	df 93       	push	r29
     304:	0f 2e       	mov	r0, r31
     306:	fb e4       	ldi	r31, 0x4B	; 75
     308:	ef 2e       	mov	r14, r31
     30a:	f5 e0       	ldi	r31, 0x05	; 5
     30c:	ff 2e       	mov	r15, r31
     30e:	f0 2d       	mov	r31, r0
     310:	00 e0       	ldi	r16, 0x00	; 0
     312:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     314:	c7 01       	movw	r24, r14
     316:	0e 94 b3 12 	call	0x2566	; 0x2566 <eeprom_read_word>
     31a:	e8 01       	movw	r28, r16
     31c:	cc 0f       	add	r28, r28
     31e:	dd 1f       	adc	r29, r29
     320:	cc 0f       	add	r28, r28
     322:	dd 1f       	adc	r29, r29
     324:	cf 59       	subi	r28, 0x9F	; 159
     326:	da 4f       	sbci	r29, 0xFA	; 250
     328:	99 83       	std	Y+1, r25	; 0x01
     32a:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     32c:	c7 01       	movw	r24, r14
     32e:	02 96       	adiw	r24, 0x02	; 2
     330:	0e 94 b3 12 	call	0x2566	; 0x2566 <eeprom_read_word>
     334:	9b 83       	std	Y+3, r25	; 0x03
     336:	8a 83       	std	Y+2, r24	; 0x02
     338:	0f 5f       	subi	r16, 0xFF	; 255
     33a:	1f 4f       	sbci	r17, 0xFF	; 255
     33c:	84 e0       	ldi	r24, 0x04	; 4
     33e:	e8 0e       	add	r14, r24
     340:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     342:	05 30       	cpi	r16, 0x05	; 5
     344:	11 05       	cpc	r17, r1
     346:	31 f7       	brne	.-52     	; 0x314 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	1f 91       	pop	r17
     34e:	0f 91       	pop	r16
     350:	ff 90       	pop	r15
     352:	ef 90       	pop	r14
     354:	08 95       	ret

00000356 <gas_sensors_init>:

void gas_sensors_init(void)
{
     356:	af 92       	push	r10
     358:	bf 92       	push	r11
     35a:	cf 92       	push	r12
     35c:	df 92       	push	r13
     35e:	ef 92       	push	r14
     360:	ff 92       	push	r15
     362:	0f 93       	push	r16
     364:	1f 93       	push	r17
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	1f 92       	push	r1
     36c:	cd b7       	in	r28, 0x3d	; 61
     36e:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     370:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     374:	10 92 7f 05 	sts	0x057F, r1	; 0x80057f <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     378:	bf df       	rcall	.-130    	; 0x2f8 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     37a:	aa df       	rcall	.-172    	; 0x2d0 <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     37c:	ea e7       	ldi	r30, 0x7A	; 122
     37e:	f0 e0       	ldi	r31, 0x00	; 0
     380:	80 81       	ld	r24, Z
     382:	80 68       	ori	r24, 0x80	; 128
     384:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     386:	19 82       	std	Y+1, r1	; 0x01
     388:	89 81       	ldd	r24, Y+1	; 0x01
     38a:	85 30       	cpi	r24, 0x05	; 5
     38c:	08 f0       	brcs	.+2      	; 0x390 <gas_sensors_init+0x3a>
     38e:	51 c0       	rjmp	.+162    	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     390:	0a e7       	ldi	r16, 0x7A	; 122
     392:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     394:	0f 2e       	mov	r0, r31
     396:	f8 e7       	ldi	r31, 0x78	; 120
     398:	ef 2e       	mov	r14, r31
     39a:	f1 2c       	mov	r15, r1
     39c:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     39e:	bb 24       	eor	r11, r11
     3a0:	b3 94       	inc	r11
     3a2:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3a4:	cc 24       	eor	r12, r12
     3a6:	c3 94       	inc	r12
     3a8:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     3aa:	89 81       	ldd	r24, Y+1	; 0x01
     3ac:	e0 de       	rcall	.-576    	; 0x16e <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
     3ae:	f8 01       	movw	r30, r16
     3b0:	80 81       	ld	r24, Z
     3b2:	80 64       	ori	r24, 0x40	; 64
     3b4:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
     3b6:	f8 01       	movw	r30, r16
     3b8:	80 81       	ld	r24, Z
     3ba:	84 ff       	sbrs	r24, 4
     3bc:	fc cf       	rjmp	.-8      	; 0x3b6 <gas_sensors_init+0x60>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3be:	f7 01       	movw	r30, r14
     3c0:	80 81       	ld	r24, Z
     3c2:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3c4:	e9 81       	ldd	r30, Y+1	; 0x01
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	ee 0f       	add	r30, r30
     3ca:	ff 1f       	adc	r31, r31
     3cc:	ee 0f       	add	r30, r30
     3ce:	ff 1f       	adc	r31, r31
     3d0:	ef 59       	subi	r30, 0x9F	; 159
     3d2:	fa 4f       	sbci	r31, 0xFA	; 250
     3d4:	20 81       	ld	r18, Z
     3d6:	31 81       	ldd	r19, Z+1	; 0x01
     3d8:	e9 81       	ldd	r30, Y+1	; 0x01
     3da:	f0 e0       	ldi	r31, 0x00	; 0
     3dc:	ee 0f       	add	r30, r30
     3de:	ff 1f       	adc	r31, r31
     3e0:	ee 0f       	add	r30, r30
     3e2:	ff 1f       	adc	r31, r31
     3e4:	ef 59       	subi	r30, 0x9F	; 159
     3e6:	fa 4f       	sbci	r31, 0xFA	; 250
     3e8:	62 81       	ldd	r22, Z+2	; 0x02
     3ea:	73 81       	ldd	r23, Z+3	; 0x03
     3ec:	4b 2d       	mov	r20, r11
     3ee:	68 17       	cp	r22, r24
     3f0:	79 07       	cpc	r23, r25
     3f2:	08 f0       	brcs	.+2      	; 0x3f6 <gas_sensors_init+0xa0>
     3f4:	4a 2d       	mov	r20, r10
     3f6:	41 11       	cpse	r20, r1
     3f8:	07 c0       	rjmp	.+14     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     3fa:	4b 2d       	mov	r20, r11
     3fc:	82 17       	cp	r24, r18
     3fe:	93 07       	cpc	r25, r19
     400:	08 f0       	brcs	.+2      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     402:	4a 2d       	mov	r20, r10
     404:	44 23       	and	r20, r20
     406:	71 f0       	breq	.+28     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     408:	99 81       	ldd	r25, Y+1	; 0x01
     40a:	20 91 8c 05 	lds	r18, 0x058C	; 0x80058c <gas_sensor_initialization_errors>
     40e:	9d 5f       	subi	r25, 0xFD	; 253
     410:	a6 01       	movw	r20, r12
     412:	02 c0       	rjmp	.+4      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
     414:	44 0f       	add	r20, r20
     416:	55 1f       	adc	r21, r21
     418:	9a 95       	dec	r25
     41a:	e2 f7       	brpl	.-8      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     41c:	ca 01       	movw	r24, r20
     41e:	82 2b       	or	r24, r18
     420:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     424:	89 81       	ldd	r24, Y+1	; 0x01
     426:	8f 5f       	subi	r24, 0xFF	; 255
     428:	89 83       	std	Y+1, r24	; 0x01
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	85 30       	cpi	r24, 0x05	; 5
     42e:	08 f4       	brcc	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     430:	bc cf       	rjmp	.-136    	; 0x3aa <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     432:	ea e7       	ldi	r30, 0x7A	; 122
     434:	f0 e0       	ldi	r31, 0x00	; 0
     436:	80 81       	ld	r24, Z
     438:	8f 77       	andi	r24, 0x7F	; 127
     43a:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     43c:	0f 90       	pop	r0
     43e:	df 91       	pop	r29
     440:	cf 91       	pop	r28
     442:	1f 91       	pop	r17
     444:	0f 91       	pop	r16
     446:	ff 90       	pop	r15
     448:	ef 90       	pop	r14
     44a:	df 90       	pop	r13
     44c:	cf 90       	pop	r12
     44e:	bf 90       	pop	r11
     450:	af 90       	pop	r10
     452:	08 95       	ret

00000454 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
     454:	8f 92       	push	r8
     456:	9f 92       	push	r9
     458:	af 92       	push	r10
     45a:	bf 92       	push	r11
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	ef 92       	push	r14
     462:	ff 92       	push	r15
     464:	0f 93       	push	r16
     466:	1f 93       	push	r17
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	00 d0       	rcall	.+0      	; 0x46e <start_gas_sensor_read+0x1a>
     46e:	1f 92       	push	r1
     470:	cd b7       	in	r28, 0x3d	; 61
     472:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     474:	ea e7       	ldi	r30, 0x7A	; 122
     476:	f0 e0       	ldi	r31, 0x00	; 0
     478:	80 81       	ld	r24, Z
     47a:	80 68       	ori	r24, 0x80	; 128
     47c:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     47e:	19 82       	std	Y+1, r1	; 0x01
     480:	89 81       	ldd	r24, Y+1	; 0x01
     482:	85 30       	cpi	r24, 0x05	; 5
     484:	08 f0       	brcs	.+2      	; 0x488 <start_gas_sensor_read+0x34>
     486:	76 c0       	rjmp	.+236    	; 0x574 <start_gas_sensor_read+0x120>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
     488:	68 94       	set
     48a:	88 24       	eor	r8, r8
     48c:	82 f8       	bld	r8, 2
     48e:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     490:	0a e7       	ldi	r16, 0x7A	; 122
     492:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     494:	0f 2e       	mov	r0, r31
     496:	f8 e7       	ldi	r31, 0x78	; 120
     498:	ef 2e       	mov	r14, r31
     49a:	f1 2c       	mov	r15, r1
     49c:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     49e:	cc 24       	eor	r12, r12
     4a0:	c3 94       	inc	r12
     4a2:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4a4:	bb 24       	eor	r11, r11
     4a6:	b3 94       	inc	r11
     4a8:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     4aa:	89 81       	ldd	r24, Y+1	; 0x01
     4ac:	60 de       	rcall	.-832    	; 0x16e <ADC_SetMux>
		total = 0;	// re-zero the average
     4ae:	1b 82       	std	Y+3, r1	; 0x03
     4b0:	1a 82       	std	Y+2, r1	; 0x02
     4b2:	28 2d       	mov	r18, r8
     4b4:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4b6:	f8 01       	movw	r30, r16
     4b8:	80 81       	ld	r24, Z
     4ba:	80 64       	ori	r24, 0x40	; 64
     4bc:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4be:	f8 01       	movw	r30, r16
     4c0:	80 81       	ld	r24, Z
     4c2:	84 ff       	sbrs	r24, 4
     4c4:	fc cf       	rjmp	.-8      	; 0x4be <start_gas_sensor_read+0x6a>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4c6:	f7 01       	movw	r30, r14
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4cc:	e9 81       	ldd	r30, Y+1	; 0x01
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	ef 59       	subi	r30, 0x9F	; 159
     4da:	fa 4f       	sbci	r31, 0xFA	; 250
     4dc:	40 81       	ld	r20, Z
     4de:	51 81       	ldd	r21, Z+1	; 0x01
     4e0:	e9 81       	ldd	r30, Y+1	; 0x01
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	ee 0f       	add	r30, r30
     4e6:	ff 1f       	adc	r31, r31
     4e8:	ee 0f       	add	r30, r30
     4ea:	ff 1f       	adc	r31, r31
     4ec:	ef 59       	subi	r30, 0x9F	; 159
     4ee:	fa 4f       	sbci	r31, 0xFA	; 250
     4f0:	62 81       	ldd	r22, Z+2	; 0x02
     4f2:	73 81       	ldd	r23, Z+3	; 0x03
     4f4:	eb 2d       	mov	r30, r11
     4f6:	68 17       	cp	r22, r24
     4f8:	79 07       	cpc	r23, r25
     4fa:	08 f0       	brcs	.+2      	; 0x4fe <start_gas_sensor_read+0xaa>
     4fc:	ea 2d       	mov	r30, r10
     4fe:	e1 11       	cpse	r30, r1
     500:	07 c0       	rjmp	.+14     	; 0x510 <start_gas_sensor_read+0xbc>
     502:	6b 2d       	mov	r22, r11
     504:	84 17       	cp	r24, r20
     506:	95 07       	cpc	r25, r21
     508:	08 f0       	brcs	.+2      	; 0x50c <start_gas_sensor_read+0xb8>
     50a:	6a 2d       	mov	r22, r10
     50c:	66 23       	and	r22, r22
     50e:	71 f0       	breq	.+28     	; 0x52c <start_gas_sensor_read+0xd8>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     510:	59 81       	ldd	r21, Y+1	; 0x01
     512:	60 91 8c 05 	lds	r22, 0x058C	; 0x80058c <gas_sensor_initialization_errors>
     516:	5d 5f       	subi	r21, 0xFD	; 253
     518:	f6 01       	movw	r30, r12
     51a:	02 c0       	rjmp	.+4      	; 0x520 <start_gas_sensor_read+0xcc>
     51c:	ee 0f       	add	r30, r30
     51e:	ff 1f       	adc	r31, r31
     520:	5a 95       	dec	r21
     522:	e2 f7       	brpl	.-8      	; 0x51c <start_gas_sensor_read+0xc8>
     524:	af 01       	movw	r20, r30
     526:	46 2b       	or	r20, r22
     528:	40 93 8c 05 	sts	0x058C, r20	; 0x80058c <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     52c:	4a 81       	ldd	r20, Y+2	; 0x02
     52e:	5b 81       	ldd	r21, Y+3	; 0x03
     530:	84 0f       	add	r24, r20
     532:	95 1f       	adc	r25, r21
     534:	9b 83       	std	Y+3, r25	; 0x03
     536:	8a 83       	std	Y+2, r24	; 0x02
     538:	21 50       	subi	r18, 0x01	; 1
     53a:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
     53c:	09 f0       	breq	.+2      	; 0x540 <start_gas_sensor_read+0xec>
     53e:	bb cf       	rjmp	.-138    	; 0x4b6 <start_gas_sensor_read+0x62>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     540:	8a 81       	ldd	r24, Y+2	; 0x02
     542:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     544:	e9 81       	ldd	r30, Y+1	; 0x01
     546:	f0 e0       	ldi	r31, 0x00	; 0
     548:	ee 0f       	add	r30, r30
     54a:	ff 1f       	adc	r31, r31
     54c:	e0 58       	subi	r30, 0x80	; 128
     54e:	fa 4f       	sbci	r31, 0xFA	; 250
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     550:	9c 01       	movw	r18, r24
     552:	99 23       	and	r25, r25
     554:	14 f4       	brge	.+4      	; 0x55a <start_gas_sensor_read+0x106>
     556:	2d 5f       	subi	r18, 0xFD	; 253
     558:	3f 4f       	sbci	r19, 0xFF	; 255
     55a:	35 95       	asr	r19
     55c:	27 95       	ror	r18
     55e:	35 95       	asr	r19
     560:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
     562:	31 83       	std	Z+1, r19	; 0x01
     564:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     566:	89 81       	ldd	r24, Y+1	; 0x01
     568:	8f 5f       	subi	r24, 0xFF	; 255
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	89 81       	ldd	r24, Y+1	; 0x01
     56e:	85 30       	cpi	r24, 0x05	; 5
     570:	08 f4       	brcc	.+2      	; 0x574 <start_gas_sensor_read+0x120>
     572:	9b cf       	rjmp	.-202    	; 0x4aa <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     574:	0f 90       	pop	r0
     576:	0f 90       	pop	r0
     578:	0f 90       	pop	r0
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	1f 91       	pop	r17
     580:	0f 91       	pop	r16
     582:	ff 90       	pop	r15
     584:	ef 90       	pop	r14
     586:	df 90       	pop	r13
     588:	cf 90       	pop	r12
     58a:	bf 90       	pop	r11
     58c:	af 90       	pop	r10
     58e:	9f 90       	pop	r9
     590:	8f 90       	pop	r8
     592:	08 95       	ret

00000594 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     594:	1f 93       	push	r17
     596:	cf 93       	push	r28
     598:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     59a:	e3 e9       	ldi	r30, 0x93	; 147
     59c:	f5 e0       	ldi	r31, 0x05	; 5
     59e:	84 ec       	ldi	r24, 0xC4	; 196
     5a0:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     5a2:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     5a4:	84 e0       	ldi	r24, 0x04	; 4
     5a6:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     5a8:	63 e0       	ldi	r22, 0x03	; 3
     5aa:	cf 01       	movw	r24, r30
     5ac:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5b0:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     5b4:	81 11       	cpse	r24, r1
     5b6:	fc cf       	rjmp	.-8      	; 0x5b0 <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5b8:	e3 e9       	ldi	r30, 0x93	; 147
     5ba:	f5 e0       	ldi	r31, 0x05	; 5
     5bc:	84 ec       	ldi	r24, 0xC4	; 196
     5be:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5c0:	81 e0       	ldi	r24, 0x01	; 1
     5c2:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5c4:	62 e0       	ldi	r22, 0x02	; 2
     5c6:	cf 01       	movw	r24, r30
     5c8:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5cc:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     5d0:	81 11       	cpse	r24, r1
     5d2:	fc cf       	rjmp	.-8      	; 0x5cc <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5d4:	c3 e9       	ldi	r28, 0x93	; 147
     5d6:	d5 e0       	ldi	r29, 0x05	; 5
     5d8:	15 ec       	ldi	r17, 0xC5	; 197
     5da:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5dc:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5de:	62 e0       	ldi	r22, 0x02	; 2
     5e0:	ce 01       	movw	r24, r28
     5e2:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5e6:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     5ea:	81 11       	cpse	r24, r1
     5ec:	fc cf       	rjmp	.-8      	; 0x5e6 <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5ee:	62 e0       	ldi	r22, 0x02	; 2
     5f0:	ce 01       	movw	r24, r28
     5f2:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     5f6:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5fa:	89 81       	ldd	r24, Y+1	; 0x01
     5fc:	80 93 a4 06 	sts	0x06A4, r24	; 0x8006a4 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     600:	80 fd       	sbrc	r24, 0
     602:	eb cf       	rjmp	.-42     	; 0x5da <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     604:	e3 e9       	ldi	r30, 0x93	; 147
     606:	f5 e0       	ldi	r31, 0x05	; 5
     608:	84 ec       	ldi	r24, 0xC4	; 196
     60a:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     60c:	8f e8       	ldi	r24, 0x8F	; 143
     60e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     610:	62 e0       	ldi	r22, 0x02	; 2
     612:	cf 01       	movw	r24, r30
     614:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     618:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     61c:	81 11       	cpse	r24, r1
     61e:	fc cf       	rjmp	.-8      	; 0x618 <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     620:	e3 e9       	ldi	r30, 0x93	; 147
     622:	f5 e0       	ldi	r31, 0x05	; 5
     624:	85 ec       	ldi	r24, 0xC5	; 197
     626:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     628:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     62a:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     62c:	63 e0       	ldi	r22, 0x03	; 3
     62e:	cf 01       	movw	r24, r30
     630:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     634:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     638:	81 11       	cpse	r24, r1
     63a:	fc cf       	rjmp	.-8      	; 0x634 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     63c:	63 e0       	ldi	r22, 0x03	; 3
     63e:	83 e9       	ldi	r24, 0x93	; 147
     640:	95 e0       	ldi	r25, 0x05	; 5
     642:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     646:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     64a:	e3 e9       	ldi	r30, 0x93	; 147
     64c:	f5 e0       	ldi	r31, 0x05	; 5
     64e:	81 81       	ldd	r24, Z+1	; 0x01
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	98 2f       	mov	r25, r24
     654:	88 27       	eor	r24, r24
     656:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
     658:	82 0f       	add	r24, r18
     65a:	91 1d       	adc	r25, r1
     65c:	df 91       	pop	r29
     65e:	cf 91       	pop	r28
     660:	1f 91       	pop	r17
     662:	08 95       	ret

00000664 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     664:	ff 92       	push	r15
     666:	0f 93       	push	r16
     668:	1f 93       	push	r17
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     66e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     672:	88 23       	and	r24, r24
     674:	59 f1       	breq	.+86     	; 0x6cc <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     676:	c4 ea       	ldi	r28, 0xA4	; 164
     678:	d5 e0       	ldi	r29, 0x05	; 5
     67a:	0f 2e       	mov	r0, r31
     67c:	fc ee       	ldi	r31, 0xEC	; 236
     67e:	ff 2e       	mov	r15, r31
     680:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     682:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     684:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     686:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     688:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     68a:	62 e0       	ldi	r22, 0x02	; 2
     68c:	ce 01       	movw	r24, r28
     68e:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     692:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     696:	81 11       	cpse	r24, r1
     698:	fc cf       	rjmp	.-8      	; 0x692 <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     69a:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     69c:	6a e1       	ldi	r22, 0x1A	; 26
     69e:	ce 01       	movw	r24, r28
     6a0:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     6a4:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     6a8:	81 11       	cpse	r24, r1
     6aa:	fc cf       	rjmp	.-8      	; 0x6a4 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     6ac:	6a e1       	ldi	r22, 0x1A	; 26
     6ae:	ce 01       	movw	r24, r28
     6b0:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     6b4:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6b8:	89 81       	ldd	r24, Y+1	; 0x01
     6ba:	83 fb       	bst	r24, 3
     6bc:	88 27       	eor	r24, r24
     6be:	80 f9       	bld	r24, 0
     6c0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6c4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6c8:	81 11       	cpse	r24, r1
     6ca:	dd cf       	rjmp	.-70     	; 0x686 <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6cc:	e4 ea       	ldi	r30, 0xA4	; 164
     6ce:	f5 e0       	ldi	r31, 0x05	; 5
     6d0:	8c ee       	ldi	r24, 0xEC	; 236
     6d2:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6d4:	88 e8       	ldi	r24, 0x88	; 136
     6d6:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6d8:	62 e0       	ldi	r22, 0x02	; 2
     6da:	cf 01       	movw	r24, r30
     6dc:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6e0:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     6e4:	81 11       	cpse	r24, r1
     6e6:	fc cf       	rjmp	.-8      	; 0x6e0 <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6e8:	8d ee       	ldi	r24, 0xED	; 237
     6ea:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6ee:	6b e1       	ldi	r22, 0x1B	; 27
     6f0:	84 ea       	ldi	r24, 0xA4	; 164
     6f2:	95 e0       	ldi	r25, 0x05	; 5
     6f4:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6f8:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     6fc:	81 11       	cpse	r24, r1
     6fe:	fc cf       	rjmp	.-8      	; 0x6f8 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     700:	6b e1       	ldi	r22, 0x1B	; 27
     702:	84 ea       	ldi	r24, 0xA4	; 164
     704:	95 e0       	ldi	r25, 0x05	; 5
     706:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     70a:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
     70e:	c5 ea       	ldi	r28, 0xA5	; 165
     710:	d5 e0       	ldi	r29, 0x05	; 5
     712:	0d ea       	ldi	r16, 0xAD	; 173
     714:	16 e0       	ldi	r17, 0x06	; 6
     716:	20 ec       	ldi	r18, 0xC0	; 192
     718:	35 e0       	ldi	r19, 0x05	; 5
     71a:	d8 01       	movw	r26, r16
     71c:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     71e:	81 91       	ld	r24, Z+
     720:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     722:	e2 17       	cp	r30, r18
     724:	f3 07       	cpc	r31, r19
     726:	d9 f7       	brne	.-10     	; 0x71e <BME_read_correction_coefficients+0xba>
     728:	8b e1       	ldi	r24, 0x1B	; 27
     72a:	80 93 2f 03 	sts	0x032F, r24	; 0x80032f <i.2309>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     72e:	ed ea       	ldi	r30, 0xAD	; 173
     730:	f6 e0       	ldi	r31, 0x06	; 6
     732:	81 81       	ldd	r24, Z+1	; 0x01
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	98 2f       	mov	r25, r24
     738:	88 27       	eor	r24, r24
     73a:	20 81       	ld	r18, Z
     73c:	82 2b       	or	r24, r18
     73e:	90 93 a8 06 	sts	0x06A8, r25	; 0x8006a8 <dig_T1+0x1>
     742:	80 93 a7 06 	sts	0x06A7, r24	; 0x8006a7 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     746:	83 81       	ldd	r24, Z+3	; 0x03
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	98 2f       	mov	r25, r24
     74c:	88 27       	eor	r24, r24
     74e:	22 81       	ldd	r18, Z+2	; 0x02
     750:	82 2b       	or	r24, r18
     752:	90 93 ac 06 	sts	0x06AC, r25	; 0x8006ac <dig_T2+0x1>
     756:	80 93 ab 06 	sts	0x06AB, r24	; 0x8006ab <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     75a:	85 81       	ldd	r24, Z+5	; 0x05
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	98 2f       	mov	r25, r24
     760:	88 27       	eor	r24, r24
     762:	24 81       	ldd	r18, Z+4	; 0x04
     764:	82 2b       	or	r24, r18
     766:	90 93 14 07 	sts	0x0714, r25	; 0x800714 <dig_T3+0x1>
     76a:	80 93 13 07 	sts	0x0713, r24	; 0x800713 <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     76e:	87 81       	ldd	r24, Z+7	; 0x07
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	98 2f       	mov	r25, r24
     774:	88 27       	eor	r24, r24
     776:	26 81       	ldd	r18, Z+6	; 0x06
     778:	82 2b       	or	r24, r18
     77a:	90 93 08 07 	sts	0x0708, r25	; 0x800708 <dig_P1+0x1>
     77e:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     782:	81 85       	ldd	r24, Z+9	; 0x09
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	98 2f       	mov	r25, r24
     788:	88 27       	eor	r24, r24
     78a:	20 85       	ldd	r18, Z+8	; 0x08
     78c:	82 2b       	or	r24, r18
     78e:	90 93 e0 06 	sts	0x06E0, r25	; 0x8006e0 <dig_P2+0x1>
     792:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     796:	83 85       	ldd	r24, Z+11	; 0x0b
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	98 2f       	mov	r25, r24
     79c:	88 27       	eor	r24, r24
     79e:	22 85       	ldd	r18, Z+10	; 0x0a
     7a0:	82 2b       	or	r24, r18
     7a2:	90 93 0a 07 	sts	0x070A, r25	; 0x80070a <dig_P3+0x1>
     7a6:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     7aa:	85 85       	ldd	r24, Z+13	; 0x0d
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	98 2f       	mov	r25, r24
     7b0:	88 27       	eor	r24, r24
     7b2:	24 85       	ldd	r18, Z+12	; 0x0c
     7b4:	82 2b       	or	r24, r18
     7b6:	90 93 e2 06 	sts	0x06E2, r25	; 0x8006e2 <dig_P4+0x1>
     7ba:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7be:	87 85       	ldd	r24, Z+15	; 0x0f
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	98 2f       	mov	r25, r24
     7c4:	88 27       	eor	r24, r24
     7c6:	26 85       	ldd	r18, Z+14	; 0x0e
     7c8:	82 2b       	or	r24, r18
     7ca:	90 93 f1 06 	sts	0x06F1, r25	; 0x8006f1 <dig_P5+0x1>
     7ce:	80 93 f0 06 	sts	0x06F0, r24	; 0x8006f0 <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7d2:	81 89       	ldd	r24, Z+17	; 0x11
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	98 2f       	mov	r25, r24
     7d8:	88 27       	eor	r24, r24
     7da:	20 89       	ldd	r18, Z+16	; 0x10
     7dc:	82 2b       	or	r24, r18
     7de:	90 93 16 07 	sts	0x0716, r25	; 0x800716 <dig_P6+0x1>
     7e2:	80 93 15 07 	sts	0x0715, r24	; 0x800715 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7e6:	83 89       	ldd	r24, Z+19	; 0x13
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	98 2f       	mov	r25, r24
     7ec:	88 27       	eor	r24, r24
     7ee:	22 89       	ldd	r18, Z+18	; 0x12
     7f0:	82 2b       	or	r24, r18
     7f2:	90 93 a6 06 	sts	0x06A6, r25	; 0x8006a6 <dig_P7+0x1>
     7f6:	80 93 a5 06 	sts	0x06A5, r24	; 0x8006a5 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7fa:	85 89       	ldd	r24, Z+21	; 0x15
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	98 2f       	mov	r25, r24
     800:	88 27       	eor	r24, r24
     802:	24 89       	ldd	r18, Z+20	; 0x14
     804:	82 2b       	or	r24, r18
     806:	90 93 0c 07 	sts	0x070C, r25	; 0x80070c <dig_P8+0x1>
     80a:	80 93 0b 07 	sts	0x070B, r24	; 0x80070b <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     80e:	87 89       	ldd	r24, Z+23	; 0x17
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	98 2f       	mov	r25, r24
     814:	88 27       	eor	r24, r24
     816:	26 89       	ldd	r18, Z+22	; 0x16
     818:	82 2b       	or	r24, r18
     81a:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <dig_P9+0x1>
     81e:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <dig_P9>
	dig_H1 = RawBMEdata[25];
     822:	81 8d       	ldd	r24, Z+25	; 0x19
     824:	90 e0       	ldi	r25, 0x00	; 0
     826:	90 93 da 06 	sts	0x06DA, r25	; 0x8006da <dig_H1+0x1>
     82a:	80 93 d9 06 	sts	0x06D9, r24	; 0x8006d9 <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     82e:	e4 ea       	ldi	r30, 0xA4	; 164
     830:	f5 e0       	ldi	r31, 0x05	; 5
     832:	8c ee       	ldi	r24, 0xEC	; 236
     834:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     836:	81 ee       	ldi	r24, 0xE1	; 225
     838:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     83a:	62 e0       	ldi	r22, 0x02	; 2
     83c:	cf 01       	movw	r24, r30
     83e:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     842:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     846:	81 11       	cpse	r24, r1
     848:	fc cf       	rjmp	.-8      	; 0x842 <BME_read_correction_coefficients+0x1de>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     84a:	8d ee       	ldi	r24, 0xED	; 237
     84c:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     850:	68 e0       	ldi	r22, 0x08	; 8
     852:	84 ea       	ldi	r24, 0xA4	; 164
     854:	95 e0       	ldi	r25, 0x05	; 5
     856:	0e 94 47 0c 	call	0x188e	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     85a:	0e 94 43 0c 	call	0x1886	; 0x1886 <TWI_Transceiver_Busy>
     85e:	81 11       	cpse	r24, r1
     860:	fc cf       	rjmp	.-8      	; 0x85a <BME_read_correction_coefficients+0x1f6>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     862:	68 e0       	ldi	r22, 0x08	; 8
     864:	84 ea       	ldi	r24, 0xA4	; 164
     866:	95 e0       	ldi	r25, 0x05	; 5
     868:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     86c:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
     870:	2c ea       	ldi	r18, 0xAC	; 172
     872:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     874:	89 91       	ld	r24, Y+
     876:	f8 01       	movw	r30, r16
     878:	81 93       	st	Z+, r24
     87a:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     87c:	c2 17       	cp	r28, r18
     87e:	d3 07       	cpc	r29, r19
     880:	c9 f7       	brne	.-14     	; 0x874 <BME_read_correction_coefficients+0x210>
     882:	87 e0       	ldi	r24, 0x07	; 7
     884:	80 93 2f 03 	sts	0x032F, r24	; 0x80032f <i.2309>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8); 
     888:	ed ea       	ldi	r30, 0xAD	; 173
     88a:	f6 e0       	ldi	r31, 0x06	; 6
     88c:	82 81       	ldd	r24, Z+2	; 0x02
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	98 2f       	mov	r25, r24
     892:	88 27       	eor	r24, r24
     894:	21 81       	ldd	r18, Z+1	; 0x01
     896:	82 2b       	or	r24, r18
     898:	90 93 18 07 	sts	0x0718, r25	; 0x800718 <dig_H2+0x1>
     89c:	80 93 17 07 	sts	0x0717, r24	; 0x800717 <dig_H2>
	dig_H3 = RawBMEdata[3]; 
     8a0:	83 81       	ldd	r24, Z+3	; 0x03
     8a2:	90 e0       	ldi	r25, 0x00	; 0
     8a4:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <dig_H3+0x1>
     8a8:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     8ac:	85 81       	ldd	r24, Z+5	; 0x05
     8ae:	82 95       	swap	r24
     8b0:	86 95       	lsr	r24
     8b2:	87 70       	andi	r24, 0x07	; 7
     8b4:	90 e0       	ldi	r25, 0x00	; 0
     8b6:	24 81       	ldd	r18, Z+4	; 0x04
     8b8:	40 e1       	ldi	r20, 0x10	; 16
     8ba:	24 9f       	mul	r18, r20
     8bc:	90 01       	movw	r18, r0
     8be:	11 24       	eor	r1, r1
     8c0:	28 2b       	or	r18, r24
     8c2:	39 2b       	or	r19, r25
     8c4:	30 93 aa 06 	sts	0x06AA, r19	; 0x8006aa <dig_H4+0x1>
     8c8:	20 93 a9 06 	sts	0x06A9, r18	; 0x8006a9 <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     8cc:	26 81       	ldd	r18, Z+6	; 0x06
     8ce:	40 e1       	ldi	r20, 0x10	; 16
     8d0:	24 9f       	mul	r18, r20
     8d2:	90 01       	movw	r18, r0
     8d4:	11 24       	eor	r1, r1
     8d6:	82 2b       	or	r24, r18
     8d8:	93 2b       	or	r25, r19
     8da:	90 93 0e 07 	sts	0x070E, r25	; 0x80070e <dig_H5+0x1>
     8de:	80 93 0d 07 	sts	0x070D, r24	; 0x80070d <dig_H5>
	dig_H6 = RawBMEdata[7];
     8e2:	87 81       	ldd	r24, Z+7	; 0x07
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	90 93 eb 06 	sts	0x06EB, r25	; 0x8006eb <dig_H6+0x1>
     8ea:	80 93 ea 06 	sts	0x06EA, r24	; 0x8006ea <dig_H6>
}
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	ff 90       	pop	r15
     8f8:	08 95       	ret

000008fa <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8fa:	e4 ea       	ldi	r30, 0xA4	; 164
     8fc:	f5 e0       	ldi	r31, 0x05	; 5
     8fe:	8c ee       	ldi	r24, 0xEC	; 236
     900:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     902:	80 ee       	ldi	r24, 0xE0	; 224
     904:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     906:	86 eb       	ldi	r24, 0xB6	; 182
     908:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     90a:	63 e0       	ldi	r22, 0x03	; 3
     90c:	cf 01       	movw	r24, r30
     90e:	bf d7       	rcall	.+3966   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     910:	ba d7       	rcall	.+3956   	; 0x1886 <TWI_Transceiver_Busy>
     912:	81 11       	cpse	r24, r1
     914:	fd cf       	rjmp	.-6      	; 0x910 <bme280basic_init+0x16>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     916:	e4 ea       	ldi	r30, 0xA4	; 164
     918:	f5 e0       	ldi	r31, 0x05	; 5
     91a:	8c ee       	ldi	r24, 0xEC	; 236
     91c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     91e:	80 ed       	ldi	r24, 0xD0	; 208
     920:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     922:	62 e0       	ldi	r22, 0x02	; 2
     924:	cf 01       	movw	r24, r30
     926:	b3 d7       	rcall	.+3942   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     928:	ae d7       	rcall	.+3932   	; 0x1886 <TWI_Transceiver_Busy>
     92a:	81 11       	cpse	r24, r1
     92c:	fd cf       	rjmp	.-6      	; 0x928 <bme280basic_init+0x2e>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     92e:	8d ee       	ldi	r24, 0xED	; 237
     930:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     934:	62 e0       	ldi	r22, 0x02	; 2
     936:	84 ea       	ldi	r24, 0xA4	; 164
     938:	95 e0       	ldi	r25, 0x05	; 5
     93a:	a9 d7       	rcall	.+3922   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     93c:	a4 d7       	rcall	.+3912   	; 0x1886 <TWI_Transceiver_Busy>
     93e:	81 11       	cpse	r24, r1
     940:	fd cf       	rjmp	.-6      	; 0x93c <bme280basic_init+0x42>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     942:	62 e0       	ldi	r22, 0x02	; 2
     944:	84 ea       	ldi	r24, 0xA4	; 164
     946:	95 e0       	ldi	r25, 0x05	; 5
     948:	ce d7       	rcall	.+3996   	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     94a:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     94e:	80 91 a5 05 	lds	r24, 0x05A5	; 0x8005a5 <BMEmessageBuf+0x1>
     952:	80 36       	cpi	r24, 0x60	; 96
     954:	69 f5       	brne	.+90     	; 0x9b0 <bme280basic_init+0xb6>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     956:	e4 ea       	ldi	r30, 0xA4	; 164
     958:	f5 e0       	ldi	r31, 0x05	; 5
     95a:	8c ee       	ldi	r24, 0xEC	; 236
     95c:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     95e:	82 ef       	ldi	r24, 0xF2	; 242
     960:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     966:	63 e0       	ldi	r22, 0x03	; 3
     968:	cf 01       	movw	r24, r30
     96a:	91 d7       	rcall	.+3874   	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     96c:	8c d7       	rcall	.+3864   	; 0x1886 <TWI_Transceiver_Busy>
     96e:	81 11       	cpse	r24, r1
     970:	fd cf       	rjmp	.-6      	; 0x96c <bme280basic_init+0x72>
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     972:	e4 ea       	ldi	r30, 0xA4	; 164
     974:	f5 e0       	ldi	r31, 0x05	; 5
     976:	8c ee       	ldi	r24, 0xEC	; 236
     978:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     97a:	85 ef       	ldi	r24, 0xF5	; 245
     97c:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     97e:	80 e1       	ldi	r24, 0x10	; 16
     980:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     982:	63 e0       	ldi	r22, 0x03	; 3
     984:	cf 01       	movw	r24, r30
     986:	83 d7       	rcall	.+3846   	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     988:	7e d7       	rcall	.+3836   	; 0x1886 <TWI_Transceiver_Busy>
     98a:	81 11       	cpse	r24, r1
     98c:	fd cf       	rjmp	.-6      	; 0x988 <bme280basic_init+0x8e>
		//
		BME_read_correction_coefficients();
     98e:	6a de       	rcall	.-812    	; 0x664 <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     990:	81 e3       	ldi	r24, 0x31	; 49
     992:	80 93 e3 06 	sts	0x06E3, r24	; 0x8006e3 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     996:	e4 ea       	ldi	r30, 0xA4	; 164
     998:	f5 e0       	ldi	r31, 0x05	; 5
     99a:	9c ee       	ldi	r25, 0xEC	; 236
     99c:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     99e:	94 ef       	ldi	r25, 0xF4	; 244
     9a0:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     9a2:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     9a4:	63 e0       	ldi	r22, 0x03	; 3
     9a6:	cf 01       	movw	r24, r30
     9a8:	72 d7       	rcall	.+3812   	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     9aa:	6d d7       	rcall	.+3802   	; 0x1886 <TWI_Transceiver_Busy>
     9ac:	81 11       	cpse	r24, r1
     9ae:	fd cf       	rjmp	.-6      	; 0x9aa <bme280basic_init+0xb0>
     9b0:	08 95       	ret

000009b2 <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     9b2:	ff 92       	push	r15
     9b4:	0f 93       	push	r16
     9b6:	1f 93       	push	r17
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	80 93 2e 03 	sts	0x032E, r24	; 0x80032e <BMEbusy.2363>
	while (BMEbusy) {
     9c2:	80 91 2e 03 	lds	r24, 0x032E	; 0x80032e <BMEbusy.2363>
     9c6:	88 23       	and	r24, r24
     9c8:	31 f1       	breq	.+76     	; 0xa16 <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9ca:	c4 ea       	ldi	r28, 0xA4	; 164
     9cc:	d5 e0       	ldi	r29, 0x05	; 5
     9ce:	0f 2e       	mov	r0, r31
     9d0:	fc ee       	ldi	r31, 0xEC	; 236
     9d2:	ff 2e       	mov	r15, r31
     9d4:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9d6:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9d8:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9da:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9dc:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9de:	62 e0       	ldi	r22, 0x02	; 2
     9e0:	ce 01       	movw	r24, r28
     9e2:	55 d7       	rcall	.+3754   	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9e4:	50 d7       	rcall	.+3744   	; 0x1886 <TWI_Transceiver_Busy>
     9e6:	81 11       	cpse	r24, r1
     9e8:	fd cf       	rjmp	.-6      	; 0x9e4 <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9ea:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     9ec:	62 e0       	ldi	r22, 0x02	; 2
     9ee:	ce 01       	movw	r24, r28
     9f0:	4e d7       	rcall	.+3740   	; 0x188e <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9f2:	49 d7       	rcall	.+3730   	; 0x1886 <TWI_Transceiver_Busy>
     9f4:	81 11       	cpse	r24, r1
     9f6:	fd cf       	rjmp	.-6      	; 0x9f2 <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9f8:	62 e0       	ldi	r22, 0x02	; 2
     9fa:	ce 01       	movw	r24, r28
     9fc:	74 d7       	rcall	.+3816   	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     9fe:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     a02:	89 81       	ldd	r24, Y+1	; 0x01
     a04:	83 fb       	bst	r24, 3
     a06:	88 27       	eor	r24, r24
     a08:	80 f9       	bld	r24, 0
     a0a:	80 93 2e 03 	sts	0x032E, r24	; 0x80032e <BMEbusy.2363>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     a0e:	80 91 2e 03 	lds	r24, 0x032E	; 0x80032e <BMEbusy.2363>
     a12:	81 11       	cpse	r24, r1
     a14:	e2 cf       	rjmp	.-60     	; 0x9da <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     a16:	e4 ea       	ldi	r30, 0xA4	; 164
     a18:	f5 e0       	ldi	r31, 0x05	; 5
     a1a:	8c ee       	ldi	r24, 0xEC	; 236
     a1c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     a1e:	87 ef       	ldi	r24, 0xF7	; 247
     a20:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     a22:	62 e0       	ldi	r22, 0x02	; 2
     a24:	cf 01       	movw	r24, r30
     a26:	33 d7       	rcall	.+3686   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a28:	2e d7       	rcall	.+3676   	; 0x1886 <TWI_Transceiver_Busy>
     a2a:	81 11       	cpse	r24, r1
     a2c:	fd cf       	rjmp	.-6      	; 0xa28 <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     a2e:	8d ee       	ldi	r24, 0xED	; 237
     a30:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     a34:	69 e0       	ldi	r22, 0x09	; 9
     a36:	84 ea       	ldi	r24, 0xA4	; 164
     a38:	95 e0       	ldi	r25, 0x05	; 5
     a3a:	29 d7       	rcall	.+3666   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a3c:	24 d7       	rcall	.+3656   	; 0x1886 <TWI_Transceiver_Busy>
     a3e:	81 11       	cpse	r24, r1
     a40:	fd cf       	rjmp	.-6      	; 0xa3c <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     a42:	69 e0       	ldi	r22, 0x09	; 9
     a44:	84 ea       	ldi	r24, 0xA4	; 164
     a46:	95 e0       	ldi	r25, 0x05	; 5
     a48:	4e d7       	rcall	.+3740   	; 0x18e6 <TWI_Get_Data_From_Transceiver>
     a4a:	80 93 a3 05 	sts	0x05A3, r24	; 0x8005a3 <TWI_XFER_STATUS>
     a4e:	e5 ea       	ldi	r30, 0xA5	; 165
     a50:	f5 e0       	ldi	r31, 0x05	; 5
     a52:	ad ea       	ldi	r26, 0xAD	; 173
     a54:	b6 e0       	ldi	r27, 0x06	; 6
     a56:	2d ea       	ldi	r18, 0xAD	; 173
     a58:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a5a:	81 91       	ld	r24, Z+
     a5c:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a5e:	e2 17       	cp	r30, r18
     a60:	f3 07       	cpc	r31, r19
     a62:	d9 f7       	brne	.-10     	; 0xa5a <bme280basic_bulk_data_read+0xa8>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a64:	ed ea       	ldi	r30, 0xAD	; 173
     a66:	f6 e0       	ldi	r31, 0x06	; 6
     a68:	81 81       	ldd	r24, Z+1	; 0x01
     a6a:	90 e0       	ldi	r25, 0x00	; 0
     a6c:	a0 e0       	ldi	r26, 0x00	; 0
     a6e:	b0 e0       	ldi	r27, 0x00	; 0
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	aa 1f       	adc	r26, r26
     a76:	bb 1f       	adc	r27, r27
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	aa 1f       	adc	r26, r26
     a7e:	bb 1f       	adc	r27, r27
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	aa 1f       	adc	r26, r26
     a86:	bb 1f       	adc	r27, r27
     a88:	88 0f       	add	r24, r24
     a8a:	99 1f       	adc	r25, r25
     a8c:	aa 1f       	adc	r26, r26
     a8e:	bb 1f       	adc	r27, r27
     a90:	40 81       	ld	r20, Z
     a92:	50 e0       	ldi	r21, 0x00	; 0
     a94:	60 e0       	ldi	r22, 0x00	; 0
     a96:	70 e0       	ldi	r23, 0x00	; 0
     a98:	03 2e       	mov	r0, r19
     a9a:	3c e0       	ldi	r19, 0x0C	; 12
     a9c:	44 0f       	add	r20, r20
     a9e:	55 1f       	adc	r21, r21
     aa0:	66 1f       	adc	r22, r22
     aa2:	77 1f       	adc	r23, r23
     aa4:	3a 95       	dec	r19
     aa6:	d1 f7       	brne	.-12     	; 0xa9c <bme280basic_bulk_data_read+0xea>
     aa8:	30 2d       	mov	r19, r0
     aaa:	84 2b       	or	r24, r20
     aac:	95 2b       	or	r25, r21
     aae:	a6 2b       	or	r26, r22
     ab0:	b7 2b       	or	r27, r23
     ab2:	22 81       	ldd	r18, Z+2	; 0x02
     ab4:	22 95       	swap	r18
     ab6:	2f 70       	andi	r18, 0x0F	; 15
     ab8:	82 2b       	or	r24, r18
     aba:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <rawPress>
     abe:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <rawPress+0x1>
     ac2:	a0 93 f5 06 	sts	0x06F5, r26	; 0x8006f5 <rawPress+0x2>
     ac6:	b0 93 f6 06 	sts	0x06F6, r27	; 0x8006f6 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     aca:	84 81       	ldd	r24, Z+4	; 0x04
     acc:	90 e0       	ldi	r25, 0x00	; 0
     ace:	a0 e0       	ldi	r26, 0x00	; 0
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
     ad2:	88 0f       	add	r24, r24
     ad4:	99 1f       	adc	r25, r25
     ad6:	aa 1f       	adc	r26, r26
     ad8:	bb 1f       	adc	r27, r27
     ada:	88 0f       	add	r24, r24
     adc:	99 1f       	adc	r25, r25
     ade:	aa 1f       	adc	r26, r26
     ae0:	bb 1f       	adc	r27, r27
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	aa 1f       	adc	r26, r26
     ae8:	bb 1f       	adc	r27, r27
     aea:	88 0f       	add	r24, r24
     aec:	99 1f       	adc	r25, r25
     aee:	aa 1f       	adc	r26, r26
     af0:	bb 1f       	adc	r27, r27
     af2:	43 81       	ldd	r20, Z+3	; 0x03
     af4:	50 e0       	ldi	r21, 0x00	; 0
     af6:	60 e0       	ldi	r22, 0x00	; 0
     af8:	70 e0       	ldi	r23, 0x00	; 0
     afa:	03 2e       	mov	r0, r19
     afc:	3c e0       	ldi	r19, 0x0C	; 12
     afe:	44 0f       	add	r20, r20
     b00:	55 1f       	adc	r21, r21
     b02:	66 1f       	adc	r22, r22
     b04:	77 1f       	adc	r23, r23
     b06:	3a 95       	dec	r19
     b08:	d1 f7       	brne	.-12     	; 0xafe <bme280basic_bulk_data_read+0x14c>
     b0a:	30 2d       	mov	r19, r0
     b0c:	84 2b       	or	r24, r20
     b0e:	95 2b       	or	r25, r21
     b10:	a6 2b       	or	r26, r22
     b12:	b7 2b       	or	r27, r23
     b14:	25 81       	ldd	r18, Z+5	; 0x05
     b16:	22 95       	swap	r18
     b18:	2f 70       	andi	r18, 0x0F	; 15
     b1a:	82 2b       	or	r24, r18
     b1c:	80 93 db 06 	sts	0x06DB, r24	; 0x8006db <rawTemp>
     b20:	90 93 dc 06 	sts	0x06DC, r25	; 0x8006dc <rawTemp+0x1>
     b24:	a0 93 dd 06 	sts	0x06DD, r26	; 0x8006dd <rawTemp+0x2>
     b28:	b0 93 de 06 	sts	0x06DE, r27	; 0x8006de <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     b2c:	86 81       	ldd	r24, Z+6	; 0x06
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	a0 e0       	ldi	r26, 0x00	; 0
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	ba 2f       	mov	r27, r26
     b36:	a9 2f       	mov	r26, r25
     b38:	98 2f       	mov	r25, r24
     b3a:	88 27       	eor	r24, r24
     b3c:	27 81       	ldd	r18, Z+7	; 0x07
     b3e:	82 2b       	or	r24, r18
     b40:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <rawHum>
     b44:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <rawHum+0x1>
     b48:	a0 93 f9 06 	sts	0x06F9, r26	; 0x8006f9 <rawHum+0x2>
     b4c:	b0 93 fa 06 	sts	0x06FA, r27	; 0x8006fa <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     b50:	e4 ea       	ldi	r30, 0xA4	; 164
     b52:	f5 e0       	ldi	r31, 0x05	; 5
     b54:	8c ee       	ldi	r24, 0xEC	; 236
     b56:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b58:	84 ef       	ldi	r24, 0xF4	; 244
     b5a:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b5c:	81 e3       	ldi	r24, 0x31	; 49
     b5e:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b60:	63 e0       	ldi	r22, 0x03	; 3
     b62:	cf 01       	movw	r24, r30
     b64:	94 d6       	rcall	.+3368   	; 0x188e <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b66:	8f d6       	rcall	.+3358   	; 0x1886 <TWI_Transceiver_Busy>
     b68:	81 11       	cpse	r24, r1
     b6a:	fd cf       	rjmp	.-6      	; 0xb66 <bme280basic_bulk_data_read+0x1b4>
	//  All done - and the next measurement cycle has  been kicked off!
}
     b6c:	df 91       	pop	r29
     b6e:	cf 91       	pop	r28
     b70:	1f 91       	pop	r17
     b72:	0f 91       	pop	r16
     b74:	ff 90       	pop	r15
     b76:	08 95       	ret

00000b78 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b78:	8f 92       	push	r8
     b7a:	9f 92       	push	r9
     b7c:	af 92       	push	r10
     b7e:	bf 92       	push	r11
     b80:	cf 92       	push	r12
     b82:	df 92       	push	r13
     b84:	ef 92       	push	r14
     b86:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b88:	20 91 a7 06 	lds	r18, 0x06A7	; 0x8006a7 <dig_T1>
     b8c:	30 91 a8 06 	lds	r19, 0x06A8	; 0x8006a8 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b90:	6b 01       	movw	r12, r22
     b92:	7c 01       	movw	r14, r24
     b94:	68 94       	set
     b96:	13 f8       	bld	r1, 3
     b98:	f5 94       	asr	r15
     b9a:	e7 94       	ror	r14
     b9c:	d7 94       	ror	r13
     b9e:	c7 94       	ror	r12
     ba0:	16 94       	lsr	r1
     ba2:	d1 f7       	brne	.-12     	; 0xb98 <BME280_compensate_T_int32+0x20>
     ba4:	c2 1a       	sub	r12, r18
     ba6:	d3 0a       	sbc	r13, r19
     ba8:	e1 08       	sbc	r14, r1
     baa:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     bac:	dc 01       	movw	r26, r24
     bae:	cb 01       	movw	r24, r22
     bb0:	68 94       	set
     bb2:	12 f8       	bld	r1, 2
     bb4:	b5 95       	asr	r27
     bb6:	a7 95       	ror	r26
     bb8:	97 95       	ror	r25
     bba:	87 95       	ror	r24
     bbc:	16 94       	lsr	r1
     bbe:	d1 f7       	brne	.-12     	; 0xbb4 <BME280_compensate_T_int32+0x3c>
     bc0:	22 0f       	add	r18, r18
     bc2:	33 1f       	adc	r19, r19
     bc4:	4c 01       	movw	r8, r24
     bc6:	5d 01       	movw	r10, r26
     bc8:	82 1a       	sub	r8, r18
     bca:	93 0a       	sbc	r9, r19
     bcc:	a1 08       	sbc	r10, r1
     bce:	b1 08       	sbc	r11, r1
     bd0:	a5 01       	movw	r20, r10
     bd2:	94 01       	movw	r18, r8
     bd4:	a0 91 ab 06 	lds	r26, 0x06AB	; 0x8006ab <dig_T2>
     bd8:	b0 91 ac 06 	lds	r27, 0x06AC	; 0x8006ac <dig_T2+0x1>
     bdc:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__mulshisi3>
     be0:	4b 01       	movw	r8, r22
     be2:	5c 01       	movw	r10, r24
     be4:	07 2e       	mov	r0, r23
     be6:	7b e0       	ldi	r23, 0x0B	; 11
     be8:	b5 94       	asr	r11
     bea:	a7 94       	ror	r10
     bec:	97 94       	ror	r9
     bee:	87 94       	ror	r8
     bf0:	7a 95       	dec	r23
     bf2:	d1 f7       	brne	.-12     	; 0xbe8 <BME280_compensate_T_int32+0x70>
     bf4:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     bf6:	a7 01       	movw	r20, r14
     bf8:	96 01       	movw	r18, r12
     bfa:	c7 01       	movw	r24, r14
     bfc:	b6 01       	movw	r22, r12
     bfe:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <__mulsi3>
     c02:	9b 01       	movw	r18, r22
     c04:	ac 01       	movw	r20, r24
     c06:	01 2e       	mov	r0, r17
     c08:	1c e0       	ldi	r17, 0x0C	; 12
     c0a:	55 95       	asr	r21
     c0c:	47 95       	ror	r20
     c0e:	37 95       	ror	r19
     c10:	27 95       	ror	r18
     c12:	1a 95       	dec	r17
     c14:	d1 f7       	brne	.-12     	; 0xc0a <BME280_compensate_T_int32+0x92>
     c16:	10 2d       	mov	r17, r0
     c18:	a0 91 13 07 	lds	r26, 0x0713	; 0x800713 <dig_T3>
     c1c:	b0 91 14 07 	lds	r27, 0x0714	; 0x800714 <dig_T3+0x1>
     c20:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__mulshisi3>
     c24:	dc 01       	movw	r26, r24
     c26:	cb 01       	movw	r24, r22
     c28:	07 2e       	mov	r0, r23
     c2a:	7e e0       	ldi	r23, 0x0E	; 14
     c2c:	b5 95       	asr	r27
     c2e:	a7 95       	ror	r26
     c30:	97 95       	ror	r25
     c32:	87 95       	ror	r24
     c34:	7a 95       	dec	r23
     c36:	d1 f7       	brne	.-12     	; 0xc2c <BME280_compensate_T_int32+0xb4>
     c38:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     c3a:	88 0d       	add	r24, r8
     c3c:	99 1d       	adc	r25, r9
     c3e:	aa 1d       	adc	r26, r10
     c40:	bb 1d       	adc	r27, r11
     c42:	80 93 19 07 	sts	0x0719, r24	; 0x800719 <t_fine>
     c46:	90 93 1a 07 	sts	0x071A, r25	; 0x80071a <t_fine+0x1>
     c4a:	a0 93 1b 07 	sts	0x071B, r26	; 0x80071b <t_fine+0x2>
     c4e:	b0 93 1c 07 	sts	0x071C, r27	; 0x80071c <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     c52:	6c 01       	movw	r12, r24
     c54:	7d 01       	movw	r14, r26
     c56:	cc 0c       	add	r12, r12
     c58:	dd 1c       	adc	r13, r13
     c5a:	ee 1c       	adc	r14, r14
     c5c:	ff 1c       	adc	r15, r15
     c5e:	cc 0c       	add	r12, r12
     c60:	dd 1c       	adc	r13, r13
     c62:	ee 1c       	adc	r14, r14
     c64:	ff 1c       	adc	r15, r15
     c66:	8c 0d       	add	r24, r12
     c68:	9d 1d       	adc	r25, r13
     c6a:	ae 1d       	adc	r26, r14
     c6c:	bf 1d       	adc	r27, r15
     c6e:	80 58       	subi	r24, 0x80	; 128
     c70:	9f 4f       	sbci	r25, 0xFF	; 255
     c72:	af 4f       	sbci	r26, 0xFF	; 255
     c74:	bf 4f       	sbci	r27, 0xFF	; 255
     c76:	69 2f       	mov	r22, r25
     c78:	7a 2f       	mov	r23, r26
     c7a:	8b 2f       	mov	r24, r27
     c7c:	99 27       	eor	r25, r25
     c7e:	87 fd       	sbrc	r24, 7
     c80:	9a 95       	dec	r25
	return T;
}
     c82:	ff 90       	pop	r15
     c84:	ef 90       	pop	r14
     c86:	df 90       	pop	r13
     c88:	cf 90       	pop	r12
     c8a:	bf 90       	pop	r11
     c8c:	af 90       	pop	r10
     c8e:	9f 90       	pop	r9
     c90:	8f 90       	pop	r8
     c92:	08 95       	ret

00000c94 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c94:	2f 92       	push	r2
     c96:	3f 92       	push	r3
     c98:	4f 92       	push	r4
     c9a:	5f 92       	push	r5
     c9c:	6f 92       	push	r6
     c9e:	7f 92       	push	r7
     ca0:	8f 92       	push	r8
     ca2:	9f 92       	push	r9
     ca4:	af 92       	push	r10
     ca6:	bf 92       	push	r11
     ca8:	cf 92       	push	r12
     caa:	df 92       	push	r13
     cac:	ef 92       	push	r14
     cae:	ff 92       	push	r15
     cb0:	0f 93       	push	r16
     cb2:	1f 93       	push	r17
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	cd b7       	in	r28, 0x3d	; 61
     cba:	de b7       	in	r29, 0x3e	; 62
     cbc:	6e 97       	sbiw	r28, 0x1e	; 30
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	f8 94       	cli
     cc2:	de bf       	out	0x3e, r29	; 62
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	cd bf       	out	0x3d, r28	; 61
     cc8:	6e 8b       	std	Y+22, r22	; 0x16
     cca:	7f 8b       	std	Y+23, r23	; 0x17
     ccc:	88 8f       	std	Y+24, r24	; 0x18
     cce:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     cd0:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <t_fine>
     cd4:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <t_fine+0x1>
     cd8:	a0 91 1b 07 	lds	r26, 0x071B	; 0x80071b <t_fine+0x2>
     cdc:	b0 91 1c 07 	lds	r27, 0x071C	; 0x80071c <t_fine+0x3>
     ce0:	8c 01       	movw	r16, r24
     ce2:	9d 01       	movw	r18, r26
     ce4:	14 5f       	subi	r17, 0xF4	; 244
     ce6:	21 40       	sbci	r18, 0x01	; 1
     ce8:	31 09       	sbc	r19, r1
     cea:	09 83       	std	Y+1, r16	; 0x01
     cec:	1a 83       	std	Y+2, r17	; 0x02
     cee:	2b 83       	std	Y+3, r18	; 0x03
     cf0:	3c 83       	std	Y+4, r19	; 0x04
     cf2:	33 0f       	add	r19, r19
     cf4:	00 0b       	sbc	r16, r16
     cf6:	10 2f       	mov	r17, r16
     cf8:	98 01       	movw	r18, r16
     cfa:	0d 83       	std	Y+5, r16	; 0x05
     cfc:	1e 83       	std	Y+6, r17	; 0x06
     cfe:	2f 83       	std	Y+7, r18	; 0x07
     d00:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     d02:	a9 80       	ldd	r10, Y+1	; 0x01
     d04:	ba 80       	ldd	r11, Y+2	; 0x02
     d06:	cb 80       	ldd	r12, Y+3	; 0x03
     d08:	dc 80       	ldd	r13, Y+4	; 0x04
     d0a:	ed 80       	ldd	r14, Y+5	; 0x05
     d0c:	fe 2c       	mov	r15, r14
     d0e:	0e 2d       	mov	r16, r14
     d10:	1e 2d       	mov	r17, r14
     d12:	2a 2d       	mov	r18, r10
     d14:	3b 2d       	mov	r19, r11
     d16:	4c 2d       	mov	r20, r12
     d18:	5d 2d       	mov	r21, r13
     d1a:	60 2f       	mov	r22, r16
     d1c:	70 2f       	mov	r23, r16
     d1e:	80 2f       	mov	r24, r16
     d20:	9e 2d       	mov	r25, r14
     d22:	bb d7       	rcall	.+3958   	; 0x1c9a <__muldi3>
     d24:	2d 87       	std	Y+13, r18	; 0x0d
     d26:	3e 87       	std	Y+14, r19	; 0x0e
     d28:	4f 87       	std	Y+15, r20	; 0x0f
     d2a:	58 8b       	std	Y+16, r21	; 0x10
     d2c:	69 8b       	std	Y+17, r22	; 0x11
     d2e:	7a 8b       	std	Y+18, r23	; 0x12
     d30:	8b 8b       	std	Y+19, r24	; 0x13
     d32:	9c 8b       	std	Y+20, r25	; 0x14
     d34:	10 91 15 07 	lds	r17, 0x0715	; 0x800715 <dig_P6>
     d38:	1a 8f       	std	Y+26, r17	; 0x1a
     d3a:	20 91 16 07 	lds	r18, 0x0716	; 0x800716 <dig_P6+0x1>
     d3e:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     d40:	30 91 f0 06 	lds	r19, 0x06F0	; 0x8006f0 <dig_P5>
     d44:	3b 8f       	std	Y+27, r19	; 0x1b
     d46:	40 91 f1 06 	lds	r20, 0x06F1	; 0x8006f1 <dig_P5+0x1>
     d4a:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     d4c:	50 91 e1 06 	lds	r21, 0x06E1	; 0x8006e1 <dig_P4>
     d50:	5c 8f       	std	Y+28, r21	; 0x1c
     d52:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <dig_P4+0x1>
     d56:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     d58:	30 91 e0 06 	lds	r19, 0x06E0	; 0x8006e0 <dig_P2+0x1>
     d5c:	20 91 df 06 	lds	r18, 0x06DF	; 0x8006df <dig_P2>
     d60:	93 2f       	mov	r25, r19
     d62:	99 0f       	add	r25, r25
     d64:	99 0b       	sbc	r25, r25
     d66:	fe 2c       	mov	r15, r14
     d68:	0e 2d       	mov	r16, r14
     d6a:	1e 2d       	mov	r17, r14
     d6c:	49 2f       	mov	r20, r25
     d6e:	59 2f       	mov	r21, r25
     d70:	69 2f       	mov	r22, r25
     d72:	79 2f       	mov	r23, r25
     d74:	89 2f       	mov	r24, r25
     d76:	91 d7       	rcall	.+3874   	; 0x1c9a <__muldi3>
     d78:	0c e0       	ldi	r16, 0x0C	; 12
     d7a:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <__ashldi3>
     d7e:	42 2e       	mov	r4, r18
     d80:	53 2e       	mov	r5, r19
     d82:	64 2e       	mov	r6, r20
     d84:	75 2e       	mov	r7, r21
     d86:	86 2e       	mov	r8, r22
     d88:	97 2e       	mov	r9, r23
     d8a:	28 2e       	mov	r2, r24
     d8c:	39 2e       	mov	r3, r25
     d8e:	b0 90 0a 07 	lds	r11, 0x070A	; 0x80070a <dig_P3+0x1>
     d92:	a0 90 09 07 	lds	r10, 0x0709	; 0x800709 <dig_P3>
     d96:	1b 2d       	mov	r17, r11
     d98:	11 0f       	add	r17, r17
     d9a:	11 0b       	sbc	r17, r17
     d9c:	c1 2e       	mov	r12, r17
     d9e:	d1 2e       	mov	r13, r17
     da0:	e1 2e       	mov	r14, r17
     da2:	f1 2e       	mov	r15, r17
     da4:	01 2f       	mov	r16, r17
     da6:	2d 85       	ldd	r18, Y+13	; 0x0d
     da8:	3e 85       	ldd	r19, Y+14	; 0x0e
     daa:	4f 85       	ldd	r20, Y+15	; 0x0f
     dac:	58 89       	ldd	r21, Y+16	; 0x10
     dae:	69 89       	ldd	r22, Y+17	; 0x11
     db0:	7a 89       	ldd	r23, Y+18	; 0x12
     db2:	8b 89       	ldd	r24, Y+19	; 0x13
     db4:	9c 89       	ldd	r25, Y+20	; 0x14
     db6:	71 d7       	rcall	.+3810   	; 0x1c9a <__muldi3>
     db8:	08 e0       	ldi	r16, 0x08	; 8
     dba:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashrdi3>
     dbe:	a4 2c       	mov	r10, r4
     dc0:	b5 2c       	mov	r11, r5
     dc2:	c6 2c       	mov	r12, r6
     dc4:	d7 2c       	mov	r13, r7
     dc6:	e8 2c       	mov	r14, r8
     dc8:	f9 2c       	mov	r15, r9
     dca:	02 2d       	mov	r16, r2
     dcc:	13 2d       	mov	r17, r3
     dce:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     dd2:	70 58       	subi	r23, 0x80	; 128
     dd4:	8f 4f       	sbci	r24, 0xFF	; 255
     dd6:	9f 4f       	sbci	r25, 0xFF	; 255
     dd8:	20 90 07 07 	lds	r2, 0x0707	; 0x800707 <dig_P1>
     ddc:	30 90 08 07 	lds	r3, 0x0708	; 0x800708 <dig_P1+0x1>
     de0:	a2 2c       	mov	r10, r2
     de2:	b3 2c       	mov	r11, r3
     de4:	c1 2c       	mov	r12, r1
     de6:	d1 2c       	mov	r13, r1
     de8:	e1 2c       	mov	r14, r1
     dea:	f1 2c       	mov	r15, r1
     dec:	00 e0       	ldi	r16, 0x00	; 0
     dee:	10 e0       	ldi	r17, 0x00	; 0
     df0:	54 d7       	rcall	.+3752   	; 0x1c9a <__muldi3>
     df2:	01 e2       	ldi	r16, 0x21	; 33
     df4:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashrdi3>
     df8:	29 87       	std	Y+9, r18	; 0x09
     dfa:	3a 87       	std	Y+10, r19	; 0x0a
     dfc:	4b 87       	std	Y+11, r20	; 0x0b
     dfe:	45 2e       	mov	r4, r21
     e00:	56 2e       	mov	r5, r22
     e02:	7c 87       	std	Y+12, r23	; 0x0c
     e04:	38 2e       	mov	r3, r24
     e06:	29 2e       	mov	r2, r25
	if (var1 == 0)
     e08:	65 2d       	mov	r22, r5
     e0a:	83 2d       	mov	r24, r3
     e0c:	92 2d       	mov	r25, r2
     e0e:	a0 e0       	ldi	r26, 0x00	; 0
     e10:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <__cmpdi2_s8>
     e14:	09 f4       	brne	.+2      	; 0xe18 <BME280_compensate_P_int64+0x184>
     e16:	72 c1       	rjmp	.+740    	; 0x10fc <BME280_compensate_P_int64+0x468>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     e18:	aa 8c       	ldd	r10, Y+26	; 0x1a
     e1a:	1e 8d       	ldd	r17, Y+30	; 0x1e
     e1c:	11 0f       	add	r17, r17
     e1e:	11 0b       	sbc	r17, r17
     e20:	be 8c       	ldd	r11, Y+30	; 0x1e
     e22:	c1 2e       	mov	r12, r17
     e24:	d1 2e       	mov	r13, r17
     e26:	e1 2e       	mov	r14, r17
     e28:	f1 2e       	mov	r15, r17
     e2a:	01 2f       	mov	r16, r17
     e2c:	2d 85       	ldd	r18, Y+13	; 0x0d
     e2e:	3e 85       	ldd	r19, Y+14	; 0x0e
     e30:	4f 85       	ldd	r20, Y+15	; 0x0f
     e32:	58 89       	ldd	r21, Y+16	; 0x10
     e34:	69 89       	ldd	r22, Y+17	; 0x11
     e36:	7a 89       	ldd	r23, Y+18	; 0x12
     e38:	8b 89       	ldd	r24, Y+19	; 0x13
     e3a:	9c 89       	ldd	r25, Y+20	; 0x14
     e3c:	2e d7       	rcall	.+3676   	; 0x1c9a <__muldi3>
     e3e:	2d 87       	std	Y+13, r18	; 0x0d
     e40:	3e 87       	std	Y+14, r19	; 0x0e
     e42:	64 2e       	mov	r6, r20
     e44:	75 2e       	mov	r7, r21
     e46:	86 2e       	mov	r8, r22
     e48:	97 2e       	mov	r9, r23
     e4a:	88 8b       	std	Y+16, r24	; 0x10
     e4c:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     e4e:	2b 8d       	ldd	r18, Y+27	; 0x1b
     e50:	9d 8d       	ldd	r25, Y+29	; 0x1d
     e52:	99 0f       	add	r25, r25
     e54:	99 0b       	sbc	r25, r25
     e56:	a9 80       	ldd	r10, Y+1	; 0x01
     e58:	ba 80       	ldd	r11, Y+2	; 0x02
     e5a:	cb 80       	ldd	r12, Y+3	; 0x03
     e5c:	dc 80       	ldd	r13, Y+4	; 0x04
     e5e:	ed 80       	ldd	r14, Y+5	; 0x05
     e60:	fe 2c       	mov	r15, r14
     e62:	0e 2d       	mov	r16, r14
     e64:	1e 2d       	mov	r17, r14
     e66:	3d 8d       	ldd	r19, Y+29	; 0x1d
     e68:	49 2f       	mov	r20, r25
     e6a:	59 2f       	mov	r21, r25
     e6c:	69 2f       	mov	r22, r25
     e6e:	79 2f       	mov	r23, r25
     e70:	89 2f       	mov	r24, r25
     e72:	13 d7       	rcall	.+3622   	; 0x1c9a <__muldi3>
     e74:	01 e1       	ldi	r16, 0x11	; 17
     e76:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <__ashldi3>
     e7a:	ad 84       	ldd	r10, Y+13	; 0x0d
     e7c:	be 84       	ldd	r11, Y+14	; 0x0e
     e7e:	c6 2c       	mov	r12, r6
     e80:	d7 2c       	mov	r13, r7
     e82:	e8 2c       	mov	r14, r8
     e84:	f9 2c       	mov	r15, r9
     e86:	08 89       	ldd	r16, Y+16	; 0x10
     e88:	1f 85       	ldd	r17, Y+15	; 0x0f
     e8a:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <__adddi3>
     e8e:	a2 2e       	mov	r10, r18
     e90:	b3 2e       	mov	r11, r19
     e92:	c4 2e       	mov	r12, r20
     e94:	d5 2e       	mov	r13, r21
     e96:	e6 2e       	mov	r14, r22
     e98:	f7 2e       	mov	r15, r23
     e9a:	e8 2f       	mov	r30, r24
     e9c:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	a0 e1       	ldi	r26, 0x10	; 16
     ea4:	b0 e0       	ldi	r27, 0x00	; 0
     ea6:	2e 89       	ldd	r18, Y+22	; 0x16
     ea8:	3f 89       	ldd	r19, Y+23	; 0x17
     eaa:	48 8d       	ldd	r20, Y+24	; 0x18
     eac:	59 8d       	ldd	r21, Y+25	; 0x19
     eae:	82 1b       	sub	r24, r18
     eb0:	93 0b       	sbc	r25, r19
     eb2:	a4 0b       	sbc	r26, r20
     eb4:	b5 0b       	sbc	r27, r21
     eb6:	3c 01       	movw	r6, r24
     eb8:	4d 01       	movw	r8, r26
     eba:	99 0c       	add	r9, r9
     ebc:	66 08       	sbc	r6, r6
     ebe:	76 2c       	mov	r7, r6
     ec0:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     ec2:	28 2f       	mov	r18, r24
     ec4:	39 2f       	mov	r19, r25
     ec6:	4a 2f       	mov	r20, r26
     ec8:	5b 2f       	mov	r21, r27
     eca:	66 2d       	mov	r22, r6
     ecc:	76 2d       	mov	r23, r6
     ece:	86 2d       	mov	r24, r6
     ed0:	96 2d       	mov	r25, r6
     ed2:	0f e1       	ldi	r16, 0x1F	; 31
     ed4:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <__ashldi3>
     ed8:	82 2e       	mov	r8, r18
     eda:	93 2e       	mov	r9, r19
     edc:	f4 2f       	mov	r31, r20
     ede:	75 2e       	mov	r7, r21
     ee0:	b6 2f       	mov	r27, r22
     ee2:	a7 2f       	mov	r26, r23
     ee4:	68 2e       	mov	r6, r24
     ee6:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     ee8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     eea:	9d 89       	ldd	r25, Y+21	; 0x15
     eec:	99 0f       	add	r25, r25
     eee:	99 0b       	sbc	r25, r25
     ef0:	3d 89       	ldd	r19, Y+21	; 0x15
     ef2:	49 2f       	mov	r20, r25
     ef4:	59 2f       	mov	r21, r25
     ef6:	69 2f       	mov	r22, r25
     ef8:	79 2f       	mov	r23, r25
     efa:	89 2f       	mov	r24, r25
     efc:	03 e2       	ldi	r16, 0x23	; 35
     efe:	ee d7       	rcall	.+4060   	; 0x1edc <__ashldi3>
     f00:	0e 2f       	mov	r16, r30
     f02:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <__adddi3>
     f06:	a2 2e       	mov	r10, r18
     f08:	b3 2e       	mov	r11, r19
     f0a:	c4 2e       	mov	r12, r20
     f0c:	d5 2e       	mov	r13, r21
     f0e:	e6 2e       	mov	r14, r22
     f10:	f7 2e       	mov	r15, r23
     f12:	08 2f       	mov	r16, r24
     f14:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     f16:	28 2d       	mov	r18, r8
     f18:	39 2d       	mov	r19, r9
     f1a:	4f 2f       	mov	r20, r31
     f1c:	57 2d       	mov	r21, r7
     f1e:	6b 2f       	mov	r22, r27
     f20:	7a 2f       	mov	r23, r26
     f22:	86 2d       	mov	r24, r6
     f24:	9d 81       	ldd	r25, Y+5	; 0x05
     f26:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <__subdi3>
     f2a:	82 2e       	mov	r8, r18
     f2c:	93 2e       	mov	r9, r19
     f2e:	49 83       	std	Y+1, r20	; 0x01
     f30:	65 2e       	mov	r6, r21
     f32:	b6 2f       	mov	r27, r22
     f34:	a7 2f       	mov	r26, r23
     f36:	f8 2f       	mov	r31, r24
     f38:	e9 2f       	mov	r30, r25
     f3a:	03 e0       	ldi	r16, 0x03	; 3
     f3c:	cf d7       	rcall	.+3998   	; 0x1edc <__ashldi3>
     f3e:	a8 2c       	mov	r10, r8
     f40:	b9 2c       	mov	r11, r9
     f42:	c9 80       	ldd	r12, Y+1	; 0x01
     f44:	d6 2c       	mov	r13, r6
     f46:	eb 2e       	mov	r14, r27
     f48:	fa 2e       	mov	r15, r26
     f4a:	0f 2f       	mov	r16, r31
     f4c:	1e 2f       	mov	r17, r30
     f4e:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <__subdi3>
     f52:	a2 2e       	mov	r10, r18
     f54:	b3 2e       	mov	r11, r19
     f56:	c4 2e       	mov	r12, r20
     f58:	d5 2e       	mov	r13, r21
     f5a:	e6 2e       	mov	r14, r22
     f5c:	f7 2e       	mov	r15, r23
     f5e:	78 2e       	mov	r7, r24
     f60:	19 2f       	mov	r17, r25
     f62:	03 e0       	ldi	r16, 0x03	; 3
     f64:	bb d7       	rcall	.+3958   	; 0x1edc <__ashldi3>
     f66:	07 2d       	mov	r16, r7
     f68:	f9 d7       	rcall	.+4082   	; 0x1f5c <__subdi3>
     f6a:	03 e0       	ldi	r16, 0x03	; 3
     f6c:	b7 d7       	rcall	.+3950   	; 0x1edc <__ashldi3>
     f6e:	a8 2c       	mov	r10, r8
     f70:	b9 2c       	mov	r11, r9
     f72:	c9 80       	ldd	r12, Y+1	; 0x01
     f74:	d6 2c       	mov	r13, r6
     f76:	eb 2e       	mov	r14, r27
     f78:	fa 2e       	mov	r15, r26
     f7a:	0f 2f       	mov	r16, r31
     f7c:	1e 2f       	mov	r17, r30
     f7e:	ee d7       	rcall	.+4060   	; 0x1f5c <__subdi3>
     f80:	02 e0       	ldi	r16, 0x02	; 2
     f82:	ac d7       	rcall	.+3928   	; 0x1edc <__ashldi3>
     f84:	0f 2f       	mov	r16, r31
     f86:	ea d7       	rcall	.+4052   	; 0x1f5c <__subdi3>
     f88:	01 e0       	ldi	r16, 0x01	; 1
     f8a:	a8 d7       	rcall	.+3920   	; 0x1edc <__ashldi3>
     f8c:	0f 2f       	mov	r16, r31
     f8e:	e6 d7       	rcall	.+4044   	; 0x1f5c <__subdi3>
     f90:	a9 84       	ldd	r10, Y+9	; 0x09
     f92:	ba 84       	ldd	r11, Y+10	; 0x0a
     f94:	cb 84       	ldd	r12, Y+11	; 0x0b
     f96:	d4 2c       	mov	r13, r4
     f98:	e5 2c       	mov	r14, r5
     f9a:	fc 84       	ldd	r15, Y+12	; 0x0c
     f9c:	03 2d       	mov	r16, r3
     f9e:	12 2d       	mov	r17, r2
     fa0:	cf d6       	rcall	.+3486   	; 0x1d40 <__divdi3>
     fa2:	2e 87       	std	Y+14, r18	; 0x0e
     fa4:	3d 87       	std	Y+13, r19	; 0x0d
     fa6:	49 83       	std	Y+1, r20	; 0x01
     fa8:	5d 83       	std	Y+5, r21	; 0x05
     faa:	69 87       	std	Y+9, r22	; 0x09
     fac:	7a 87       	std	Y+10, r23	; 0x0a
     fae:	8b 87       	std	Y+11, r24	; 0x0b
     fb0:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     fb2:	0d e0       	ldi	r16, 0x0D	; 13
     fb4:	ac d7       	rcall	.+3928   	; 0x1f0e <__ashrdi3>
     fb6:	82 2e       	mov	r8, r18
     fb8:	93 2e       	mov	r9, r19
     fba:	74 2e       	mov	r7, r20
     fbc:	65 2e       	mov	r6, r21
     fbe:	56 2e       	mov	r5, r22
     fc0:	47 2e       	mov	r4, r23
     fc2:	38 2e       	mov	r3, r24
     fc4:	29 2e       	mov	r2, r25
     fc6:	30 91 12 07 	lds	r19, 0x0712	; 0x800712 <dig_P9+0x1>
     fca:	20 91 11 07 	lds	r18, 0x0711	; 0x800711 <dig_P9>
     fce:	93 2f       	mov	r25, r19
     fd0:	99 0f       	add	r25, r25
     fd2:	99 0b       	sbc	r25, r25
     fd4:	a8 2c       	mov	r10, r8
     fd6:	b9 2c       	mov	r11, r9
     fd8:	c7 2c       	mov	r12, r7
     fda:	d6 2c       	mov	r13, r6
     fdc:	e5 2c       	mov	r14, r5
     fde:	f4 2c       	mov	r15, r4
     fe0:	03 2d       	mov	r16, r3
     fe2:	12 2d       	mov	r17, r2
     fe4:	49 2f       	mov	r20, r25
     fe6:	59 2f       	mov	r21, r25
     fe8:	69 2f       	mov	r22, r25
     fea:	79 2f       	mov	r23, r25
     fec:	89 2f       	mov	r24, r25
     fee:	55 d6       	rcall	.+3242   	; 0x1c9a <__muldi3>
     ff0:	a2 2e       	mov	r10, r18
     ff2:	b3 2e       	mov	r11, r19
     ff4:	c4 2e       	mov	r12, r20
     ff6:	d5 2e       	mov	r13, r21
     ff8:	e6 2e       	mov	r14, r22
     ffa:	f7 2e       	mov	r15, r23
     ffc:	08 2f       	mov	r16, r24
     ffe:	19 2f       	mov	r17, r25
    1000:	28 2d       	mov	r18, r8
    1002:	39 2d       	mov	r19, r9
    1004:	47 2d       	mov	r20, r7
    1006:	56 2d       	mov	r21, r6
    1008:	65 2d       	mov	r22, r5
    100a:	74 2d       	mov	r23, r4
    100c:	83 2d       	mov	r24, r3
    100e:	92 2d       	mov	r25, r2
    1010:	44 d6       	rcall	.+3208   	; 0x1c9a <__muldi3>
    1012:	09 e1       	ldi	r16, 0x19	; 25
    1014:	7c d7       	rcall	.+3832   	; 0x1f0e <__ashrdi3>
    1016:	a2 2e       	mov	r10, r18
    1018:	b3 2e       	mov	r11, r19
    101a:	c4 2e       	mov	r12, r20
    101c:	d5 2e       	mov	r13, r21
    101e:	e6 2e       	mov	r14, r22
    1020:	f7 2e       	mov	r15, r23
    1022:	08 2f       	mov	r16, r24
    1024:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1026:	2e 85       	ldd	r18, Y+14	; 0x0e
    1028:	3d 85       	ldd	r19, Y+13	; 0x0d
    102a:	49 81       	ldd	r20, Y+1	; 0x01
    102c:	5d 81       	ldd	r21, Y+5	; 0x05
    102e:	69 85       	ldd	r22, Y+9	; 0x09
    1030:	7a 85       	ldd	r23, Y+10	; 0x0a
    1032:	8b 85       	ldd	r24, Y+11	; 0x0b
    1034:	9c 85       	ldd	r25, Y+12	; 0x0c
    1036:	89 d7       	rcall	.+3858   	; 0x1f4a <__adddi3>
    1038:	22 2e       	mov	r2, r18
    103a:	33 2e       	mov	r3, r19
    103c:	44 2e       	mov	r4, r20
    103e:	55 2e       	mov	r5, r21
    1040:	66 2e       	mov	r6, r22
    1042:	77 2e       	mov	r7, r23
    1044:	88 2e       	mov	r8, r24
    1046:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
    1048:	30 91 0c 07 	lds	r19, 0x070C	; 0x80070c <dig_P8+0x1>
    104c:	20 91 0b 07 	lds	r18, 0x070B	; 0x80070b <dig_P8>
    1050:	93 2f       	mov	r25, r19
    1052:	99 0f       	add	r25, r25
    1054:	99 0b       	sbc	r25, r25
    1056:	ae 84       	ldd	r10, Y+14	; 0x0e
    1058:	bd 84       	ldd	r11, Y+13	; 0x0d
    105a:	c9 80       	ldd	r12, Y+1	; 0x01
    105c:	dd 80       	ldd	r13, Y+5	; 0x05
    105e:	e9 84       	ldd	r14, Y+9	; 0x09
    1060:	fa 84       	ldd	r15, Y+10	; 0x0a
    1062:	0b 85       	ldd	r16, Y+11	; 0x0b
    1064:	1c 85       	ldd	r17, Y+12	; 0x0c
    1066:	49 2f       	mov	r20, r25
    1068:	59 2f       	mov	r21, r25
    106a:	69 2f       	mov	r22, r25
    106c:	79 2f       	mov	r23, r25
    106e:	89 2f       	mov	r24, r25
    1070:	14 d6       	rcall	.+3112   	; 0x1c9a <__muldi3>
    1072:	03 e1       	ldi	r16, 0x13	; 19
    1074:	4c d7       	rcall	.+3736   	; 0x1f0e <__ashrdi3>
    1076:	a2 2e       	mov	r10, r18
    1078:	b3 2e       	mov	r11, r19
    107a:	c4 2e       	mov	r12, r20
    107c:	d5 2e       	mov	r13, r21
    107e:	e6 2e       	mov	r14, r22
    1080:	f7 2e       	mov	r15, r23
    1082:	08 2f       	mov	r16, r24
    1084:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1086:	22 2d       	mov	r18, r2
    1088:	33 2d       	mov	r19, r3
    108a:	44 2d       	mov	r20, r4
    108c:	55 2d       	mov	r21, r5
    108e:	66 2d       	mov	r22, r6
    1090:	77 2d       	mov	r23, r7
    1092:	88 2d       	mov	r24, r8
    1094:	99 2d       	mov	r25, r9
    1096:	59 d7       	rcall	.+3762   	; 0x1f4a <__adddi3>
    1098:	08 e0       	ldi	r16, 0x08	; 8
    109a:	39 d7       	rcall	.+3698   	; 0x1f0e <__ashrdi3>
    109c:	40 90 a5 06 	lds	r4, 0x06A5	; 0x8006a5 <dig_P7>
    10a0:	50 90 a6 06 	lds	r5, 0x06A6	; 0x8006a6 <dig_P7+0x1>
    10a4:	05 2c       	mov	r0, r5
    10a6:	00 0c       	add	r0, r0
    10a8:	66 08       	sbc	r6, r6
    10aa:	77 08       	sbc	r7, r7
    10ac:	44 0c       	add	r4, r4
    10ae:	55 1c       	adc	r5, r5
    10b0:	66 1c       	adc	r6, r6
    10b2:	77 1c       	adc	r7, r7
    10b4:	44 0c       	add	r4, r4
    10b6:	55 1c       	adc	r5, r5
    10b8:	66 1c       	adc	r6, r6
    10ba:	77 1c       	adc	r7, r7
    10bc:	44 0c       	add	r4, r4
    10be:	55 1c       	adc	r5, r5
    10c0:	66 1c       	adc	r6, r6
    10c2:	77 1c       	adc	r7, r7
    10c4:	44 0c       	add	r4, r4
    10c6:	55 1c       	adc	r5, r5
    10c8:	66 1c       	adc	r6, r6
    10ca:	77 1c       	adc	r7, r7
    10cc:	83 01       	movw	r16, r6
    10ce:	72 01       	movw	r14, r4
    10d0:	11 0f       	add	r17, r17
    10d2:	ee 08       	sbc	r14, r14
    10d4:	fe 2c       	mov	r15, r14
    10d6:	87 01       	movw	r16, r14
    10d8:	e9 82       	std	Y+1, r14	; 0x01
    10da:	fa 82       	std	Y+2, r15	; 0x02
    10dc:	0b 83       	std	Y+3, r16	; 0x03
    10de:	1c 83       	std	Y+4, r17	; 0x04
    10e0:	a4 2c       	mov	r10, r4
    10e2:	b5 2c       	mov	r11, r5
    10e4:	c6 2c       	mov	r12, r6
    10e6:	d7 2c       	mov	r13, r7
    10e8:	e9 80       	ldd	r14, Y+1	; 0x01
    10ea:	fe 2c       	mov	r15, r14
    10ec:	0e 2d       	mov	r16, r14
    10ee:	1e 2d       	mov	r17, r14
    10f0:	2c d7       	rcall	.+3672   	; 0x1f4a <__adddi3>
	return(long)p;
    10f2:	62 2f       	mov	r22, r18
    10f4:	73 2f       	mov	r23, r19
    10f6:	84 2f       	mov	r24, r20
    10f8:	95 2f       	mov	r25, r21
    10fa:	04 c0       	rjmp	.+8      	; 0x1104 <BME280_compensate_P_int64+0x470>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    10fc:	60 e0       	ldi	r22, 0x00	; 0
    10fe:	70 e0       	ldi	r23, 0x00	; 0
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    1104:	6e 96       	adiw	r28, 0x1e	; 30
    1106:	0f b6       	in	r0, 0x3f	; 63
    1108:	f8 94       	cli
    110a:	de bf       	out	0x3e, r29	; 62
    110c:	0f be       	out	0x3f, r0	; 63
    110e:	cd bf       	out	0x3d, r28	; 61
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	1f 91       	pop	r17
    1116:	0f 91       	pop	r16
    1118:	ff 90       	pop	r15
    111a:	ef 90       	pop	r14
    111c:	df 90       	pop	r13
    111e:	cf 90       	pop	r12
    1120:	bf 90       	pop	r11
    1122:	af 90       	pop	r10
    1124:	9f 90       	pop	r9
    1126:	8f 90       	pop	r8
    1128:	7f 90       	pop	r7
    112a:	6f 90       	pop	r6
    112c:	5f 90       	pop	r5
    112e:	4f 90       	pop	r4
    1130:	3f 90       	pop	r3
    1132:	2f 90       	pop	r2
    1134:	08 95       	ret

00001136 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    1136:	2f 92       	push	r2
    1138:	3f 92       	push	r3
    113a:	4f 92       	push	r4
    113c:	5f 92       	push	r5
    113e:	6f 92       	push	r6
    1140:	7f 92       	push	r7
    1142:	8f 92       	push	r8
    1144:	9f 92       	push	r9
    1146:	af 92       	push	r10
    1148:	bf 92       	push	r11
    114a:	cf 92       	push	r12
    114c:	df 92       	push	r13
    114e:	ef 92       	push	r14
    1150:	ff 92       	push	r15
    1152:	0f 93       	push	r16
    1154:	1f 93       	push	r17
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	cd b7       	in	r28, 0x3d	; 61
    115c:	de b7       	in	r29, 0x3e	; 62
    115e:	67 97       	sbiw	r28, 0x17	; 23
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	de bf       	out	0x3e, r29	; 62
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	cd bf       	out	0x3d, r28	; 61
    116a:	2b 01       	movw	r4, r22
    116c:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    116e:	80 91 19 07 	lds	r24, 0x0719	; 0x800719 <t_fine>
    1172:	90 91 1a 07 	lds	r25, 0x071A	; 0x80071a <t_fine+0x1>
    1176:	a0 91 1b 07 	lds	r26, 0x071B	; 0x80071b <t_fine+0x2>
    117a:	b0 91 1c 07 	lds	r27, 0x071C	; 0x80071c <t_fine+0x3>
    117e:	6c 01       	movw	r12, r24
    1180:	7d 01       	movw	r14, r26
    1182:	ff 0c       	add	r15, r15
    1184:	cc 08       	sbc	r12, r12
    1186:	dc 2c       	mov	r13, r12
    1188:	76 01       	movw	r14, r12
    118a:	28 2f       	mov	r18, r24
    118c:	39 2f       	mov	r19, r25
    118e:	4a 2f       	mov	r20, r26
    1190:	5b 2f       	mov	r21, r27
    1192:	6c 2d       	mov	r22, r12
    1194:	7c 2d       	mov	r23, r12
    1196:	8c 2d       	mov	r24, r12
    1198:	9c 2d       	mov	r25, r12
    119a:	3c 52       	subi	r19, 0x2C	; 44
    119c:	41 40       	sbci	r20, 0x01	; 1
    119e:	51 09       	sbc	r21, r1
    11a0:	61 09       	sbc	r22, r1
    11a2:	71 09       	sbc	r23, r1
    11a4:	81 09       	sbc	r24, r1
    11a6:	91 09       	sbc	r25, r1
    11a8:	2f 8b       	std	Y+23, r18	; 0x17
    11aa:	3e 8b       	std	Y+22, r19	; 0x16
    11ac:	49 83       	std	Y+1, r20	; 0x01
    11ae:	59 87       	std	Y+9, r21	; 0x09
    11b0:	6a 87       	std	Y+10, r22	; 0x0a
    11b2:	7b 87       	std	Y+11, r23	; 0x0b
    11b4:	8c 87       	std	Y+12, r24	; 0x0c
    11b6:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    11b8:	03 2e       	mov	r0, r19
    11ba:	3e e0       	ldi	r19, 0x0E	; 14
    11bc:	44 0c       	add	r4, r4
    11be:	55 1c       	adc	r5, r5
    11c0:	66 1c       	adc	r6, r6
    11c2:	77 1c       	adc	r7, r7
    11c4:	3a 95       	dec	r19
    11c6:	d1 f7       	brne	.-12     	; 0x11bc <bme280_compensate_H_int32+0x86>
    11c8:	30 2d       	mov	r19, r0
    11ca:	53 01       	movw	r10, r6
    11cc:	42 01       	movw	r8, r4
    11ce:	bb 0c       	add	r11, r11
    11d0:	88 08       	sbc	r8, r8
    11d2:	98 2c       	mov	r9, r8
    11d4:	54 01       	movw	r10, r8
    11d6:	30 91 aa 06 	lds	r19, 0x06AA	; 0x8006aa <dig_H4+0x1>
    11da:	20 91 a9 06 	lds	r18, 0x06A9	; 0x8006a9 <dig_H4>
    11de:	93 2f       	mov	r25, r19
    11e0:	99 0f       	add	r25, r25
    11e2:	99 0b       	sbc	r25, r25
    11e4:	49 2f       	mov	r20, r25
    11e6:	59 2f       	mov	r21, r25
    11e8:	69 2f       	mov	r22, r25
    11ea:	79 2f       	mov	r23, r25
    11ec:	89 2f       	mov	r24, r25
    11ee:	04 e1       	ldi	r16, 0x14	; 20
    11f0:	75 d6       	rcall	.+3306   	; 0x1edc <__ashldi3>
    11f2:	f2 2f       	mov	r31, r18
    11f4:	e3 2f       	mov	r30, r19
    11f6:	c4 2e       	mov	r12, r20
    11f8:	d5 2e       	mov	r13, r21
    11fa:	e6 2e       	mov	r14, r22
    11fc:	f7 2e       	mov	r15, r23
    11fe:	08 2f       	mov	r16, r24
    1200:	19 2f       	mov	r17, r25
    1202:	24 2d       	mov	r18, r4
    1204:	35 2d       	mov	r19, r5
    1206:	46 2d       	mov	r20, r6
    1208:	57 2d       	mov	r21, r7
    120a:	68 2d       	mov	r22, r8
    120c:	78 2d       	mov	r23, r8
    120e:	88 2d       	mov	r24, r8
    1210:	98 2d       	mov	r25, r8
    1212:	af 2e       	mov	r10, r31
    1214:	be 2e       	mov	r11, r30
    1216:	a2 d6       	rcall	.+3396   	; 0x1f5c <__subdi3>
    1218:	22 2e       	mov	r2, r18
    121a:	33 2e       	mov	r3, r19
    121c:	44 2e       	mov	r4, r20
    121e:	55 2e       	mov	r5, r21
    1220:	66 2e       	mov	r6, r22
    1222:	77 2e       	mov	r7, r23
    1224:	88 2e       	mov	r8, r24
    1226:	99 2e       	mov	r9, r25
    1228:	30 91 0e 07 	lds	r19, 0x070E	; 0x80070e <dig_H5+0x1>
    122c:	20 91 0d 07 	lds	r18, 0x070D	; 0x80070d <dig_H5>
    1230:	93 2f       	mov	r25, r19
    1232:	99 0f       	add	r25, r25
    1234:	99 0b       	sbc	r25, r25
    1236:	af 88       	ldd	r10, Y+23	; 0x17
    1238:	be 88       	ldd	r11, Y+22	; 0x16
    123a:	c9 80       	ldd	r12, Y+1	; 0x01
    123c:	d9 84       	ldd	r13, Y+9	; 0x09
    123e:	ea 84       	ldd	r14, Y+10	; 0x0a
    1240:	fb 84       	ldd	r15, Y+11	; 0x0b
    1242:	0c 85       	ldd	r16, Y+12	; 0x0c
    1244:	1d 85       	ldd	r17, Y+13	; 0x0d
    1246:	49 2f       	mov	r20, r25
    1248:	59 2f       	mov	r21, r25
    124a:	69 2f       	mov	r22, r25
    124c:	79 2f       	mov	r23, r25
    124e:	89 2f       	mov	r24, r25
    1250:	24 d5       	rcall	.+2632   	; 0x1c9a <__muldi3>
    1252:	a2 2e       	mov	r10, r18
    1254:	b3 2e       	mov	r11, r19
    1256:	c4 2e       	mov	r12, r20
    1258:	d5 2e       	mov	r13, r21
    125a:	e6 2e       	mov	r14, r22
    125c:	f7 2e       	mov	r15, r23
    125e:	08 2f       	mov	r16, r24
    1260:	19 2f       	mov	r17, r25
    1262:	22 2d       	mov	r18, r2
    1264:	33 2d       	mov	r19, r3
    1266:	44 2d       	mov	r20, r4
    1268:	55 2d       	mov	r21, r5
    126a:	66 2d       	mov	r22, r6
    126c:	77 2d       	mov	r23, r7
    126e:	88 2d       	mov	r24, r8
    1270:	99 2d       	mov	r25, r9
    1272:	74 d6       	rcall	.+3304   	; 0x1f5c <__subdi3>
    1274:	30 5c       	subi	r19, 0xC0	; 192
    1276:	4f 4f       	sbci	r20, 0xFF	; 255
    1278:	5f 4f       	sbci	r21, 0xFF	; 255
    127a:	6f 4f       	sbci	r22, 0xFF	; 255
    127c:	7f 4f       	sbci	r23, 0xFF	; 255
    127e:	8f 4f       	sbci	r24, 0xFF	; 255
    1280:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1282:	0f e0       	ldi	r16, 0x0F	; 15
    1284:	44 d6       	rcall	.+3208   	; 0x1f0e <__ashrdi3>
    1286:	2e 87       	std	Y+14, r18	; 0x0e
    1288:	3f 87       	std	Y+15, r19	; 0x0f
    128a:	48 8b       	std	Y+16, r20	; 0x10
    128c:	59 8b       	std	Y+17, r21	; 0x11
    128e:	6a 8b       	std	Y+18, r22	; 0x12
    1290:	7b 8b       	std	Y+19, r23	; 0x13
    1292:	8c 8b       	std	Y+20, r24	; 0x14
    1294:	9d 8b       	std	Y+21, r25	; 0x15
    1296:	30 91 eb 06 	lds	r19, 0x06EB	; 0x8006eb <dig_H6+0x1>
    129a:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <dig_H6>
    129e:	93 2f       	mov	r25, r19
    12a0:	99 0f       	add	r25, r25
    12a2:	99 0b       	sbc	r25, r25
    12a4:	af 88       	ldd	r10, Y+23	; 0x17
    12a6:	be 88       	ldd	r11, Y+22	; 0x16
    12a8:	c9 80       	ldd	r12, Y+1	; 0x01
    12aa:	d9 84       	ldd	r13, Y+9	; 0x09
    12ac:	ea 84       	ldd	r14, Y+10	; 0x0a
    12ae:	fb 84       	ldd	r15, Y+11	; 0x0b
    12b0:	0c 85       	ldd	r16, Y+12	; 0x0c
    12b2:	1d 85       	ldd	r17, Y+13	; 0x0d
    12b4:	49 2f       	mov	r20, r25
    12b6:	59 2f       	mov	r21, r25
    12b8:	69 2f       	mov	r22, r25
    12ba:	79 2f       	mov	r23, r25
    12bc:	89 2f       	mov	r24, r25
    12be:	ed d4       	rcall	.+2522   	; 0x1c9a <__muldi3>
    12c0:	0a e0       	ldi	r16, 0x0A	; 10
    12c2:	25 d6       	rcall	.+3146   	; 0x1f0e <__ashrdi3>
    12c4:	82 2e       	mov	r8, r18
    12c6:	93 2e       	mov	r9, r19
    12c8:	74 2e       	mov	r7, r20
    12ca:	65 2e       	mov	r6, r21
    12cc:	56 2e       	mov	r5, r22
    12ce:	47 2e       	mov	r4, r23
    12d0:	38 2e       	mov	r3, r24
    12d2:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12d4:	40 91 0f 07 	lds	r20, 0x070F	; 0x80070f <dig_H3>
    12d8:	50 91 10 07 	lds	r21, 0x0710	; 0x800710 <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12dc:	0c 85       	ldd	r16, Y+12	; 0x0c
    12de:	24 2f       	mov	r18, r20
    12e0:	35 2f       	mov	r19, r21
    12e2:	40 e0       	ldi	r20, 0x00	; 0
    12e4:	50 e0       	ldi	r21, 0x00	; 0
    12e6:	60 e0       	ldi	r22, 0x00	; 0
    12e8:	70 e0       	ldi	r23, 0x00	; 0
    12ea:	80 e0       	ldi	r24, 0x00	; 0
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	d5 d4       	rcall	.+2474   	; 0x1c9a <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12f0:	0b e0       	ldi	r16, 0x0B	; 11
    12f2:	0d d6       	rcall	.+3098   	; 0x1f0e <__ashrdi3>
    12f4:	30 58       	subi	r19, 0x80	; 128
    12f6:	4f 4f       	sbci	r20, 0xFF	; 255
    12f8:	5f 4f       	sbci	r21, 0xFF	; 255
    12fa:	6f 4f       	sbci	r22, 0xFF	; 255
    12fc:	7f 4f       	sbci	r23, 0xFF	; 255
    12fe:	8f 4f       	sbci	r24, 0xFF	; 255
    1300:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1302:	a2 2e       	mov	r10, r18
    1304:	b3 2e       	mov	r11, r19
    1306:	c4 2e       	mov	r12, r20
    1308:	d5 2e       	mov	r13, r21
    130a:	e6 2e       	mov	r14, r22
    130c:	f7 2e       	mov	r15, r23
    130e:	08 2f       	mov	r16, r24
    1310:	19 2f       	mov	r17, r25
    1312:	28 2d       	mov	r18, r8
    1314:	39 2d       	mov	r19, r9
    1316:	47 2d       	mov	r20, r7
    1318:	56 2d       	mov	r21, r6
    131a:	65 2d       	mov	r22, r5
    131c:	74 2d       	mov	r23, r4
    131e:	83 2d       	mov	r24, r3
    1320:	92 2d       	mov	r25, r2
    1322:	bb d4       	rcall	.+2422   	; 0x1c9a <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1324:	0a e0       	ldi	r16, 0x0A	; 10
    1326:	f3 d5       	rcall	.+3046   	; 0x1f0e <__ashrdi3>
    1328:	40 5e       	subi	r20, 0xE0	; 224
    132a:	5f 4f       	sbci	r21, 0xFF	; 255
    132c:	6f 4f       	sbci	r22, 0xFF	; 255
    132e:	7f 4f       	sbci	r23, 0xFF	; 255
    1330:	8f 4f       	sbci	r24, 0xFF	; 255
    1332:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
    1334:	b0 90 18 07 	lds	r11, 0x0718	; 0x800718 <dig_H2+0x1>
    1338:	a0 90 17 07 	lds	r10, 0x0717	; 0x800717 <dig_H2>
    133c:	1b 2d       	mov	r17, r11
    133e:	11 0f       	add	r17, r17
    1340:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1342:	c1 2e       	mov	r12, r17
    1344:	d1 2e       	mov	r13, r17
    1346:	e1 2e       	mov	r14, r17
    1348:	f1 2e       	mov	r15, r17
    134a:	01 2f       	mov	r16, r17
    134c:	a6 d4       	rcall	.+2380   	; 0x1c9a <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    134e:	30 5e       	subi	r19, 0xE0	; 224
    1350:	4f 4f       	sbci	r20, 0xFF	; 255
    1352:	5f 4f       	sbci	r21, 0xFF	; 255
    1354:	6f 4f       	sbci	r22, 0xFF	; 255
    1356:	7f 4f       	sbci	r23, 0xFF	; 255
    1358:	8f 4f       	sbci	r24, 0xFF	; 255
    135a:	9f 4f       	sbci	r25, 0xFF	; 255
    135c:	0e e0       	ldi	r16, 0x0E	; 14
    135e:	d7 d5       	rcall	.+2990   	; 0x1f0e <__ashrdi3>
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1360:	a2 2e       	mov	r10, r18
    1362:	b3 2e       	mov	r11, r19
    1364:	c4 2e       	mov	r12, r20
    1366:	d5 2e       	mov	r13, r21
    1368:	e6 2e       	mov	r14, r22
    136a:	f7 2e       	mov	r15, r23
    136c:	08 2f       	mov	r16, r24
    136e:	19 2f       	mov	r17, r25
    1370:	2e 85       	ldd	r18, Y+14	; 0x0e
    1372:	3f 85       	ldd	r19, Y+15	; 0x0f
    1374:	48 89       	ldd	r20, Y+16	; 0x10
    1376:	59 89       	ldd	r21, Y+17	; 0x11
    1378:	6a 89       	ldd	r22, Y+18	; 0x12
    137a:	7b 89       	ldd	r23, Y+19	; 0x13
    137c:	8c 89       	ldd	r24, Y+20	; 0x14
    137e:	9d 89       	ldd	r25, Y+21	; 0x15
    1380:	8c d4       	rcall	.+2328   	; 0x1c9a <__muldi3>
    1382:	42 2e       	mov	r4, r18
    1384:	53 2e       	mov	r5, r19
    1386:	64 2e       	mov	r6, r20
    1388:	75 2e       	mov	r7, r21
    138a:	86 2e       	mov	r8, r22
    138c:	97 2e       	mov	r9, r23
    138e:	28 2e       	mov	r2, r24
    1390:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1392:	0f e0       	ldi	r16, 0x0F	; 15
    1394:	bc d5       	rcall	.+2936   	; 0x1f0e <__ashrdi3>
    1396:	a2 2e       	mov	r10, r18
    1398:	b3 2e       	mov	r11, r19
    139a:	c4 2e       	mov	r12, r20
    139c:	d5 2e       	mov	r13, r21
    139e:	e6 2e       	mov	r14, r22
    13a0:	f7 2e       	mov	r15, r23
    13a2:	08 2f       	mov	r16, r24
    13a4:	19 2f       	mov	r17, r25
    13a6:	79 d4       	rcall	.+2290   	; 0x1c9a <__muldi3>
    13a8:	07 e0       	ldi	r16, 0x07	; 7
    13aa:	b1 d5       	rcall	.+2914   	; 0x1f0e <__ashrdi3>
    13ac:	e0 91 d9 06 	lds	r30, 0x06D9	; 0x8006d9 <dig_H1>
    13b0:	f0 91 da 06 	lds	r31, 0x06DA	; 0x8006da <dig_H1+0x1>
    13b4:	5f 01       	movw	r10, r30
    13b6:	c1 2c       	mov	r12, r1
    13b8:	d1 2c       	mov	r13, r1
    13ba:	e1 2c       	mov	r14, r1
    13bc:	f1 2c       	mov	r15, r1
    13be:	87 01       	movw	r16, r14
    13c0:	e9 83       	std	Y+1, r30	; 0x01
    13c2:	ba 82       	std	Y+2, r11	; 0x02
    13c4:	cb 82       	std	Y+3, r12	; 0x03
    13c6:	dc 82       	std	Y+4, r13	; 0x04
    13c8:	ed 82       	std	Y+5, r14	; 0x05
    13ca:	fe 82       	std	Y+6, r15	; 0x06
    13cc:	0f 83       	std	Y+7, r16	; 0x07
    13ce:	18 87       	std	Y+8, r17	; 0x08
    13d0:	c1 2c       	mov	r12, r1
    13d2:	d1 2c       	mov	r13, r1
    13d4:	e1 2c       	mov	r14, r1
    13d6:	f1 2c       	mov	r15, r1
    13d8:	00 e0       	ldi	r16, 0x00	; 0
    13da:	10 e0       	ldi	r17, 0x00	; 0
    13dc:	5e d4       	rcall	.+2236   	; 0x1c9a <__muldi3>
    13de:	04 e0       	ldi	r16, 0x04	; 4
    13e0:	96 d5       	rcall	.+2860   	; 0x1f0e <__ashrdi3>
    13e2:	a2 2e       	mov	r10, r18
    13e4:	b3 2e       	mov	r11, r19
    13e6:	c4 2e       	mov	r12, r20
    13e8:	d5 2e       	mov	r13, r21
    13ea:	e6 2e       	mov	r14, r22
    13ec:	f7 2e       	mov	r15, r23
    13ee:	08 2f       	mov	r16, r24
    13f0:	19 2f       	mov	r17, r25
    13f2:	24 2d       	mov	r18, r4
    13f4:	35 2d       	mov	r19, r5
    13f6:	46 2d       	mov	r20, r6
    13f8:	57 2d       	mov	r21, r7
    13fa:	68 2d       	mov	r22, r8
    13fc:	79 2d       	mov	r23, r9
    13fe:	82 2d       	mov	r24, r2
    1400:	93 2d       	mov	r25, r3
    1402:	ac d5       	rcall	.+2904   	; 0x1f5c <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    1404:	f2 2e       	mov	r15, r18
    1406:	03 2f       	mov	r16, r19
    1408:	14 2f       	mov	r17, r20
    140a:	65 2e       	mov	r6, r21
    140c:	76 2e       	mov	r7, r22
    140e:	b7 2f       	mov	r27, r23
    1410:	f8 2f       	mov	r31, r24
    1412:	e9 2f       	mov	r30, r25
    1414:	a0 e0       	ldi	r26, 0x00	; 0
    1416:	ab d5       	rcall	.+2902   	; 0x1f6e <__cmpdi2_s8>
    1418:	44 f4       	brge	.+16     	; 0x142a <bme280_compensate_H_int32+0x2f4>
    141a:	f1 2c       	mov	r15, r1
    141c:	00 e0       	ldi	r16, 0x00	; 0
    141e:	10 e0       	ldi	r17, 0x00	; 0
    1420:	61 2c       	mov	r6, r1
    1422:	71 2c       	mov	r7, r1
    1424:	b0 e0       	ldi	r27, 0x00	; 0
    1426:	f0 e0       	ldi	r31, 0x00	; 0
    1428:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    142a:	8f 2c       	mov	r8, r15
    142c:	90 2e       	mov	r9, r16
    142e:	a1 2e       	mov	r10, r17
    1430:	b6 2c       	mov	r11, r6
    1432:	c7 2c       	mov	r12, r7
    1434:	db 2e       	mov	r13, r27
    1436:	ef 2e       	mov	r14, r31
    1438:	ae 2f       	mov	r26, r30
    143a:	2f 2d       	mov	r18, r15
    143c:	30 2f       	mov	r19, r16
    143e:	41 2f       	mov	r20, r17
    1440:	56 2d       	mov	r21, r6
    1442:	67 2d       	mov	r22, r7
    1444:	7b 2f       	mov	r23, r27
    1446:	8f 2f       	mov	r24, r31
    1448:	9e 2f       	mov	r25, r30
    144a:	21 15       	cp	r18, r1
    144c:	31 05       	cpc	r19, r1
    144e:	41 05       	cpc	r20, r1
    1450:	59 41       	sbci	r21, 0x19	; 25
    1452:	61 05       	cpc	r22, r1
    1454:	71 05       	cpc	r23, r1
    1456:	81 05       	cpc	r24, r1
    1458:	91 05       	cpc	r25, r1
    145a:	61 f0       	breq	.+24     	; 0x1474 <bme280_compensate_H_int32+0x33e>
    145c:	5c f0       	brlt	.+22     	; 0x1474 <bme280_compensate_H_int32+0x33e>
    145e:	81 2c       	mov	r8, r1
    1460:	91 2c       	mov	r9, r1
    1462:	a1 2c       	mov	r10, r1
    1464:	0f 2e       	mov	r0, r31
    1466:	f9 e1       	ldi	r31, 0x19	; 25
    1468:	bf 2e       	mov	r11, r31
    146a:	f0 2d       	mov	r31, r0
    146c:	c1 2c       	mov	r12, r1
    146e:	d1 2c       	mov	r13, r1
    1470:	e1 2c       	mov	r14, r1
    1472:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    1474:	28 2d       	mov	r18, r8
    1476:	39 2d       	mov	r19, r9
    1478:	4a 2d       	mov	r20, r10
    147a:	5b 2d       	mov	r21, r11
    147c:	6c 2d       	mov	r22, r12
    147e:	7d 2d       	mov	r23, r13
    1480:	8e 2d       	mov	r24, r14
    1482:	9a 2f       	mov	r25, r26
    1484:	0c e0       	ldi	r16, 0x0C	; 12
    1486:	43 d5       	rcall	.+2694   	; 0x1f0e <__ashrdi3>
    1488:	62 2f       	mov	r22, r18
    148a:	73 2f       	mov	r23, r19
    148c:	84 2f       	mov	r24, r20
    148e:	95 2f       	mov	r25, r21
}
    1490:	67 96       	adiw	r28, 0x17	; 23
    1492:	0f b6       	in	r0, 0x3f	; 63
    1494:	f8 94       	cli
    1496:	de bf       	out	0x3e, r29	; 62
    1498:	0f be       	out	0x3f, r0	; 63
    149a:	cd bf       	out	0x3d, r28	; 61
    149c:	df 91       	pop	r29
    149e:	cf 91       	pop	r28
    14a0:	1f 91       	pop	r17
    14a2:	0f 91       	pop	r16
    14a4:	ff 90       	pop	r15
    14a6:	ef 90       	pop	r14
    14a8:	df 90       	pop	r13
    14aa:	cf 90       	pop	r12
    14ac:	bf 90       	pop	r11
    14ae:	af 90       	pop	r10
    14b0:	9f 90       	pop	r9
    14b2:	8f 90       	pop	r8
    14b4:	7f 90       	pop	r7
    14b6:	6f 90       	pop	r6
    14b8:	5f 90       	pop	r5
    14ba:	4f 90       	pop	r4
    14bc:	3f 90       	pop	r3
    14be:	2f 90       	pop	r2
    14c0:	08 95       	ret

000014c2 <main>:
/********************************************************************************
						Main
********************************************************************************/
int main(void)
{
    14c2:	cf 93       	push	r28
    14c4:	df 93       	push	r29
    14c6:	00 d0       	rcall	.+0      	; 0x14c8 <main+0x6>
    14c8:	cd b7       	in	r28, 0x3d	; 61
    14ca:	de b7       	in	r29, 0x3e	; 62
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    14cc:	0e 94 5e 01 	call	0x2bc	; 0x2bc <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    14d0:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <seconds+0x1>
    14d4:	10 92 05 07 	sts	0x0705, r1	; 0x800705 <seconds>
	ItsTime=0;
    14d8:	10 92 60 05 	sts	0x0560, r1	; 0x800560 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout0;
    14dc:	8b e2       	ldi	r24, 0x2B	; 43
    14de:	91 e0       	ldi	r25, 0x01	; 1
    14e0:	90 93 20 09 	sts	0x0920, r25	; 0x800920 <__iob+0x3>
    14e4:	80 93 1f 09 	sts	0x091F, r24	; 0x80091f <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
    14e8:	b6 d1       	rcall	.+876    	; 0x1856 <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    14ea:	81 e8       	ldi	r24, 0x81	; 129
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	9e d2       	rcall	.+1340   	; 0x1a2c <USART0_init>
	USART1_init(MYUBRR1);
    14f0:	81 e8       	ldi	r24, 0x81	; 129
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	13 d3       	rcall	.+1574   	; 0x1b1c <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    14f6:	bd d1       	rcall	.+890    	; 0x1872 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    14f8:	0e 94 c0 00 	call	0x180	; 0x180 <ADC_init>
	//
	// FOR DEBUG ONLY: Initialize the RGB sensor - Craig uses this to ensure I2C is working
//	RGBsensor_init();
	//
 	// initialize the gas sensors
	gas_sensors_init();
    14fc:	0e 94 ab 01 	call	0x356	; 0x356 <gas_sensors_init>
	// 
	// Start all interrupts
	sei();
    1500:	78 94       	sei
	//
	// Initialize the pressure / temperature /  humidity sensor
	// BME280_init(); 
	//
	// Check the BME interface...
	bme280basic_init();
    1502:	fb d9       	rcall	.-3082   	; 0x8fa <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    1504:	81 e0       	ldi	r24, 0x01	; 1
    1506:	91 e0       	ldi	r25, 0x01	; 1
    1508:	ce d2       	rcall	.+1436   	; 0x1aa6 <USART0_putstring>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    150a:	2f e7       	ldi	r18, 0x7F	; 127
    150c:	84 e8       	ldi	r24, 0x84	; 132
    150e:	9e e1       	ldi	r25, 0x1E	; 30
    1510:	21 50       	subi	r18, 0x01	; 1
    1512:	80 40       	sbci	r24, 0x00	; 0
    1514:	90 40       	sbci	r25, 0x00	; 0
    1516:	e1 f7       	brne	.-8      	; 0x1510 <main+0x4e>
    1518:	00 c0       	rjmp	.+0      	; 0x151a <main+0x58>
    151a:	00 00       	nop
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
    printf("hi ");
    151c:	8a e3       	ldi	r24, 0x3A	; 58
    151e:	91 e0       	ldi	r25, 0x01	; 1
    1520:	9f 93       	push	r25
    1522:	8f 93       	push	r24
    1524:	3f d5       	rcall	.+2686   	; 0x1fa4 <printf>
    1526:	0f 90       	pop	r0
    1528:	0f 90       	pop	r0
    152a:	0f 2e       	mov	r0, r31
    152c:	fd e1       	ldi	r31, 0x1D	; 29
    152e:	8f 2e       	mov	r8, r31
    1530:	f8 e0       	ldi	r31, 0x08	; 8
    1532:	9f 2e       	mov	r9, r31
    1534:	f0 2d       	mov	r31, r0
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
    1536:	0f 2e       	mov	r0, r31
    1538:	fe e4       	ldi	r31, 0x4E	; 78
    153a:	2f 2e       	mov	r2, r31
    153c:	f1 e0       	ldi	r31, 0x01	; 1
    153e:	3f 2e       	mov	r3, r31
    1540:	f0 2d       	mov	r31, r0
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
			{
				USART0_TransmitByte(messageWant[i]);
				time[i] = messageWant[i];
    1542:	0f 2e       	mov	r0, r31
    1544:	ff ef       	ldi	r31, 0xFF	; 255
    1546:	6f 2e       	mov	r6, r31
    1548:	f6 e0       	ldi	r31, 0x06	; 6
    154a:	7f 2e       	mov	r7, r31
    154c:	f0 2d       	mov	r31, r0
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    154e:	0f 2e       	mov	r0, r31
    1550:	f0 e8       	ldi	r31, 0x80	; 128
    1552:	af 2e       	mov	r10, r31
    1554:	f5 e0       	ldi	r31, 0x05	; 5
    1556:	bf 2e       	mov	r11, r31
    1558:	f0 2d       	mov	r31, r0
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
    155a:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <ItsTime>
    155e:	81 30       	cpi	r24, 0x01	; 1
    1560:	e1 f7       	brne	.-8      	; 0x155a <main+0x98>
			ItsTime = 0; 
    1562:	10 92 60 05 	sts	0x0560, r1	; 0x800560 <ItsTime>
			seconds++;
    1566:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <seconds>
    156a:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <seconds+0x1>
    156e:	01 96       	adiw	r24, 0x01	; 1
    1570:	90 93 06 07 	sts	0x0706, r25	; 0x800706 <seconds+0x1>
    1574:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <seconds>
			printf("\nSeconds = %u \n", seconds);
    1578:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <seconds>
    157c:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <seconds+0x1>
    1580:	9f 93       	push	r25
    1582:	8f 93       	push	r24
    1584:	ae e3       	ldi	r26, 0x3E	; 62
    1586:	b1 e0       	ldi	r27, 0x01	; 1
    1588:	bf 93       	push	r27
    158a:	af 93       	push	r26
    158c:	0b d5       	rcall	.+2582   	; 0x1fa4 <printf>
    158e:	84 01       	movw	r16, r8
    1590:	0f 90       	pop	r0
    1592:	0f 90       	pop	r0
    1594:	0f 90       	pop	r0
    1596:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
			{
				USART0_TransmitByte(messageWant[i]);
    1598:	d8 01       	movw	r26, r16
    159a:	8d 91       	ld	r24, X+
    159c:	8d 01       	movw	r16, r26
    159e:	59 d2       	rcall	.+1202   	; 0x1a52 <USART0_TransmitByte>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
    15a0:	b8 e0       	ldi	r27, 0x08	; 8
    15a2:	05 36       	cpi	r16, 0x65	; 101
    15a4:	1b 07       	cpc	r17, r27
    15a6:	c1 f7       	brne	.-16     	; 0x1598 <main+0xd6>
			printf("\n=================");
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
    15a8:	0e 94 ca 02 	call	0x594	; 0x594 <LIDAR_distance>
    15ac:	80 93 7b 05 	sts	0x057B, r24	; 0x80057b <distance>
    15b0:	90 93 7c 05 	sts	0x057C, r25	; 0x80057c <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
    15b4:	9f 93       	push	r25
    15b6:	8f 93       	push	r24
    15b8:	3f 92       	push	r3
    15ba:	2f 92       	push	r2
    15bc:	f3 d4       	rcall	.+2534   	; 0x1fa4 <printf>
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
    15be:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <distance+0x1>
    15c2:	8f 93       	push	r24
    15c4:	80 91 7b 05 	lds	r24, 0x057B	; 0x80057b <distance>
    15c8:	8f 93       	push	r24
    15ca:	a3 e6       	ldi	r26, 0x63	; 99
    15cc:	b1 e0       	ldi	r27, 0x01	; 1
    15ce:	bf 93       	push	r27
    15d0:	af 93       	push	r26
    15d2:	e8 d4       	rcall	.+2512   	; 0x1fa4 <printf>
			for (uint8_t i = 8; i<= 13; i++)//adds in time
			{
				USART0_TransmitByte(messageWant[i]);
    15d4:	d4 01       	movw	r26, r8
    15d6:	18 96       	adiw	r26, 0x08	; 8
    15d8:	8c 91       	ld	r24, X
    15da:	3b d2       	rcall	.+1142   	; 0x1a52 <USART0_TransmitByte>
				time[i] = messageWant[i];
    15dc:	f4 01       	movw	r30, r8
    15de:	80 85       	ldd	r24, Z+8	; 0x08
    15e0:	d3 01       	movw	r26, r6
    15e2:	18 96       	adiw	r26, 0x08	; 8
    15e4:	8c 93       	st	X, r24
    15e6:	06 e2       	ldi	r16, 0x26	; 38
    15e8:	18 e0       	ldi	r17, 0x08	; 8
    15ea:	0f 2e       	mov	r0, r31
    15ec:	f8 e0       	ldi	r31, 0x08	; 8
    15ee:	cf 2e       	mov	r12, r31
    15f0:	f7 e0       	ldi	r31, 0x07	; 7
    15f2:	df 2e       	mov	r13, r31
    15f4:	f0 2d       	mov	r31, r0
    15f6:	0f b6       	in	r0, 0x3f	; 63
    15f8:	f8 94       	cli
    15fa:	de bf       	out	0x3e, r29	; 62
    15fc:	0f be       	out	0x3f, r0	; 63
    15fe:	cd bf       	out	0x3d, r28	; 61
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    1600:	68 94       	set
    1602:	55 24       	eor	r5, r5
    1604:	53 f8       	bld	r5, 3
    1606:	78 01       	movw	r14, r16
    1608:	85 e6       	ldi	r24, 0x65	; 101
    160a:	98 e0       	ldi	r25, 0x08	; 8
    160c:	9a 83       	std	Y+2, r25	; 0x02
    160e:	89 83       	std	Y+1, r24	; 0x01
    1610:	0f c0       	rjmp	.+30     	; 0x1630 <main+0x16e>
    1612:	87 01       	movw	r16, r14
			{
				USART0_TransmitByte(messageWant[i]);
    1614:	d7 01       	movw	r26, r14
    1616:	8d 91       	ld	r24, X+
    1618:	7d 01       	movw	r14, r26
    161a:	1b d2       	rcall	.+1078   	; 0x1a52 <USART0_TransmitByte>
				time[i] = messageWant[i];
    161c:	f8 01       	movw	r30, r16
    161e:	80 81       	ld	r24, Z
    1620:	d6 01       	movw	r26, r12
    1622:	8d 93       	st	X+, r24
    1624:	6d 01       	movw	r12, r26
				if (i%2 ==1)
    1626:	50 fe       	sbrs	r5, 0
    1628:	03 c0       	rjmp	.+6      	; 0x1630 <main+0x16e>
				{
					printf(":");
    162a:	8a e3       	ldi	r24, 0x3A	; 58
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	cd d4       	rcall	.+2458   	; 0x1fca <putchar>
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    1630:	53 94       	inc	r5
    1632:	be e0       	ldi	r27, 0x0E	; 14
    1634:	5b 12       	cpse	r5, r27
    1636:	ed cf       	rjmp	.-38     	; 0x1612 <main+0x150>
				if (i%2 ==1)
				{
					printf(":");
				}
			}
			printf("Z");
    1638:	8a e5       	ldi	r24, 0x5A	; 90
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	c6 d4       	rcall	.+2444   	; 0x1fca <putchar>
			// Davita has this routine specified in the notebook.
			//============================
			//
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    163e:	0e 94 2a 02 	call	0x454	; 0x454 <start_gas_sensor_read>
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    1642:	f5 01       	movw	r30, r10
    1644:	81 81       	ldd	r24, Z+1	; 0x01
    1646:	8f 93       	push	r24
    1648:	80 81       	ld	r24, Z
    164a:	8f 93       	push	r24
    164c:	a0 ee       	ldi	r26, 0xE0	; 224
    164e:	b1 e0       	ldi	r27, 0x01	; 1
    1650:	bf 93       	push	r27
    1652:	af 93       	push	r26
    1654:	a7 d4       	rcall	.+2382   	; 0x1fa4 <printf>
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
    1656:	d5 01       	movw	r26, r10
    1658:	13 96       	adiw	r26, 0x03	; 3
    165a:	8c 91       	ld	r24, X
    165c:	13 97       	sbiw	r26, 0x03	; 3
    165e:	8f 93       	push	r24
    1660:	12 96       	adiw	r26, 0x02	; 2
    1662:	8c 91       	ld	r24, X
    1664:	8f 93       	push	r24
    1666:	a6 ef       	ldi	r26, 0xF6	; 246
    1668:	b1 e0       	ldi	r27, 0x01	; 1
    166a:	bf 93       	push	r27
    166c:	af 93       	push	r26
    166e:	9a d4       	rcall	.+2356   	; 0x1fa4 <printf>
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
    1670:	d5 01       	movw	r26, r10
    1672:	15 96       	adiw	r26, 0x05	; 5
    1674:	8c 91       	ld	r24, X
    1676:	15 97       	sbiw	r26, 0x05	; 5
    1678:	8f 93       	push	r24
    167a:	14 96       	adiw	r26, 0x04	; 4
    167c:	8c 91       	ld	r24, X
    167e:	8f 93       	push	r24
    1680:	a5 e0       	ldi	r26, 0x05	; 5
    1682:	b2 e0       	ldi	r27, 0x02	; 2
    1684:	bf 93       	push	r27
    1686:	af 93       	push	r26
    1688:	8d d4       	rcall	.+2330   	; 0x1fa4 <printf>
 			printf("\nMethane = %u", raw_gas_vector[3]);
    168a:	d5 01       	movw	r26, r10
    168c:	17 96       	adiw	r26, 0x07	; 7
    168e:	8c 91       	ld	r24, X
    1690:	17 97       	sbiw	r26, 0x07	; 7
    1692:	8f 93       	push	r24
    1694:	16 96       	adiw	r26, 0x06	; 6
    1696:	8c 91       	ld	r24, X
    1698:	8f 93       	push	r24
    169a:	a3 e1       	ldi	r26, 0x13	; 19
    169c:	b2 e0       	ldi	r27, 0x02	; 2
    169e:	bf 93       	push	r27
    16a0:	af 93       	push	r26
    16a2:	80 d4       	rcall	.+2304   	; 0x1fa4 <printf>
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
    16a4:	d5 01       	movw	r26, r10
    16a6:	19 96       	adiw	r26, 0x09	; 9
    16a8:	8c 91       	ld	r24, X
    16aa:	19 97       	sbiw	r26, 0x09	; 9
    16ac:	8f 93       	push	r24
    16ae:	18 96       	adiw	r26, 0x08	; 8
    16b0:	8c 91       	ld	r24, X
    16b2:	8f 93       	push	r24
    16b4:	81 e2       	ldi	r24, 0x21	; 33
    16b6:	92 e0       	ldi	r25, 0x02	; 2
    16b8:	9f 93       	push	r25
    16ba:	8f 93       	push	r24
    16bc:	73 d4       	rcall	.+2278   	; 0x1fa4 <printf>
			// Now test the BME interface...
			// THIS ROUTINE NOT YET WRITTEN
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
    16be:	79 d9       	rcall	.-3342   	; 0x9b2 <bme280basic_bulk_data_read>
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    16c0:	60 91 db 06 	lds	r22, 0x06DB	; 0x8006db <rawTemp>
    16c4:	70 91 dc 06 	lds	r23, 0x06DC	; 0x8006dc <rawTemp+0x1>
    16c8:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <rawTemp+0x2>
    16cc:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <rawTemp+0x3>
    16d0:	53 da       	rcall	.-2906   	; 0xb78 <BME280_compensate_T_int32>
    16d2:	60 93 d5 06 	sts	0x06D5, r22	; 0x8006d5 <tempCelsius>
    16d6:	70 93 d6 06 	sts	0x06D6, r23	; 0x8006d6 <tempCelsius+0x1>
    16da:	80 93 d7 06 	sts	0x06D7, r24	; 0x8006d7 <tempCelsius+0x2>
    16de:	90 93 d8 06 	sts	0x06D8, r25	; 0x8006d8 <tempCelsius+0x3>

			sprintf(temperatureBuf, "%lu", tempCelsius);
    16e2:	9f 93       	push	r25
    16e4:	8f 93       	push	r24
    16e6:	7f 93       	push	r23
    16e8:	6f 93       	push	r22
    16ea:	8e e2       	ldi	r24, 0x2E	; 46
    16ec:	92 e0       	ldi	r25, 0x02	; 2
    16ee:	9f 93       	push	r25
    16f0:	8f 93       	push	r24
    16f2:	8b ef       	ldi	r24, 0xFB	; 251
    16f4:	96 e0       	ldi	r25, 0x06	; 6
    16f6:	9f 93       	push	r25
    16f8:	8f 93       	push	r24
    16fa:	6c d4       	rcall	.+2264   	; 0x1fd4 <sprintf>

 			printf("\nCelsius = %lu\n", tempCelsius);
    16fc:	80 91 d8 06 	lds	r24, 0x06D8	; 0x8006d8 <tempCelsius+0x3>
    1700:	8f 93       	push	r24
    1702:	80 91 d7 06 	lds	r24, 0x06D7	; 0x8006d7 <tempCelsius+0x2>
    1706:	8f 93       	push	r24
    1708:	80 91 d6 06 	lds	r24, 0x06D6	; 0x8006d6 <tempCelsius+0x1>
    170c:	8f 93       	push	r24
    170e:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <tempCelsius>
    1712:	8f 93       	push	r24
    1714:	82 e3       	ldi	r24, 0x32	; 50
    1716:	92 e0       	ldi	r25, 0x02	; 2
    1718:	9f 93       	push	r25
    171a:	8f 93       	push	r24
    171c:	43 d4       	rcall	.+2182   	; 0x1fa4 <printf>

			pressure = BME280_compensate_P_int64(rawPress);
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	60 91 f3 06 	lds	r22, 0x06F3	; 0x8006f3 <rawPress>
    172c:	70 91 f4 06 	lds	r23, 0x06F4	; 0x8006f4 <rawPress+0x1>
    1730:	80 91 f5 06 	lds	r24, 0x06F5	; 0x8006f5 <rawPress+0x2>
    1734:	90 91 f6 06 	lds	r25, 0x06F6	; 0x8006f6 <rawPress+0x3>
    1738:	ad da       	rcall	.-2726   	; 0xc94 <BME280_compensate_P_int64>
    173a:	60 93 e4 06 	sts	0x06E4, r22	; 0x8006e4 <pressure>
    173e:	70 93 e5 06 	sts	0x06E5, r23	; 0x8006e5 <pressure+0x1>
    1742:	80 93 e6 06 	sts	0x06E6, r24	; 0x8006e6 <pressure+0x2>
    1746:	90 93 e7 06 	sts	0x06E7, r25	; 0x8006e7 <pressure+0x3>

			printf("\nPressure in Pa = %lu\n", pressure>>8);
    174a:	bb 27       	eor	r27, r27
    174c:	97 fd       	sbrc	r25, 7
    174e:	ba 95       	dec	r27
    1750:	a9 2f       	mov	r26, r25
    1752:	98 2f       	mov	r25, r24
    1754:	87 2f       	mov	r24, r23
    1756:	bf 93       	push	r27
    1758:	af 93       	push	r26
    175a:	9f 93       	push	r25
    175c:	8f 93       	push	r24
    175e:	82 e4       	ldi	r24, 0x42	; 66
    1760:	92 e0       	ldi	r25, 0x02	; 2
    1762:	9f 93       	push	r25
    1764:	8f 93       	push	r24
    1766:	1e d4       	rcall	.+2108   	; 0x1fa4 <printf>

			humidity = bme280_compensate_H_int32(rawHum);
    1768:	60 91 f7 06 	lds	r22, 0x06F7	; 0x8006f7 <rawHum>
    176c:	70 91 f8 06 	lds	r23, 0x06F8	; 0x8006f8 <rawHum+0x1>
    1770:	80 91 f9 06 	lds	r24, 0x06F9	; 0x8006f9 <rawHum+0x2>
    1774:	90 91 fa 06 	lds	r25, 0x06FA	; 0x8006fa <rawHum+0x3>
    1778:	de dc       	rcall	.-1604   	; 0x1136 <bme280_compensate_H_int32>
    177a:	6b 01       	movw	r12, r22
    177c:	7c 01       	movw	r14, r24
    177e:	60 93 ec 06 	sts	0x06EC, r22	; 0x8006ec <humidity>
    1782:	70 93 ed 06 	sts	0x06ED, r23	; 0x8006ed <humidity+0x1>
    1786:	80 93 ee 06 	sts	0x06EE, r24	; 0x8006ee <humidity+0x2>
    178a:	90 93 ef 06 	sts	0x06EF, r25	; 0x8006ef <humidity+0x3>

			printf("\n Humidity in percent relative humidity= %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    178e:	a8 ee       	ldi	r26, 0xE8	; 232
    1790:	b3 e0       	ldi	r27, 0x03	; 3
    1792:	9b 01       	movw	r18, r22
    1794:	ac 01       	movw	r20, r24
    1796:	71 d2       	rcall	.+1250   	; 0x1c7a <__muluhisi3>
    1798:	dc 01       	movw	r26, r24
    179a:	cb 01       	movw	r24, r22
    179c:	07 2e       	mov	r0, r23
    179e:	7a e0       	ldi	r23, 0x0A	; 10
    17a0:	b5 95       	asr	r27
    17a2:	a7 95       	ror	r26
    17a4:	97 95       	ror	r25
    17a6:	87 95       	ror	r24
    17a8:	7a 95       	dec	r23
    17aa:	d1 f7       	brne	.-12     	; 0x17a0 <main+0x2de>
    17ac:	70 2d       	mov	r23, r0
    17ae:	bf 93       	push	r27
    17b0:	af 93       	push	r26
    17b2:	9f 93       	push	r25
    17b4:	8f 93       	push	r24
    17b6:	d7 01       	movw	r26, r14
    17b8:	c6 01       	movw	r24, r12
    17ba:	07 2e       	mov	r0, r23
    17bc:	7a e0       	ldi	r23, 0x0A	; 10
    17be:	b5 95       	asr	r27
    17c0:	a7 95       	ror	r26
    17c2:	97 95       	ror	r25
    17c4:	87 95       	ror	r24
    17c6:	7a 95       	dec	r23
    17c8:	d1 f7       	brne	.-12     	; 0x17be <main+0x2fc>
    17ca:	70 2d       	mov	r23, r0
    17cc:	bf 93       	push	r27
    17ce:	af 93       	push	r26
    17d0:	9f 93       	push	r25
    17d2:	8f 93       	push	r24
    17d4:	89 e5       	ldi	r24, 0x59	; 89
    17d6:	92 e0       	ldi	r25, 0x02	; 2
    17d8:	9f 93       	push	r25
    17da:	8f 93       	push	r24
    17dc:	e3 d3       	rcall	.+1990   	; 0x1fa4 <printf>

			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
    17de:	80 91 78 05 	lds	r24, 0x0578	; 0x800578 <temp>
    17e2:	40 91 78 05 	lds	r20, 0x0578	; 0x800578 <temp>
    17e6:	23 e0       	ldi	r18, 0x03	; 3
    17e8:	37 e0       	ldi	r19, 0x07	; 7
    17ea:	3f 93       	push	r19
    17ec:	2f 93       	push	r18
    17ee:	21 e0       	ldi	r18, 0x01	; 1
    17f0:	37 e0       	ldi	r19, 0x07	; 7
    17f2:	3f 93       	push	r19
    17f4:	2f 93       	push	r18
    17f6:	7f 92       	push	r7
    17f8:	6f 92       	push	r6
    17fa:	90 91 ef 06 	lds	r25, 0x06EF	; 0x8006ef <humidity+0x3>
    17fe:	9f 93       	push	r25
    1800:	90 91 ee 06 	lds	r25, 0x06EE	; 0x8006ee <humidity+0x2>
    1804:	9f 93       	push	r25
    1806:	90 91 ed 06 	lds	r25, 0x06ED	; 0x8006ed <humidity+0x1>
    180a:	9f 93       	push	r25
    180c:	90 91 ec 06 	lds	r25, 0x06EC	; 0x8006ec <humidity>
    1810:	9f 93       	push	r25
    1812:	90 91 e7 06 	lds	r25, 0x06E7	; 0x8006e7 <pressure+0x3>
    1816:	9f 93       	push	r25
    1818:	90 91 e6 06 	lds	r25, 0x06E6	; 0x8006e6 <pressure+0x2>
    181c:	9f 93       	push	r25
    181e:	90 91 e5 06 	lds	r25, 0x06E5	; 0x8006e5 <pressure+0x1>
    1822:	9f 93       	push	r25
    1824:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <pressure>
    1828:	9f 93       	push	r25
    182a:	90 e0       	ldi	r25, 0x00	; 0
    182c:	02 96       	adiw	r24, 0x02	; 2
    182e:	9f 93       	push	r25
    1830:	8f 93       	push	r24
    1832:	1f 92       	push	r1
    1834:	4f 93       	push	r20
    1836:	8b e8       	ldi	r24, 0x8B	; 139
    1838:	92 e0       	ldi	r25, 0x02	; 2
    183a:	9f 93       	push	r25
    183c:	8f 93       	push	r24
    183e:	b2 d3       	rcall	.+1892   	; 0x1fa4 <printf>
			
			UCSR1B |= (1<<RXEN1); 
    1840:	e9 ec       	ldi	r30, 0xC9	; 201
    1842:	f0 e0       	ldi	r31, 0x00	; 0
    1844:	80 81       	ld	r24, Z
    1846:	80 61       	ori	r24, 0x10	; 16
    1848:	80 83       	st	Z, r24
    184a:	0f b6       	in	r0, 0x3f	; 63
    184c:	f8 94       	cli
    184e:	de bf       	out	0x3e, r29	; 62
    1850:	0f be       	out	0x3f, r0	; 63
    1852:	cd bf       	out	0x3d, r28	; 61
    1854:	82 ce       	rjmp	.-764    	; 0x155a <main+0x98>

00001856 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    1856:	8d e0       	ldi	r24, 0x0D	; 13
    1858:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    185c:	8a e4       	ldi	r24, 0x4A	; 74
    185e:	9c e4       	ldi	r25, 0x4C	; 76
    1860:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1864:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
    1868:	82 e0       	ldi	r24, 0x02	; 2
    186a:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    186e:	08 95       	ret

00001870 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    1870:	18 95       	reti

00001872 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1872:	81 e1       	ldi	r24, 0x11	; 17
    1874:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    1878:	8f ef       	ldi	r24, 0xFF	; 255
    187a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    187e:	84 e0       	ldi	r24, 0x04	; 4
    1880:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1884:	08 95       	ret

00001886 <TWI_Transceiver_Busy>:
    1886:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    188a:	81 78       	andi	r24, 0x81	; 129
    188c:	08 95       	ret

0000188e <TWI_Start_Transceiver_With_Data>:
    188e:	cf 93       	push	r28
    1890:	df 93       	push	r29
    1892:	ec 01       	movw	r28, r24
    1894:	ec eb       	ldi	r30, 0xBC	; 188
    1896:	f0 e0       	ldi	r31, 0x00	; 0
    1898:	90 81       	ld	r25, Z
    189a:	91 78       	andi	r25, 0x81	; 129
    189c:	e9 f7       	brne	.-6      	; 0x1898 <TWI_Start_Transceiver_With_Data+0xa>
    189e:	60 93 32 03 	sts	0x0332, r22	; 0x800332 <TWI_msgSize>
    18a2:	88 81       	ld	r24, Y
    18a4:	80 93 33 03 	sts	0x0333, r24	; 0x800333 <TWI_buf>
    18a8:	80 fd       	sbrc	r24, 0
    18aa:	12 c0       	rjmp	.+36     	; 0x18d0 <TWI_Start_Transceiver_With_Data+0x42>
    18ac:	62 30       	cpi	r22, 0x02	; 2
    18ae:	80 f0       	brcs	.+32     	; 0x18d0 <TWI_Start_Transceiver_With_Data+0x42>
    18b0:	fe 01       	movw	r30, r28
    18b2:	31 96       	adiw	r30, 0x01	; 1
    18b4:	a4 e3       	ldi	r26, 0x34	; 52
    18b6:	b3 e0       	ldi	r27, 0x03	; 3
    18b8:	62 50       	subi	r22, 0x02	; 2
    18ba:	26 2f       	mov	r18, r22
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	2e 5f       	subi	r18, 0xFE	; 254
    18c0:	3f 4f       	sbci	r19, 0xFF	; 255
    18c2:	2c 0f       	add	r18, r28
    18c4:	3d 1f       	adc	r19, r29
    18c6:	91 91       	ld	r25, Z+
    18c8:	9d 93       	st	X+, r25
    18ca:	e2 17       	cp	r30, r18
    18cc:	f3 07       	cpc	r31, r19
    18ce:	d9 f7       	brne	.-10     	; 0x18c6 <TWI_Start_Transceiver_With_Data+0x38>
    18d0:	10 92 31 03 	sts	0x0331, r1	; 0x800331 <TWI_statusReg>
    18d4:	88 ef       	ldi	r24, 0xF8	; 248
    18d6:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    18da:	85 ea       	ldi	r24, 0xA5	; 165
    18dc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18e0:	df 91       	pop	r29
    18e2:	cf 91       	pop	r28
    18e4:	08 95       	ret

000018e6 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    18e6:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    18e8:	ec eb       	ldi	r30, 0xBC	; 188
    18ea:	f0 e0       	ldi	r31, 0x00	; 0
    18ec:	90 81       	ld	r25, Z
    18ee:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    18f0:	e9 f7       	brne	.-6      	; 0x18ec <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    18f2:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <TWI_statusReg>
    18f6:	80 ff       	sbrs	r24, 0
    18f8:	11 c0       	rjmp	.+34     	; 0x191c <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    18fa:	66 23       	and	r22, r22
    18fc:	79 f0       	breq	.+30     	; 0x191c <TWI_Get_Data_From_Transceiver+0x36>
    18fe:	a3 e3       	ldi	r26, 0x33	; 51
    1900:	b3 e0       	ldi	r27, 0x03	; 3
    1902:	fa 01       	movw	r30, r20
    1904:	61 50       	subi	r22, 0x01	; 1
    1906:	26 2f       	mov	r18, r22
    1908:	30 e0       	ldi	r19, 0x00	; 0
    190a:	2f 5f       	subi	r18, 0xFF	; 255
    190c:	3f 4f       	sbci	r19, 0xFF	; 255
    190e:	24 0f       	add	r18, r20
    1910:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    1912:	9d 91       	ld	r25, X+
    1914:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1916:	e2 17       	cp	r30, r18
    1918:	f3 07       	cpc	r31, r19
    191a:	d9 f7       	brne	.-10     	; 0x1912 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    191c:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <TWI_statusReg>
}
    1920:	81 70       	andi	r24, 0x01	; 1
    1922:	08 95       	ret

00001924 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    1924:	1f 92       	push	r1
    1926:	0f 92       	push	r0
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	0f 92       	push	r0
    192c:	11 24       	eor	r1, r1
    192e:	0b b6       	in	r0, 0x3b	; 59
    1930:	0f 92       	push	r0
    1932:	2f 93       	push	r18
    1934:	3f 93       	push	r19
    1936:	8f 93       	push	r24
    1938:	9f 93       	push	r25
    193a:	af 93       	push	r26
    193c:	bf 93       	push	r27
    193e:	ef 93       	push	r30
    1940:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1942:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1946:	8e 2f       	mov	r24, r30
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	fc 01       	movw	r30, r24
    194c:	38 97       	sbiw	r30, 0x08	; 8
    194e:	e1 35       	cpi	r30, 0x51	; 81
    1950:	f1 05       	cpc	r31, r1
    1952:	08 f0       	brcs	.+2      	; 0x1956 <__vector_26+0x32>
    1954:	55 c0       	rjmp	.+170    	; 0x1a00 <__vector_26+0xdc>
    1956:	ea 5b       	subi	r30, 0xBA	; 186
    1958:	ff 4f       	sbci	r31, 0xFF	; 255
    195a:	86 c1       	rjmp	.+780    	; 0x1c68 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    195c:	10 92 30 03 	sts	0x0330, r1	; 0x800330 <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    1960:	e0 91 30 03 	lds	r30, 0x0330	; 0x800330 <TWI_bufPtr.1555>
    1964:	80 91 32 03 	lds	r24, 0x0332	; 0x800332 <TWI_msgSize>
    1968:	e8 17       	cp	r30, r24
    196a:	70 f4       	brcc	.+28     	; 0x1988 <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	8e 0f       	add	r24, r30
    1970:	80 93 30 03 	sts	0x0330, r24	; 0x800330 <TWI_bufPtr.1555>
    1974:	f0 e0       	ldi	r31, 0x00	; 0
    1976:	ed 5c       	subi	r30, 0xCD	; 205
    1978:	fc 4f       	sbci	r31, 0xFC	; 252
    197a:	80 81       	ld	r24, Z
    197c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1980:	85 e8       	ldi	r24, 0x85	; 133
    1982:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1986:	43 c0       	rjmp	.+134    	; 0x1a0e <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1988:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <TWI_statusReg>
    198c:	81 60       	ori	r24, 0x01	; 1
    198e:	80 93 31 03 	sts	0x0331, r24	; 0x800331 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1992:	84 e9       	ldi	r24, 0x94	; 148
    1994:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1998:	3a c0       	rjmp	.+116    	; 0x1a0e <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    199a:	e0 91 30 03 	lds	r30, 0x0330	; 0x800330 <TWI_bufPtr.1555>
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	8e 0f       	add	r24, r30
    19a2:	80 93 30 03 	sts	0x0330, r24	; 0x800330 <TWI_bufPtr.1555>
    19a6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	ed 5c       	subi	r30, 0xCD	; 205
    19ae:	fc 4f       	sbci	r31, 0xFC	; 252
    19b0:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    19b2:	20 91 30 03 	lds	r18, 0x0330	; 0x800330 <TWI_bufPtr.1555>
    19b6:	30 e0       	ldi	r19, 0x00	; 0
    19b8:	80 91 32 03 	lds	r24, 0x0332	; 0x800332 <TWI_msgSize>
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	01 97       	sbiw	r24, 0x01	; 1
    19c0:	28 17       	cp	r18, r24
    19c2:	39 07       	cpc	r19, r25
    19c4:	24 f4       	brge	.+8      	; 0x19ce <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19c6:	85 ec       	ldi	r24, 0xC5	; 197
    19c8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    19cc:	20 c0       	rjmp	.+64     	; 0x1a0e <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19ce:	85 e8       	ldi	r24, 0x85	; 133
    19d0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    19d4:	1c c0       	rjmp	.+56     	; 0x1a0e <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    19d6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    19da:	e0 91 30 03 	lds	r30, 0x0330	; 0x800330 <TWI_bufPtr.1555>
    19de:	f0 e0       	ldi	r31, 0x00	; 0
    19e0:	ed 5c       	subi	r30, 0xCD	; 205
    19e2:	fc 4f       	sbci	r31, 0xFC	; 252
    19e4:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    19e6:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <TWI_statusReg>
    19ea:	81 60       	ori	r24, 0x01	; 1
    19ec:	80 93 31 03 	sts	0x0331, r24	; 0x800331 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19f0:	84 e9       	ldi	r24, 0x94	; 148
    19f2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    19f6:	0b c0       	rjmp	.+22     	; 0x1a0e <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19f8:	85 ea       	ldi	r24, 0xA5	; 165
    19fa:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    19fe:	07 c0       	rjmp	.+14     	; 0x1a0e <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    1a00:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1a04:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1a08:	84 e0       	ldi	r24, 0x04	; 4
    1a0a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    1a0e:	ff 91       	pop	r31
    1a10:	ef 91       	pop	r30
    1a12:	bf 91       	pop	r27
    1a14:	af 91       	pop	r26
    1a16:	9f 91       	pop	r25
    1a18:	8f 91       	pop	r24
    1a1a:	3f 91       	pop	r19
    1a1c:	2f 91       	pop	r18
    1a1e:	0f 90       	pop	r0
    1a20:	0b be       	out	0x3b, r0	; 59
    1a22:	0f 90       	pop	r0
    1a24:	0f be       	out	0x3f, r0	; 63
    1a26:	0f 90       	pop	r0
    1a28:	1f 90       	pop	r1
    1a2a:	18 95       	reti

00001a2c <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    1a2c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    1a30:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    1a34:	88 e9       	ldi	r24, 0x98	; 152
    1a36:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1a3a:	8e e0       	ldi	r24, 0x0E	; 14
    1a3c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1a40:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <UART0_RxTail>
    1a44:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <UART0_RxHead>
    1a48:	10 92 43 03 	sts	0x0343, r1	; 0x800343 <UART0_TxTail>
    1a4c:	10 92 44 03 	sts	0x0344, r1	; 0x800344 <UART0_TxHead>
    1a50:	08 95       	ret

00001a52 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1a52:	20 91 44 03 	lds	r18, 0x0344	; 0x800344 <UART0_TxHead>
    1a56:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1a58:	90 91 43 03 	lds	r25, 0x0343	; 0x800343 <UART0_TxTail>
    1a5c:	29 17       	cp	r18, r25
    1a5e:	e1 f3       	breq	.-8      	; 0x1a58 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    1a60:	e2 2f       	mov	r30, r18
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	eb 5b       	subi	r30, 0xBB	; 187
    1a66:	fc 4f       	sbci	r31, 0xFC	; 252
    1a68:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    1a6a:	20 93 44 03 	sts	0x0344, r18	; 0x800344 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    1a6e:	e1 ec       	ldi	r30, 0xC1	; 193
    1a70:	f0 e0       	ldi	r31, 0x00	; 0
    1a72:	80 81       	ld	r24, Z
    1a74:	80 62       	ori	r24, 0x20	; 32
    1a76:	80 83       	st	Z, r24
    1a78:	08 95       	ret

00001a7a <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1a7a:	20 91 44 03 	lds	r18, 0x0344	; 0x800344 <UART0_TxHead>
    1a7e:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1a80:	90 91 43 03 	lds	r25, 0x0343	; 0x800343 <UART0_TxTail>
    1a84:	29 17       	cp	r18, r25
    1a86:	e1 f3       	breq	.-8      	; 0x1a80 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    1a88:	e2 2f       	mov	r30, r18
    1a8a:	f0 e0       	ldi	r31, 0x00	; 0
    1a8c:	eb 5b       	subi	r30, 0xBB	; 187
    1a8e:	fc 4f       	sbci	r31, 0xFC	; 252
    1a90:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    1a92:	20 93 44 03 	sts	0x0344, r18	; 0x800344 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    1a96:	e1 ec       	ldi	r30, 0xC1	; 193
    1a98:	f0 e0       	ldi	r31, 0x00	; 0
    1a9a:	80 81       	ld	r24, Z
    1a9c:	80 62       	ori	r24, 0x20	; 32
    1a9e:	80 83       	st	Z, r24
	return(0);
}
    1aa0:	80 e0       	ldi	r24, 0x00	; 0
    1aa2:	90 e0       	ldi	r25, 0x00	; 0
    1aa4:	08 95       	ret

00001aa6 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    1aa6:	cf 93       	push	r28
    1aa8:	df 93       	push	r29
    1aaa:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    1aac:	88 81       	ld	r24, Y
    1aae:	88 23       	and	r24, r24
    1ab0:	29 f0       	breq	.+10     	; 0x1abc <USART0_putstring+0x16>
    1ab2:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    1ab4:	ce df       	rcall	.-100    	; 0x1a52 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    1ab6:	89 91       	ld	r24, Y+
    1ab8:	81 11       	cpse	r24, r1
    1aba:	fc cf       	rjmp	.-8      	; 0x1ab4 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	08 95       	ret

00001ac2 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1ac2:	1f 92       	push	r1
    1ac4:	0f 92       	push	r0
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	0f 92       	push	r0
    1aca:	11 24       	eor	r1, r1
    1acc:	0b b6       	in	r0, 0x3b	; 59
    1ace:	0f 92       	push	r0
    1ad0:	8f 93       	push	r24
    1ad2:	9f 93       	push	r25
    1ad4:	ef 93       	push	r30
    1ad6:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1ad8:	90 91 44 03 	lds	r25, 0x0344	; 0x800344 <UART0_TxHead>
    1adc:	80 91 43 03 	lds	r24, 0x0343	; 0x800343 <UART0_TxTail>
    1ae0:	98 17       	cp	r25, r24
    1ae2:	61 f0       	breq	.+24     	; 0x1afc <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1ae4:	e0 91 43 03 	lds	r30, 0x0343	; 0x800343 <UART0_TxTail>
    1ae8:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1aea:	e0 93 43 03 	sts	0x0343, r30	; 0x800343 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1aee:	f0 e0       	ldi	r31, 0x00	; 0
    1af0:	eb 5b       	subi	r30, 0xBB	; 187
    1af2:	fc 4f       	sbci	r31, 0xFC	; 252
    1af4:	80 81       	ld	r24, Z
    1af6:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1afa:	05 c0       	rjmp	.+10     	; 0x1b06 <__vector_21+0x44>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1afc:	e1 ec       	ldi	r30, 0xC1	; 193
    1afe:	f0 e0       	ldi	r31, 0x00	; 0
    1b00:	80 81       	ld	r24, Z
    1b02:	8f 7d       	andi	r24, 0xDF	; 223
    1b04:	80 83       	st	Z, r24
	}
    1b06:	ff 91       	pop	r31
    1b08:	ef 91       	pop	r30
    1b0a:	9f 91       	pop	r25
    1b0c:	8f 91       	pop	r24
    1b0e:	0f 90       	pop	r0
    1b10:	0b be       	out	0x3b, r0	; 59
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	0f 90       	pop	r0
    1b18:	1f 90       	pop	r1
    1b1a:	18 95       	reti

00001b1c <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1b1c:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1b20:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1b24:	88 e9       	ldi	r24, 0x98	; 152
    1b26:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1b2a:	86 e0       	ldi	r24, 0x06	; 6
    1b2c:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1b30:	10 92 49 05 	sts	0x0549, r1	; 0x800549 <UART1_RxTail>
    1b34:	10 92 4a 05 	sts	0x054A, r1	; 0x80054a <UART1_RxHead>
    1b38:	10 92 47 04 	sts	0x0447, r1	; 0x800447 <UART1_TxTail>
    1b3c:	10 92 48 04 	sts	0x0448, r1	; 0x800448 <UART1_TxHead>
    1b40:	08 95       	ret

00001b42 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1b42:	1f 92       	push	r1
    1b44:	0f 92       	push	r0
    1b46:	0f b6       	in	r0, 0x3f	; 63
    1b48:	0f 92       	push	r0
    1b4a:	11 24       	eor	r1, r1
    1b4c:	0b b6       	in	r0, 0x3b	; 59
    1b4e:	0f 92       	push	r0
    1b50:	2f 93       	push	r18
    1b52:	3f 93       	push	r19
    1b54:	8f 93       	push	r24
    1b56:	9f 93       	push	r25
    1b58:	af 93       	push	r26
    1b5a:	bf 93       	push	r27
    1b5c:	cf 93       	push	r28
    1b5e:	df 93       	push	r29
    1b60:	ef 93       	push	r30
    1b62:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1b64:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1b68:	80 91 4a 05 	lds	r24, 0x054A	; 0x80054a <UART1_RxHead>
    1b6c:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1b6e:	80 93 4a 05 	sts	0x054A, r24	; 0x80054a <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1b72:	20 91 49 05 	lds	r18, 0x0549	; 0x800549 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1b76:	e8 2f       	mov	r30, r24
    1b78:	f0 e0       	ldi	r31, 0x00	; 0
    1b7a:	e3 5e       	subi	r30, 0xE3	; 227
    1b7c:	f8 4f       	sbci	r31, 0xF8	; 248
    1b7e:	90 83       	st	Z, r25
	
	if (data == 10)
    1b80:	9a 30       	cpi	r25, 0x0A	; 10
    1b82:	29 f5       	brne	.+74     	; 0x1bce <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1b84:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <UART1_RxBuf+0x5>
    1b88:	97 34       	cpi	r25, 0x47	; 71
    1b8a:	e9 f4       	brne	.+58     	; 0x1bc6 <__vector_28+0x84>
    1b8c:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
    1b8e:	2e 2f       	mov	r18, r30
    1b90:	30 e0       	ldi	r19, 0x00	; 0
    1b92:	d9 01       	movw	r26, r18
    1b94:	a3 5e       	subi	r26, 0xE3	; 227
    1b96:	b7 4f       	sbci	r27, 0xF7	; 247
    1b98:	e9 01       	movw	r28, r18
    1b9a:	c3 5e       	subi	r28, 0xE3	; 227
    1b9c:	d8 4f       	sbci	r29, 0xF8	; 248
    1b9e:	98 81       	ld	r25, Y
    1ba0:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1ba2:	ef 5f       	subi	r30, 0xFF	; 255
    1ba4:	8e 17       	cp	r24, r30
    1ba6:	98 f7       	brcc	.-26     	; 0x1b8e <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
    1ba8:	f0 e0       	ldi	r31, 0x00	; 0
    1baa:	e3 5e       	subi	r30, 0xE3	; 227
    1bac:	f7 4f       	sbci	r31, 0xF7	; 247
    1bae:	11 82       	std	Z+1, r1	; 0x01
			UCSR1B &= !(1<<RXEN1);  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1bb0:	e9 ec       	ldi	r30, 0xC9	; 201
    1bb2:	f0 e0       	ldi	r31, 0x00	; 0
    1bb4:	80 81       	ld	r24, Z
    1bb6:	10 82       	st	Z, r1
			ItsTime = 1;
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	80 93 60 05 	sts	0x0560, r24	; 0x800560 <ItsTime>
			ToggleBit(PORTB, PORTB1);
    1bbe:	95 b1       	in	r25, 0x05	; 5
    1bc0:	82 e0       	ldi	r24, 0x02	; 2
    1bc2:	89 27       	eor	r24, r25
    1bc4:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1bc6:	10 92 49 05 	sts	0x0549, r1	; 0x800549 <UART1_RxTail>
		UART1_RxHead = 0;
    1bca:	10 92 4a 05 	sts	0x054A, r1	; 0x80054a <UART1_RxHead>
	}
}
    1bce:	ff 91       	pop	r31
    1bd0:	ef 91       	pop	r30
    1bd2:	df 91       	pop	r29
    1bd4:	cf 91       	pop	r28
    1bd6:	bf 91       	pop	r27
    1bd8:	af 91       	pop	r26
    1bda:	9f 91       	pop	r25
    1bdc:	8f 91       	pop	r24
    1bde:	3f 91       	pop	r19
    1be0:	2f 91       	pop	r18
    1be2:	0f 90       	pop	r0
    1be4:	0b be       	out	0x3b, r0	; 59
    1be6:	0f 90       	pop	r0
    1be8:	0f be       	out	0x3f, r0	; 63
    1bea:	0f 90       	pop	r0
    1bec:	1f 90       	pop	r1
    1bee:	18 95       	reti

00001bf0 <__vector_29>:

ISR(USART1_UDRE_vect)
{
    1bf0:	1f 92       	push	r1
    1bf2:	0f 92       	push	r0
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	0f 92       	push	r0
    1bf8:	11 24       	eor	r1, r1
    1bfa:	0b b6       	in	r0, 0x3b	; 59
    1bfc:	0f 92       	push	r0
    1bfe:	8f 93       	push	r24
    1c00:	9f 93       	push	r25
    1c02:	ef 93       	push	r30
    1c04:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
    1c06:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <UART1_TxHead>
    1c0a:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <UART1_TxTail>
    1c0e:	98 17       	cp	r25, r24
    1c10:	61 f0       	breq	.+24     	; 0x1c2a <__vector_29+0x3a>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
    1c12:	e0 91 47 04 	lds	r30, 0x0447	; 0x800447 <UART1_TxTail>
    1c16:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
    1c18:	e0 93 47 04 	sts	0x0447, r30	; 0x800447 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	e7 5b       	subi	r30, 0xB7	; 183
    1c20:	fb 4f       	sbci	r31, 0xFB	; 251
    1c22:	80 81       	ld	r24, Z
    1c24:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1c28:	05 c0       	rjmp	.+10     	; 0x1c34 <__vector_29+0x44>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
    1c2a:	e9 ec       	ldi	r30, 0xC9	; 201
    1c2c:	f0 e0       	ldi	r31, 0x00	; 0
    1c2e:	80 81       	ld	r24, Z
    1c30:	8f 7d       	andi	r24, 0xDF	; 223
    1c32:	80 83       	st	Z, r24
	}
    1c34:	ff 91       	pop	r31
    1c36:	ef 91       	pop	r30
    1c38:	9f 91       	pop	r25
    1c3a:	8f 91       	pop	r24
    1c3c:	0f 90       	pop	r0
    1c3e:	0b be       	out	0x3b, r0	; 59
    1c40:	0f 90       	pop	r0
    1c42:	0f be       	out	0x3f, r0	; 63
    1c44:	0f 90       	pop	r0
    1c46:	1f 90       	pop	r1
    1c48:	18 95       	reti

00001c4a <__mulsi3>:
    1c4a:	db 01       	movw	r26, r22
    1c4c:	8f 93       	push	r24
    1c4e:	9f 93       	push	r25
    1c50:	14 d0       	rcall	.+40     	; 0x1c7a <__muluhisi3>
    1c52:	bf 91       	pop	r27
    1c54:	af 91       	pop	r26
    1c56:	a2 9f       	mul	r26, r18
    1c58:	80 0d       	add	r24, r0
    1c5a:	91 1d       	adc	r25, r1
    1c5c:	a3 9f       	mul	r26, r19
    1c5e:	90 0d       	add	r25, r0
    1c60:	b2 9f       	mul	r27, r18
    1c62:	90 0d       	add	r25, r0
    1c64:	11 24       	eor	r1, r1
    1c66:	08 95       	ret

00001c68 <__tablejump2__>:
    1c68:	ee 0f       	add	r30, r30
    1c6a:	ff 1f       	adc	r31, r31
    1c6c:	00 24       	eor	r0, r0
    1c6e:	00 1c       	adc	r0, r0
    1c70:	0b be       	out	0x3b, r0	; 59
    1c72:	07 90       	elpm	r0, Z+
    1c74:	f6 91       	elpm	r31, Z
    1c76:	e0 2d       	mov	r30, r0
    1c78:	09 94       	ijmp

00001c7a <__muluhisi3>:
    1c7a:	85 d1       	rcall	.+778    	; 0x1f86 <__umulhisi3>
    1c7c:	a5 9f       	mul	r26, r21
    1c7e:	90 0d       	add	r25, r0
    1c80:	b4 9f       	mul	r27, r20
    1c82:	90 0d       	add	r25, r0
    1c84:	a4 9f       	mul	r26, r20
    1c86:	80 0d       	add	r24, r0
    1c88:	91 1d       	adc	r25, r1
    1c8a:	11 24       	eor	r1, r1
    1c8c:	08 95       	ret

00001c8e <__mulshisi3>:
    1c8e:	b7 ff       	sbrs	r27, 7
    1c90:	f4 cf       	rjmp	.-24     	; 0x1c7a <__muluhisi3>

00001c92 <__mulohisi3>:
    1c92:	f3 df       	rcall	.-26     	; 0x1c7a <__muluhisi3>
    1c94:	82 1b       	sub	r24, r18
    1c96:	93 0b       	sbc	r25, r19
    1c98:	08 95       	ret

00001c9a <__muldi3>:
    1c9a:	df 93       	push	r29
    1c9c:	cf 93       	push	r28
    1c9e:	1f 93       	push	r17
    1ca0:	0f 93       	push	r16
    1ca2:	9a 9d       	mul	r25, r10
    1ca4:	f0 2d       	mov	r31, r0
    1ca6:	21 9f       	mul	r18, r17
    1ca8:	f0 0d       	add	r31, r0
    1caa:	8b 9d       	mul	r24, r11
    1cac:	f0 0d       	add	r31, r0
    1cae:	8a 9d       	mul	r24, r10
    1cb0:	e0 2d       	mov	r30, r0
    1cb2:	f1 0d       	add	r31, r1
    1cb4:	03 9f       	mul	r16, r19
    1cb6:	f0 0d       	add	r31, r0
    1cb8:	02 9f       	mul	r16, r18
    1cba:	e0 0d       	add	r30, r0
    1cbc:	f1 1d       	adc	r31, r1
    1cbe:	4e 9d       	mul	r20, r14
    1cc0:	e0 0d       	add	r30, r0
    1cc2:	f1 1d       	adc	r31, r1
    1cc4:	5e 9d       	mul	r21, r14
    1cc6:	f0 0d       	add	r31, r0
    1cc8:	4f 9d       	mul	r20, r15
    1cca:	f0 0d       	add	r31, r0
    1ccc:	7f 93       	push	r23
    1cce:	6f 93       	push	r22
    1cd0:	bf 92       	push	r11
    1cd2:	af 92       	push	r10
    1cd4:	5f 93       	push	r21
    1cd6:	4f 93       	push	r20
    1cd8:	d5 01       	movw	r26, r10
    1cda:	55 d1       	rcall	.+682    	; 0x1f86 <__umulhisi3>
    1cdc:	8b 01       	movw	r16, r22
    1cde:	ac 01       	movw	r20, r24
    1ce0:	d7 01       	movw	r26, r14
    1ce2:	51 d1       	rcall	.+674    	; 0x1f86 <__umulhisi3>
    1ce4:	eb 01       	movw	r28, r22
    1ce6:	e8 0f       	add	r30, r24
    1ce8:	f9 1f       	adc	r31, r25
    1cea:	d6 01       	movw	r26, r12
    1cec:	1f d0       	rcall	.+62     	; 0x1d2c <__muldi3_6>
    1cee:	2f 91       	pop	r18
    1cf0:	3f 91       	pop	r19
    1cf2:	d6 01       	movw	r26, r12
    1cf4:	48 d1       	rcall	.+656    	; 0x1f86 <__umulhisi3>
    1cf6:	c6 0f       	add	r28, r22
    1cf8:	d7 1f       	adc	r29, r23
    1cfa:	e8 1f       	adc	r30, r24
    1cfc:	f9 1f       	adc	r31, r25
    1cfe:	af 91       	pop	r26
    1d00:	bf 91       	pop	r27
    1d02:	14 d0       	rcall	.+40     	; 0x1d2c <__muldi3_6>
    1d04:	2f 91       	pop	r18
    1d06:	3f 91       	pop	r19
    1d08:	3e d1       	rcall	.+636    	; 0x1f86 <__umulhisi3>
    1d0a:	c6 0f       	add	r28, r22
    1d0c:	d7 1f       	adc	r29, r23
    1d0e:	e8 1f       	adc	r30, r24
    1d10:	f9 1f       	adc	r31, r25
    1d12:	d6 01       	movw	r26, r12
    1d14:	38 d1       	rcall	.+624    	; 0x1f86 <__umulhisi3>
    1d16:	e6 0f       	add	r30, r22
    1d18:	f7 1f       	adc	r31, r23
    1d1a:	98 01       	movw	r18, r16
    1d1c:	be 01       	movw	r22, r28
    1d1e:	cf 01       	movw	r24, r30
    1d20:	11 24       	eor	r1, r1
    1d22:	0f 91       	pop	r16
    1d24:	1f 91       	pop	r17
    1d26:	cf 91       	pop	r28
    1d28:	df 91       	pop	r29
    1d2a:	08 95       	ret

00001d2c <__muldi3_6>:
    1d2c:	2c d1       	rcall	.+600    	; 0x1f86 <__umulhisi3>
    1d2e:	46 0f       	add	r20, r22
    1d30:	57 1f       	adc	r21, r23
    1d32:	c8 1f       	adc	r28, r24
    1d34:	d9 1f       	adc	r29, r25
    1d36:	08 f4       	brcc	.+2      	; 0x1d3a <__muldi3_6+0xe>
    1d38:	31 96       	adiw	r30, 0x01	; 1
    1d3a:	08 95       	ret

00001d3c <__moddi3>:
    1d3c:	68 94       	set
    1d3e:	01 c0       	rjmp	.+2      	; 0x1d42 <__divdi3_moddi3>

00001d40 <__divdi3>:
    1d40:	e8 94       	clt

00001d42 <__divdi3_moddi3>:
    1d42:	f9 2f       	mov	r31, r25
    1d44:	f1 2b       	or	r31, r17
    1d46:	0a f0       	brmi	.+2      	; 0x1d4a <__divdi3_moddi3+0x8>
    1d48:	27 c0       	rjmp	.+78     	; 0x1d98 <__udivdi3_umoddi3>
    1d4a:	a0 e0       	ldi	r26, 0x00	; 0
    1d4c:	b0 e0       	ldi	r27, 0x00	; 0
    1d4e:	ea ea       	ldi	r30, 0xAA	; 170
    1d50:	fe e0       	ldi	r31, 0x0E	; 14
    1d52:	93 c0       	rjmp	.+294    	; 0x1e7a <__prologue_saves__+0xc>
    1d54:	09 2e       	mov	r0, r25
    1d56:	05 94       	asr	r0
    1d58:	1a f4       	brpl	.+6      	; 0x1d60 <__divdi3_moddi3+0x1e>
    1d5a:	79 d0       	rcall	.+242    	; 0x1e4e <__negdi2>
    1d5c:	11 23       	and	r17, r17
    1d5e:	92 f4       	brpl	.+36     	; 0x1d84 <__divdi3_moddi3+0x42>
    1d60:	f0 e8       	ldi	r31, 0x80	; 128
    1d62:	0f 26       	eor	r0, r31
    1d64:	ff ef       	ldi	r31, 0xFF	; 255
    1d66:	e0 94       	com	r14
    1d68:	f0 94       	com	r15
    1d6a:	00 95       	com	r16
    1d6c:	10 95       	com	r17
    1d6e:	b0 94       	com	r11
    1d70:	c0 94       	com	r12
    1d72:	d0 94       	com	r13
    1d74:	a1 94       	neg	r10
    1d76:	bf 0a       	sbc	r11, r31
    1d78:	cf 0a       	sbc	r12, r31
    1d7a:	df 0a       	sbc	r13, r31
    1d7c:	ef 0a       	sbc	r14, r31
    1d7e:	ff 0a       	sbc	r15, r31
    1d80:	0f 0b       	sbc	r16, r31
    1d82:	1f 0b       	sbc	r17, r31
    1d84:	13 d0       	rcall	.+38     	; 0x1dac <__udivmod64>
    1d86:	07 fc       	sbrc	r0, 7
    1d88:	62 d0       	rcall	.+196    	; 0x1e4e <__negdi2>
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	ec e0       	ldi	r30, 0x0C	; 12
    1d90:	90 c0       	rjmp	.+288    	; 0x1eb2 <__epilogue_restores__+0xc>

00001d92 <__umoddi3>:
    1d92:	68 94       	set
    1d94:	01 c0       	rjmp	.+2      	; 0x1d98 <__udivdi3_umoddi3>

00001d96 <__udivdi3>:
    1d96:	e8 94       	clt

00001d98 <__udivdi3_umoddi3>:
    1d98:	8f 92       	push	r8
    1d9a:	9f 92       	push	r9
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	05 d0       	rcall	.+10     	; 0x1dac <__udivmod64>
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	9f 90       	pop	r9
    1da8:	8f 90       	pop	r8
    1daa:	08 95       	ret

00001dac <__udivmod64>:
    1dac:	88 24       	eor	r8, r8
    1dae:	99 24       	eor	r9, r9
    1db0:	f4 01       	movw	r30, r8
    1db2:	e4 01       	movw	r28, r8
    1db4:	b0 e4       	ldi	r27, 0x40	; 64
    1db6:	9f 93       	push	r25
    1db8:	aa 27       	eor	r26, r26
    1dba:	9a 15       	cp	r25, r10
    1dbc:	8b 04       	cpc	r8, r11
    1dbe:	9c 04       	cpc	r9, r12
    1dc0:	ed 05       	cpc	r30, r13
    1dc2:	fe 05       	cpc	r31, r14
    1dc4:	cf 05       	cpc	r28, r15
    1dc6:	d0 07       	cpc	r29, r16
    1dc8:	a1 07       	cpc	r26, r17
    1dca:	98 f4       	brcc	.+38     	; 0x1df2 <__udivmod64+0x46>
    1dcc:	ad 2f       	mov	r26, r29
    1dce:	dc 2f       	mov	r29, r28
    1dd0:	cf 2f       	mov	r28, r31
    1dd2:	fe 2f       	mov	r31, r30
    1dd4:	e9 2d       	mov	r30, r9
    1dd6:	98 2c       	mov	r9, r8
    1dd8:	89 2e       	mov	r8, r25
    1dda:	98 2f       	mov	r25, r24
    1ddc:	87 2f       	mov	r24, r23
    1dde:	76 2f       	mov	r23, r22
    1de0:	65 2f       	mov	r22, r21
    1de2:	54 2f       	mov	r21, r20
    1de4:	43 2f       	mov	r20, r19
    1de6:	32 2f       	mov	r19, r18
    1de8:	22 27       	eor	r18, r18
    1dea:	b8 50       	subi	r27, 0x08	; 8
    1dec:	31 f7       	brne	.-52     	; 0x1dba <__udivmod64+0xe>
    1dee:	bf 91       	pop	r27
    1df0:	27 c0       	rjmp	.+78     	; 0x1e40 <__udivmod64+0x94>
    1df2:	1b 2e       	mov	r1, r27
    1df4:	bf 91       	pop	r27
    1df6:	bb 27       	eor	r27, r27
    1df8:	22 0f       	add	r18, r18
    1dfa:	33 1f       	adc	r19, r19
    1dfc:	44 1f       	adc	r20, r20
    1dfe:	55 1f       	adc	r21, r21
    1e00:	66 1f       	adc	r22, r22
    1e02:	77 1f       	adc	r23, r23
    1e04:	88 1f       	adc	r24, r24
    1e06:	99 1f       	adc	r25, r25
    1e08:	88 1c       	adc	r8, r8
    1e0a:	99 1c       	adc	r9, r9
    1e0c:	ee 1f       	adc	r30, r30
    1e0e:	ff 1f       	adc	r31, r31
    1e10:	cc 1f       	adc	r28, r28
    1e12:	dd 1f       	adc	r29, r29
    1e14:	aa 1f       	adc	r26, r26
    1e16:	bb 1f       	adc	r27, r27
    1e18:	8a 14       	cp	r8, r10
    1e1a:	9b 04       	cpc	r9, r11
    1e1c:	ec 05       	cpc	r30, r12
    1e1e:	fd 05       	cpc	r31, r13
    1e20:	ce 05       	cpc	r28, r14
    1e22:	df 05       	cpc	r29, r15
    1e24:	a0 07       	cpc	r26, r16
    1e26:	b1 07       	cpc	r27, r17
    1e28:	48 f0       	brcs	.+18     	; 0x1e3c <__udivmod64+0x90>
    1e2a:	8a 18       	sub	r8, r10
    1e2c:	9b 08       	sbc	r9, r11
    1e2e:	ec 09       	sbc	r30, r12
    1e30:	fd 09       	sbc	r31, r13
    1e32:	ce 09       	sbc	r28, r14
    1e34:	df 09       	sbc	r29, r15
    1e36:	a0 0b       	sbc	r26, r16
    1e38:	b1 0b       	sbc	r27, r17
    1e3a:	21 60       	ori	r18, 0x01	; 1
    1e3c:	1a 94       	dec	r1
    1e3e:	e1 f6       	brne	.-72     	; 0x1df8 <__udivmod64+0x4c>
    1e40:	2e f4       	brtc	.+10     	; 0x1e4c <__udivmod64+0xa0>
    1e42:	94 01       	movw	r18, r8
    1e44:	af 01       	movw	r20, r30
    1e46:	be 01       	movw	r22, r28
    1e48:	cd 01       	movw	r24, r26
    1e4a:	00 0c       	add	r0, r0
    1e4c:	08 95       	ret

00001e4e <__negdi2>:
    1e4e:	60 95       	com	r22
    1e50:	70 95       	com	r23
    1e52:	80 95       	com	r24
    1e54:	90 95       	com	r25
    1e56:	30 95       	com	r19
    1e58:	40 95       	com	r20
    1e5a:	50 95       	com	r21
    1e5c:	21 95       	neg	r18
    1e5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e60:	4f 4f       	sbci	r20, 0xFF	; 255
    1e62:	5f 4f       	sbci	r21, 0xFF	; 255
    1e64:	6f 4f       	sbci	r22, 0xFF	; 255
    1e66:	7f 4f       	sbci	r23, 0xFF	; 255
    1e68:	8f 4f       	sbci	r24, 0xFF	; 255
    1e6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e6c:	08 95       	ret

00001e6e <__prologue_saves__>:
    1e6e:	2f 92       	push	r2
    1e70:	3f 92       	push	r3
    1e72:	4f 92       	push	r4
    1e74:	5f 92       	push	r5
    1e76:	6f 92       	push	r6
    1e78:	7f 92       	push	r7
    1e7a:	8f 92       	push	r8
    1e7c:	9f 92       	push	r9
    1e7e:	af 92       	push	r10
    1e80:	bf 92       	push	r11
    1e82:	cf 92       	push	r12
    1e84:	df 92       	push	r13
    1e86:	ef 92       	push	r14
    1e88:	ff 92       	push	r15
    1e8a:	0f 93       	push	r16
    1e8c:	1f 93       	push	r17
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
    1e96:	ca 1b       	sub	r28, r26
    1e98:	db 0b       	sbc	r29, r27
    1e9a:	0f b6       	in	r0, 0x3f	; 63
    1e9c:	f8 94       	cli
    1e9e:	de bf       	out	0x3e, r29	; 62
    1ea0:	0f be       	out	0x3f, r0	; 63
    1ea2:	cd bf       	out	0x3d, r28	; 61
    1ea4:	09 94       	ijmp

00001ea6 <__epilogue_restores__>:
    1ea6:	2a 88       	ldd	r2, Y+18	; 0x12
    1ea8:	39 88       	ldd	r3, Y+17	; 0x11
    1eaa:	48 88       	ldd	r4, Y+16	; 0x10
    1eac:	5f 84       	ldd	r5, Y+15	; 0x0f
    1eae:	6e 84       	ldd	r6, Y+14	; 0x0e
    1eb0:	7d 84       	ldd	r7, Y+13	; 0x0d
    1eb2:	8c 84       	ldd	r8, Y+12	; 0x0c
    1eb4:	9b 84       	ldd	r9, Y+11	; 0x0b
    1eb6:	aa 84       	ldd	r10, Y+10	; 0x0a
    1eb8:	b9 84       	ldd	r11, Y+9	; 0x09
    1eba:	c8 84       	ldd	r12, Y+8	; 0x08
    1ebc:	df 80       	ldd	r13, Y+7	; 0x07
    1ebe:	ee 80       	ldd	r14, Y+6	; 0x06
    1ec0:	fd 80       	ldd	r15, Y+5	; 0x05
    1ec2:	0c 81       	ldd	r16, Y+4	; 0x04
    1ec4:	1b 81       	ldd	r17, Y+3	; 0x03
    1ec6:	aa 81       	ldd	r26, Y+2	; 0x02
    1ec8:	b9 81       	ldd	r27, Y+1	; 0x01
    1eca:	ce 0f       	add	r28, r30
    1ecc:	d1 1d       	adc	r29, r1
    1ece:	0f b6       	in	r0, 0x3f	; 63
    1ed0:	f8 94       	cli
    1ed2:	de bf       	out	0x3e, r29	; 62
    1ed4:	0f be       	out	0x3f, r0	; 63
    1ed6:	cd bf       	out	0x3d, r28	; 61
    1ed8:	ed 01       	movw	r28, r26
    1eda:	08 95       	ret

00001edc <__ashldi3>:
    1edc:	0f 93       	push	r16
    1ede:	08 30       	cpi	r16, 0x08	; 8
    1ee0:	90 f0       	brcs	.+36     	; 0x1f06 <__ashldi3+0x2a>
    1ee2:	98 2f       	mov	r25, r24
    1ee4:	87 2f       	mov	r24, r23
    1ee6:	76 2f       	mov	r23, r22
    1ee8:	65 2f       	mov	r22, r21
    1eea:	54 2f       	mov	r21, r20
    1eec:	43 2f       	mov	r20, r19
    1eee:	32 2f       	mov	r19, r18
    1ef0:	22 27       	eor	r18, r18
    1ef2:	08 50       	subi	r16, 0x08	; 8
    1ef4:	f4 cf       	rjmp	.-24     	; 0x1ede <__ashldi3+0x2>
    1ef6:	22 0f       	add	r18, r18
    1ef8:	33 1f       	adc	r19, r19
    1efa:	44 1f       	adc	r20, r20
    1efc:	55 1f       	adc	r21, r21
    1efe:	66 1f       	adc	r22, r22
    1f00:	77 1f       	adc	r23, r23
    1f02:	88 1f       	adc	r24, r24
    1f04:	99 1f       	adc	r25, r25
    1f06:	0a 95       	dec	r16
    1f08:	b2 f7       	brpl	.-20     	; 0x1ef6 <__ashldi3+0x1a>
    1f0a:	0f 91       	pop	r16
    1f0c:	08 95       	ret

00001f0e <__ashrdi3>:
    1f0e:	97 fb       	bst	r25, 7
    1f10:	10 f8       	bld	r1, 0

00001f12 <__lshrdi3>:
    1f12:	16 94       	lsr	r1
    1f14:	00 08       	sbc	r0, r0
    1f16:	0f 93       	push	r16
    1f18:	08 30       	cpi	r16, 0x08	; 8
    1f1a:	98 f0       	brcs	.+38     	; 0x1f42 <__lshrdi3+0x30>
    1f1c:	08 50       	subi	r16, 0x08	; 8
    1f1e:	23 2f       	mov	r18, r19
    1f20:	34 2f       	mov	r19, r20
    1f22:	45 2f       	mov	r20, r21
    1f24:	56 2f       	mov	r21, r22
    1f26:	67 2f       	mov	r22, r23
    1f28:	78 2f       	mov	r23, r24
    1f2a:	89 2f       	mov	r24, r25
    1f2c:	90 2d       	mov	r25, r0
    1f2e:	f4 cf       	rjmp	.-24     	; 0x1f18 <__lshrdi3+0x6>
    1f30:	05 94       	asr	r0
    1f32:	97 95       	ror	r25
    1f34:	87 95       	ror	r24
    1f36:	77 95       	ror	r23
    1f38:	67 95       	ror	r22
    1f3a:	57 95       	ror	r21
    1f3c:	47 95       	ror	r20
    1f3e:	37 95       	ror	r19
    1f40:	27 95       	ror	r18
    1f42:	0a 95       	dec	r16
    1f44:	aa f7       	brpl	.-22     	; 0x1f30 <__lshrdi3+0x1e>
    1f46:	0f 91       	pop	r16
    1f48:	08 95       	ret

00001f4a <__adddi3>:
    1f4a:	2a 0d       	add	r18, r10
    1f4c:	3b 1d       	adc	r19, r11
    1f4e:	4c 1d       	adc	r20, r12
    1f50:	5d 1d       	adc	r21, r13
    1f52:	6e 1d       	adc	r22, r14
    1f54:	7f 1d       	adc	r23, r15
    1f56:	80 1f       	adc	r24, r16
    1f58:	91 1f       	adc	r25, r17
    1f5a:	08 95       	ret

00001f5c <__subdi3>:
    1f5c:	2a 19       	sub	r18, r10
    1f5e:	3b 09       	sbc	r19, r11
    1f60:	4c 09       	sbc	r20, r12
    1f62:	5d 09       	sbc	r21, r13
    1f64:	6e 09       	sbc	r22, r14
    1f66:	7f 09       	sbc	r23, r15
    1f68:	80 0b       	sbc	r24, r16
    1f6a:	91 0b       	sbc	r25, r17
    1f6c:	08 95       	ret

00001f6e <__cmpdi2_s8>:
    1f6e:	00 24       	eor	r0, r0
    1f70:	a7 fd       	sbrc	r26, 7
    1f72:	00 94       	com	r0
    1f74:	2a 17       	cp	r18, r26
    1f76:	30 05       	cpc	r19, r0
    1f78:	40 05       	cpc	r20, r0
    1f7a:	50 05       	cpc	r21, r0
    1f7c:	60 05       	cpc	r22, r0
    1f7e:	70 05       	cpc	r23, r0
    1f80:	80 05       	cpc	r24, r0
    1f82:	90 05       	cpc	r25, r0
    1f84:	08 95       	ret

00001f86 <__umulhisi3>:
    1f86:	a2 9f       	mul	r26, r18
    1f88:	b0 01       	movw	r22, r0
    1f8a:	b3 9f       	mul	r27, r19
    1f8c:	c0 01       	movw	r24, r0
    1f8e:	a3 9f       	mul	r26, r19
    1f90:	70 0d       	add	r23, r0
    1f92:	81 1d       	adc	r24, r1
    1f94:	11 24       	eor	r1, r1
    1f96:	91 1d       	adc	r25, r1
    1f98:	b2 9f       	mul	r27, r18
    1f9a:	70 0d       	add	r23, r0
    1f9c:	81 1d       	adc	r24, r1
    1f9e:	11 24       	eor	r1, r1
    1fa0:	91 1d       	adc	r25, r1
    1fa2:	08 95       	ret

00001fa4 <printf>:
    1fa4:	cf 93       	push	r28
    1fa6:	df 93       	push	r29
    1fa8:	cd b7       	in	r28, 0x3d	; 61
    1faa:	de b7       	in	r29, 0x3e	; 62
    1fac:	ae 01       	movw	r20, r28
    1fae:	4b 5f       	subi	r20, 0xFB	; 251
    1fb0:	5f 4f       	sbci	r21, 0xFF	; 255
    1fb2:	fa 01       	movw	r30, r20
    1fb4:	61 91       	ld	r22, Z+
    1fb6:	71 91       	ld	r23, Z+
    1fb8:	af 01       	movw	r20, r30
    1fba:	80 91 1f 09 	lds	r24, 0x091F	; 0x80091f <__iob+0x2>
    1fbe:	90 91 20 09 	lds	r25, 0x0920	; 0x800920 <__iob+0x3>
    1fc2:	37 d0       	rcall	.+110    	; 0x2032 <vfprintf>
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28
    1fc8:	08 95       	ret

00001fca <putchar>:
    1fca:	60 91 1f 09 	lds	r22, 0x091F	; 0x80091f <__iob+0x2>
    1fce:	70 91 20 09 	lds	r23, 0x0920	; 0x800920 <__iob+0x3>
    1fd2:	33 c2       	rjmp	.+1126   	; 0x243a <fputc>

00001fd4 <sprintf>:
    1fd4:	0f 93       	push	r16
    1fd6:	1f 93       	push	r17
    1fd8:	cf 93       	push	r28
    1fda:	df 93       	push	r29
    1fdc:	cd b7       	in	r28, 0x3d	; 61
    1fde:	de b7       	in	r29, 0x3e	; 62
    1fe0:	2e 97       	sbiw	r28, 0x0e	; 14
    1fe2:	0f b6       	in	r0, 0x3f	; 63
    1fe4:	f8 94       	cli
    1fe6:	de bf       	out	0x3e, r29	; 62
    1fe8:	0f be       	out	0x3f, r0	; 63
    1fea:	cd bf       	out	0x3d, r28	; 61
    1fec:	0d 89       	ldd	r16, Y+21	; 0x15
    1fee:	1e 89       	ldd	r17, Y+22	; 0x16
    1ff0:	86 e0       	ldi	r24, 0x06	; 6
    1ff2:	8c 83       	std	Y+4, r24	; 0x04
    1ff4:	1a 83       	std	Y+2, r17	; 0x02
    1ff6:	09 83       	std	Y+1, r16	; 0x01
    1ff8:	8f ef       	ldi	r24, 0xFF	; 255
    1ffa:	9f e7       	ldi	r25, 0x7F	; 127
    1ffc:	9e 83       	std	Y+6, r25	; 0x06
    1ffe:	8d 83       	std	Y+5, r24	; 0x05
    2000:	ae 01       	movw	r20, r28
    2002:	47 5e       	subi	r20, 0xE7	; 231
    2004:	5f 4f       	sbci	r21, 0xFF	; 255
    2006:	6f 89       	ldd	r22, Y+23	; 0x17
    2008:	78 8d       	ldd	r23, Y+24	; 0x18
    200a:	ce 01       	movw	r24, r28
    200c:	01 96       	adiw	r24, 0x01	; 1
    200e:	11 d0       	rcall	.+34     	; 0x2032 <vfprintf>
    2010:	2f 81       	ldd	r18, Y+7	; 0x07
    2012:	38 85       	ldd	r19, Y+8	; 0x08
    2014:	f8 01       	movw	r30, r16
    2016:	e2 0f       	add	r30, r18
    2018:	f3 1f       	adc	r31, r19
    201a:	10 82       	st	Z, r1
    201c:	2e 96       	adiw	r28, 0x0e	; 14
    201e:	0f b6       	in	r0, 0x3f	; 63
    2020:	f8 94       	cli
    2022:	de bf       	out	0x3e, r29	; 62
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	cd bf       	out	0x3d, r28	; 61
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	08 95       	ret

00002032 <vfprintf>:
    2032:	2f 92       	push	r2
    2034:	3f 92       	push	r3
    2036:	4f 92       	push	r4
    2038:	5f 92       	push	r5
    203a:	6f 92       	push	r6
    203c:	7f 92       	push	r7
    203e:	8f 92       	push	r8
    2040:	9f 92       	push	r9
    2042:	af 92       	push	r10
    2044:	bf 92       	push	r11
    2046:	cf 92       	push	r12
    2048:	df 92       	push	r13
    204a:	ef 92       	push	r14
    204c:	ff 92       	push	r15
    204e:	0f 93       	push	r16
    2050:	1f 93       	push	r17
    2052:	cf 93       	push	r28
    2054:	df 93       	push	r29
    2056:	cd b7       	in	r28, 0x3d	; 61
    2058:	de b7       	in	r29, 0x3e	; 62
    205a:	2c 97       	sbiw	r28, 0x0c	; 12
    205c:	0f b6       	in	r0, 0x3f	; 63
    205e:	f8 94       	cli
    2060:	de bf       	out	0x3e, r29	; 62
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	cd bf       	out	0x3d, r28	; 61
    2066:	7c 01       	movw	r14, r24
    2068:	6b 01       	movw	r12, r22
    206a:	8a 01       	movw	r16, r20
    206c:	fc 01       	movw	r30, r24
    206e:	17 82       	std	Z+7, r1	; 0x07
    2070:	16 82       	std	Z+6, r1	; 0x06
    2072:	83 81       	ldd	r24, Z+3	; 0x03
    2074:	81 ff       	sbrs	r24, 1
    2076:	b0 c1       	rjmp	.+864    	; 0x23d8 <vfprintf+0x3a6>
    2078:	ce 01       	movw	r24, r28
    207a:	01 96       	adiw	r24, 0x01	; 1
    207c:	4c 01       	movw	r8, r24
    207e:	f7 01       	movw	r30, r14
    2080:	93 81       	ldd	r25, Z+3	; 0x03
    2082:	f6 01       	movw	r30, r12
    2084:	93 fd       	sbrc	r25, 3
    2086:	85 91       	lpm	r24, Z+
    2088:	93 ff       	sbrs	r25, 3
    208a:	81 91       	ld	r24, Z+
    208c:	6f 01       	movw	r12, r30
    208e:	88 23       	and	r24, r24
    2090:	09 f4       	brne	.+2      	; 0x2094 <vfprintf+0x62>
    2092:	9e c1       	rjmp	.+828    	; 0x23d0 <vfprintf+0x39e>
    2094:	85 32       	cpi	r24, 0x25	; 37
    2096:	39 f4       	brne	.+14     	; 0x20a6 <vfprintf+0x74>
    2098:	93 fd       	sbrc	r25, 3
    209a:	85 91       	lpm	r24, Z+
    209c:	93 ff       	sbrs	r25, 3
    209e:	81 91       	ld	r24, Z+
    20a0:	6f 01       	movw	r12, r30
    20a2:	85 32       	cpi	r24, 0x25	; 37
    20a4:	21 f4       	brne	.+8      	; 0x20ae <vfprintf+0x7c>
    20a6:	b7 01       	movw	r22, r14
    20a8:	90 e0       	ldi	r25, 0x00	; 0
    20aa:	c7 d1       	rcall	.+910    	; 0x243a <fputc>
    20ac:	e8 cf       	rjmp	.-48     	; 0x207e <vfprintf+0x4c>
    20ae:	51 2c       	mov	r5, r1
    20b0:	31 2c       	mov	r3, r1
    20b2:	20 e0       	ldi	r18, 0x00	; 0
    20b4:	20 32       	cpi	r18, 0x20	; 32
    20b6:	a0 f4       	brcc	.+40     	; 0x20e0 <vfprintf+0xae>
    20b8:	8b 32       	cpi	r24, 0x2B	; 43
    20ba:	69 f0       	breq	.+26     	; 0x20d6 <vfprintf+0xa4>
    20bc:	30 f4       	brcc	.+12     	; 0x20ca <vfprintf+0x98>
    20be:	80 32       	cpi	r24, 0x20	; 32
    20c0:	59 f0       	breq	.+22     	; 0x20d8 <vfprintf+0xa6>
    20c2:	83 32       	cpi	r24, 0x23	; 35
    20c4:	69 f4       	brne	.+26     	; 0x20e0 <vfprintf+0xae>
    20c6:	20 61       	ori	r18, 0x10	; 16
    20c8:	2c c0       	rjmp	.+88     	; 0x2122 <vfprintf+0xf0>
    20ca:	8d 32       	cpi	r24, 0x2D	; 45
    20cc:	39 f0       	breq	.+14     	; 0x20dc <vfprintf+0xaa>
    20ce:	80 33       	cpi	r24, 0x30	; 48
    20d0:	39 f4       	brne	.+14     	; 0x20e0 <vfprintf+0xae>
    20d2:	21 60       	ori	r18, 0x01	; 1
    20d4:	26 c0       	rjmp	.+76     	; 0x2122 <vfprintf+0xf0>
    20d6:	22 60       	ori	r18, 0x02	; 2
    20d8:	24 60       	ori	r18, 0x04	; 4
    20da:	23 c0       	rjmp	.+70     	; 0x2122 <vfprintf+0xf0>
    20dc:	28 60       	ori	r18, 0x08	; 8
    20de:	21 c0       	rjmp	.+66     	; 0x2122 <vfprintf+0xf0>
    20e0:	27 fd       	sbrc	r18, 7
    20e2:	27 c0       	rjmp	.+78     	; 0x2132 <vfprintf+0x100>
    20e4:	30 ed       	ldi	r19, 0xD0	; 208
    20e6:	38 0f       	add	r19, r24
    20e8:	3a 30       	cpi	r19, 0x0A	; 10
    20ea:	78 f4       	brcc	.+30     	; 0x210a <vfprintf+0xd8>
    20ec:	26 ff       	sbrs	r18, 6
    20ee:	06 c0       	rjmp	.+12     	; 0x20fc <vfprintf+0xca>
    20f0:	fa e0       	ldi	r31, 0x0A	; 10
    20f2:	5f 9e       	mul	r5, r31
    20f4:	30 0d       	add	r19, r0
    20f6:	11 24       	eor	r1, r1
    20f8:	53 2e       	mov	r5, r19
    20fa:	13 c0       	rjmp	.+38     	; 0x2122 <vfprintf+0xf0>
    20fc:	8a e0       	ldi	r24, 0x0A	; 10
    20fe:	38 9e       	mul	r3, r24
    2100:	30 0d       	add	r19, r0
    2102:	11 24       	eor	r1, r1
    2104:	33 2e       	mov	r3, r19
    2106:	20 62       	ori	r18, 0x20	; 32
    2108:	0c c0       	rjmp	.+24     	; 0x2122 <vfprintf+0xf0>
    210a:	8e 32       	cpi	r24, 0x2E	; 46
    210c:	21 f4       	brne	.+8      	; 0x2116 <vfprintf+0xe4>
    210e:	26 fd       	sbrc	r18, 6
    2110:	5f c1       	rjmp	.+702    	; 0x23d0 <vfprintf+0x39e>
    2112:	20 64       	ori	r18, 0x40	; 64
    2114:	06 c0       	rjmp	.+12     	; 0x2122 <vfprintf+0xf0>
    2116:	8c 36       	cpi	r24, 0x6C	; 108
    2118:	11 f4       	brne	.+4      	; 0x211e <vfprintf+0xec>
    211a:	20 68       	ori	r18, 0x80	; 128
    211c:	02 c0       	rjmp	.+4      	; 0x2122 <vfprintf+0xf0>
    211e:	88 36       	cpi	r24, 0x68	; 104
    2120:	41 f4       	brne	.+16     	; 0x2132 <vfprintf+0x100>
    2122:	f6 01       	movw	r30, r12
    2124:	93 fd       	sbrc	r25, 3
    2126:	85 91       	lpm	r24, Z+
    2128:	93 ff       	sbrs	r25, 3
    212a:	81 91       	ld	r24, Z+
    212c:	6f 01       	movw	r12, r30
    212e:	81 11       	cpse	r24, r1
    2130:	c1 cf       	rjmp	.-126    	; 0x20b4 <vfprintf+0x82>
    2132:	98 2f       	mov	r25, r24
    2134:	9f 7d       	andi	r25, 0xDF	; 223
    2136:	95 54       	subi	r25, 0x45	; 69
    2138:	93 30       	cpi	r25, 0x03	; 3
    213a:	28 f4       	brcc	.+10     	; 0x2146 <vfprintf+0x114>
    213c:	0c 5f       	subi	r16, 0xFC	; 252
    213e:	1f 4f       	sbci	r17, 0xFF	; 255
    2140:	ff e3       	ldi	r31, 0x3F	; 63
    2142:	f9 83       	std	Y+1, r31	; 0x01
    2144:	0d c0       	rjmp	.+26     	; 0x2160 <vfprintf+0x12e>
    2146:	83 36       	cpi	r24, 0x63	; 99
    2148:	31 f0       	breq	.+12     	; 0x2156 <vfprintf+0x124>
    214a:	83 37       	cpi	r24, 0x73	; 115
    214c:	71 f0       	breq	.+28     	; 0x216a <vfprintf+0x138>
    214e:	83 35       	cpi	r24, 0x53	; 83
    2150:	09 f0       	breq	.+2      	; 0x2154 <vfprintf+0x122>
    2152:	57 c0       	rjmp	.+174    	; 0x2202 <vfprintf+0x1d0>
    2154:	21 c0       	rjmp	.+66     	; 0x2198 <vfprintf+0x166>
    2156:	f8 01       	movw	r30, r16
    2158:	80 81       	ld	r24, Z
    215a:	89 83       	std	Y+1, r24	; 0x01
    215c:	0e 5f       	subi	r16, 0xFE	; 254
    215e:	1f 4f       	sbci	r17, 0xFF	; 255
    2160:	44 24       	eor	r4, r4
    2162:	43 94       	inc	r4
    2164:	51 2c       	mov	r5, r1
    2166:	54 01       	movw	r10, r8
    2168:	14 c0       	rjmp	.+40     	; 0x2192 <vfprintf+0x160>
    216a:	38 01       	movw	r6, r16
    216c:	f2 e0       	ldi	r31, 0x02	; 2
    216e:	6f 0e       	add	r6, r31
    2170:	71 1c       	adc	r7, r1
    2172:	f8 01       	movw	r30, r16
    2174:	a0 80       	ld	r10, Z
    2176:	b1 80       	ldd	r11, Z+1	; 0x01
    2178:	26 ff       	sbrs	r18, 6
    217a:	03 c0       	rjmp	.+6      	; 0x2182 <vfprintf+0x150>
    217c:	65 2d       	mov	r22, r5
    217e:	70 e0       	ldi	r23, 0x00	; 0
    2180:	02 c0       	rjmp	.+4      	; 0x2186 <vfprintf+0x154>
    2182:	6f ef       	ldi	r22, 0xFF	; 255
    2184:	7f ef       	ldi	r23, 0xFF	; 255
    2186:	c5 01       	movw	r24, r10
    2188:	2c 87       	std	Y+12, r18	; 0x0c
    218a:	4c d1       	rcall	.+664    	; 0x2424 <strnlen>
    218c:	2c 01       	movw	r4, r24
    218e:	83 01       	movw	r16, r6
    2190:	2c 85       	ldd	r18, Y+12	; 0x0c
    2192:	2f 77       	andi	r18, 0x7F	; 127
    2194:	22 2e       	mov	r2, r18
    2196:	16 c0       	rjmp	.+44     	; 0x21c4 <vfprintf+0x192>
    2198:	38 01       	movw	r6, r16
    219a:	f2 e0       	ldi	r31, 0x02	; 2
    219c:	6f 0e       	add	r6, r31
    219e:	71 1c       	adc	r7, r1
    21a0:	f8 01       	movw	r30, r16
    21a2:	a0 80       	ld	r10, Z
    21a4:	b1 80       	ldd	r11, Z+1	; 0x01
    21a6:	26 ff       	sbrs	r18, 6
    21a8:	03 c0       	rjmp	.+6      	; 0x21b0 <vfprintf+0x17e>
    21aa:	65 2d       	mov	r22, r5
    21ac:	70 e0       	ldi	r23, 0x00	; 0
    21ae:	02 c0       	rjmp	.+4      	; 0x21b4 <vfprintf+0x182>
    21b0:	6f ef       	ldi	r22, 0xFF	; 255
    21b2:	7f ef       	ldi	r23, 0xFF	; 255
    21b4:	c5 01       	movw	r24, r10
    21b6:	2c 87       	std	Y+12, r18	; 0x0c
    21b8:	2a d1       	rcall	.+596    	; 0x240e <strnlen_P>
    21ba:	2c 01       	movw	r4, r24
    21bc:	2c 85       	ldd	r18, Y+12	; 0x0c
    21be:	20 68       	ori	r18, 0x80	; 128
    21c0:	22 2e       	mov	r2, r18
    21c2:	83 01       	movw	r16, r6
    21c4:	23 fc       	sbrc	r2, 3
    21c6:	19 c0       	rjmp	.+50     	; 0x21fa <vfprintf+0x1c8>
    21c8:	83 2d       	mov	r24, r3
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	48 16       	cp	r4, r24
    21ce:	59 06       	cpc	r5, r25
    21d0:	a0 f4       	brcc	.+40     	; 0x21fa <vfprintf+0x1c8>
    21d2:	b7 01       	movw	r22, r14
    21d4:	80 e2       	ldi	r24, 0x20	; 32
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	30 d1       	rcall	.+608    	; 0x243a <fputc>
    21da:	3a 94       	dec	r3
    21dc:	f5 cf       	rjmp	.-22     	; 0x21c8 <vfprintf+0x196>
    21de:	f5 01       	movw	r30, r10
    21e0:	27 fc       	sbrc	r2, 7
    21e2:	85 91       	lpm	r24, Z+
    21e4:	27 fe       	sbrs	r2, 7
    21e6:	81 91       	ld	r24, Z+
    21e8:	5f 01       	movw	r10, r30
    21ea:	b7 01       	movw	r22, r14
    21ec:	90 e0       	ldi	r25, 0x00	; 0
    21ee:	25 d1       	rcall	.+586    	; 0x243a <fputc>
    21f0:	31 10       	cpse	r3, r1
    21f2:	3a 94       	dec	r3
    21f4:	f1 e0       	ldi	r31, 0x01	; 1
    21f6:	4f 1a       	sub	r4, r31
    21f8:	51 08       	sbc	r5, r1
    21fa:	41 14       	cp	r4, r1
    21fc:	51 04       	cpc	r5, r1
    21fe:	79 f7       	brne	.-34     	; 0x21de <vfprintf+0x1ac>
    2200:	de c0       	rjmp	.+444    	; 0x23be <vfprintf+0x38c>
    2202:	84 36       	cpi	r24, 0x64	; 100
    2204:	11 f0       	breq	.+4      	; 0x220a <vfprintf+0x1d8>
    2206:	89 36       	cpi	r24, 0x69	; 105
    2208:	31 f5       	brne	.+76     	; 0x2256 <vfprintf+0x224>
    220a:	f8 01       	movw	r30, r16
    220c:	27 ff       	sbrs	r18, 7
    220e:	07 c0       	rjmp	.+14     	; 0x221e <vfprintf+0x1ec>
    2210:	60 81       	ld	r22, Z
    2212:	71 81       	ldd	r23, Z+1	; 0x01
    2214:	82 81       	ldd	r24, Z+2	; 0x02
    2216:	93 81       	ldd	r25, Z+3	; 0x03
    2218:	0c 5f       	subi	r16, 0xFC	; 252
    221a:	1f 4f       	sbci	r17, 0xFF	; 255
    221c:	08 c0       	rjmp	.+16     	; 0x222e <vfprintf+0x1fc>
    221e:	60 81       	ld	r22, Z
    2220:	71 81       	ldd	r23, Z+1	; 0x01
    2222:	07 2e       	mov	r0, r23
    2224:	00 0c       	add	r0, r0
    2226:	88 0b       	sbc	r24, r24
    2228:	99 0b       	sbc	r25, r25
    222a:	0e 5f       	subi	r16, 0xFE	; 254
    222c:	1f 4f       	sbci	r17, 0xFF	; 255
    222e:	2f 76       	andi	r18, 0x6F	; 111
    2230:	72 2e       	mov	r7, r18
    2232:	97 ff       	sbrs	r25, 7
    2234:	09 c0       	rjmp	.+18     	; 0x2248 <vfprintf+0x216>
    2236:	90 95       	com	r25
    2238:	80 95       	com	r24
    223a:	70 95       	com	r23
    223c:	61 95       	neg	r22
    223e:	7f 4f       	sbci	r23, 0xFF	; 255
    2240:	8f 4f       	sbci	r24, 0xFF	; 255
    2242:	9f 4f       	sbci	r25, 0xFF	; 255
    2244:	20 68       	ori	r18, 0x80	; 128
    2246:	72 2e       	mov	r7, r18
    2248:	2a e0       	ldi	r18, 0x0A	; 10
    224a:	30 e0       	ldi	r19, 0x00	; 0
    224c:	a4 01       	movw	r20, r8
    224e:	2d d1       	rcall	.+602    	; 0x24aa <__ultoa_invert>
    2250:	a8 2e       	mov	r10, r24
    2252:	a8 18       	sub	r10, r8
    2254:	43 c0       	rjmp	.+134    	; 0x22dc <vfprintf+0x2aa>
    2256:	85 37       	cpi	r24, 0x75	; 117
    2258:	29 f4       	brne	.+10     	; 0x2264 <vfprintf+0x232>
    225a:	2f 7e       	andi	r18, 0xEF	; 239
    225c:	b2 2e       	mov	r11, r18
    225e:	2a e0       	ldi	r18, 0x0A	; 10
    2260:	30 e0       	ldi	r19, 0x00	; 0
    2262:	25 c0       	rjmp	.+74     	; 0x22ae <vfprintf+0x27c>
    2264:	f2 2f       	mov	r31, r18
    2266:	f9 7f       	andi	r31, 0xF9	; 249
    2268:	bf 2e       	mov	r11, r31
    226a:	8f 36       	cpi	r24, 0x6F	; 111
    226c:	c1 f0       	breq	.+48     	; 0x229e <vfprintf+0x26c>
    226e:	18 f4       	brcc	.+6      	; 0x2276 <vfprintf+0x244>
    2270:	88 35       	cpi	r24, 0x58	; 88
    2272:	79 f0       	breq	.+30     	; 0x2292 <vfprintf+0x260>
    2274:	ad c0       	rjmp	.+346    	; 0x23d0 <vfprintf+0x39e>
    2276:	80 37       	cpi	r24, 0x70	; 112
    2278:	19 f0       	breq	.+6      	; 0x2280 <vfprintf+0x24e>
    227a:	88 37       	cpi	r24, 0x78	; 120
    227c:	21 f0       	breq	.+8      	; 0x2286 <vfprintf+0x254>
    227e:	a8 c0       	rjmp	.+336    	; 0x23d0 <vfprintf+0x39e>
    2280:	2f 2f       	mov	r18, r31
    2282:	20 61       	ori	r18, 0x10	; 16
    2284:	b2 2e       	mov	r11, r18
    2286:	b4 fe       	sbrs	r11, 4
    2288:	0d c0       	rjmp	.+26     	; 0x22a4 <vfprintf+0x272>
    228a:	8b 2d       	mov	r24, r11
    228c:	84 60       	ori	r24, 0x04	; 4
    228e:	b8 2e       	mov	r11, r24
    2290:	09 c0       	rjmp	.+18     	; 0x22a4 <vfprintf+0x272>
    2292:	24 ff       	sbrs	r18, 4
    2294:	0a c0       	rjmp	.+20     	; 0x22aa <vfprintf+0x278>
    2296:	9f 2f       	mov	r25, r31
    2298:	96 60       	ori	r25, 0x06	; 6
    229a:	b9 2e       	mov	r11, r25
    229c:	06 c0       	rjmp	.+12     	; 0x22aa <vfprintf+0x278>
    229e:	28 e0       	ldi	r18, 0x08	; 8
    22a0:	30 e0       	ldi	r19, 0x00	; 0
    22a2:	05 c0       	rjmp	.+10     	; 0x22ae <vfprintf+0x27c>
    22a4:	20 e1       	ldi	r18, 0x10	; 16
    22a6:	30 e0       	ldi	r19, 0x00	; 0
    22a8:	02 c0       	rjmp	.+4      	; 0x22ae <vfprintf+0x27c>
    22aa:	20 e1       	ldi	r18, 0x10	; 16
    22ac:	32 e0       	ldi	r19, 0x02	; 2
    22ae:	f8 01       	movw	r30, r16
    22b0:	b7 fe       	sbrs	r11, 7
    22b2:	07 c0       	rjmp	.+14     	; 0x22c2 <vfprintf+0x290>
    22b4:	60 81       	ld	r22, Z
    22b6:	71 81       	ldd	r23, Z+1	; 0x01
    22b8:	82 81       	ldd	r24, Z+2	; 0x02
    22ba:	93 81       	ldd	r25, Z+3	; 0x03
    22bc:	0c 5f       	subi	r16, 0xFC	; 252
    22be:	1f 4f       	sbci	r17, 0xFF	; 255
    22c0:	06 c0       	rjmp	.+12     	; 0x22ce <vfprintf+0x29c>
    22c2:	60 81       	ld	r22, Z
    22c4:	71 81       	ldd	r23, Z+1	; 0x01
    22c6:	80 e0       	ldi	r24, 0x00	; 0
    22c8:	90 e0       	ldi	r25, 0x00	; 0
    22ca:	0e 5f       	subi	r16, 0xFE	; 254
    22cc:	1f 4f       	sbci	r17, 0xFF	; 255
    22ce:	a4 01       	movw	r20, r8
    22d0:	ec d0       	rcall	.+472    	; 0x24aa <__ultoa_invert>
    22d2:	a8 2e       	mov	r10, r24
    22d4:	a8 18       	sub	r10, r8
    22d6:	fb 2d       	mov	r31, r11
    22d8:	ff 77       	andi	r31, 0x7F	; 127
    22da:	7f 2e       	mov	r7, r31
    22dc:	76 fe       	sbrs	r7, 6
    22de:	0b c0       	rjmp	.+22     	; 0x22f6 <vfprintf+0x2c4>
    22e0:	37 2d       	mov	r19, r7
    22e2:	3e 7f       	andi	r19, 0xFE	; 254
    22e4:	a5 14       	cp	r10, r5
    22e6:	50 f4       	brcc	.+20     	; 0x22fc <vfprintf+0x2ca>
    22e8:	74 fe       	sbrs	r7, 4
    22ea:	0a c0       	rjmp	.+20     	; 0x2300 <vfprintf+0x2ce>
    22ec:	72 fc       	sbrc	r7, 2
    22ee:	08 c0       	rjmp	.+16     	; 0x2300 <vfprintf+0x2ce>
    22f0:	37 2d       	mov	r19, r7
    22f2:	3e 7e       	andi	r19, 0xEE	; 238
    22f4:	05 c0       	rjmp	.+10     	; 0x2300 <vfprintf+0x2ce>
    22f6:	ba 2c       	mov	r11, r10
    22f8:	37 2d       	mov	r19, r7
    22fa:	03 c0       	rjmp	.+6      	; 0x2302 <vfprintf+0x2d0>
    22fc:	ba 2c       	mov	r11, r10
    22fe:	01 c0       	rjmp	.+2      	; 0x2302 <vfprintf+0x2d0>
    2300:	b5 2c       	mov	r11, r5
    2302:	34 ff       	sbrs	r19, 4
    2304:	0d c0       	rjmp	.+26     	; 0x2320 <vfprintf+0x2ee>
    2306:	fe 01       	movw	r30, r28
    2308:	ea 0d       	add	r30, r10
    230a:	f1 1d       	adc	r31, r1
    230c:	80 81       	ld	r24, Z
    230e:	80 33       	cpi	r24, 0x30	; 48
    2310:	11 f4       	brne	.+4      	; 0x2316 <vfprintf+0x2e4>
    2312:	39 7e       	andi	r19, 0xE9	; 233
    2314:	09 c0       	rjmp	.+18     	; 0x2328 <vfprintf+0x2f6>
    2316:	32 ff       	sbrs	r19, 2
    2318:	06 c0       	rjmp	.+12     	; 0x2326 <vfprintf+0x2f4>
    231a:	b3 94       	inc	r11
    231c:	b3 94       	inc	r11
    231e:	04 c0       	rjmp	.+8      	; 0x2328 <vfprintf+0x2f6>
    2320:	83 2f       	mov	r24, r19
    2322:	86 78       	andi	r24, 0x86	; 134
    2324:	09 f0       	breq	.+2      	; 0x2328 <vfprintf+0x2f6>
    2326:	b3 94       	inc	r11
    2328:	33 fd       	sbrc	r19, 3
    232a:	12 c0       	rjmp	.+36     	; 0x2350 <vfprintf+0x31e>
    232c:	30 ff       	sbrs	r19, 0
    232e:	06 c0       	rjmp	.+12     	; 0x233c <vfprintf+0x30a>
    2330:	5a 2c       	mov	r5, r10
    2332:	b3 14       	cp	r11, r3
    2334:	18 f4       	brcc	.+6      	; 0x233c <vfprintf+0x30a>
    2336:	53 0c       	add	r5, r3
    2338:	5b 18       	sub	r5, r11
    233a:	b3 2c       	mov	r11, r3
    233c:	b3 14       	cp	r11, r3
    233e:	60 f4       	brcc	.+24     	; 0x2358 <vfprintf+0x326>
    2340:	b7 01       	movw	r22, r14
    2342:	80 e2       	ldi	r24, 0x20	; 32
    2344:	90 e0       	ldi	r25, 0x00	; 0
    2346:	3c 87       	std	Y+12, r19	; 0x0c
    2348:	78 d0       	rcall	.+240    	; 0x243a <fputc>
    234a:	b3 94       	inc	r11
    234c:	3c 85       	ldd	r19, Y+12	; 0x0c
    234e:	f6 cf       	rjmp	.-20     	; 0x233c <vfprintf+0x30a>
    2350:	b3 14       	cp	r11, r3
    2352:	10 f4       	brcc	.+4      	; 0x2358 <vfprintf+0x326>
    2354:	3b 18       	sub	r3, r11
    2356:	01 c0       	rjmp	.+2      	; 0x235a <vfprintf+0x328>
    2358:	31 2c       	mov	r3, r1
    235a:	34 ff       	sbrs	r19, 4
    235c:	11 c0       	rjmp	.+34     	; 0x2380 <vfprintf+0x34e>
    235e:	b7 01       	movw	r22, r14
    2360:	80 e3       	ldi	r24, 0x30	; 48
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	3c 87       	std	Y+12, r19	; 0x0c
    2366:	69 d0       	rcall	.+210    	; 0x243a <fputc>
    2368:	3c 85       	ldd	r19, Y+12	; 0x0c
    236a:	32 ff       	sbrs	r19, 2
    236c:	16 c0       	rjmp	.+44     	; 0x239a <vfprintf+0x368>
    236e:	31 fd       	sbrc	r19, 1
    2370:	03 c0       	rjmp	.+6      	; 0x2378 <vfprintf+0x346>
    2372:	88 e7       	ldi	r24, 0x78	; 120
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	02 c0       	rjmp	.+4      	; 0x237c <vfprintf+0x34a>
    2378:	88 e5       	ldi	r24, 0x58	; 88
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	b7 01       	movw	r22, r14
    237e:	0c c0       	rjmp	.+24     	; 0x2398 <vfprintf+0x366>
    2380:	83 2f       	mov	r24, r19
    2382:	86 78       	andi	r24, 0x86	; 134
    2384:	51 f0       	breq	.+20     	; 0x239a <vfprintf+0x368>
    2386:	31 ff       	sbrs	r19, 1
    2388:	02 c0       	rjmp	.+4      	; 0x238e <vfprintf+0x35c>
    238a:	8b e2       	ldi	r24, 0x2B	; 43
    238c:	01 c0       	rjmp	.+2      	; 0x2390 <vfprintf+0x35e>
    238e:	80 e2       	ldi	r24, 0x20	; 32
    2390:	37 fd       	sbrc	r19, 7
    2392:	8d e2       	ldi	r24, 0x2D	; 45
    2394:	b7 01       	movw	r22, r14
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	50 d0       	rcall	.+160    	; 0x243a <fputc>
    239a:	a5 14       	cp	r10, r5
    239c:	30 f4       	brcc	.+12     	; 0x23aa <vfprintf+0x378>
    239e:	b7 01       	movw	r22, r14
    23a0:	80 e3       	ldi	r24, 0x30	; 48
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	4a d0       	rcall	.+148    	; 0x243a <fputc>
    23a6:	5a 94       	dec	r5
    23a8:	f8 cf       	rjmp	.-16     	; 0x239a <vfprintf+0x368>
    23aa:	aa 94       	dec	r10
    23ac:	f4 01       	movw	r30, r8
    23ae:	ea 0d       	add	r30, r10
    23b0:	f1 1d       	adc	r31, r1
    23b2:	80 81       	ld	r24, Z
    23b4:	b7 01       	movw	r22, r14
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	40 d0       	rcall	.+128    	; 0x243a <fputc>
    23ba:	a1 10       	cpse	r10, r1
    23bc:	f6 cf       	rjmp	.-20     	; 0x23aa <vfprintf+0x378>
    23be:	33 20       	and	r3, r3
    23c0:	09 f4       	brne	.+2      	; 0x23c4 <vfprintf+0x392>
    23c2:	5d ce       	rjmp	.-838    	; 0x207e <vfprintf+0x4c>
    23c4:	b7 01       	movw	r22, r14
    23c6:	80 e2       	ldi	r24, 0x20	; 32
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	37 d0       	rcall	.+110    	; 0x243a <fputc>
    23cc:	3a 94       	dec	r3
    23ce:	f7 cf       	rjmp	.-18     	; 0x23be <vfprintf+0x38c>
    23d0:	f7 01       	movw	r30, r14
    23d2:	86 81       	ldd	r24, Z+6	; 0x06
    23d4:	97 81       	ldd	r25, Z+7	; 0x07
    23d6:	02 c0       	rjmp	.+4      	; 0x23dc <vfprintf+0x3aa>
    23d8:	8f ef       	ldi	r24, 0xFF	; 255
    23da:	9f ef       	ldi	r25, 0xFF	; 255
    23dc:	2c 96       	adiw	r28, 0x0c	; 12
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	de bf       	out	0x3e, r29	; 62
    23e4:	0f be       	out	0x3f, r0	; 63
    23e6:	cd bf       	out	0x3d, r28	; 61
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	ff 90       	pop	r15
    23f2:	ef 90       	pop	r14
    23f4:	df 90       	pop	r13
    23f6:	cf 90       	pop	r12
    23f8:	bf 90       	pop	r11
    23fa:	af 90       	pop	r10
    23fc:	9f 90       	pop	r9
    23fe:	8f 90       	pop	r8
    2400:	7f 90       	pop	r7
    2402:	6f 90       	pop	r6
    2404:	5f 90       	pop	r5
    2406:	4f 90       	pop	r4
    2408:	3f 90       	pop	r3
    240a:	2f 90       	pop	r2
    240c:	08 95       	ret

0000240e <strnlen_P>:
    240e:	fc 01       	movw	r30, r24
    2410:	05 90       	lpm	r0, Z+
    2412:	61 50       	subi	r22, 0x01	; 1
    2414:	70 40       	sbci	r23, 0x00	; 0
    2416:	01 10       	cpse	r0, r1
    2418:	d8 f7       	brcc	.-10     	; 0x2410 <strnlen_P+0x2>
    241a:	80 95       	com	r24
    241c:	90 95       	com	r25
    241e:	8e 0f       	add	r24, r30
    2420:	9f 1f       	adc	r25, r31
    2422:	08 95       	ret

00002424 <strnlen>:
    2424:	fc 01       	movw	r30, r24
    2426:	61 50       	subi	r22, 0x01	; 1
    2428:	70 40       	sbci	r23, 0x00	; 0
    242a:	01 90       	ld	r0, Z+
    242c:	01 10       	cpse	r0, r1
    242e:	d8 f7       	brcc	.-10     	; 0x2426 <strnlen+0x2>
    2430:	80 95       	com	r24
    2432:	90 95       	com	r25
    2434:	8e 0f       	add	r24, r30
    2436:	9f 1f       	adc	r25, r31
    2438:	08 95       	ret

0000243a <fputc>:
    243a:	0f 93       	push	r16
    243c:	1f 93       	push	r17
    243e:	cf 93       	push	r28
    2440:	df 93       	push	r29
    2442:	fb 01       	movw	r30, r22
    2444:	23 81       	ldd	r18, Z+3	; 0x03
    2446:	21 fd       	sbrc	r18, 1
    2448:	03 c0       	rjmp	.+6      	; 0x2450 <fputc+0x16>
    244a:	8f ef       	ldi	r24, 0xFF	; 255
    244c:	9f ef       	ldi	r25, 0xFF	; 255
    244e:	28 c0       	rjmp	.+80     	; 0x24a0 <fputc+0x66>
    2450:	22 ff       	sbrs	r18, 2
    2452:	16 c0       	rjmp	.+44     	; 0x2480 <fputc+0x46>
    2454:	46 81       	ldd	r20, Z+6	; 0x06
    2456:	57 81       	ldd	r21, Z+7	; 0x07
    2458:	24 81       	ldd	r18, Z+4	; 0x04
    245a:	35 81       	ldd	r19, Z+5	; 0x05
    245c:	42 17       	cp	r20, r18
    245e:	53 07       	cpc	r21, r19
    2460:	44 f4       	brge	.+16     	; 0x2472 <fputc+0x38>
    2462:	a0 81       	ld	r26, Z
    2464:	b1 81       	ldd	r27, Z+1	; 0x01
    2466:	9d 01       	movw	r18, r26
    2468:	2f 5f       	subi	r18, 0xFF	; 255
    246a:	3f 4f       	sbci	r19, 0xFF	; 255
    246c:	31 83       	std	Z+1, r19	; 0x01
    246e:	20 83       	st	Z, r18
    2470:	8c 93       	st	X, r24
    2472:	26 81       	ldd	r18, Z+6	; 0x06
    2474:	37 81       	ldd	r19, Z+7	; 0x07
    2476:	2f 5f       	subi	r18, 0xFF	; 255
    2478:	3f 4f       	sbci	r19, 0xFF	; 255
    247a:	37 83       	std	Z+7, r19	; 0x07
    247c:	26 83       	std	Z+6, r18	; 0x06
    247e:	10 c0       	rjmp	.+32     	; 0x24a0 <fputc+0x66>
    2480:	eb 01       	movw	r28, r22
    2482:	09 2f       	mov	r16, r25
    2484:	18 2f       	mov	r17, r24
    2486:	00 84       	ldd	r0, Z+8	; 0x08
    2488:	f1 85       	ldd	r31, Z+9	; 0x09
    248a:	e0 2d       	mov	r30, r0
    248c:	09 95       	icall
    248e:	89 2b       	or	r24, r25
    2490:	e1 f6       	brne	.-72     	; 0x244a <fputc+0x10>
    2492:	8e 81       	ldd	r24, Y+6	; 0x06
    2494:	9f 81       	ldd	r25, Y+7	; 0x07
    2496:	01 96       	adiw	r24, 0x01	; 1
    2498:	9f 83       	std	Y+7, r25	; 0x07
    249a:	8e 83       	std	Y+6, r24	; 0x06
    249c:	81 2f       	mov	r24, r17
    249e:	90 2f       	mov	r25, r16
    24a0:	df 91       	pop	r29
    24a2:	cf 91       	pop	r28
    24a4:	1f 91       	pop	r17
    24a6:	0f 91       	pop	r16
    24a8:	08 95       	ret

000024aa <__ultoa_invert>:
    24aa:	fa 01       	movw	r30, r20
    24ac:	aa 27       	eor	r26, r26
    24ae:	28 30       	cpi	r18, 0x08	; 8
    24b0:	51 f1       	breq	.+84     	; 0x2506 <__ultoa_invert+0x5c>
    24b2:	20 31       	cpi	r18, 0x10	; 16
    24b4:	81 f1       	breq	.+96     	; 0x2516 <__ultoa_invert+0x6c>
    24b6:	e8 94       	clt
    24b8:	6f 93       	push	r22
    24ba:	6e 7f       	andi	r22, 0xFE	; 254
    24bc:	6e 5f       	subi	r22, 0xFE	; 254
    24be:	7f 4f       	sbci	r23, 0xFF	; 255
    24c0:	8f 4f       	sbci	r24, 0xFF	; 255
    24c2:	9f 4f       	sbci	r25, 0xFF	; 255
    24c4:	af 4f       	sbci	r26, 0xFF	; 255
    24c6:	b1 e0       	ldi	r27, 0x01	; 1
    24c8:	3e d0       	rcall	.+124    	; 0x2546 <__ultoa_invert+0x9c>
    24ca:	b4 e0       	ldi	r27, 0x04	; 4
    24cc:	3c d0       	rcall	.+120    	; 0x2546 <__ultoa_invert+0x9c>
    24ce:	67 0f       	add	r22, r23
    24d0:	78 1f       	adc	r23, r24
    24d2:	89 1f       	adc	r24, r25
    24d4:	9a 1f       	adc	r25, r26
    24d6:	a1 1d       	adc	r26, r1
    24d8:	68 0f       	add	r22, r24
    24da:	79 1f       	adc	r23, r25
    24dc:	8a 1f       	adc	r24, r26
    24de:	91 1d       	adc	r25, r1
    24e0:	a1 1d       	adc	r26, r1
    24e2:	6a 0f       	add	r22, r26
    24e4:	71 1d       	adc	r23, r1
    24e6:	81 1d       	adc	r24, r1
    24e8:	91 1d       	adc	r25, r1
    24ea:	a1 1d       	adc	r26, r1
    24ec:	20 d0       	rcall	.+64     	; 0x252e <__ultoa_invert+0x84>
    24ee:	09 f4       	brne	.+2      	; 0x24f2 <__ultoa_invert+0x48>
    24f0:	68 94       	set
    24f2:	3f 91       	pop	r19
    24f4:	2a e0       	ldi	r18, 0x0A	; 10
    24f6:	26 9f       	mul	r18, r22
    24f8:	11 24       	eor	r1, r1
    24fa:	30 19       	sub	r19, r0
    24fc:	30 5d       	subi	r19, 0xD0	; 208
    24fe:	31 93       	st	Z+, r19
    2500:	de f6       	brtc	.-74     	; 0x24b8 <__ultoa_invert+0xe>
    2502:	cf 01       	movw	r24, r30
    2504:	08 95       	ret
    2506:	46 2f       	mov	r20, r22
    2508:	47 70       	andi	r20, 0x07	; 7
    250a:	40 5d       	subi	r20, 0xD0	; 208
    250c:	41 93       	st	Z+, r20
    250e:	b3 e0       	ldi	r27, 0x03	; 3
    2510:	0f d0       	rcall	.+30     	; 0x2530 <__ultoa_invert+0x86>
    2512:	c9 f7       	brne	.-14     	; 0x2506 <__ultoa_invert+0x5c>
    2514:	f6 cf       	rjmp	.-20     	; 0x2502 <__ultoa_invert+0x58>
    2516:	46 2f       	mov	r20, r22
    2518:	4f 70       	andi	r20, 0x0F	; 15
    251a:	40 5d       	subi	r20, 0xD0	; 208
    251c:	4a 33       	cpi	r20, 0x3A	; 58
    251e:	18 f0       	brcs	.+6      	; 0x2526 <__ultoa_invert+0x7c>
    2520:	49 5d       	subi	r20, 0xD9	; 217
    2522:	31 fd       	sbrc	r19, 1
    2524:	40 52       	subi	r20, 0x20	; 32
    2526:	41 93       	st	Z+, r20
    2528:	02 d0       	rcall	.+4      	; 0x252e <__ultoa_invert+0x84>
    252a:	a9 f7       	brne	.-22     	; 0x2516 <__ultoa_invert+0x6c>
    252c:	ea cf       	rjmp	.-44     	; 0x2502 <__ultoa_invert+0x58>
    252e:	b4 e0       	ldi	r27, 0x04	; 4
    2530:	a6 95       	lsr	r26
    2532:	97 95       	ror	r25
    2534:	87 95       	ror	r24
    2536:	77 95       	ror	r23
    2538:	67 95       	ror	r22
    253a:	ba 95       	dec	r27
    253c:	c9 f7       	brne	.-14     	; 0x2530 <__ultoa_invert+0x86>
    253e:	00 97       	sbiw	r24, 0x00	; 0
    2540:	61 05       	cpc	r22, r1
    2542:	71 05       	cpc	r23, r1
    2544:	08 95       	ret
    2546:	9b 01       	movw	r18, r22
    2548:	ac 01       	movw	r20, r24
    254a:	0a 2e       	mov	r0, r26
    254c:	06 94       	lsr	r0
    254e:	57 95       	ror	r21
    2550:	47 95       	ror	r20
    2552:	37 95       	ror	r19
    2554:	27 95       	ror	r18
    2556:	ba 95       	dec	r27
    2558:	c9 f7       	brne	.-14     	; 0x254c <__ultoa_invert+0xa2>
    255a:	62 0f       	add	r22, r18
    255c:	73 1f       	adc	r23, r19
    255e:	84 1f       	adc	r24, r20
    2560:	95 1f       	adc	r25, r21
    2562:	a0 1d       	adc	r26, r0
    2564:	08 95       	ret

00002566 <eeprom_read_word>:
    2566:	a8 e1       	ldi	r26, 0x18	; 24
    2568:	b0 e0       	ldi	r27, 0x00	; 0
    256a:	42 e0       	ldi	r20, 0x02	; 2
    256c:	50 e0       	ldi	r21, 0x00	; 0
    256e:	02 c0       	rjmp	.+4      	; 0x2574 <eeprom_read_blraw>

00002570 <eeprom_read_block>:
    2570:	dc 01       	movw	r26, r24
    2572:	cb 01       	movw	r24, r22

00002574 <eeprom_read_blraw>:
    2574:	fc 01       	movw	r30, r24
    2576:	f9 99       	sbic	0x1f, 1	; 31
    2578:	fe cf       	rjmp	.-4      	; 0x2576 <eeprom_read_blraw+0x2>
    257a:	06 c0       	rjmp	.+12     	; 0x2588 <eeprom_read_blraw+0x14>
    257c:	f2 bd       	out	0x22, r31	; 34
    257e:	e1 bd       	out	0x21, r30	; 33
    2580:	f8 9a       	sbi	0x1f, 0	; 31
    2582:	31 96       	adiw	r30, 0x01	; 1
    2584:	00 b4       	in	r0, 0x20	; 32
    2586:	0d 92       	st	X+, r0
    2588:	41 50       	subi	r20, 0x01	; 1
    258a:	50 40       	sbci	r21, 0x00	; 0
    258c:	b8 f7       	brcc	.-18     	; 0x257c <eeprom_read_blraw+0x8>
    258e:	08 95       	ret

00002590 <_exit>:
    2590:	f8 94       	cli

00002592 <__stop_program>:
    2592:	ff cf       	rjmp	.-2      	; 0x2592 <__stop_program>
