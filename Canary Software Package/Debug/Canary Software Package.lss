
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800100  00000b7a  00000c0e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b7a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000037d  00800132  00800132  00000c40  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00000c40  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c9c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001b0  00000000  00000000  00000cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000023e6  00000000  00000000  00000e8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011a9  00000000  00000000  00003272  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f46  00000000  00000000  0000441b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000384  00000000  00000000  00005364  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000928  00000000  00000000  000056e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000093c  00000000  00000000  00006010  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  0000694c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	8e c0       	rjmp	.+284    	; 0x11e <__ctors_end>
   2:	00 00       	nop
   4:	a7 c0       	rjmp	.+334    	; 0x154 <__bad_interrupt>
   6:	00 00       	nop
   8:	a5 c0       	rjmp	.+330    	; 0x154 <__bad_interrupt>
   a:	00 00       	nop
   c:	a3 c0       	rjmp	.+326    	; 0x154 <__bad_interrupt>
   e:	00 00       	nop
  10:	a1 c0       	rjmp	.+322    	; 0x154 <__bad_interrupt>
  12:	00 00       	nop
  14:	9f c0       	rjmp	.+318    	; 0x154 <__bad_interrupt>
  16:	00 00       	nop
  18:	9d c0       	rjmp	.+314    	; 0x154 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	9b c0       	rjmp	.+310    	; 0x154 <__bad_interrupt>
  1e:	00 00       	nop
  20:	99 c0       	rjmp	.+306    	; 0x154 <__bad_interrupt>
  22:	00 00       	nop
  24:	97 c0       	rjmp	.+302    	; 0x154 <__bad_interrupt>
  26:	00 00       	nop
  28:	95 c0       	rjmp	.+298    	; 0x154 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	93 c0       	rjmp	.+294    	; 0x154 <__bad_interrupt>
  2e:	00 00       	nop
  30:	91 c0       	rjmp	.+290    	; 0x154 <__bad_interrupt>
  32:	00 00       	nop
  34:	46 c1       	rjmp	.+652    	; 0x2c2 <__vector_13>
  36:	00 00       	nop
  38:	8d c0       	rjmp	.+282    	; 0x154 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	8b c0       	rjmp	.+278    	; 0x154 <__bad_interrupt>
  3e:	00 00       	nop
  40:	3f c1       	rjmp	.+638    	; 0x2c0 <__vector_16>
  42:	00 00       	nop
  44:	87 c0       	rjmp	.+270    	; 0x154 <__bad_interrupt>
  46:	00 00       	nop
  48:	85 c0       	rjmp	.+266    	; 0x154 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	83 c0       	rjmp	.+262    	; 0x154 <__bad_interrupt>
  4e:	00 00       	nop
  50:	81 c0       	rjmp	.+258    	; 0x154 <__bad_interrupt>
  52:	00 00       	nop
  54:	4d c2       	rjmp	.+1178   	; 0x4f0 <__vector_21>
  56:	00 00       	nop
  58:	7d c0       	rjmp	.+250    	; 0x154 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	7b c0       	rjmp	.+246    	; 0x154 <__bad_interrupt>
  5e:	00 00       	nop
  60:	79 c0       	rjmp	.+242    	; 0x154 <__bad_interrupt>
  62:	00 00       	nop
  64:	77 c0       	rjmp	.+238    	; 0x154 <__bad_interrupt>
  66:	00 00       	nop
  68:	9a c1       	rjmp	.+820    	; 0x39e <__vector_26>
  6a:	00 00       	nop
  6c:	73 c0       	rjmp	.+230    	; 0x154 <__bad_interrupt>
  6e:	00 00       	nop
  70:	68 c2       	rjmp	.+1232   	; 0x542 <__vector_28>
  72:	00 00       	nop
  74:	85 c2       	rjmp	.+1290   	; 0x580 <__vector_29>
  76:	00 00       	nop
  78:	6d c0       	rjmp	.+218    	; 0x154 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	e9 01       	movw	r28, r18
  7e:	3b 02       	muls	r19, r27
  80:	3b 02       	muls	r19, r27
  82:	3b 02       	muls	r19, r27
  84:	3b 02       	muls	r19, r27
  86:	3b 02       	muls	r19, r27
  88:	3b 02       	muls	r19, r27
  8a:	3b 02       	muls	r19, r27
  8c:	e9 01       	movw	r28, r18
  8e:	3b 02       	muls	r19, r27
  90:	3b 02       	muls	r19, r27
  92:	3b 02       	muls	r19, r27
  94:	3b 02       	muls	r19, r27
  96:	3b 02       	muls	r19, r27
  98:	3b 02       	muls	r19, r27
  9a:	3b 02       	muls	r19, r27
  9c:	eb 01       	movw	r28, r22
  9e:	3b 02       	muls	r19, r27
  a0:	3b 02       	muls	r19, r27
  a2:	3b 02       	muls	r19, r27
  a4:	3b 02       	muls	r19, r27
  a6:	3b 02       	muls	r19, r27
  a8:	3b 02       	muls	r19, r27
  aa:	3b 02       	muls	r19, r27
  ac:	3b 02       	muls	r19, r27
  ae:	3b 02       	muls	r19, r27
  b0:	3b 02       	muls	r19, r27
  b2:	3b 02       	muls	r19, r27
  b4:	3b 02       	muls	r19, r27
  b6:	3b 02       	muls	r19, r27
  b8:	3b 02       	muls	r19, r27
  ba:	3b 02       	muls	r19, r27
  bc:	eb 01       	movw	r28, r22
  be:	3b 02       	muls	r19, r27
  c0:	3b 02       	muls	r19, r27
  c2:	3b 02       	muls	r19, r27
  c4:	3b 02       	muls	r19, r27
  c6:	3b 02       	muls	r19, r27
  c8:	3b 02       	muls	r19, r27
  ca:	3b 02       	muls	r19, r27
  cc:	3b 02       	muls	r19, r27
  ce:	3b 02       	muls	r19, r27
  d0:	3b 02       	muls	r19, r27
  d2:	3b 02       	muls	r19, r27
  d4:	3b 02       	muls	r19, r27
  d6:	3b 02       	muls	r19, r27
  d8:	3b 02       	muls	r19, r27
  da:	3b 02       	muls	r19, r27
  dc:	37 02       	muls	r19, r23
  de:	3b 02       	muls	r19, r27
  e0:	3b 02       	muls	r19, r27
  e2:	3b 02       	muls	r19, r27
  e4:	3b 02       	muls	r19, r27
  e6:	3b 02       	muls	r19, r27
  e8:	3b 02       	muls	r19, r27
  ea:	3b 02       	muls	r19, r27
  ec:	14 02       	muls	r17, r20
  ee:	3b 02       	muls	r19, r27
  f0:	3b 02       	muls	r19, r27
  f2:	3b 02       	muls	r19, r27
  f4:	3b 02       	muls	r19, r27
  f6:	3b 02       	muls	r19, r27
  f8:	3b 02       	muls	r19, r27
  fa:	3b 02       	muls	r19, r27
  fc:	3b 02       	muls	r19, r27
  fe:	3b 02       	muls	r19, r27
 100:	3b 02       	muls	r19, r27
 102:	3b 02       	muls	r19, r27
 104:	3b 02       	muls	r19, r27
 106:	3b 02       	muls	r19, r27
 108:	3b 02       	muls	r19, r27
 10a:	3b 02       	muls	r19, r27
 10c:	08 02       	muls	r16, r24
 10e:	3b 02       	muls	r19, r27
 110:	3b 02       	muls	r19, r27
 112:	3b 02       	muls	r19, r27
 114:	3b 02       	muls	r19, r27
 116:	3b 02       	muls	r19, r27
 118:	3b 02       	muls	r19, r27
 11a:	3b 02       	muls	r19, r27
 11c:	26 02       	muls	r18, r22

0000011e <__ctors_end>:
 11e:	11 24       	eor	r1, r1
 120:	1f be       	out	0x3f, r1	; 63
 122:	cf ef       	ldi	r28, 0xFF	; 255
 124:	d8 e0       	ldi	r29, 0x08	; 8
 126:	de bf       	out	0x3e, r29	; 62
 128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
 12a:	11 e0       	ldi	r17, 0x01	; 1
 12c:	a0 e0       	ldi	r26, 0x00	; 0
 12e:	b1 e0       	ldi	r27, 0x01	; 1
 130:	ea e7       	ldi	r30, 0x7A	; 122
 132:	fb e0       	ldi	r31, 0x0B	; 11
 134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
 136:	05 90       	lpm	r0, Z+
 138:	0d 92       	st	X+, r0
 13a:	a2 33       	cpi	r26, 0x32	; 50
 13c:	b1 07       	cpc	r27, r17
 13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
 140:	24 e0       	ldi	r18, 0x04	; 4
 142:	a2 e3       	ldi	r26, 0x32	; 50
 144:	b1 e0       	ldi	r27, 0x01	; 1
 146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
 148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
 14a:	af 3a       	cpi	r26, 0xAF	; 175
 14c:	b2 07       	cpc	r27, r18
 14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
 150:	68 d0       	rcall	.+208    	; 0x222 <main>
 152:	11 c5       	rjmp	.+2594   	; 0xb76 <_exit>

00000154 <__bad_interrupt>:
 154:	55 cf       	rjmp	.-342    	; 0x0 <__vectors>

00000156 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
 156:	87 e0       	ldi	r24, 0x07	; 7
 158:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
 15a:	85 b1       	in	r24, 0x05	; 5
 15c:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
 15e:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
 160:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
 162:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
 164:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
 166:	41 9a       	sbi	0x08, 1	; 8
 168:	08 95       	ret

0000016a <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
 16a:	1f 93       	push	r17
 16c:	cf 93       	push	r28
 16e:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
 170:	e4 e9       	ldi	r30, 0x94	; 148
 172:	f4 e0       	ldi	r31, 0x04	; 4
 174:	84 ec       	ldi	r24, 0xC4	; 196
 176:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
 178:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
 17a:	84 e0       	ldi	r24, 0x04	; 4
 17c:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
 17e:	63 e0       	ldi	r22, 0x03	; 3
 180:	cf 01       	movw	r24, r30
 182:	c2 d0       	rcall	.+388    	; 0x308 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
 184:	bd d0       	rcall	.+378    	; 0x300 <TWI_Transceiver_Busy>
 186:	81 11       	cpse	r24, r1
 188:	fd cf       	rjmp	.-6      	; 0x184 <LIDAR_distance+0x1a>
 18a:	e4 e9       	ldi	r30, 0x94	; 148
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
 18c:	f4 e0       	ldi	r31, 0x04	; 4
 18e:	84 ec       	ldi	r24, 0xC4	; 196
 190:	80 83       	st	Z, r24
 192:	81 e0       	ldi	r24, 0x01	; 1
	messageBuf[1] = 0x01; // Select register 0x01
 194:	81 83       	std	Z+1, r24	; 0x01
 196:	62 e0       	ldi	r22, 0x02	; 2
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
 198:	cf 01       	movw	r24, r30
 19a:	b6 d0       	rcall	.+364    	; 0x308 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
 19c:	b1 d0       	rcall	.+354    	; 0x300 <TWI_Transceiver_Busy>
 19e:	81 11       	cpse	r24, r1
 1a0:	fd cf       	rjmp	.-6      	; 0x19c <LIDAR_distance+0x32>
 1a2:	c4 e9       	ldi	r28, 0x94	; 148
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
 1a4:	d4 e0       	ldi	r29, 0x04	; 4
 1a6:	15 ec       	ldi	r17, 0xC5	; 197
 1a8:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
 1aa:	19 82       	std	Y+1, r1	; 0x01
 1ac:	62 e0       	ldi	r22, 0x02	; 2
 1ae:	ce 01       	movw	r24, r28
 1b0:	ab d0       	rcall	.+342    	; 0x308 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
 1b2:	a6 d0       	rcall	.+332    	; 0x300 <TWI_Transceiver_Busy>
 1b4:	81 11       	cpse	r24, r1
 1b6:	fd cf       	rjmp	.-6      	; 0x1b2 <LIDAR_distance+0x48>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
 1b8:	62 e0       	ldi	r22, 0x02	; 2
 1ba:	ce 01       	movw	r24, r28
 1bc:	d1 d0       	rcall	.+418    	; 0x360 <TWI_Get_Data_From_Transceiver>
 1be:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <TWI_XFER_STATUS>
 1c2:	89 81       	ldd	r24, Y+1	; 0x01
		testing = messageBuf[1]; //This is here for debug purposes
 1c4:	80 93 a5 04 	sts	0x04A5, r24	; 0x8004a5 <testing>
 1c8:	80 fd       	sbrc	r24, 0
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
 1ca:	ee cf       	rjmp	.-36     	; 0x1a8 <LIDAR_distance+0x3e>
 1cc:	e4 e9       	ldi	r30, 0x94	; 148
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
 1ce:	f4 e0       	ldi	r31, 0x04	; 4
 1d0:	84 ec       	ldi	r24, 0xC4	; 196
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
 1d2:	80 83       	st	Z, r24
 1d4:	8f e8       	ldi	r24, 0x8F	; 143
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
 1d6:	81 83       	std	Z+1, r24	; 0x01
 1d8:	62 e0       	ldi	r22, 0x02	; 2
 1da:	cf 01       	movw	r24, r30
 1dc:	95 d0       	rcall	.+298    	; 0x308 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
 1de:	90 d0       	rcall	.+288    	; 0x300 <TWI_Transceiver_Busy>
 1e0:	81 11       	cpse	r24, r1
 1e2:	fd cf       	rjmp	.-6      	; 0x1de <LIDAR_distance+0x74>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
 1e4:	e4 e9       	ldi	r30, 0x94	; 148
 1e6:	f4 e0       	ldi	r31, 0x04	; 4
 1e8:	85 ec       	ldi	r24, 0xC5	; 197
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
 1ea:	80 83       	st	Z, r24
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
 1ec:	11 82       	std	Z+1, r1	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
 1ee:	12 82       	std	Z+2, r1	; 0x02
 1f0:	63 e0       	ldi	r22, 0x03	; 3
 1f2:	cf 01       	movw	r24, r30
	while ( TWI_Transceiver_Busy() );	
 1f4:	89 d0       	rcall	.+274    	; 0x308 <TWI_Start_Transceiver_With_Data>
 1f6:	84 d0       	rcall	.+264    	; 0x300 <TWI_Transceiver_Busy>
 1f8:	81 11       	cpse	r24, r1
 1fa:	fd cf       	rjmp	.-6      	; 0x1f6 <LIDAR_distance+0x8c>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
 1fc:	63 e0       	ldi	r22, 0x03	; 3
 1fe:	84 e9       	ldi	r24, 0x94	; 148
 200:	94 e0       	ldi	r25, 0x04	; 4
 202:	ae d0       	rcall	.+348    	; 0x360 <TWI_Get_Data_From_Transceiver>
 204:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <TWI_XFER_STATUS>
 208:	e4 e9       	ldi	r30, 0x94	; 148
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
 20a:	f4 e0       	ldi	r31, 0x04	; 4
 20c:	81 81       	ldd	r24, Z+1	; 0x01
	// That's all, folks...
	return(Ldistance);
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	98 2f       	mov	r25, r24
 212:	88 27       	eor	r24, r24
 214:	22 81       	ldd	r18, Z+2	; 0x02
 216:	82 0f       	add	r24, r18
}
 218:	91 1d       	adc	r25, r1
 21a:	df 91       	pop	r29
 21c:	cf 91       	pop	r28
 21e:	1f 91       	pop	r17
 220:	08 95       	ret

00000222 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
 222:	99 df       	rcall	.-206    	; 0x156 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
 224:	10 92 a8 04 	sts	0x04A8, r1	; 0x8004a8 <seconds+0x1>
 228:	10 92 a7 04 	sts	0x04A7, r1	; 0x8004a7 <seconds>
	ItsTime=0;
 22c:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
 230:	80 e0       	ldi	r24, 0x00	; 0
 232:	91 e0       	ldi	r25, 0x01	; 1
 234:	90 93 ac 04 	sts	0x04AC, r25	; 0x8004ac <__iob+0x3>
 238:	80 93 ab 04 	sts	0x04AB, r24	; 0x8004ab <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
 23c:	34 d0       	rcall	.+104    	; 0x2a6 <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
 23e:	83 e0       	ldi	r24, 0x03	; 3
 240:	91 e0       	ldi	r25, 0x01	; 1
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
 242:	2d d1       	rcall	.+602    	; 0x49e <USART0_init>
 244:	53 d0       	rcall	.+166    	; 0x2ec <TWI_Master_Initialise>
	//
 	// initialize the gas sensors
	//gas_sensors_init();
	// 
	// Start all interrupts
	sei();
 246:	78 94       	sei
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
 248:	0f e0       	ldi	r16, 0x0F	; 15
 24a:	11 e0       	ldi	r17, 0x01	; 1
			//============================
	*/		//
			//============================
			// Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
 24c:	cd e1       	ldi	r28, 0x1D	; 29
 24e:	d1 e0       	ldi	r29, 0x01	; 1
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////////
		//
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		if (ItsTime == 1){ //wait for our 1Hz flag
 250:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <ItsTime>
 254:	81 30       	cpi	r24, 0x01	; 1
 256:	e1 f7       	brne	.-8      	; 0x250 <main+0x2e>
			ItsTime = 0; 
 258:	10 92 62 04 	sts	0x0462, r1	; 0x800462 <ItsTime>
			seconds++;
 25c:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <seconds>
 260:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <seconds+0x1>
 264:	01 96       	adiw	r24, 0x01	; 1
 266:	90 93 a8 04 	sts	0x04A8, r25	; 0x8004a8 <seconds+0x1>
 26a:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <seconds>
			printf("\nSeconds = %u", seconds);
 26e:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <seconds>
 272:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <seconds+0x1>
 276:	9f 93       	push	r25
 278:	8f 93       	push	r24
 27a:	1f 93       	push	r17
 27c:	0f 93       	push	r16
			printf("\n=================");
			//============================
	*/		//
			//============================
			// Now test reading the LIDAR interface
			distance = LIDAR_distance();
 27e:	e6 d1       	rcall	.+972    	; 0x64c <printf>
 280:	74 df       	rcall	.-280    	; 0x16a <LIDAR_distance>
 282:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <distance>
 286:	90 93 7d 04 	sts	0x047D, r25	; 0x80047d <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
 28a:	9f 93       	push	r25
 28c:	8f 93       	push	r24
 28e:	df 93       	push	r29
 290:	cf 93       	push	r28
 292:	dc d1       	rcall	.+952    	; 0x64c <printf>
 294:	8d b7       	in	r24, 0x3d	; 61
 296:	9e b7       	in	r25, 0x3e	; 62
 298:	08 96       	adiw	r24, 0x08	; 8
 29a:	0f b6       	in	r0, 0x3f	; 63
 29c:	f8 94       	cli
 29e:	9e bf       	out	0x3e, r25	; 62
 2a0:	0f be       	out	0x3f, r0	; 63
 2a2:	8d bf       	out	0x3d, r24	; 61
 2a4:	d5 cf       	rjmp	.-86     	; 0x250 <main+0x2e>

000002a6 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
 2a6:	8d e0       	ldi	r24, 0x0D	; 13
 2a8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
 2ac:	8a e4       	ldi	r24, 0x4A	; 74
 2ae:	9c e4       	ldi	r25, 0x4C	; 76
 2b0:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 2b4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
 2b8:	82 e0       	ldi	r24, 0x02	; 2
 2ba:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 2be:	08 95       	ret

000002c0 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
 2c0:	18 95       	reti

000002c2 <__vector_13>:
}
*/


ISR(TIMER1_COMPA_vect)
{
 2c2:	1f 92       	push	r1
 2c4:	0f 92       	push	r0
 2c6:	0f b6       	in	r0, 0x3f	; 63
 2c8:	0f 92       	push	r0
 2ca:	11 24       	eor	r1, r1
 2cc:	8f 93       	push	r24
 2ce:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
 2d0:	95 b1       	in	r25, 0x05	; 5
 2d2:	82 e0       	ldi	r24, 0x02	; 2
 2d4:	89 27       	eor	r24, r25
 2d6:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
 2d8:	81 e0       	ldi	r24, 0x01	; 1
 2da:	80 93 62 04 	sts	0x0462, r24	; 0x800462 <ItsTime>
}
 2de:	9f 91       	pop	r25
 2e0:	8f 91       	pop	r24
 2e2:	0f 90       	pop	r0
 2e4:	0f be       	out	0x3f, r0	; 63
 2e6:	0f 90       	pop	r0
 2e8:	1f 90       	pop	r1
 2ea:	18 95       	reti

000002ec <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 2ec:	81 e1       	ldi	r24, 0x11	; 17
 2ee:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
 2f2:	8f ef       	ldi	r24, 0xFF	; 255
 2f4:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 2f8:	84 e0       	ldi	r24, 0x04	; 4
 2fa:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 2fe:	08 95       	ret

00000300 <TWI_Transceiver_Busy>:
 300:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 304:	81 78       	andi	r24, 0x81	; 129
 306:	08 95       	ret

00000308 <TWI_Start_Transceiver_With_Data>:
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
 30c:	ec 01       	movw	r28, r24
 30e:	ec eb       	ldi	r30, 0xBC	; 188
 310:	f0 e0       	ldi	r31, 0x00	; 0
 312:	90 81       	ld	r25, Z
 314:	91 78       	andi	r25, 0x81	; 129
 316:	e9 f7       	brne	.-6      	; 0x312 <TWI_Start_Transceiver_With_Data+0xa>
 318:	60 93 34 01 	sts	0x0134, r22	; 0x800134 <TWI_msgSize>
 31c:	88 81       	ld	r24, Y
 31e:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <TWI_buf>
 322:	80 fd       	sbrc	r24, 0
 324:	12 c0       	rjmp	.+36     	; 0x34a <TWI_Start_Transceiver_With_Data+0x42>
 326:	62 30       	cpi	r22, 0x02	; 2
 328:	80 f0       	brcs	.+32     	; 0x34a <TWI_Start_Transceiver_With_Data+0x42>
 32a:	fe 01       	movw	r30, r28
 32c:	31 96       	adiw	r30, 0x01	; 1
 32e:	a6 e3       	ldi	r26, 0x36	; 54
 330:	b1 e0       	ldi	r27, 0x01	; 1
 332:	62 50       	subi	r22, 0x02	; 2
 334:	26 2f       	mov	r18, r22
 336:	30 e0       	ldi	r19, 0x00	; 0
 338:	2e 5f       	subi	r18, 0xFE	; 254
 33a:	3f 4f       	sbci	r19, 0xFF	; 255
 33c:	2c 0f       	add	r18, r28
 33e:	3d 1f       	adc	r19, r29
 340:	91 91       	ld	r25, Z+
 342:	9d 93       	st	X+, r25
 344:	e2 17       	cp	r30, r18
 346:	f3 07       	cpc	r31, r19
 348:	d9 f7       	brne	.-10     	; 0x340 <TWI_Start_Transceiver_With_Data+0x38>
 34a:	10 92 33 01 	sts	0x0133, r1	; 0x800133 <TWI_statusReg>
 34e:	88 ef       	ldi	r24, 0xF8	; 248
 350:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <TWI_state>
 354:	85 ea       	ldi	r24, 0xA5	; 165
 356:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 35a:	df 91       	pop	r29
 35c:	cf 91       	pop	r28
 35e:	08 95       	ret

00000360 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 360:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
 362:	ec eb       	ldi	r30, 0xBC	; 188
 364:	f0 e0       	ldi	r31, 0x00	; 0
 366:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 368:	91 78       	andi	r25, 0x81	; 129
 36a:	e9 f7       	brne	.-6      	; 0x366 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 36c:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <TWI_statusReg>
 370:	80 ff       	sbrs	r24, 0
 372:	11 c0       	rjmp	.+34     	; 0x396 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 374:	66 23       	and	r22, r22
 376:	79 f0       	breq	.+30     	; 0x396 <TWI_Get_Data_From_Transceiver+0x36>
 378:	a5 e3       	ldi	r26, 0x35	; 53
 37a:	b1 e0       	ldi	r27, 0x01	; 1
 37c:	fa 01       	movw	r30, r20
 37e:	61 50       	subi	r22, 0x01	; 1
 380:	26 2f       	mov	r18, r22
 382:	30 e0       	ldi	r19, 0x00	; 0
 384:	2f 5f       	subi	r18, 0xFF	; 255
 386:	3f 4f       	sbci	r19, 0xFF	; 255
 388:	24 0f       	add	r18, r20
 38a:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
 38c:	9d 91       	ld	r25, X+
 38e:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 390:	e2 17       	cp	r30, r18
 392:	f3 07       	cpc	r31, r19
 394:	d9 f7       	brne	.-10     	; 0x38c <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
 396:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <TWI_statusReg>
}
 39a:	81 70       	andi	r24, 0x01	; 1
 39c:	08 95       	ret

0000039e <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 39e:	1f 92       	push	r1
 3a0:	0f 92       	push	r0
 3a2:	0f b6       	in	r0, 0x3f	; 63
 3a4:	0f 92       	push	r0
 3a6:	11 24       	eor	r1, r1
 3a8:	2f 93       	push	r18
 3aa:	3f 93       	push	r19
 3ac:	8f 93       	push	r24
 3ae:	9f 93       	push	r25
 3b0:	af 93       	push	r26
 3b2:	bf 93       	push	r27
 3b4:	ef 93       	push	r30
 3b6:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 3b8:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 3bc:	8e 2f       	mov	r24, r30
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	fc 01       	movw	r30, r24
 3c2:	38 97       	sbiw	r30, 0x08	; 8
 3c4:	e1 35       	cpi	r30, 0x51	; 81
 3c6:	f1 05       	cpc	r31, r1
 3c8:	08 f0       	brcs	.+2      	; 0x3cc <__vector_26+0x2e>
 3ca:	55 c0       	rjmp	.+170    	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
 3cc:	e2 5c       	subi	r30, 0xC2	; 194
 3ce:	ff 4f       	sbci	r31, 0xFF	; 255
 3d0:	00 c1       	rjmp	.+512    	; 0x5d2 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 3d2:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <__data_end>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 3d6:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <__data_end>
 3da:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <TWI_msgSize>
 3de:	e8 17       	cp	r30, r24
 3e0:	70 f4       	brcc	.+28     	; 0x3fe <__vector_26+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 3e2:	81 e0       	ldi	r24, 0x01	; 1
 3e4:	8e 0f       	add	r24, r30
 3e6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
 3ea:	f0 e0       	ldi	r31, 0x00	; 0
 3ec:	eb 5c       	subi	r30, 0xCB	; 203
 3ee:	fe 4f       	sbci	r31, 0xFE	; 254
 3f0:	80 81       	ld	r24, Z
 3f2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 3f6:	85 e8       	ldi	r24, 0x85	; 133
 3f8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 3fc:	43 c0       	rjmp	.+134    	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 3fe:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <TWI_statusReg>
 402:	81 60       	ori	r24, 0x01	; 1
 404:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 408:	84 e9       	ldi	r24, 0x94	; 148
 40a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 40e:	3a c0       	rjmp	.+116    	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 410:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <__data_end>
 414:	81 e0       	ldi	r24, 0x01	; 1
 416:	8e 0f       	add	r24, r30
 418:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
 41c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 420:	f0 e0       	ldi	r31, 0x00	; 0
 422:	eb 5c       	subi	r30, 0xCB	; 203
 424:	fe 4f       	sbci	r31, 0xFE	; 254
 426:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 428:	20 91 32 01 	lds	r18, 0x0132	; 0x800132 <__data_end>
 42c:	30 e0       	ldi	r19, 0x00	; 0
 42e:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <TWI_msgSize>
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	01 97       	sbiw	r24, 0x01	; 1
 436:	28 17       	cp	r18, r24
 438:	39 07       	cpc	r19, r25
 43a:	24 f4       	brge	.+8      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 43c:	85 ec       	ldi	r24, 0xC5	; 197
 43e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 442:	20 c0       	rjmp	.+64     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 444:	85 e8       	ldi	r24, 0x85	; 133
 446:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 44a:	1c c0       	rjmp	.+56     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 44c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 450:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <__data_end>
 454:	f0 e0       	ldi	r31, 0x00	; 0
 456:	eb 5c       	subi	r30, 0xCB	; 203
 458:	fe 4f       	sbci	r31, 0xFE	; 254
 45a:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 45c:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <TWI_statusReg>
 460:	81 60       	ori	r24, 0x01	; 1
 462:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 466:	84 e9       	ldi	r24, 0x94	; 148
 468:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 46c:	0b c0       	rjmp	.+22     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 46e:	85 ea       	ldi	r24, 0xA5	; 165
 470:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 474:	07 c0       	rjmp	.+14     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 476:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 47a:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 47e:	84 e0       	ldi	r24, 0x04	; 4
 480:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 484:	ff 91       	pop	r31
 486:	ef 91       	pop	r30
 488:	bf 91       	pop	r27
 48a:	af 91       	pop	r26
 48c:	9f 91       	pop	r25
 48e:	8f 91       	pop	r24
 490:	3f 91       	pop	r19
 492:	2f 91       	pop	r18
 494:	0f 90       	pop	r0
 496:	0f be       	out	0x3f, r0	; 63
 498:	0f 90       	pop	r0
 49a:	1f 90       	pop	r1
 49c:	18 95       	reti

0000049e <USART0_init>:
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
 49e:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
 4a2:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
 4a6:	88 e9       	ldi	r24, 0x98	; 152
 4a8:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 4ac:	8e e0       	ldi	r24, 0x0E	; 14
 4ae:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 4b2:	10 92 47 02 	sts	0x0247, r1	; 0x800247 <UART0_RxTail>
 4b6:	10 92 48 02 	sts	0x0248, r1	; 0x800248 <UART0_RxHead>
 4ba:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <UART0_TxTail>
 4be:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <UART0_TxHead>
 4c2:	08 95       	ret

000004c4 <USART0_Transmit_IO>:
 4c4:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <UART0_TxHead>
 4c8:	2f 5f       	subi	r18, 0xFF	; 255
 4ca:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <UART0_TxTail>
 4ce:	29 17       	cp	r18, r25
 4d0:	e1 f3       	breq	.-8      	; 0x4ca <USART0_Transmit_IO+0x6>
 4d2:	e2 2f       	mov	r30, r18
 4d4:	f0 e0       	ldi	r31, 0x00	; 0
 4d6:	e9 5b       	subi	r30, 0xB9	; 185
 4d8:	fe 4f       	sbci	r31, 0xFE	; 254
 4da:	80 83       	st	Z, r24
 4dc:	20 93 46 01 	sts	0x0146, r18	; 0x800146 <UART0_TxHead>
 4e0:	e1 ec       	ldi	r30, 0xC1	; 193
 4e2:	f0 e0       	ldi	r31, 0x00	; 0
 4e4:	80 81       	ld	r24, Z
 4e6:	80 62       	ori	r24, 0x20	; 32
 4e8:	80 83       	st	Z, r24
 4ea:	80 e0       	ldi	r24, 0x00	; 0
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	08 95       	ret

000004f0 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
 4f0:	1f 92       	push	r1
 4f2:	0f 92       	push	r0
 4f4:	0f b6       	in	r0, 0x3f	; 63
 4f6:	0f 92       	push	r0
 4f8:	11 24       	eor	r1, r1
 4fa:	8f 93       	push	r24
 4fc:	9f 93       	push	r25
 4fe:	ef 93       	push	r30
 500:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
 502:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <UART0_TxHead>
 506:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <UART0_TxTail>
 50a:	98 17       	cp	r25, r24
 50c:	61 f0       	breq	.+24     	; 0x526 <__vector_21+0x36>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
 50e:	e0 91 45 01 	lds	r30, 0x0145	; 0x800145 <UART0_TxTail>
 512:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
 514:	e0 93 45 01 	sts	0x0145, r30	; 0x800145 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
 518:	f0 e0       	ldi	r31, 0x00	; 0
 51a:	e9 5b       	subi	r30, 0xB9	; 185
 51c:	fe 4f       	sbci	r31, 0xFE	; 254
 51e:	80 81       	ld	r24, Z
 520:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 524:	05 c0       	rjmp	.+10     	; 0x530 <__vector_21+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
 526:	e1 ec       	ldi	r30, 0xC1	; 193
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	80 81       	ld	r24, Z
 52c:	8f 7d       	andi	r24, 0xDF	; 223
 52e:	80 83       	st	Z, r24
	}
 530:	ff 91       	pop	r31
 532:	ef 91       	pop	r30
 534:	9f 91       	pop	r25
 536:	8f 91       	pop	r24
 538:	0f 90       	pop	r0
 53a:	0f be       	out	0x3f, r0	; 63
 53c:	0f 90       	pop	r0
 53e:	1f 90       	pop	r1
 540:	18 95       	reti

00000542 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
 542:	1f 92       	push	r1
 544:	0f 92       	push	r0
 546:	0f b6       	in	r0, 0x3f	; 63
 548:	0f 92       	push	r0
 54a:	11 24       	eor	r1, r1
 54c:	8f 93       	push	r24
 54e:	9f 93       	push	r25
 550:	ef 93       	push	r30
 552:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	
	// Read the received data 
	data = UDR1;
 554:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
 558:	e0 91 4c 03 	lds	r30, 0x034C	; 0x80034c <UART1_RxHead>
 55c:	ef 5f       	subi	r30, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
 55e:	e0 93 4c 03 	sts	0x034C, r30	; 0x80034c <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
 562:	90 91 4b 03 	lds	r25, 0x034B	; 0x80034b <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
 566:	f0 e0       	ldi	r31, 0x00	; 0
 568:	e3 5b       	subi	r30, 0xB3	; 179
 56a:	fc 4f       	sbci	r31, 0xFC	; 252
 56c:	80 83       	st	Z, r24
}
 56e:	ff 91       	pop	r31
 570:	ef 91       	pop	r30
 572:	9f 91       	pop	r25
 574:	8f 91       	pop	r24
 576:	0f 90       	pop	r0
 578:	0f be       	out	0x3f, r0	; 63
 57a:	0f 90       	pop	r0
 57c:	1f 90       	pop	r1
 57e:	18 95       	reti

00000580 <__vector_29>:

ISR(USART1_UDRE_vect)
{
 580:	1f 92       	push	r1
 582:	0f 92       	push	r0
 584:	0f b6       	in	r0, 0x3f	; 63
 586:	0f 92       	push	r0
 588:	11 24       	eor	r1, r1
 58a:	8f 93       	push	r24
 58c:	9f 93       	push	r25
 58e:	ef 93       	push	r30
 590:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
 592:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <UART1_TxHead>
 596:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <UART1_TxTail>
 59a:	98 17       	cp	r25, r24
 59c:	61 f0       	breq	.+24     	; 0x5b6 <__vector_29+0x36>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
 59e:	e0 91 49 02 	lds	r30, 0x0249	; 0x800249 <UART1_TxTail>
 5a2:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
 5a4:	e0 93 49 02 	sts	0x0249, r30	; 0x800249 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
 5a8:	f0 e0       	ldi	r31, 0x00	; 0
 5aa:	e5 5b       	subi	r30, 0xB5	; 181
 5ac:	fd 4f       	sbci	r31, 0xFD	; 253
 5ae:	80 81       	ld	r24, Z
 5b0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 5b4:	05 c0       	rjmp	.+10     	; 0x5c0 <__vector_29+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
 5b6:	e9 ec       	ldi	r30, 0xC9	; 201
 5b8:	f0 e0       	ldi	r31, 0x00	; 0
 5ba:	80 81       	ld	r24, Z
 5bc:	8f 7d       	andi	r24, 0xDF	; 223
 5be:	80 83       	st	Z, r24
	}
 5c0:	ff 91       	pop	r31
 5c2:	ef 91       	pop	r30
 5c4:	9f 91       	pop	r25
 5c6:	8f 91       	pop	r24
 5c8:	0f 90       	pop	r0
 5ca:	0f be       	out	0x3f, r0	; 63
 5cc:	0f 90       	pop	r0
 5ce:	1f 90       	pop	r1
 5d0:	18 95       	reti

000005d2 <__tablejump2__>:
 5d2:	ee 0f       	add	r30, r30
 5d4:	ff 1f       	adc	r31, r31
 5d6:	05 90       	lpm	r0, Z+
 5d8:	f4 91       	lpm	r31, Z
 5da:	e0 2d       	mov	r30, r0
 5dc:	09 94       	ijmp

000005de <__prologue_saves__>:
 5de:	2f 92       	push	r2
 5e0:	3f 92       	push	r3
 5e2:	4f 92       	push	r4
 5e4:	5f 92       	push	r5
 5e6:	6f 92       	push	r6
 5e8:	7f 92       	push	r7
 5ea:	8f 92       	push	r8
 5ec:	9f 92       	push	r9
 5ee:	af 92       	push	r10
 5f0:	bf 92       	push	r11
 5f2:	cf 92       	push	r12
 5f4:	df 92       	push	r13
 5f6:	ef 92       	push	r14
 5f8:	ff 92       	push	r15
 5fa:	0f 93       	push	r16
 5fc:	1f 93       	push	r17
 5fe:	cf 93       	push	r28
 600:	df 93       	push	r29
 602:	cd b7       	in	r28, 0x3d	; 61
 604:	de b7       	in	r29, 0x3e	; 62
 606:	ca 1b       	sub	r28, r26
 608:	db 0b       	sbc	r29, r27
 60a:	0f b6       	in	r0, 0x3f	; 63
 60c:	f8 94       	cli
 60e:	de bf       	out	0x3e, r29	; 62
 610:	0f be       	out	0x3f, r0	; 63
 612:	cd bf       	out	0x3d, r28	; 61
 614:	09 94       	ijmp

00000616 <__epilogue_restores__>:
 616:	2a 88       	ldd	r2, Y+18	; 0x12
 618:	39 88       	ldd	r3, Y+17	; 0x11
 61a:	48 88       	ldd	r4, Y+16	; 0x10
 61c:	5f 84       	ldd	r5, Y+15	; 0x0f
 61e:	6e 84       	ldd	r6, Y+14	; 0x0e
 620:	7d 84       	ldd	r7, Y+13	; 0x0d
 622:	8c 84       	ldd	r8, Y+12	; 0x0c
 624:	9b 84       	ldd	r9, Y+11	; 0x0b
 626:	aa 84       	ldd	r10, Y+10	; 0x0a
 628:	b9 84       	ldd	r11, Y+9	; 0x09
 62a:	c8 84       	ldd	r12, Y+8	; 0x08
 62c:	df 80       	ldd	r13, Y+7	; 0x07
 62e:	ee 80       	ldd	r14, Y+6	; 0x06
 630:	fd 80       	ldd	r15, Y+5	; 0x05
 632:	0c 81       	ldd	r16, Y+4	; 0x04
 634:	1b 81       	ldd	r17, Y+3	; 0x03
 636:	aa 81       	ldd	r26, Y+2	; 0x02
 638:	b9 81       	ldd	r27, Y+1	; 0x01
 63a:	ce 0f       	add	r28, r30
 63c:	d1 1d       	adc	r29, r1
 63e:	0f b6       	in	r0, 0x3f	; 63
 640:	f8 94       	cli
 642:	de bf       	out	0x3e, r29	; 62
 644:	0f be       	out	0x3f, r0	; 63
 646:	cd bf       	out	0x3d, r28	; 61
 648:	ed 01       	movw	r28, r26
 64a:	08 95       	ret

0000064c <printf>:
 64c:	a0 e0       	ldi	r26, 0x00	; 0
 64e:	b0 e0       	ldi	r27, 0x00	; 0
 650:	eb e2       	ldi	r30, 0x2B	; 43
 652:	f3 e0       	ldi	r31, 0x03	; 3
 654:	d4 cf       	rjmp	.-88     	; 0x5fe <__prologue_saves__+0x20>
 656:	ae 01       	movw	r20, r28
 658:	4b 5f       	subi	r20, 0xFB	; 251
 65a:	5f 4f       	sbci	r21, 0xFF	; 255
 65c:	fa 01       	movw	r30, r20
 65e:	61 91       	ld	r22, Z+
 660:	71 91       	ld	r23, Z+
 662:	af 01       	movw	r20, r30
 664:	80 91 ab 04 	lds	r24, 0x04AB	; 0x8004ab <__iob+0x2>
 668:	90 91 ac 04 	lds	r25, 0x04AC	; 0x8004ac <__iob+0x3>
 66c:	02 d0       	rcall	.+4      	; 0x672 <vfprintf>
 66e:	e2 e0       	ldi	r30, 0x02	; 2
 670:	e2 cf       	rjmp	.-60     	; 0x636 <__epilogue_restores__+0x20>

00000672 <vfprintf>:
 672:	ab e0       	ldi	r26, 0x0B	; 11
 674:	b0 e0       	ldi	r27, 0x00	; 0
 676:	ee e3       	ldi	r30, 0x3E	; 62
 678:	f3 e0       	ldi	r31, 0x03	; 3
 67a:	b1 cf       	rjmp	.-158    	; 0x5de <__prologue_saves__>
 67c:	6c 01       	movw	r12, r24
 67e:	7b 01       	movw	r14, r22
 680:	8a 01       	movw	r16, r20
 682:	fc 01       	movw	r30, r24
 684:	17 82       	std	Z+7, r1	; 0x07
 686:	16 82       	std	Z+6, r1	; 0x06
 688:	83 81       	ldd	r24, Z+3	; 0x03
 68a:	81 ff       	sbrs	r24, 1
 68c:	bf c1       	rjmp	.+894    	; 0xa0c <__stack+0x10d>
 68e:	ce 01       	movw	r24, r28
 690:	01 96       	adiw	r24, 0x01	; 1
 692:	3c 01       	movw	r6, r24
 694:	f6 01       	movw	r30, r12
 696:	93 81       	ldd	r25, Z+3	; 0x03
 698:	f7 01       	movw	r30, r14
 69a:	93 fd       	sbrc	r25, 3
 69c:	85 91       	lpm	r24, Z+
 69e:	93 ff       	sbrs	r25, 3
 6a0:	81 91       	ld	r24, Z+
 6a2:	7f 01       	movw	r14, r30
 6a4:	88 23       	and	r24, r24
 6a6:	09 f4       	brne	.+2      	; 0x6aa <vfprintf+0x38>
 6a8:	ad c1       	rjmp	.+858    	; 0xa04 <__stack+0x105>
 6aa:	85 32       	cpi	r24, 0x25	; 37
 6ac:	39 f4       	brne	.+14     	; 0x6bc <vfprintf+0x4a>
 6ae:	93 fd       	sbrc	r25, 3
 6b0:	85 91       	lpm	r24, Z+
 6b2:	93 ff       	sbrs	r25, 3
 6b4:	81 91       	ld	r24, Z+
 6b6:	7f 01       	movw	r14, r30
 6b8:	85 32       	cpi	r24, 0x25	; 37
 6ba:	21 f4       	brne	.+8      	; 0x6c4 <vfprintf+0x52>
 6bc:	b6 01       	movw	r22, r12
 6be:	90 e0       	ldi	r25, 0x00	; 0
 6c0:	c0 d1       	rcall	.+896    	; 0xa42 <fputc>
 6c2:	e8 cf       	rjmp	.-48     	; 0x694 <vfprintf+0x22>
 6c4:	91 2c       	mov	r9, r1
 6c6:	21 2c       	mov	r2, r1
 6c8:	31 2c       	mov	r3, r1
 6ca:	ff e1       	ldi	r31, 0x1F	; 31
 6cc:	f3 15       	cp	r31, r3
 6ce:	d8 f0       	brcs	.+54     	; 0x706 <vfprintf+0x94>
 6d0:	8b 32       	cpi	r24, 0x2B	; 43
 6d2:	79 f0       	breq	.+30     	; 0x6f2 <vfprintf+0x80>
 6d4:	38 f4       	brcc	.+14     	; 0x6e4 <vfprintf+0x72>
 6d6:	80 32       	cpi	r24, 0x20	; 32
 6d8:	79 f0       	breq	.+30     	; 0x6f8 <vfprintf+0x86>
 6da:	83 32       	cpi	r24, 0x23	; 35
 6dc:	a1 f4       	brne	.+40     	; 0x706 <vfprintf+0x94>
 6de:	23 2d       	mov	r18, r3
 6e0:	20 61       	ori	r18, 0x10	; 16
 6e2:	1d c0       	rjmp	.+58     	; 0x71e <vfprintf+0xac>
 6e4:	8d 32       	cpi	r24, 0x2D	; 45
 6e6:	61 f0       	breq	.+24     	; 0x700 <vfprintf+0x8e>
 6e8:	80 33       	cpi	r24, 0x30	; 48
 6ea:	69 f4       	brne	.+26     	; 0x706 <vfprintf+0x94>
 6ec:	23 2d       	mov	r18, r3
 6ee:	21 60       	ori	r18, 0x01	; 1
 6f0:	16 c0       	rjmp	.+44     	; 0x71e <vfprintf+0xac>
 6f2:	83 2d       	mov	r24, r3
 6f4:	82 60       	ori	r24, 0x02	; 2
 6f6:	38 2e       	mov	r3, r24
 6f8:	e3 2d       	mov	r30, r3
 6fa:	e4 60       	ori	r30, 0x04	; 4
 6fc:	3e 2e       	mov	r3, r30
 6fe:	2a c0       	rjmp	.+84     	; 0x754 <vfprintf+0xe2>
 700:	f3 2d       	mov	r31, r3
 702:	f8 60       	ori	r31, 0x08	; 8
 704:	1d c0       	rjmp	.+58     	; 0x740 <vfprintf+0xce>
 706:	37 fc       	sbrc	r3, 7
 708:	2d c0       	rjmp	.+90     	; 0x764 <vfprintf+0xf2>
 70a:	20 ed       	ldi	r18, 0xD0	; 208
 70c:	28 0f       	add	r18, r24
 70e:	2a 30       	cpi	r18, 0x0A	; 10
 710:	40 f0       	brcs	.+16     	; 0x722 <vfprintf+0xb0>
 712:	8e 32       	cpi	r24, 0x2E	; 46
 714:	b9 f4       	brne	.+46     	; 0x744 <vfprintf+0xd2>
 716:	36 fc       	sbrc	r3, 6
 718:	75 c1       	rjmp	.+746    	; 0xa04 <__stack+0x105>
 71a:	23 2d       	mov	r18, r3
 71c:	20 64       	ori	r18, 0x40	; 64
 71e:	32 2e       	mov	r3, r18
 720:	19 c0       	rjmp	.+50     	; 0x754 <vfprintf+0xe2>
 722:	36 fe       	sbrs	r3, 6
 724:	06 c0       	rjmp	.+12     	; 0x732 <vfprintf+0xc0>
 726:	8a e0       	ldi	r24, 0x0A	; 10
 728:	98 9e       	mul	r9, r24
 72a:	20 0d       	add	r18, r0
 72c:	11 24       	eor	r1, r1
 72e:	92 2e       	mov	r9, r18
 730:	11 c0       	rjmp	.+34     	; 0x754 <vfprintf+0xe2>
 732:	ea e0       	ldi	r30, 0x0A	; 10
 734:	2e 9e       	mul	r2, r30
 736:	20 0d       	add	r18, r0
 738:	11 24       	eor	r1, r1
 73a:	22 2e       	mov	r2, r18
 73c:	f3 2d       	mov	r31, r3
 73e:	f0 62       	ori	r31, 0x20	; 32
 740:	3f 2e       	mov	r3, r31
 742:	08 c0       	rjmp	.+16     	; 0x754 <vfprintf+0xe2>
 744:	8c 36       	cpi	r24, 0x6C	; 108
 746:	21 f4       	brne	.+8      	; 0x750 <vfprintf+0xde>
 748:	83 2d       	mov	r24, r3
 74a:	80 68       	ori	r24, 0x80	; 128
 74c:	38 2e       	mov	r3, r24
 74e:	02 c0       	rjmp	.+4      	; 0x754 <vfprintf+0xe2>
 750:	88 36       	cpi	r24, 0x68	; 104
 752:	41 f4       	brne	.+16     	; 0x764 <vfprintf+0xf2>
 754:	f7 01       	movw	r30, r14
 756:	93 fd       	sbrc	r25, 3
 758:	85 91       	lpm	r24, Z+
 75a:	93 ff       	sbrs	r25, 3
 75c:	81 91       	ld	r24, Z+
 75e:	7f 01       	movw	r14, r30
 760:	81 11       	cpse	r24, r1
 762:	b3 cf       	rjmp	.-154    	; 0x6ca <vfprintf+0x58>
 764:	98 2f       	mov	r25, r24
 766:	9f 7d       	andi	r25, 0xDF	; 223
 768:	95 54       	subi	r25, 0x45	; 69
 76a:	93 30       	cpi	r25, 0x03	; 3
 76c:	28 f4       	brcc	.+10     	; 0x778 <vfprintf+0x106>
 76e:	0c 5f       	subi	r16, 0xFC	; 252
 770:	1f 4f       	sbci	r17, 0xFF	; 255
 772:	9f e3       	ldi	r25, 0x3F	; 63
 774:	99 83       	std	Y+1, r25	; 0x01
 776:	0d c0       	rjmp	.+26     	; 0x792 <vfprintf+0x120>
 778:	83 36       	cpi	r24, 0x63	; 99
 77a:	31 f0       	breq	.+12     	; 0x788 <vfprintf+0x116>
 77c:	83 37       	cpi	r24, 0x73	; 115
 77e:	71 f0       	breq	.+28     	; 0x79c <vfprintf+0x12a>
 780:	83 35       	cpi	r24, 0x53	; 83
 782:	09 f0       	breq	.+2      	; 0x786 <vfprintf+0x114>
 784:	55 c0       	rjmp	.+170    	; 0x830 <vfprintf+0x1be>
 786:	20 c0       	rjmp	.+64     	; 0x7c8 <vfprintf+0x156>
 788:	f8 01       	movw	r30, r16
 78a:	80 81       	ld	r24, Z
 78c:	89 83       	std	Y+1, r24	; 0x01
 78e:	0e 5f       	subi	r16, 0xFE	; 254
 790:	1f 4f       	sbci	r17, 0xFF	; 255
 792:	88 24       	eor	r8, r8
 794:	83 94       	inc	r8
 796:	91 2c       	mov	r9, r1
 798:	53 01       	movw	r10, r6
 79a:	12 c0       	rjmp	.+36     	; 0x7c0 <vfprintf+0x14e>
 79c:	28 01       	movw	r4, r16
 79e:	f2 e0       	ldi	r31, 0x02	; 2
 7a0:	4f 0e       	add	r4, r31
 7a2:	51 1c       	adc	r5, r1
 7a4:	f8 01       	movw	r30, r16
 7a6:	a0 80       	ld	r10, Z
 7a8:	b1 80       	ldd	r11, Z+1	; 0x01
 7aa:	36 fe       	sbrs	r3, 6
 7ac:	03 c0       	rjmp	.+6      	; 0x7b4 <vfprintf+0x142>
 7ae:	69 2d       	mov	r22, r9
 7b0:	70 e0       	ldi	r23, 0x00	; 0
 7b2:	02 c0       	rjmp	.+4      	; 0x7b8 <vfprintf+0x146>
 7b4:	6f ef       	ldi	r22, 0xFF	; 255
 7b6:	7f ef       	ldi	r23, 0xFF	; 255
 7b8:	c5 01       	movw	r24, r10
 7ba:	38 d1       	rcall	.+624    	; 0xa2c <strnlen>
 7bc:	4c 01       	movw	r8, r24
 7be:	82 01       	movw	r16, r4
 7c0:	f3 2d       	mov	r31, r3
 7c2:	ff 77       	andi	r31, 0x7F	; 127
 7c4:	3f 2e       	mov	r3, r31
 7c6:	15 c0       	rjmp	.+42     	; 0x7f2 <vfprintf+0x180>
 7c8:	28 01       	movw	r4, r16
 7ca:	22 e0       	ldi	r18, 0x02	; 2
 7cc:	42 0e       	add	r4, r18
 7ce:	51 1c       	adc	r5, r1
 7d0:	f8 01       	movw	r30, r16
 7d2:	a0 80       	ld	r10, Z
 7d4:	b1 80       	ldd	r11, Z+1	; 0x01
 7d6:	36 fe       	sbrs	r3, 6
 7d8:	03 c0       	rjmp	.+6      	; 0x7e0 <vfprintf+0x16e>
 7da:	69 2d       	mov	r22, r9
 7dc:	70 e0       	ldi	r23, 0x00	; 0
 7de:	02 c0       	rjmp	.+4      	; 0x7e4 <vfprintf+0x172>
 7e0:	6f ef       	ldi	r22, 0xFF	; 255
 7e2:	7f ef       	ldi	r23, 0xFF	; 255
 7e4:	c5 01       	movw	r24, r10
 7e6:	17 d1       	rcall	.+558    	; 0xa16 <strnlen_P>
 7e8:	4c 01       	movw	r8, r24
 7ea:	f3 2d       	mov	r31, r3
 7ec:	f0 68       	ori	r31, 0x80	; 128
 7ee:	3f 2e       	mov	r3, r31
 7f0:	82 01       	movw	r16, r4
 7f2:	33 fc       	sbrc	r3, 3
 7f4:	19 c0       	rjmp	.+50     	; 0x828 <vfprintf+0x1b6>
 7f6:	82 2d       	mov	r24, r2
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	88 16       	cp	r8, r24
 7fc:	99 06       	cpc	r9, r25
 7fe:	a0 f4       	brcc	.+40     	; 0x828 <vfprintf+0x1b6>
 800:	b6 01       	movw	r22, r12
 802:	80 e2       	ldi	r24, 0x20	; 32
 804:	90 e0       	ldi	r25, 0x00	; 0
 806:	1d d1       	rcall	.+570    	; 0xa42 <fputc>
 808:	2a 94       	dec	r2
 80a:	f5 cf       	rjmp	.-22     	; 0x7f6 <vfprintf+0x184>
 80c:	f5 01       	movw	r30, r10
 80e:	37 fc       	sbrc	r3, 7
 810:	85 91       	lpm	r24, Z+
 812:	37 fe       	sbrs	r3, 7
 814:	81 91       	ld	r24, Z+
 816:	5f 01       	movw	r10, r30
 818:	b6 01       	movw	r22, r12
 81a:	90 e0       	ldi	r25, 0x00	; 0
 81c:	12 d1       	rcall	.+548    	; 0xa42 <fputc>
 81e:	21 10       	cpse	r2, r1
 820:	2a 94       	dec	r2
 822:	21 e0       	ldi	r18, 0x01	; 1
 824:	82 1a       	sub	r8, r18
 826:	91 08       	sbc	r9, r1
 828:	81 14       	cp	r8, r1
 82a:	91 04       	cpc	r9, r1
 82c:	79 f7       	brne	.-34     	; 0x80c <vfprintf+0x19a>
 82e:	e1 c0       	rjmp	.+450    	; 0x9f2 <__stack+0xf3>
 830:	84 36       	cpi	r24, 0x64	; 100
 832:	11 f0       	breq	.+4      	; 0x838 <vfprintf+0x1c6>
 834:	89 36       	cpi	r24, 0x69	; 105
 836:	39 f5       	brne	.+78     	; 0x886 <vfprintf+0x214>
 838:	f8 01       	movw	r30, r16
 83a:	37 fe       	sbrs	r3, 7
 83c:	07 c0       	rjmp	.+14     	; 0x84c <vfprintf+0x1da>
 83e:	60 81       	ld	r22, Z
 840:	71 81       	ldd	r23, Z+1	; 0x01
 842:	82 81       	ldd	r24, Z+2	; 0x02
 844:	93 81       	ldd	r25, Z+3	; 0x03
 846:	0c 5f       	subi	r16, 0xFC	; 252
 848:	1f 4f       	sbci	r17, 0xFF	; 255
 84a:	08 c0       	rjmp	.+16     	; 0x85c <vfprintf+0x1ea>
 84c:	60 81       	ld	r22, Z
 84e:	71 81       	ldd	r23, Z+1	; 0x01
 850:	07 2e       	mov	r0, r23
 852:	00 0c       	add	r0, r0
 854:	88 0b       	sbc	r24, r24
 856:	99 0b       	sbc	r25, r25
 858:	0e 5f       	subi	r16, 0xFE	; 254
 85a:	1f 4f       	sbci	r17, 0xFF	; 255
 85c:	f3 2d       	mov	r31, r3
 85e:	ff 76       	andi	r31, 0x6F	; 111
 860:	3f 2e       	mov	r3, r31
 862:	97 ff       	sbrs	r25, 7
 864:	09 c0       	rjmp	.+18     	; 0x878 <vfprintf+0x206>
 866:	90 95       	com	r25
 868:	80 95       	com	r24
 86a:	70 95       	com	r23
 86c:	61 95       	neg	r22
 86e:	7f 4f       	sbci	r23, 0xFF	; 255
 870:	8f 4f       	sbci	r24, 0xFF	; 255
 872:	9f 4f       	sbci	r25, 0xFF	; 255
 874:	f0 68       	ori	r31, 0x80	; 128
 876:	3f 2e       	mov	r3, r31
 878:	2a e0       	ldi	r18, 0x0A	; 10
 87a:	30 e0       	ldi	r19, 0x00	; 0
 87c:	a3 01       	movw	r20, r6
 87e:	1d d1       	rcall	.+570    	; 0xaba <__ultoa_invert>
 880:	88 2e       	mov	r8, r24
 882:	86 18       	sub	r8, r6
 884:	44 c0       	rjmp	.+136    	; 0x90e <__stack+0xf>
 886:	85 37       	cpi	r24, 0x75	; 117
 888:	31 f4       	brne	.+12     	; 0x896 <vfprintf+0x224>
 88a:	23 2d       	mov	r18, r3
 88c:	2f 7e       	andi	r18, 0xEF	; 239
 88e:	b2 2e       	mov	r11, r18
 890:	2a e0       	ldi	r18, 0x0A	; 10
 892:	30 e0       	ldi	r19, 0x00	; 0
 894:	25 c0       	rjmp	.+74     	; 0x8e0 <vfprintf+0x26e>
 896:	93 2d       	mov	r25, r3
 898:	99 7f       	andi	r25, 0xF9	; 249
 89a:	b9 2e       	mov	r11, r25
 89c:	8f 36       	cpi	r24, 0x6F	; 111
 89e:	c1 f0       	breq	.+48     	; 0x8d0 <vfprintf+0x25e>
 8a0:	18 f4       	brcc	.+6      	; 0x8a8 <vfprintf+0x236>
 8a2:	88 35       	cpi	r24, 0x58	; 88
 8a4:	79 f0       	breq	.+30     	; 0x8c4 <vfprintf+0x252>
 8a6:	ae c0       	rjmp	.+348    	; 0xa04 <__stack+0x105>
 8a8:	80 37       	cpi	r24, 0x70	; 112
 8aa:	19 f0       	breq	.+6      	; 0x8b2 <vfprintf+0x240>
 8ac:	88 37       	cpi	r24, 0x78	; 120
 8ae:	21 f0       	breq	.+8      	; 0x8b8 <vfprintf+0x246>
 8b0:	a9 c0       	rjmp	.+338    	; 0xa04 <__stack+0x105>
 8b2:	e9 2f       	mov	r30, r25
 8b4:	e0 61       	ori	r30, 0x10	; 16
 8b6:	be 2e       	mov	r11, r30
 8b8:	b4 fe       	sbrs	r11, 4
 8ba:	0d c0       	rjmp	.+26     	; 0x8d6 <vfprintf+0x264>
 8bc:	fb 2d       	mov	r31, r11
 8be:	f4 60       	ori	r31, 0x04	; 4
 8c0:	bf 2e       	mov	r11, r31
 8c2:	09 c0       	rjmp	.+18     	; 0x8d6 <vfprintf+0x264>
 8c4:	34 fe       	sbrs	r3, 4
 8c6:	0a c0       	rjmp	.+20     	; 0x8dc <vfprintf+0x26a>
 8c8:	29 2f       	mov	r18, r25
 8ca:	26 60       	ori	r18, 0x06	; 6
 8cc:	b2 2e       	mov	r11, r18
 8ce:	06 c0       	rjmp	.+12     	; 0x8dc <vfprintf+0x26a>
 8d0:	28 e0       	ldi	r18, 0x08	; 8
 8d2:	30 e0       	ldi	r19, 0x00	; 0
 8d4:	05 c0       	rjmp	.+10     	; 0x8e0 <vfprintf+0x26e>
 8d6:	20 e1       	ldi	r18, 0x10	; 16
 8d8:	30 e0       	ldi	r19, 0x00	; 0
 8da:	02 c0       	rjmp	.+4      	; 0x8e0 <vfprintf+0x26e>
 8dc:	20 e1       	ldi	r18, 0x10	; 16
 8de:	32 e0       	ldi	r19, 0x02	; 2
 8e0:	f8 01       	movw	r30, r16
 8e2:	b7 fe       	sbrs	r11, 7
 8e4:	07 c0       	rjmp	.+14     	; 0x8f4 <vfprintf+0x282>
 8e6:	60 81       	ld	r22, Z
 8e8:	71 81       	ldd	r23, Z+1	; 0x01
 8ea:	82 81       	ldd	r24, Z+2	; 0x02
 8ec:	93 81       	ldd	r25, Z+3	; 0x03
 8ee:	0c 5f       	subi	r16, 0xFC	; 252
 8f0:	1f 4f       	sbci	r17, 0xFF	; 255
 8f2:	06 c0       	rjmp	.+12     	; 0x900 <__stack+0x1>
 8f4:	60 81       	ld	r22, Z
 8f6:	71 81       	ldd	r23, Z+1	; 0x01
 8f8:	80 e0       	ldi	r24, 0x00	; 0
 8fa:	90 e0       	ldi	r25, 0x00	; 0
 8fc:	0e 5f       	subi	r16, 0xFE	; 254
 8fe:	1f 4f       	sbci	r17, 0xFF	; 255
 900:	a3 01       	movw	r20, r6
 902:	db d0       	rcall	.+438    	; 0xaba <__ultoa_invert>
 904:	88 2e       	mov	r8, r24
 906:	86 18       	sub	r8, r6
 908:	fb 2d       	mov	r31, r11
 90a:	ff 77       	andi	r31, 0x7F	; 127
 90c:	3f 2e       	mov	r3, r31
 90e:	36 fe       	sbrs	r3, 6
 910:	0d c0       	rjmp	.+26     	; 0x92c <__stack+0x2d>
 912:	23 2d       	mov	r18, r3
 914:	2e 7f       	andi	r18, 0xFE	; 254
 916:	a2 2e       	mov	r10, r18
 918:	89 14       	cp	r8, r9
 91a:	58 f4       	brcc	.+22     	; 0x932 <__stack+0x33>
 91c:	34 fe       	sbrs	r3, 4
 91e:	0b c0       	rjmp	.+22     	; 0x936 <__stack+0x37>
 920:	32 fc       	sbrc	r3, 2
 922:	09 c0       	rjmp	.+18     	; 0x936 <__stack+0x37>
 924:	83 2d       	mov	r24, r3
 926:	8e 7e       	andi	r24, 0xEE	; 238
 928:	a8 2e       	mov	r10, r24
 92a:	05 c0       	rjmp	.+10     	; 0x936 <__stack+0x37>
 92c:	b8 2c       	mov	r11, r8
 92e:	a3 2c       	mov	r10, r3
 930:	03 c0       	rjmp	.+6      	; 0x938 <__stack+0x39>
 932:	b8 2c       	mov	r11, r8
 934:	01 c0       	rjmp	.+2      	; 0x938 <__stack+0x39>
 936:	b9 2c       	mov	r11, r9
 938:	a4 fe       	sbrs	r10, 4
 93a:	0f c0       	rjmp	.+30     	; 0x95a <__stack+0x5b>
 93c:	fe 01       	movw	r30, r28
 93e:	e8 0d       	add	r30, r8
 940:	f1 1d       	adc	r31, r1
 942:	80 81       	ld	r24, Z
 944:	80 33       	cpi	r24, 0x30	; 48
 946:	21 f4       	brne	.+8      	; 0x950 <__stack+0x51>
 948:	9a 2d       	mov	r25, r10
 94a:	99 7e       	andi	r25, 0xE9	; 233
 94c:	a9 2e       	mov	r10, r25
 94e:	09 c0       	rjmp	.+18     	; 0x962 <__stack+0x63>
 950:	a2 fe       	sbrs	r10, 2
 952:	06 c0       	rjmp	.+12     	; 0x960 <__stack+0x61>
 954:	b3 94       	inc	r11
 956:	b3 94       	inc	r11
 958:	04 c0       	rjmp	.+8      	; 0x962 <__stack+0x63>
 95a:	8a 2d       	mov	r24, r10
 95c:	86 78       	andi	r24, 0x86	; 134
 95e:	09 f0       	breq	.+2      	; 0x962 <__stack+0x63>
 960:	b3 94       	inc	r11
 962:	a3 fc       	sbrc	r10, 3
 964:	10 c0       	rjmp	.+32     	; 0x986 <__stack+0x87>
 966:	a0 fe       	sbrs	r10, 0
 968:	06 c0       	rjmp	.+12     	; 0x976 <__stack+0x77>
 96a:	b2 14       	cp	r11, r2
 96c:	80 f4       	brcc	.+32     	; 0x98e <__stack+0x8f>
 96e:	28 0c       	add	r2, r8
 970:	92 2c       	mov	r9, r2
 972:	9b 18       	sub	r9, r11
 974:	0d c0       	rjmp	.+26     	; 0x990 <__stack+0x91>
 976:	b2 14       	cp	r11, r2
 978:	58 f4       	brcc	.+22     	; 0x990 <__stack+0x91>
 97a:	b6 01       	movw	r22, r12
 97c:	80 e2       	ldi	r24, 0x20	; 32
 97e:	90 e0       	ldi	r25, 0x00	; 0
 980:	60 d0       	rcall	.+192    	; 0xa42 <fputc>
 982:	b3 94       	inc	r11
 984:	f8 cf       	rjmp	.-16     	; 0x976 <__stack+0x77>
 986:	b2 14       	cp	r11, r2
 988:	18 f4       	brcc	.+6      	; 0x990 <__stack+0x91>
 98a:	2b 18       	sub	r2, r11
 98c:	02 c0       	rjmp	.+4      	; 0x992 <__stack+0x93>
 98e:	98 2c       	mov	r9, r8
 990:	21 2c       	mov	r2, r1
 992:	a4 fe       	sbrs	r10, 4
 994:	0f c0       	rjmp	.+30     	; 0x9b4 <__stack+0xb5>
 996:	b6 01       	movw	r22, r12
 998:	80 e3       	ldi	r24, 0x30	; 48
 99a:	90 e0       	ldi	r25, 0x00	; 0
 99c:	52 d0       	rcall	.+164    	; 0xa42 <fputc>
 99e:	a2 fe       	sbrs	r10, 2
 9a0:	16 c0       	rjmp	.+44     	; 0x9ce <__stack+0xcf>
 9a2:	a1 fc       	sbrc	r10, 1
 9a4:	03 c0       	rjmp	.+6      	; 0x9ac <__stack+0xad>
 9a6:	88 e7       	ldi	r24, 0x78	; 120
 9a8:	90 e0       	ldi	r25, 0x00	; 0
 9aa:	02 c0       	rjmp	.+4      	; 0x9b0 <__stack+0xb1>
 9ac:	88 e5       	ldi	r24, 0x58	; 88
 9ae:	90 e0       	ldi	r25, 0x00	; 0
 9b0:	b6 01       	movw	r22, r12
 9b2:	0c c0       	rjmp	.+24     	; 0x9cc <__stack+0xcd>
 9b4:	8a 2d       	mov	r24, r10
 9b6:	86 78       	andi	r24, 0x86	; 134
 9b8:	51 f0       	breq	.+20     	; 0x9ce <__stack+0xcf>
 9ba:	a1 fe       	sbrs	r10, 1
 9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <__stack+0xc3>
 9be:	8b e2       	ldi	r24, 0x2B	; 43
 9c0:	01 c0       	rjmp	.+2      	; 0x9c4 <__stack+0xc5>
 9c2:	80 e2       	ldi	r24, 0x20	; 32
 9c4:	a7 fc       	sbrc	r10, 7
 9c6:	8d e2       	ldi	r24, 0x2D	; 45
 9c8:	b6 01       	movw	r22, r12
 9ca:	90 e0       	ldi	r25, 0x00	; 0
 9cc:	3a d0       	rcall	.+116    	; 0xa42 <fputc>
 9ce:	89 14       	cp	r8, r9
 9d0:	30 f4       	brcc	.+12     	; 0x9de <__stack+0xdf>
 9d2:	b6 01       	movw	r22, r12
 9d4:	80 e3       	ldi	r24, 0x30	; 48
 9d6:	90 e0       	ldi	r25, 0x00	; 0
 9d8:	34 d0       	rcall	.+104    	; 0xa42 <fputc>
 9da:	9a 94       	dec	r9
 9dc:	f8 cf       	rjmp	.-16     	; 0x9ce <__stack+0xcf>
 9de:	8a 94       	dec	r8
 9e0:	f3 01       	movw	r30, r6
 9e2:	e8 0d       	add	r30, r8
 9e4:	f1 1d       	adc	r31, r1
 9e6:	80 81       	ld	r24, Z
 9e8:	b6 01       	movw	r22, r12
 9ea:	90 e0       	ldi	r25, 0x00	; 0
 9ec:	2a d0       	rcall	.+84     	; 0xa42 <fputc>
 9ee:	81 10       	cpse	r8, r1
 9f0:	f6 cf       	rjmp	.-20     	; 0x9de <__stack+0xdf>
 9f2:	22 20       	and	r2, r2
 9f4:	09 f4       	brne	.+2      	; 0x9f8 <__stack+0xf9>
 9f6:	4e ce       	rjmp	.-868    	; 0x694 <vfprintf+0x22>
 9f8:	b6 01       	movw	r22, r12
 9fa:	80 e2       	ldi	r24, 0x20	; 32
 9fc:	90 e0       	ldi	r25, 0x00	; 0
 9fe:	21 d0       	rcall	.+66     	; 0xa42 <fputc>
 a00:	2a 94       	dec	r2
 a02:	f7 cf       	rjmp	.-18     	; 0x9f2 <__stack+0xf3>
 a04:	f6 01       	movw	r30, r12
 a06:	86 81       	ldd	r24, Z+6	; 0x06
 a08:	97 81       	ldd	r25, Z+7	; 0x07
 a0a:	02 c0       	rjmp	.+4      	; 0xa10 <__stack+0x111>
 a0c:	8f ef       	ldi	r24, 0xFF	; 255
 a0e:	9f ef       	ldi	r25, 0xFF	; 255
 a10:	2b 96       	adiw	r28, 0x0b	; 11
 a12:	e2 e1       	ldi	r30, 0x12	; 18
 a14:	00 ce       	rjmp	.-1024   	; 0x616 <__epilogue_restores__>

00000a16 <strnlen_P>:
 a16:	fc 01       	movw	r30, r24
 a18:	05 90       	lpm	r0, Z+
 a1a:	61 50       	subi	r22, 0x01	; 1
 a1c:	70 40       	sbci	r23, 0x00	; 0
 a1e:	01 10       	cpse	r0, r1
 a20:	d8 f7       	brcc	.-10     	; 0xa18 <strnlen_P+0x2>
 a22:	80 95       	com	r24
 a24:	90 95       	com	r25
 a26:	8e 0f       	add	r24, r30
 a28:	9f 1f       	adc	r25, r31
 a2a:	08 95       	ret

00000a2c <strnlen>:
 a2c:	fc 01       	movw	r30, r24
 a2e:	61 50       	subi	r22, 0x01	; 1
 a30:	70 40       	sbci	r23, 0x00	; 0
 a32:	01 90       	ld	r0, Z+
 a34:	01 10       	cpse	r0, r1
 a36:	d8 f7       	brcc	.-10     	; 0xa2e <strnlen+0x2>
 a38:	80 95       	com	r24
 a3a:	90 95       	com	r25
 a3c:	8e 0f       	add	r24, r30
 a3e:	9f 1f       	adc	r25, r31
 a40:	08 95       	ret

00000a42 <fputc>:
 a42:	0f 93       	push	r16
 a44:	1f 93       	push	r17
 a46:	cf 93       	push	r28
 a48:	df 93       	push	r29
 a4a:	fb 01       	movw	r30, r22
 a4c:	23 81       	ldd	r18, Z+3	; 0x03
 a4e:	21 fd       	sbrc	r18, 1
 a50:	03 c0       	rjmp	.+6      	; 0xa58 <fputc+0x16>
 a52:	8f ef       	ldi	r24, 0xFF	; 255
 a54:	9f ef       	ldi	r25, 0xFF	; 255
 a56:	2c c0       	rjmp	.+88     	; 0xab0 <fputc+0x6e>
 a58:	22 ff       	sbrs	r18, 2
 a5a:	16 c0       	rjmp	.+44     	; 0xa88 <fputc+0x46>
 a5c:	46 81       	ldd	r20, Z+6	; 0x06
 a5e:	57 81       	ldd	r21, Z+7	; 0x07
 a60:	24 81       	ldd	r18, Z+4	; 0x04
 a62:	35 81       	ldd	r19, Z+5	; 0x05
 a64:	42 17       	cp	r20, r18
 a66:	53 07       	cpc	r21, r19
 a68:	44 f4       	brge	.+16     	; 0xa7a <fputc+0x38>
 a6a:	a0 81       	ld	r26, Z
 a6c:	b1 81       	ldd	r27, Z+1	; 0x01
 a6e:	9d 01       	movw	r18, r26
 a70:	2f 5f       	subi	r18, 0xFF	; 255
 a72:	3f 4f       	sbci	r19, 0xFF	; 255
 a74:	31 83       	std	Z+1, r19	; 0x01
 a76:	20 83       	st	Z, r18
 a78:	8c 93       	st	X, r24
 a7a:	26 81       	ldd	r18, Z+6	; 0x06
 a7c:	37 81       	ldd	r19, Z+7	; 0x07
 a7e:	2f 5f       	subi	r18, 0xFF	; 255
 a80:	3f 4f       	sbci	r19, 0xFF	; 255
 a82:	37 83       	std	Z+7, r19	; 0x07
 a84:	26 83       	std	Z+6, r18	; 0x06
 a86:	14 c0       	rjmp	.+40     	; 0xab0 <fputc+0x6e>
 a88:	8b 01       	movw	r16, r22
 a8a:	ec 01       	movw	r28, r24
 a8c:	fb 01       	movw	r30, r22
 a8e:	00 84       	ldd	r0, Z+8	; 0x08
 a90:	f1 85       	ldd	r31, Z+9	; 0x09
 a92:	e0 2d       	mov	r30, r0
 a94:	09 95       	icall
 a96:	89 2b       	or	r24, r25
 a98:	e1 f6       	brne	.-72     	; 0xa52 <fputc+0x10>
 a9a:	d8 01       	movw	r26, r16
 a9c:	16 96       	adiw	r26, 0x06	; 6
 a9e:	8d 91       	ld	r24, X+
 aa0:	9c 91       	ld	r25, X
 aa2:	17 97       	sbiw	r26, 0x07	; 7
 aa4:	01 96       	adiw	r24, 0x01	; 1
 aa6:	17 96       	adiw	r26, 0x07	; 7
 aa8:	9c 93       	st	X, r25
 aaa:	8e 93       	st	-X, r24
 aac:	16 97       	sbiw	r26, 0x06	; 6
 aae:	ce 01       	movw	r24, r28
 ab0:	df 91       	pop	r29
 ab2:	cf 91       	pop	r28
 ab4:	1f 91       	pop	r17
 ab6:	0f 91       	pop	r16
 ab8:	08 95       	ret

00000aba <__ultoa_invert>:
 aba:	fa 01       	movw	r30, r20
 abc:	aa 27       	eor	r26, r26
 abe:	28 30       	cpi	r18, 0x08	; 8
 ac0:	51 f1       	breq	.+84     	; 0xb16 <__ultoa_invert+0x5c>
 ac2:	20 31       	cpi	r18, 0x10	; 16
 ac4:	81 f1       	breq	.+96     	; 0xb26 <__ultoa_invert+0x6c>
 ac6:	e8 94       	clt
 ac8:	6f 93       	push	r22
 aca:	6e 7f       	andi	r22, 0xFE	; 254
 acc:	6e 5f       	subi	r22, 0xFE	; 254
 ace:	7f 4f       	sbci	r23, 0xFF	; 255
 ad0:	8f 4f       	sbci	r24, 0xFF	; 255
 ad2:	9f 4f       	sbci	r25, 0xFF	; 255
 ad4:	af 4f       	sbci	r26, 0xFF	; 255
 ad6:	b1 e0       	ldi	r27, 0x01	; 1
 ad8:	3e d0       	rcall	.+124    	; 0xb56 <__ultoa_invert+0x9c>
 ada:	b4 e0       	ldi	r27, 0x04	; 4
 adc:	3c d0       	rcall	.+120    	; 0xb56 <__ultoa_invert+0x9c>
 ade:	67 0f       	add	r22, r23
 ae0:	78 1f       	adc	r23, r24
 ae2:	89 1f       	adc	r24, r25
 ae4:	9a 1f       	adc	r25, r26
 ae6:	a1 1d       	adc	r26, r1
 ae8:	68 0f       	add	r22, r24
 aea:	79 1f       	adc	r23, r25
 aec:	8a 1f       	adc	r24, r26
 aee:	91 1d       	adc	r25, r1
 af0:	a1 1d       	adc	r26, r1
 af2:	6a 0f       	add	r22, r26
 af4:	71 1d       	adc	r23, r1
 af6:	81 1d       	adc	r24, r1
 af8:	91 1d       	adc	r25, r1
 afa:	a1 1d       	adc	r26, r1
 afc:	20 d0       	rcall	.+64     	; 0xb3e <__ultoa_invert+0x84>
 afe:	09 f4       	brne	.+2      	; 0xb02 <__ultoa_invert+0x48>
 b00:	68 94       	set
 b02:	3f 91       	pop	r19
 b04:	2a e0       	ldi	r18, 0x0A	; 10
 b06:	26 9f       	mul	r18, r22
 b08:	11 24       	eor	r1, r1
 b0a:	30 19       	sub	r19, r0
 b0c:	30 5d       	subi	r19, 0xD0	; 208
 b0e:	31 93       	st	Z+, r19
 b10:	de f6       	brtc	.-74     	; 0xac8 <__ultoa_invert+0xe>
 b12:	cf 01       	movw	r24, r30
 b14:	08 95       	ret
 b16:	46 2f       	mov	r20, r22
 b18:	47 70       	andi	r20, 0x07	; 7
 b1a:	40 5d       	subi	r20, 0xD0	; 208
 b1c:	41 93       	st	Z+, r20
 b1e:	b3 e0       	ldi	r27, 0x03	; 3
 b20:	0f d0       	rcall	.+30     	; 0xb40 <__ultoa_invert+0x86>
 b22:	c9 f7       	brne	.-14     	; 0xb16 <__ultoa_invert+0x5c>
 b24:	f6 cf       	rjmp	.-20     	; 0xb12 <__ultoa_invert+0x58>
 b26:	46 2f       	mov	r20, r22
 b28:	4f 70       	andi	r20, 0x0F	; 15
 b2a:	40 5d       	subi	r20, 0xD0	; 208
 b2c:	4a 33       	cpi	r20, 0x3A	; 58
 b2e:	18 f0       	brcs	.+6      	; 0xb36 <__ultoa_invert+0x7c>
 b30:	49 5d       	subi	r20, 0xD9	; 217
 b32:	31 fd       	sbrc	r19, 1
 b34:	40 52       	subi	r20, 0x20	; 32
 b36:	41 93       	st	Z+, r20
 b38:	02 d0       	rcall	.+4      	; 0xb3e <__ultoa_invert+0x84>
 b3a:	a9 f7       	brne	.-22     	; 0xb26 <__ultoa_invert+0x6c>
 b3c:	ea cf       	rjmp	.-44     	; 0xb12 <__ultoa_invert+0x58>
 b3e:	b4 e0       	ldi	r27, 0x04	; 4
 b40:	a6 95       	lsr	r26
 b42:	97 95       	ror	r25
 b44:	87 95       	ror	r24
 b46:	77 95       	ror	r23
 b48:	67 95       	ror	r22
 b4a:	ba 95       	dec	r27
 b4c:	c9 f7       	brne	.-14     	; 0xb40 <__ultoa_invert+0x86>
 b4e:	00 97       	sbiw	r24, 0x00	; 0
 b50:	61 05       	cpc	r22, r1
 b52:	71 05       	cpc	r23, r1
 b54:	08 95       	ret
 b56:	9b 01       	movw	r18, r22
 b58:	ac 01       	movw	r20, r24
 b5a:	0a 2e       	mov	r0, r26
 b5c:	06 94       	lsr	r0
 b5e:	57 95       	ror	r21
 b60:	47 95       	ror	r20
 b62:	37 95       	ror	r19
 b64:	27 95       	ror	r18
 b66:	ba 95       	dec	r27
 b68:	c9 f7       	brne	.-14     	; 0xb5c <__ultoa_invert+0xa2>
 b6a:	62 0f       	add	r22, r18
 b6c:	73 1f       	adc	r23, r19
 b6e:	84 1f       	adc	r24, r20
 b70:	95 1f       	adc	r25, r21
 b72:	a0 1d       	adc	r26, r0
 b74:	08 95       	ret

00000b76 <_exit>:
 b76:	f8 94       	cli

00000b78 <__stop_program>:
 b78:	ff cf       	rjmp	.-2      	; 0xb78 <__stop_program>
