
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000021e  00800100  000024b2  00002546  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000024b2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005f1  0080031e  0080031e  00002764  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002764  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000027c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000308  00000000  00000000  00002800  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004fc4  00000000  00000000  00002b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000190c  00000000  00000000  00007acc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002424  00000000  00000000  000093d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a68  00000000  00000000  0000b7fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010af  00000000  00000000  0000c264  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003c26  00000000  00000000  0000d313  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  00010f39  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8e c0       	rjmp	.+284    	; 0x11e <__ctors_end>
       2:	00 00       	nop
       4:	a9 c0       	rjmp	.+338    	; 0x158 <__bad_interrupt>
       6:	00 00       	nop
       8:	a7 c0       	rjmp	.+334    	; 0x158 <__bad_interrupt>
       a:	00 00       	nop
       c:	a5 c0       	rjmp	.+330    	; 0x158 <__bad_interrupt>
       e:	00 00       	nop
      10:	a3 c0       	rjmp	.+326    	; 0x158 <__bad_interrupt>
      12:	00 00       	nop
      14:	a1 c0       	rjmp	.+322    	; 0x158 <__bad_interrupt>
      16:	00 00       	nop
      18:	9f c0       	rjmp	.+318    	; 0x158 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9d c0       	rjmp	.+314    	; 0x158 <__bad_interrupt>
      1e:	00 00       	nop
      20:	9b c0       	rjmp	.+310    	; 0x158 <__bad_interrupt>
      22:	00 00       	nop
      24:	99 c0       	rjmp	.+306    	; 0x158 <__bad_interrupt>
      26:	00 00       	nop
      28:	97 c0       	rjmp	.+302    	; 0x158 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	95 c0       	rjmp	.+298    	; 0x158 <__bad_interrupt>
      2e:	00 00       	nop
      30:	93 c0       	rjmp	.+294    	; 0x158 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 0b 0c 	jmp	0x1816	; 0x1816 <__vector_13>
      38:	8f c0       	rjmp	.+286    	; 0x158 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8d c0       	rjmp	.+282    	; 0x158 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 0a 0c 	jmp	0x1814	; 0x1814 <__vector_16>
      44:	89 c0       	rjmp	.+274    	; 0x158 <__bad_interrupt>
      46:	00 00       	nop
      48:	87 c0       	rjmp	.+270    	; 0x158 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	85 c0       	rjmp	.+266    	; 0x158 <__bad_interrupt>
      4e:	00 00       	nop
      50:	83 c0       	rjmp	.+262    	; 0x158 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 44 0d 	jmp	0x1a88	; 0x1a88 <__vector_21>
      58:	7f c0       	rjmp	.+254    	; 0x158 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7d c0       	rjmp	.+250    	; 0x158 <__bad_interrupt>
      5e:	00 00       	nop
      60:	7b c0       	rjmp	.+246    	; 0x158 <__bad_interrupt>
      62:	00 00       	nop
      64:	79 c0       	rjmp	.+242    	; 0x158 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 79 0c 	jmp	0x18f2	; 0x18f2 <__vector_26>
      6c:	75 c0       	rjmp	.+234    	; 0x158 <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 80 0d 	jmp	0x1b00	; 0x1b00 <__vector_28>
      74:	0c 94 c8 0d 	jmp	0x1b90	; 0x1b90 <__vector_29>
      78:	6f c0       	rjmp	.+222    	; 0x158 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	93 0c       	add	r9, r3
      7e:	e5 0c       	add	r14, r5
      80:	e5 0c       	add	r14, r5
      82:	e5 0c       	add	r14, r5
      84:	e5 0c       	add	r14, r5
      86:	e5 0c       	add	r14, r5
      88:	e5 0c       	add	r14, r5
      8a:	e5 0c       	add	r14, r5
      8c:	93 0c       	add	r9, r3
      8e:	e5 0c       	add	r14, r5
      90:	e5 0c       	add	r14, r5
      92:	e5 0c       	add	r14, r5
      94:	e5 0c       	add	r14, r5
      96:	e5 0c       	add	r14, r5
      98:	e5 0c       	add	r14, r5
      9a:	e5 0c       	add	r14, r5
      9c:	95 0c       	add	r9, r5
      9e:	e5 0c       	add	r14, r5
      a0:	e5 0c       	add	r14, r5
      a2:	e5 0c       	add	r14, r5
      a4:	e5 0c       	add	r14, r5
      a6:	e5 0c       	add	r14, r5
      a8:	e5 0c       	add	r14, r5
      aa:	e5 0c       	add	r14, r5
      ac:	e5 0c       	add	r14, r5
      ae:	e5 0c       	add	r14, r5
      b0:	e5 0c       	add	r14, r5
      b2:	e5 0c       	add	r14, r5
      b4:	e5 0c       	add	r14, r5
      b6:	e5 0c       	add	r14, r5
      b8:	e5 0c       	add	r14, r5
      ba:	e5 0c       	add	r14, r5
      bc:	95 0c       	add	r9, r5
      be:	e5 0c       	add	r14, r5
      c0:	e5 0c       	add	r14, r5
      c2:	e5 0c       	add	r14, r5
      c4:	e5 0c       	add	r14, r5
      c6:	e5 0c       	add	r14, r5
      c8:	e5 0c       	add	r14, r5
      ca:	e5 0c       	add	r14, r5
      cc:	e5 0c       	add	r14, r5
      ce:	e5 0c       	add	r14, r5
      d0:	e5 0c       	add	r14, r5
      d2:	e5 0c       	add	r14, r5
      d4:	e5 0c       	add	r14, r5
      d6:	e5 0c       	add	r14, r5
      d8:	e5 0c       	add	r14, r5
      da:	e5 0c       	add	r14, r5
      dc:	e1 0c       	add	r14, r1
      de:	e5 0c       	add	r14, r5
      e0:	e5 0c       	add	r14, r5
      e2:	e5 0c       	add	r14, r5
      e4:	e5 0c       	add	r14, r5
      e6:	e5 0c       	add	r14, r5
      e8:	e5 0c       	add	r14, r5
      ea:	e5 0c       	add	r14, r5
      ec:	be 0c       	add	r11, r14
      ee:	e5 0c       	add	r14, r5
      f0:	e5 0c       	add	r14, r5
      f2:	e5 0c       	add	r14, r5
      f4:	e5 0c       	add	r14, r5
      f6:	e5 0c       	add	r14, r5
      f8:	e5 0c       	add	r14, r5
      fa:	e5 0c       	add	r14, r5
      fc:	e5 0c       	add	r14, r5
      fe:	e5 0c       	add	r14, r5
     100:	e5 0c       	add	r14, r5
     102:	e5 0c       	add	r14, r5
     104:	e5 0c       	add	r14, r5
     106:	e5 0c       	add	r14, r5
     108:	e5 0c       	add	r14, r5
     10a:	e5 0c       	add	r14, r5
     10c:	b2 0c       	add	r11, r2
     10e:	e5 0c       	add	r14, r5
     110:	e5 0c       	add	r14, r5
     112:	e5 0c       	add	r14, r5
     114:	e5 0c       	add	r14, r5
     116:	e5 0c       	add	r14, r5
     118:	e5 0c       	add	r14, r5
     11a:	e5 0c       	add	r14, r5
     11c:	d0 0c       	add	r13, r0

0000011e <__ctors_end>:
     11e:	11 24       	eor	r1, r1
     120:	1f be       	out	0x3f, r1	; 63
     122:	cf ef       	ldi	r28, 0xFF	; 255
     124:	d8 e0       	ldi	r29, 0x08	; 8
     126:	de bf       	out	0x3e, r29	; 62
     128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
     12a:	13 e0       	ldi	r17, 0x03	; 3
     12c:	a0 e0       	ldi	r26, 0x00	; 0
     12e:	b1 e0       	ldi	r27, 0x01	; 1
     130:	e2 eb       	ldi	r30, 0xB2	; 178
     132:	f4 e2       	ldi	r31, 0x24	; 36
     134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
     136:	05 90       	lpm	r0, Z+
     138:	0d 92       	st	X+, r0
     13a:	ae 31       	cpi	r26, 0x1E	; 30
     13c:	b1 07       	cpc	r27, r17
     13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
     140:	29 e0       	ldi	r18, 0x09	; 9
     142:	ae e1       	ldi	r26, 0x1E	; 30
     144:	b3 e0       	ldi	r27, 0x03	; 3
     146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
     148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
     14a:	af 30       	cpi	r26, 0x0F	; 15
     14c:	b2 07       	cpc	r27, r18
     14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
     150:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <main>
     154:	0c 94 57 12 	jmp	0x24ae	; 0x24ae <_exit>

00000158 <__bad_interrupt>:
     158:	53 cf       	rjmp	.-346    	; 0x0 <__vectors>

0000015a <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     15a:	ec e7       	ldi	r30, 0x7C	; 124
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	90 81       	ld	r25, Z
     160:	90 7e       	andi	r25, 0xE0	; 224
     162:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     164:	90 81       	ld	r25, Z
     166:	89 2b       	or	r24, r25
     168:	80 83       	st	Z, r24
     16a:	08 95       	ret

0000016c <ADC_init>:
}

void ADC_init(void)
{
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	80 81       	ld	r24, Z
     176:	80 64       	ori	r24, 0x40	; 64
     178:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     17a:	ca e7       	ldi	r28, 0x7A	; 122
     17c:	d0 e0       	ldi	r29, 0x00	; 0
     17e:	88 81       	ld	r24, Y
     180:	81 60       	ori	r24, 0x01	; 1
     182:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     184:	88 81       	ld	r24, Y
     186:	82 60       	ori	r24, 0x02	; 2
     188:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     18a:	88 81       	ld	r24, Y
     18c:	84 60       	ori	r24, 0x04	; 4
     18e:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     190:	a4 e6       	ldi	r26, 0x64	; 100
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	8c 91       	ld	r24, X
     196:	8e 7f       	andi	r24, 0xFE	; 254
     198:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     19a:	80 81       	ld	r24, Z
     19c:	8f 7d       	andi	r24, 0xDF	; 223
     19e:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1a0:	8f e3       	ldi	r24, 0x3F	; 63
     1a2:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1a6:	88 81       	ld	r24, Y
     1a8:	80 68       	ori	r24, 0x80	; 128
     1aa:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1ac:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1b0:	8f e1       	ldi	r24, 0x1F	; 31
     1b2:	d3 df       	rcall	.-90     	; 0x15a <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1b4:	88 81       	ld	r24, Y
     1b6:	80 64       	ori	r24, 0x40	; 64
     1b8:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ba:	ea e7       	ldi	r30, 0x7A	; 122
     1bc:	f0 e0       	ldi	r31, 0x00	; 0
     1be:	80 81       	ld	r24, Z
     1c0:	84 ff       	sbrs	r24, 4
     1c2:	fd cf       	rjmp	.-6      	; 0x1be <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1c4:	ea e7       	ldi	r30, 0x7A	; 122
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	80 81       	ld	r24, Z
     1ca:	80 64       	ori	r24, 0x40	; 64
     1cc:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ce:	80 81       	ld	r24, Z
     1d0:	84 ff       	sbrs	r24, 4
     1d2:	fd cf       	rjmp	.-6      	; 0x1ce <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1d4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <__data_end+0x1>
     1de:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1e2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1e6:	20 91 1e 03 	lds	r18, 0x031E	; 0x80031e <__data_end>
     1ea:	30 91 1f 03 	lds	r19, 0x031F	; 0x80031f <__data_end+0x1>
     1ee:	89 2f       	mov	r24, r25
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	98 2f       	mov	r25, r24
     1f4:	88 27       	eor	r24, r24
     1f6:	82 0f       	add	r24, r18
     1f8:	93 1f       	adc	r25, r19
     1fa:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <__data_end+0x1>
     1fe:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     202:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <__data_end>
     206:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <__data_end+0x1>
     20a:	99 23       	and	r25, r25
     20c:	1c f4       	brge	.+6      	; 0x214 <ADC_init+0xa8>
     20e:	91 95       	neg	r25
     210:	81 95       	neg	r24
     212:	91 09       	sbc	r25, r1
     214:	05 97       	sbiw	r24, 0x05	; 5
     216:	2c f0       	brlt	.+10     	; 0x222 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     218:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <gas_sensor_initialization_errors>
     21c:	81 60       	ori	r24, 0x01	; 1
     21e:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     222:	8e e1       	ldi	r24, 0x1E	; 30
     224:	9a df       	rcall	.-204    	; 0x15a <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     226:	ea e7       	ldi	r30, 0x7A	; 122
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	80 81       	ld	r24, Z
     22c:	80 64       	ori	r24, 0x40	; 64
     22e:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     230:	80 81       	ld	r24, Z
     232:	84 ff       	sbrs	r24, 4
     234:	fd cf       	rjmp	.-6      	; 0x230 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     236:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <__data_end+0x1>
     240:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     244:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     248:	20 91 1e 03 	lds	r18, 0x031E	; 0x80031e <__data_end>
     24c:	30 91 1f 03 	lds	r19, 0x031F	; 0x80031f <__data_end+0x1>
     250:	89 2f       	mov	r24, r25
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	98 2f       	mov	r25, r24
     256:	88 27       	eor	r24, r24
     258:	82 0f       	add	r24, r18
     25a:	93 1f       	adc	r25, r19
     25c:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <__data_end+0x1>
     260:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     264:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <__data_end>
     268:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <__data_end+0x1>
     26c:	81 5e       	subi	r24, 0xE1	; 225
     26e:	91 09       	sbc	r25, r1
     270:	90 93 1f 03 	sts	0x031F, r25	; 0x80031f <__data_end+0x1>
     274:	80 93 1e 03 	sts	0x031E, r24	; 0x80031e <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     278:	80 91 1e 03 	lds	r24, 0x031E	; 0x80031e <__data_end>
     27c:	90 91 1f 03 	lds	r25, 0x031F	; 0x80031f <__data_end+0x1>
     280:	99 23       	and	r25, r25
     282:	1c f4       	brge	.+6      	; 0x28a <ADC_init+0x11e>
     284:	91 95       	neg	r25
     286:	81 95       	neg	r24
     288:	91 09       	sbc	r25, r1
     28a:	05 97       	sbiw	r24, 0x05	; 5
     28c:	2c f0       	brlt	.+10     	; 0x298 <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     28e:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <gas_sensor_initialization_errors>
     292:	82 60       	ori	r24, 0x02	; 2
     294:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     298:	ea e7       	ldi	r30, 0x7A	; 122
     29a:	f0 e0       	ldi	r31, 0x00	; 0
     29c:	80 81       	ld	r24, Z
     29e:	8f 77       	andi	r24, 0x7F	; 127
     2a0:	80 83       	st	Z, r24
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	08 95       	ret

000002a8 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2a8:	87 e0       	ldi	r24, 0x07	; 7
     2aa:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2ac:	85 b1       	in	r24, 0x05	; 5
     2ae:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2b0:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2b2:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2b4:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2b6:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2b8:	41 9a       	sbi	0x08, 1	; 8
     2ba:	08 95       	ret

000002bc <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2c0:	2f ef       	ldi	r18, 0xFF	; 255
     2c2:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2c4:	fc 01       	movw	r30, r24
     2c6:	ee 0f       	add	r30, r30
     2c8:	ff 1f       	adc	r31, r31
     2ca:	ee 0f       	add	r30, r30
     2cc:	ff 1f       	adc	r31, r31
     2ce:	ed 5a       	subi	r30, 0xAD	; 173
     2d0:	fa 4f       	sbci	r31, 0xFA	; 250
     2d2:	11 82       	std	Z+1, r1	; 0x01
     2d4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2d6:	33 83       	std	Z+3, r19	; 0x03
     2d8:	22 83       	std	Z+2, r18	; 0x02
     2da:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2dc:	85 30       	cpi	r24, 0x05	; 5
     2de:	91 05       	cpc	r25, r1
     2e0:	89 f7       	brne	.-30     	; 0x2c4 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2e2:	08 95       	ret

000002e4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2e4:	ef 92       	push	r14
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	0f 2e       	mov	r0, r31
     2f2:	fd e3       	ldi	r31, 0x3D	; 61
     2f4:	ef 2e       	mov	r14, r31
     2f6:	f5 e0       	ldi	r31, 0x05	; 5
     2f8:	ff 2e       	mov	r15, r31
     2fa:	f0 2d       	mov	r31, r0
     2fc:	00 e0       	ldi	r16, 0x00	; 0
     2fe:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     300:	c7 01       	movw	r24, r14
     302:	0e 94 42 12 	call	0x2484	; 0x2484 <eeprom_read_word>
     306:	e8 01       	movw	r28, r16
     308:	cc 0f       	add	r28, r28
     30a:	dd 1f       	adc	r29, r29
     30c:	cc 0f       	add	r28, r28
     30e:	dd 1f       	adc	r29, r29
     310:	cd 5a       	subi	r28, 0xAD	; 173
     312:	da 4f       	sbci	r29, 0xFA	; 250
     314:	99 83       	std	Y+1, r25	; 0x01
     316:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     318:	c7 01       	movw	r24, r14
     31a:	02 96       	adiw	r24, 0x02	; 2
     31c:	0e 94 42 12 	call	0x2484	; 0x2484 <eeprom_read_word>
     320:	9b 83       	std	Y+3, r25	; 0x03
     322:	8a 83       	std	Y+2, r24	; 0x02
     324:	0f 5f       	subi	r16, 0xFF	; 255
     326:	1f 4f       	sbci	r17, 0xFF	; 255
     328:	84 e0       	ldi	r24, 0x04	; 4
     32a:	e8 0e       	add	r14, r24
     32c:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     32e:	05 30       	cpi	r16, 0x05	; 5
     330:	11 05       	cpc	r17, r1
     332:	31 f7       	brne	.-52     	; 0x300 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     334:	df 91       	pop	r29
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	08 95       	ret

00000342 <gas_sensors_init>:

void gas_sensors_init(void)
{
     342:	af 92       	push	r10
     344:	bf 92       	push	r11
     346:	cf 92       	push	r12
     348:	df 92       	push	r13
     34a:	ef 92       	push	r14
     34c:	ff 92       	push	r15
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	1f 92       	push	r1
     358:	cd b7       	in	r28, 0x3d	; 61
     35a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     35c:	10 92 7e 05 	sts	0x057E, r1	; 0x80057e <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     360:	10 92 71 05 	sts	0x0571, r1	; 0x800571 <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     364:	bf df       	rcall	.-130    	; 0x2e4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     366:	aa df       	rcall	.-172    	; 0x2bc <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     368:	ea e7       	ldi	r30, 0x7A	; 122
     36a:	f0 e0       	ldi	r31, 0x00	; 0
     36c:	80 81       	ld	r24, Z
     36e:	80 68       	ori	r24, 0x80	; 128
     370:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     372:	19 82       	std	Y+1, r1	; 0x01
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	85 30       	cpi	r24, 0x05	; 5
     378:	08 f0       	brcs	.+2      	; 0x37c <gas_sensors_init+0x3a>
     37a:	51 c0       	rjmp	.+162    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     37c:	0a e7       	ldi	r16, 0x7A	; 122
     37e:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     380:	0f 2e       	mov	r0, r31
     382:	f8 e7       	ldi	r31, 0x78	; 120
     384:	ef 2e       	mov	r14, r31
     386:	f1 2c       	mov	r15, r1
     388:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     38a:	bb 24       	eor	r11, r11
     38c:	b3 94       	inc	r11
     38e:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     390:	cc 24       	eor	r12, r12
     392:	c3 94       	inc	r12
     394:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	e0 de       	rcall	.-576    	; 0x15a <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
     39a:	f8 01       	movw	r30, r16
     39c:	80 81       	ld	r24, Z
     39e:	80 64       	ori	r24, 0x40	; 64
     3a0:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
     3a2:	f8 01       	movw	r30, r16
     3a4:	80 81       	ld	r24, Z
     3a6:	84 ff       	sbrs	r24, 4
     3a8:	fc cf       	rjmp	.-8      	; 0x3a2 <gas_sensors_init+0x60>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3aa:	f7 01       	movw	r30, r14
     3ac:	80 81       	ld	r24, Z
     3ae:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3b0:	e9 81       	ldd	r30, Y+1	; 0x01
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	ee 0f       	add	r30, r30
     3b6:	ff 1f       	adc	r31, r31
     3b8:	ee 0f       	add	r30, r30
     3ba:	ff 1f       	adc	r31, r31
     3bc:	ed 5a       	subi	r30, 0xAD	; 173
     3be:	fa 4f       	sbci	r31, 0xFA	; 250
     3c0:	20 81       	ld	r18, Z
     3c2:	31 81       	ldd	r19, Z+1	; 0x01
     3c4:	e9 81       	ldd	r30, Y+1	; 0x01
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	ee 0f       	add	r30, r30
     3ca:	ff 1f       	adc	r31, r31
     3cc:	ee 0f       	add	r30, r30
     3ce:	ff 1f       	adc	r31, r31
     3d0:	ed 5a       	subi	r30, 0xAD	; 173
     3d2:	fa 4f       	sbci	r31, 0xFA	; 250
     3d4:	62 81       	ldd	r22, Z+2	; 0x02
     3d6:	73 81       	ldd	r23, Z+3	; 0x03
     3d8:	4b 2d       	mov	r20, r11
     3da:	68 17       	cp	r22, r24
     3dc:	79 07       	cpc	r23, r25
     3de:	08 f0       	brcs	.+2      	; 0x3e2 <gas_sensors_init+0xa0>
     3e0:	4a 2d       	mov	r20, r10
     3e2:	41 11       	cpse	r20, r1
     3e4:	07 c0       	rjmp	.+14     	; 0x3f4 <gas_sensors_init+0xb2>
     3e6:	4b 2d       	mov	r20, r11
     3e8:	82 17       	cp	r24, r18
     3ea:	93 07       	cpc	r25, r19
     3ec:	08 f0       	brcs	.+2      	; 0x3f0 <gas_sensors_init+0xae>
     3ee:	4a 2d       	mov	r20, r10
     3f0:	44 23       	and	r20, r20
     3f2:	71 f0       	breq	.+28     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3f4:	99 81       	ldd	r25, Y+1	; 0x01
     3f6:	20 91 7e 05 	lds	r18, 0x057E	; 0x80057e <gas_sensor_initialization_errors>
     3fa:	9d 5f       	subi	r25, 0xFD	; 253
     3fc:	a6 01       	movw	r20, r12
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     400:	44 0f       	add	r20, r20
     402:	55 1f       	adc	r21, r21
     404:	9a 95       	dec	r25
     406:	e2 f7       	brpl	.-8      	; 0x400 <__LOCK_REGION_LENGTH__>
     408:	ca 01       	movw	r24, r20
     40a:	82 2b       	or	r24, r18
     40c:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     410:	89 81       	ldd	r24, Y+1	; 0x01
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	89 83       	std	Y+1, r24	; 0x01
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	85 30       	cpi	r24, 0x05	; 5
     41a:	08 f4       	brcc	.+2      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     41c:	bc cf       	rjmp	.-136    	; 0x396 <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     41e:	ea e7       	ldi	r30, 0x7A	; 122
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	8f 77       	andi	r24, 0x7F	; 127
     426:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     428:	0f 90       	pop	r0
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	08 95       	ret

00000440 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
     440:	8f 92       	push	r8
     442:	9f 92       	push	r9
     444:	af 92       	push	r10
     446:	bf 92       	push	r11
     448:	cf 92       	push	r12
     44a:	df 92       	push	r13
     44c:	ef 92       	push	r14
     44e:	ff 92       	push	r15
     450:	0f 93       	push	r16
     452:	1f 93       	push	r17
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	00 d0       	rcall	.+0      	; 0x45a <start_gas_sensor_read+0x1a>
     45a:	1f 92       	push	r1
     45c:	cd b7       	in	r28, 0x3d	; 61
     45e:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     460:	ea e7       	ldi	r30, 0x7A	; 122
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	80 81       	ld	r24, Z
     466:	80 68       	ori	r24, 0x80	; 128
     468:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     46a:	19 82       	std	Y+1, r1	; 0x01
     46c:	89 81       	ldd	r24, Y+1	; 0x01
     46e:	85 30       	cpi	r24, 0x05	; 5
     470:	08 f0       	brcs	.+2      	; 0x474 <start_gas_sensor_read+0x34>
     472:	76 c0       	rjmp	.+236    	; 0x560 <start_gas_sensor_read+0x120>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
     474:	68 94       	set
     476:	88 24       	eor	r8, r8
     478:	82 f8       	bld	r8, 2
     47a:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     47c:	0a e7       	ldi	r16, 0x7A	; 122
     47e:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     480:	0f 2e       	mov	r0, r31
     482:	f8 e7       	ldi	r31, 0x78	; 120
     484:	ef 2e       	mov	r14, r31
     486:	f1 2c       	mov	r15, r1
     488:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     48a:	cc 24       	eor	r12, r12
     48c:	c3 94       	inc	r12
     48e:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     490:	bb 24       	eor	r11, r11
     492:	b3 94       	inc	r11
     494:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     496:	89 81       	ldd	r24, Y+1	; 0x01
     498:	60 de       	rcall	.-832    	; 0x15a <ADC_SetMux>
		total = 0;	// re-zero the average
     49a:	1b 82       	std	Y+3, r1	; 0x03
     49c:	1a 82       	std	Y+2, r1	; 0x02
     49e:	28 2d       	mov	r18, r8
     4a0:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4a2:	f8 01       	movw	r30, r16
     4a4:	80 81       	ld	r24, Z
     4a6:	80 64       	ori	r24, 0x40	; 64
     4a8:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4aa:	f8 01       	movw	r30, r16
     4ac:	80 81       	ld	r24, Z
     4ae:	84 ff       	sbrs	r24, 4
     4b0:	fc cf       	rjmp	.-8      	; 0x4aa <start_gas_sensor_read+0x6a>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4b2:	f7 01       	movw	r30, r14
     4b4:	80 81       	ld	r24, Z
     4b6:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4b8:	e9 81       	ldd	r30, Y+1	; 0x01
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	ee 0f       	add	r30, r30
     4c2:	ff 1f       	adc	r31, r31
     4c4:	ed 5a       	subi	r30, 0xAD	; 173
     4c6:	fa 4f       	sbci	r31, 0xFA	; 250
     4c8:	40 81       	ld	r20, Z
     4ca:	51 81       	ldd	r21, Z+1	; 0x01
     4cc:	e9 81       	ldd	r30, Y+1	; 0x01
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	ed 5a       	subi	r30, 0xAD	; 173
     4da:	fa 4f       	sbci	r31, 0xFA	; 250
     4dc:	62 81       	ldd	r22, Z+2	; 0x02
     4de:	73 81       	ldd	r23, Z+3	; 0x03
     4e0:	eb 2d       	mov	r30, r11
     4e2:	68 17       	cp	r22, r24
     4e4:	79 07       	cpc	r23, r25
     4e6:	08 f0       	brcs	.+2      	; 0x4ea <start_gas_sensor_read+0xaa>
     4e8:	ea 2d       	mov	r30, r10
     4ea:	e1 11       	cpse	r30, r1
     4ec:	07 c0       	rjmp	.+14     	; 0x4fc <start_gas_sensor_read+0xbc>
     4ee:	6b 2d       	mov	r22, r11
     4f0:	84 17       	cp	r24, r20
     4f2:	95 07       	cpc	r25, r21
     4f4:	08 f0       	brcs	.+2      	; 0x4f8 <start_gas_sensor_read+0xb8>
     4f6:	6a 2d       	mov	r22, r10
     4f8:	66 23       	and	r22, r22
     4fa:	71 f0       	breq	.+28     	; 0x518 <start_gas_sensor_read+0xd8>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     4fc:	59 81       	ldd	r21, Y+1	; 0x01
     4fe:	60 91 7e 05 	lds	r22, 0x057E	; 0x80057e <gas_sensor_initialization_errors>
     502:	5d 5f       	subi	r21, 0xFD	; 253
     504:	f6 01       	movw	r30, r12
     506:	02 c0       	rjmp	.+4      	; 0x50c <start_gas_sensor_read+0xcc>
     508:	ee 0f       	add	r30, r30
     50a:	ff 1f       	adc	r31, r31
     50c:	5a 95       	dec	r21
     50e:	e2 f7       	brpl	.-8      	; 0x508 <start_gas_sensor_read+0xc8>
     510:	af 01       	movw	r20, r30
     512:	46 2b       	or	r20, r22
     514:	40 93 7e 05 	sts	0x057E, r20	; 0x80057e <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     518:	4a 81       	ldd	r20, Y+2	; 0x02
     51a:	5b 81       	ldd	r21, Y+3	; 0x03
     51c:	84 0f       	add	r24, r20
     51e:	95 1f       	adc	r25, r21
     520:	9b 83       	std	Y+3, r25	; 0x03
     522:	8a 83       	std	Y+2, r24	; 0x02
     524:	21 50       	subi	r18, 0x01	; 1
     526:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
     528:	09 f0       	breq	.+2      	; 0x52c <start_gas_sensor_read+0xec>
     52a:	bb cf       	rjmp	.-138    	; 0x4a2 <start_gas_sensor_read+0x62>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     52c:	8a 81       	ldd	r24, Y+2	; 0x02
     52e:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     530:	e9 81       	ldd	r30, Y+1	; 0x01
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	ee 58       	subi	r30, 0x8E	; 142
     53a:	fa 4f       	sbci	r31, 0xFA	; 250
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     53c:	9c 01       	movw	r18, r24
     53e:	99 23       	and	r25, r25
     540:	14 f4       	brge	.+4      	; 0x546 <start_gas_sensor_read+0x106>
     542:	2d 5f       	subi	r18, 0xFD	; 253
     544:	3f 4f       	sbci	r19, 0xFF	; 255
     546:	35 95       	asr	r19
     548:	27 95       	ror	r18
     54a:	35 95       	asr	r19
     54c:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
     54e:	31 83       	std	Z+1, r19	; 0x01
     550:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     552:	89 81       	ldd	r24, Y+1	; 0x01
     554:	8f 5f       	subi	r24, 0xFF	; 255
     556:	89 83       	std	Y+1, r24	; 0x01
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	85 30       	cpi	r24, 0x05	; 5
     55c:	08 f4       	brcc	.+2      	; 0x560 <start_gas_sensor_read+0x120>
     55e:	9b cf       	rjmp	.-202    	; 0x496 <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	1f 91       	pop	r17
     56c:	0f 91       	pop	r16
     56e:	ff 90       	pop	r15
     570:	ef 90       	pop	r14
     572:	df 90       	pop	r13
     574:	cf 90       	pop	r12
     576:	bf 90       	pop	r11
     578:	af 90       	pop	r10
     57a:	9f 90       	pop	r9
     57c:	8f 90       	pop	r8
     57e:	08 95       	ret

00000580 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     580:	1f 93       	push	r17
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     586:	e5 e8       	ldi	r30, 0x85	; 133
     588:	f5 e0       	ldi	r31, 0x05	; 5
     58a:	84 ec       	ldi	r24, 0xC4	; 196
     58c:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     58e:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     590:	84 e0       	ldi	r24, 0x04	; 4
     592:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     594:	63 e0       	ldi	r22, 0x03	; 3
     596:	cf 01       	movw	r24, r30
     598:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     59c:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     5a0:	81 11       	cpse	r24, r1
     5a2:	fc cf       	rjmp	.-8      	; 0x59c <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5a4:	e5 e8       	ldi	r30, 0x85	; 133
     5a6:	f5 e0       	ldi	r31, 0x05	; 5
     5a8:	84 ec       	ldi	r24, 0xC4	; 196
     5aa:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b0:	62 e0       	ldi	r22, 0x02	; 2
     5b2:	cf 01       	movw	r24, r30
     5b4:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5b8:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     5bc:	81 11       	cpse	r24, r1
     5be:	fc cf       	rjmp	.-8      	; 0x5b8 <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5c0:	c5 e8       	ldi	r28, 0x85	; 133
     5c2:	d5 e0       	ldi	r29, 0x05	; 5
     5c4:	15 ec       	ldi	r17, 0xC5	; 197
     5c6:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5c8:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5ca:	62 e0       	ldi	r22, 0x02	; 2
     5cc:	ce 01       	movw	r24, r28
     5ce:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5d2:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     5d6:	81 11       	cpse	r24, r1
     5d8:	fc cf       	rjmp	.-8      	; 0x5d2 <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5da:	62 e0       	ldi	r22, 0x02	; 2
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     5e2:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5e6:	89 81       	ldd	r24, Y+1	; 0x01
     5e8:	80 93 96 06 	sts	0x0696, r24	; 0x800696 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5ec:	80 fd       	sbrc	r24, 0
     5ee:	eb cf       	rjmp	.-42     	; 0x5c6 <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5f0:	e5 e8       	ldi	r30, 0x85	; 133
     5f2:	f5 e0       	ldi	r31, 0x05	; 5
     5f4:	84 ec       	ldi	r24, 0xC4	; 196
     5f6:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     5f8:	8f e8       	ldi	r24, 0x8F	; 143
     5fa:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5fc:	62 e0       	ldi	r22, 0x02	; 2
     5fe:	cf 01       	movw	r24, r30
     600:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     604:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     608:	81 11       	cpse	r24, r1
     60a:	fc cf       	rjmp	.-8      	; 0x604 <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     60c:	e5 e8       	ldi	r30, 0x85	; 133
     60e:	f5 e0       	ldi	r31, 0x05	; 5
     610:	85 ec       	ldi	r24, 0xC5	; 197
     612:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     614:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     616:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     618:	63 e0       	ldi	r22, 0x03	; 3
     61a:	cf 01       	movw	r24, r30
     61c:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     620:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     624:	81 11       	cpse	r24, r1
     626:	fc cf       	rjmp	.-8      	; 0x620 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     628:	63 e0       	ldi	r22, 0x03	; 3
     62a:	85 e8       	ldi	r24, 0x85	; 133
     62c:	95 e0       	ldi	r25, 0x05	; 5
     62e:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     632:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     636:	e5 e8       	ldi	r30, 0x85	; 133
     638:	f5 e0       	ldi	r31, 0x05	; 5
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	98 2f       	mov	r25, r24
     640:	88 27       	eor	r24, r24
     642:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
     644:	82 0f       	add	r24, r18
     646:	91 1d       	adc	r25, r1
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret

00000650 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     650:	ff 92       	push	r15
     652:	0f 93       	push	r16
     654:	1f 93       	push	r17
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     65a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     65e:	88 23       	and	r24, r24
     660:	59 f1       	breq	.+86     	; 0x6b8 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     662:	c6 e9       	ldi	r28, 0x96	; 150
     664:	d5 e0       	ldi	r29, 0x05	; 5
     666:	0f 2e       	mov	r0, r31
     668:	fc ee       	ldi	r31, 0xEC	; 236
     66a:	ff 2e       	mov	r15, r31
     66c:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     66e:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     670:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     672:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     674:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     676:	62 e0       	ldi	r22, 0x02	; 2
     678:	ce 01       	movw	r24, r28
     67a:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     67e:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     682:	81 11       	cpse	r24, r1
     684:	fc cf       	rjmp	.-8      	; 0x67e <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     686:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     688:	6a e1       	ldi	r22, 0x1A	; 26
     68a:	ce 01       	movw	r24, r28
     68c:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     690:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     694:	81 11       	cpse	r24, r1
     696:	fc cf       	rjmp	.-8      	; 0x690 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     698:	6a e1       	ldi	r22, 0x1A	; 26
     69a:	ce 01       	movw	r24, r28
     69c:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     6a0:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6a4:	89 81       	ldd	r24, Y+1	; 0x01
     6a6:	83 fb       	bst	r24, 3
     6a8:	88 27       	eor	r24, r24
     6aa:	80 f9       	bld	r24, 0
     6ac:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6b0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6b4:	81 11       	cpse	r24, r1
     6b6:	dd cf       	rjmp	.-70     	; 0x672 <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6b8:	e6 e9       	ldi	r30, 0x96	; 150
     6ba:	f5 e0       	ldi	r31, 0x05	; 5
     6bc:	8c ee       	ldi	r24, 0xEC	; 236
     6be:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6c0:	88 e8       	ldi	r24, 0x88	; 136
     6c2:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6c4:	62 e0       	ldi	r22, 0x02	; 2
     6c6:	cf 01       	movw	r24, r30
     6c8:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6cc:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     6d0:	81 11       	cpse	r24, r1
     6d2:	fc cf       	rjmp	.-8      	; 0x6cc <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6d4:	8d ee       	ldi	r24, 0xED	; 237
     6d6:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6da:	6b e1       	ldi	r22, 0x1B	; 27
     6dc:	86 e9       	ldi	r24, 0x96	; 150
     6de:	95 e0       	ldi	r25, 0x05	; 5
     6e0:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6e4:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     6e8:	81 11       	cpse	r24, r1
     6ea:	fc cf       	rjmp	.-8      	; 0x6e4 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     6ec:	6b e1       	ldi	r22, 0x1B	; 27
     6ee:	86 e9       	ldi	r24, 0x96	; 150
     6f0:	95 e0       	ldi	r25, 0x05	; 5
     6f2:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     6f6:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
     6fa:	c7 e9       	ldi	r28, 0x97	; 151
     6fc:	d5 e0       	ldi	r29, 0x05	; 5
     6fe:	0f e9       	ldi	r16, 0x9F	; 159
     700:	16 e0       	ldi	r17, 0x06	; 6
     702:	22 eb       	ldi	r18, 0xB2	; 178
     704:	35 e0       	ldi	r19, 0x05	; 5
     706:	d8 01       	movw	r26, r16
     708:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     70a:	81 91       	ld	r24, Z+
     70c:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     70e:	e2 17       	cp	r30, r18
     710:	f3 07       	cpc	r31, r19
     712:	d9 f7       	brne	.-10     	; 0x70a <BME_read_correction_coefficients+0xba>
     714:	8b e1       	ldi	r24, 0x1B	; 27
     716:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <i.2289>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     71a:	ef e9       	ldi	r30, 0x9F	; 159
     71c:	f6 e0       	ldi	r31, 0x06	; 6
     71e:	81 81       	ldd	r24, Z+1	; 0x01
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	98 2f       	mov	r25, r24
     724:	88 27       	eor	r24, r24
     726:	20 81       	ld	r18, Z
     728:	82 2b       	or	r24, r18
     72a:	90 93 9a 06 	sts	0x069A, r25	; 0x80069a <dig_T1+0x1>
     72e:	80 93 99 06 	sts	0x0699, r24	; 0x800699 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     732:	83 81       	ldd	r24, Z+3	; 0x03
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	98 2f       	mov	r25, r24
     738:	88 27       	eor	r24, r24
     73a:	22 81       	ldd	r18, Z+2	; 0x02
     73c:	82 2b       	or	r24, r18
     73e:	90 93 9e 06 	sts	0x069E, r25	; 0x80069e <dig_T2+0x1>
     742:	80 93 9d 06 	sts	0x069D, r24	; 0x80069d <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     746:	85 81       	ldd	r24, Z+5	; 0x05
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	98 2f       	mov	r25, r24
     74c:	88 27       	eor	r24, r24
     74e:	24 81       	ldd	r18, Z+4	; 0x04
     750:	82 2b       	or	r24, r18
     752:	90 93 00 07 	sts	0x0700, r25	; 0x800700 <dig_T3+0x1>
     756:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     75a:	87 81       	ldd	r24, Z+7	; 0x07
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	98 2f       	mov	r25, r24
     760:	88 27       	eor	r24, r24
     762:	26 81       	ldd	r18, Z+6	; 0x06
     764:	82 2b       	or	r24, r18
     766:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <dig_P1+0x1>
     76a:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     76e:	81 85       	ldd	r24, Z+9	; 0x09
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	98 2f       	mov	r25, r24
     774:	88 27       	eor	r24, r24
     776:	20 85       	ldd	r18, Z+8	; 0x08
     778:	82 2b       	or	r24, r18
     77a:	90 93 d2 06 	sts	0x06D2, r25	; 0x8006d2 <dig_P2+0x1>
     77e:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     782:	83 85       	ldd	r24, Z+11	; 0x0b
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	98 2f       	mov	r25, r24
     788:	88 27       	eor	r24, r24
     78a:	22 85       	ldd	r18, Z+10	; 0x0a
     78c:	82 2b       	or	r24, r18
     78e:	90 93 f6 06 	sts	0x06F6, r25	; 0x8006f6 <dig_P3+0x1>
     792:	80 93 f5 06 	sts	0x06F5, r24	; 0x8006f5 <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     796:	85 85       	ldd	r24, Z+13	; 0x0d
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	98 2f       	mov	r25, r24
     79c:	88 27       	eor	r24, r24
     79e:	24 85       	ldd	r18, Z+12	; 0x0c
     7a0:	82 2b       	or	r24, r18
     7a2:	90 93 d4 06 	sts	0x06D4, r25	; 0x8006d4 <dig_P4+0x1>
     7a6:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7aa:	87 85       	ldd	r24, Z+15	; 0x0f
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	98 2f       	mov	r25, r24
     7b0:	88 27       	eor	r24, r24
     7b2:	26 85       	ldd	r18, Z+14	; 0x0e
     7b4:	82 2b       	or	r24, r18
     7b6:	90 93 e3 06 	sts	0x06E3, r25	; 0x8006e3 <dig_P5+0x1>
     7ba:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7be:	81 89       	ldd	r24, Z+17	; 0x11
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	98 2f       	mov	r25, r24
     7c4:	88 27       	eor	r24, r24
     7c6:	20 89       	ldd	r18, Z+16	; 0x10
     7c8:	82 2b       	or	r24, r18
     7ca:	90 93 02 07 	sts	0x0702, r25	; 0x800702 <dig_P6+0x1>
     7ce:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7d2:	83 89       	ldd	r24, Z+19	; 0x13
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	98 2f       	mov	r25, r24
     7d8:	88 27       	eor	r24, r24
     7da:	22 89       	ldd	r18, Z+18	; 0x12
     7dc:	82 2b       	or	r24, r18
     7de:	90 93 98 06 	sts	0x0698, r25	; 0x800698 <dig_P7+0x1>
     7e2:	80 93 97 06 	sts	0x0697, r24	; 0x800697 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7e6:	85 89       	ldd	r24, Z+21	; 0x15
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	98 2f       	mov	r25, r24
     7ec:	88 27       	eor	r24, r24
     7ee:	24 89       	ldd	r18, Z+20	; 0x14
     7f0:	82 2b       	or	r24, r18
     7f2:	90 93 f8 06 	sts	0x06F8, r25	; 0x8006f8 <dig_P8+0x1>
     7f6:	80 93 f7 06 	sts	0x06F7, r24	; 0x8006f7 <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     7fa:	87 89       	ldd	r24, Z+23	; 0x17
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	98 2f       	mov	r25, r24
     800:	88 27       	eor	r24, r24
     802:	26 89       	ldd	r18, Z+22	; 0x16
     804:	82 2b       	or	r24, r18
     806:	90 93 fe 06 	sts	0x06FE, r25	; 0x8006fe <dig_P9+0x1>
     80a:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <dig_P9>
	dig_H1 = RawBMEdata[25];
     80e:	81 8d       	ldd	r24, Z+25	; 0x19
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <dig_H1+0x1>
     816:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     81a:	e6 e9       	ldi	r30, 0x96	; 150
     81c:	f5 e0       	ldi	r31, 0x05	; 5
     81e:	8c ee       	ldi	r24, 0xEC	; 236
     820:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     822:	81 ee       	ldi	r24, 0xE1	; 225
     824:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     826:	62 e0       	ldi	r22, 0x02	; 2
     828:	cf 01       	movw	r24, r30
     82a:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     82e:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     832:	81 11       	cpse	r24, r1
     834:	fc cf       	rjmp	.-8      	; 0x82e <BME_read_correction_coefficients+0x1de>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     836:	8d ee       	ldi	r24, 0xED	; 237
     838:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     83c:	68 e0       	ldi	r22, 0x08	; 8
     83e:	86 e9       	ldi	r24, 0x96	; 150
     840:	95 e0       	ldi	r25, 0x05	; 5
     842:	0e 94 2e 0c 	call	0x185c	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     846:	0e 94 2a 0c 	call	0x1854	; 0x1854 <TWI_Transceiver_Busy>
     84a:	81 11       	cpse	r24, r1
     84c:	fc cf       	rjmp	.-8      	; 0x846 <BME_read_correction_coefficients+0x1f6>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     84e:	68 e0       	ldi	r22, 0x08	; 8
     850:	86 e9       	ldi	r24, 0x96	; 150
     852:	95 e0       	ldi	r25, 0x05	; 5
     854:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     858:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
     85c:	2e e9       	ldi	r18, 0x9E	; 158
     85e:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     860:	89 91       	ld	r24, Y+
     862:	f8 01       	movw	r30, r16
     864:	81 93       	st	Z+, r24
     866:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     868:	c2 17       	cp	r28, r18
     86a:	d3 07       	cpc	r29, r19
     86c:	c9 f7       	brne	.-14     	; 0x860 <BME_read_correction_coefficients+0x210>
     86e:	87 e0       	ldi	r24, 0x07	; 7
     870:	80 93 21 03 	sts	0x0321, r24	; 0x800321 <i.2289>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8); 
     874:	ef e9       	ldi	r30, 0x9F	; 159
     876:	f6 e0       	ldi	r31, 0x06	; 6
     878:	82 81       	ldd	r24, Z+2	; 0x02
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	98 2f       	mov	r25, r24
     87e:	88 27       	eor	r24, r24
     880:	21 81       	ldd	r18, Z+1	; 0x01
     882:	82 2b       	or	r24, r18
     884:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <dig_H2+0x1>
     888:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <dig_H2>
	dig_H3 = RawBMEdata[3]; 
     88c:	83 81       	ldd	r24, Z+3	; 0x03
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <dig_H3+0x1>
     894:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     898:	85 81       	ldd	r24, Z+5	; 0x05
     89a:	82 95       	swap	r24
     89c:	86 95       	lsr	r24
     89e:	87 70       	andi	r24, 0x07	; 7
     8a0:	90 e0       	ldi	r25, 0x00	; 0
     8a2:	24 81       	ldd	r18, Z+4	; 0x04
     8a4:	40 e1       	ldi	r20, 0x10	; 16
     8a6:	24 9f       	mul	r18, r20
     8a8:	90 01       	movw	r18, r0
     8aa:	11 24       	eor	r1, r1
     8ac:	28 2b       	or	r18, r24
     8ae:	39 2b       	or	r19, r25
     8b0:	30 93 9c 06 	sts	0x069C, r19	; 0x80069c <dig_H4+0x1>
     8b4:	20 93 9b 06 	sts	0x069B, r18	; 0x80069b <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     8b8:	26 81       	ldd	r18, Z+6	; 0x06
     8ba:	40 e1       	ldi	r20, 0x10	; 16
     8bc:	24 9f       	mul	r18, r20
     8be:	90 01       	movw	r18, r0
     8c0:	11 24       	eor	r1, r1
     8c2:	82 2b       	or	r24, r18
     8c4:	93 2b       	or	r25, r19
     8c6:	90 93 fa 06 	sts	0x06FA, r25	; 0x8006fa <dig_H5+0x1>
     8ca:	80 93 f9 06 	sts	0x06F9, r24	; 0x8006f9 <dig_H5>
	dig_H6 = RawBMEdata[7];
     8ce:	87 81       	ldd	r24, Z+7	; 0x07
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	90 93 dd 06 	sts	0x06DD, r25	; 0x8006dd <dig_H6+0x1>
     8d6:	80 93 dc 06 	sts	0x06DC, r24	; 0x8006dc <dig_H6>
}
     8da:	df 91       	pop	r29
     8dc:	cf 91       	pop	r28
     8de:	1f 91       	pop	r17
     8e0:	0f 91       	pop	r16
     8e2:	ff 90       	pop	r15
     8e4:	08 95       	ret

000008e6 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8e6:	e6 e9       	ldi	r30, 0x96	; 150
     8e8:	f5 e0       	ldi	r31, 0x05	; 5
     8ea:	8c ee       	ldi	r24, 0xEC	; 236
     8ec:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     8ee:	80 ee       	ldi	r24, 0xE0	; 224
     8f0:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     8f2:	86 eb       	ldi	r24, 0xB6	; 182
     8f4:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     8f6:	63 e0       	ldi	r22, 0x03	; 3
     8f8:	cf 01       	movw	r24, r30
     8fa:	b0 d7       	rcall	.+3936   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     8fc:	ab d7       	rcall	.+3926   	; 0x1854 <TWI_Transceiver_Busy>
     8fe:	81 11       	cpse	r24, r1
     900:	fd cf       	rjmp	.-6      	; 0x8fc <bme280basic_init+0x16>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     902:	e6 e9       	ldi	r30, 0x96	; 150
     904:	f5 e0       	ldi	r31, 0x05	; 5
     906:	8c ee       	ldi	r24, 0xEC	; 236
     908:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     90a:	80 ed       	ldi	r24, 0xD0	; 208
     90c:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     90e:	62 e0       	ldi	r22, 0x02	; 2
     910:	cf 01       	movw	r24, r30
     912:	a4 d7       	rcall	.+3912   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     914:	9f d7       	rcall	.+3902   	; 0x1854 <TWI_Transceiver_Busy>
     916:	81 11       	cpse	r24, r1
     918:	fd cf       	rjmp	.-6      	; 0x914 <__stack+0x15>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     91a:	8d ee       	ldi	r24, 0xED	; 237
     91c:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     920:	62 e0       	ldi	r22, 0x02	; 2
     922:	86 e9       	ldi	r24, 0x96	; 150
     924:	95 e0       	ldi	r25, 0x05	; 5
     926:	9a d7       	rcall	.+3892   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     928:	95 d7       	rcall	.+3882   	; 0x1854 <TWI_Transceiver_Busy>
     92a:	81 11       	cpse	r24, r1
     92c:	fd cf       	rjmp	.-6      	; 0x928 <__stack+0x29>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     92e:	62 e0       	ldi	r22, 0x02	; 2
     930:	86 e9       	ldi	r24, 0x96	; 150
     932:	95 e0       	ldi	r25, 0x05	; 5
     934:	bf d7       	rcall	.+3966   	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     936:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     93a:	80 91 97 05 	lds	r24, 0x0597	; 0x800597 <BMEmessageBuf+0x1>
     93e:	80 36       	cpi	r24, 0x60	; 96
     940:	69 f5       	brne	.+90     	; 0x99c <__stack+0x9d>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     942:	e6 e9       	ldi	r30, 0x96	; 150
     944:	f5 e0       	ldi	r31, 0x05	; 5
     946:	8c ee       	ldi	r24, 0xEC	; 236
     948:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     94a:	82 ef       	ldi	r24, 0xF2	; 242
     94c:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     94e:	81 e0       	ldi	r24, 0x01	; 1
     950:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     952:	63 e0       	ldi	r22, 0x03	; 3
     954:	cf 01       	movw	r24, r30
     956:	82 d7       	rcall	.+3844   	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     958:	7d d7       	rcall	.+3834   	; 0x1854 <TWI_Transceiver_Busy>
     95a:	81 11       	cpse	r24, r1
     95c:	fd cf       	rjmp	.-6      	; 0x958 <__stack+0x59>
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     95e:	e6 e9       	ldi	r30, 0x96	; 150
     960:	f5 e0       	ldi	r31, 0x05	; 5
     962:	8c ee       	ldi	r24, 0xEC	; 236
     964:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     966:	85 ef       	ldi	r24, 0xF5	; 245
     968:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     96a:	80 e1       	ldi	r24, 0x10	; 16
     96c:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     96e:	63 e0       	ldi	r22, 0x03	; 3
     970:	cf 01       	movw	r24, r30
     972:	74 d7       	rcall	.+3816   	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     974:	6f d7       	rcall	.+3806   	; 0x1854 <TWI_Transceiver_Busy>
     976:	81 11       	cpse	r24, r1
     978:	fd cf       	rjmp	.-6      	; 0x974 <__stack+0x75>
		//
		BME_read_correction_coefficients();
     97a:	6a de       	rcall	.-812    	; 0x650 <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     97c:	81 e3       	ldi	r24, 0x31	; 49
     97e:	80 93 d5 06 	sts	0x06D5, r24	; 0x8006d5 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     982:	e6 e9       	ldi	r30, 0x96	; 150
     984:	f5 e0       	ldi	r31, 0x05	; 5
     986:	9c ee       	ldi	r25, 0xEC	; 236
     988:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     98a:	94 ef       	ldi	r25, 0xF4	; 244
     98c:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     98e:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     990:	63 e0       	ldi	r22, 0x03	; 3
     992:	cf 01       	movw	r24, r30
     994:	63 d7       	rcall	.+3782   	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     996:	5e d7       	rcall	.+3772   	; 0x1854 <TWI_Transceiver_Busy>
     998:	81 11       	cpse	r24, r1
     99a:	fd cf       	rjmp	.-6      	; 0x996 <__stack+0x97>
     99c:	08 95       	ret

0000099e <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     99e:	ff 92       	push	r15
     9a0:	0f 93       	push	r16
     9a2:	1f 93       	push	r17
     9a4:	cf 93       	push	r28
     9a6:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <BMEbusy.2343>
	while (BMEbusy) {
     9ae:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <BMEbusy.2343>
     9b2:	88 23       	and	r24, r24
     9b4:	31 f1       	breq	.+76     	; 0xa02 <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9b6:	c6 e9       	ldi	r28, 0x96	; 150
     9b8:	d5 e0       	ldi	r29, 0x05	; 5
     9ba:	0f 2e       	mov	r0, r31
     9bc:	fc ee       	ldi	r31, 0xEC	; 236
     9be:	ff 2e       	mov	r15, r31
     9c0:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9c2:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9c4:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9c6:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9c8:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9ca:	62 e0       	ldi	r22, 0x02	; 2
     9cc:	ce 01       	movw	r24, r28
     9ce:	46 d7       	rcall	.+3724   	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9d0:	41 d7       	rcall	.+3714   	; 0x1854 <TWI_Transceiver_Busy>
     9d2:	81 11       	cpse	r24, r1
     9d4:	fd cf       	rjmp	.-6      	; 0x9d0 <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9d6:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     9d8:	62 e0       	ldi	r22, 0x02	; 2
     9da:	ce 01       	movw	r24, r28
     9dc:	3f d7       	rcall	.+3710   	; 0x185c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9de:	3a d7       	rcall	.+3700   	; 0x1854 <TWI_Transceiver_Busy>
     9e0:	81 11       	cpse	r24, r1
     9e2:	fd cf       	rjmp	.-6      	; 0x9de <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9e4:	62 e0       	ldi	r22, 0x02	; 2
     9e6:	ce 01       	movw	r24, r28
     9e8:	65 d7       	rcall	.+3786   	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     9ea:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     9ee:	89 81       	ldd	r24, Y+1	; 0x01
     9f0:	83 fb       	bst	r24, 3
     9f2:	88 27       	eor	r24, r24
     9f4:	80 f9       	bld	r24, 0
     9f6:	80 93 20 03 	sts	0x0320, r24	; 0x800320 <BMEbusy.2343>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     9fa:	80 91 20 03 	lds	r24, 0x0320	; 0x800320 <BMEbusy.2343>
     9fe:	81 11       	cpse	r24, r1
     a00:	e2 cf       	rjmp	.-60     	; 0x9c6 <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     a02:	e6 e9       	ldi	r30, 0x96	; 150
     a04:	f5 e0       	ldi	r31, 0x05	; 5
     a06:	8c ee       	ldi	r24, 0xEC	; 236
     a08:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     a0a:	87 ef       	ldi	r24, 0xF7	; 247
     a0c:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     a0e:	62 e0       	ldi	r22, 0x02	; 2
     a10:	cf 01       	movw	r24, r30
     a12:	24 d7       	rcall	.+3656   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a14:	1f d7       	rcall	.+3646   	; 0x1854 <TWI_Transceiver_Busy>
     a16:	81 11       	cpse	r24, r1
     a18:	fd cf       	rjmp	.-6      	; 0xa14 <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     a1a:	8d ee       	ldi	r24, 0xED	; 237
     a1c:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     a20:	69 e0       	ldi	r22, 0x09	; 9
     a22:	86 e9       	ldi	r24, 0x96	; 150
     a24:	95 e0       	ldi	r25, 0x05	; 5
     a26:	1a d7       	rcall	.+3636   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a28:	15 d7       	rcall	.+3626   	; 0x1854 <TWI_Transceiver_Busy>
     a2a:	81 11       	cpse	r24, r1
     a2c:	fd cf       	rjmp	.-6      	; 0xa28 <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     a2e:	69 e0       	ldi	r22, 0x09	; 9
     a30:	86 e9       	ldi	r24, 0x96	; 150
     a32:	95 e0       	ldi	r25, 0x05	; 5
     a34:	3f d7       	rcall	.+3710   	; 0x18b4 <TWI_Get_Data_From_Transceiver>
     a36:	80 93 95 05 	sts	0x0595, r24	; 0x800595 <TWI_XFER_STATUS>
     a3a:	e7 e9       	ldi	r30, 0x97	; 151
     a3c:	f5 e0       	ldi	r31, 0x05	; 5
     a3e:	af e9       	ldi	r26, 0x9F	; 159
     a40:	b6 e0       	ldi	r27, 0x06	; 6
     a42:	2f e9       	ldi	r18, 0x9F	; 159
     a44:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a46:	81 91       	ld	r24, Z+
     a48:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a4a:	e2 17       	cp	r30, r18
     a4c:	f3 07       	cpc	r31, r19
     a4e:	d9 f7       	brne	.-10     	; 0xa46 <bme280basic_bulk_data_read+0xa8>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a50:	ef e9       	ldi	r30, 0x9F	; 159
     a52:	f6 e0       	ldi	r31, 0x06	; 6
     a54:	81 81       	ldd	r24, Z+1	; 0x01
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	a0 e0       	ldi	r26, 0x00	; 0
     a5a:	b0 e0       	ldi	r27, 0x00	; 0
     a5c:	88 0f       	add	r24, r24
     a5e:	99 1f       	adc	r25, r25
     a60:	aa 1f       	adc	r26, r26
     a62:	bb 1f       	adc	r27, r27
     a64:	88 0f       	add	r24, r24
     a66:	99 1f       	adc	r25, r25
     a68:	aa 1f       	adc	r26, r26
     a6a:	bb 1f       	adc	r27, r27
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	aa 1f       	adc	r26, r26
     a72:	bb 1f       	adc	r27, r27
     a74:	88 0f       	add	r24, r24
     a76:	99 1f       	adc	r25, r25
     a78:	aa 1f       	adc	r26, r26
     a7a:	bb 1f       	adc	r27, r27
     a7c:	40 81       	ld	r20, Z
     a7e:	50 e0       	ldi	r21, 0x00	; 0
     a80:	60 e0       	ldi	r22, 0x00	; 0
     a82:	70 e0       	ldi	r23, 0x00	; 0
     a84:	03 2e       	mov	r0, r19
     a86:	3c e0       	ldi	r19, 0x0C	; 12
     a88:	44 0f       	add	r20, r20
     a8a:	55 1f       	adc	r21, r21
     a8c:	66 1f       	adc	r22, r22
     a8e:	77 1f       	adc	r23, r23
     a90:	3a 95       	dec	r19
     a92:	d1 f7       	brne	.-12     	; 0xa88 <bme280basic_bulk_data_read+0xea>
     a94:	30 2d       	mov	r19, r0
     a96:	84 2b       	or	r24, r20
     a98:	95 2b       	or	r25, r21
     a9a:	a6 2b       	or	r26, r22
     a9c:	b7 2b       	or	r27, r23
     a9e:	22 81       	ldd	r18, Z+2	; 0x02
     aa0:	22 95       	swap	r18
     aa2:	2f 70       	andi	r18, 0x0F	; 15
     aa4:	82 2b       	or	r24, r18
     aa6:	80 93 e5 06 	sts	0x06E5, r24	; 0x8006e5 <rawPress>
     aaa:	90 93 e6 06 	sts	0x06E6, r25	; 0x8006e6 <rawPress+0x1>
     aae:	a0 93 e7 06 	sts	0x06E7, r26	; 0x8006e7 <rawPress+0x2>
     ab2:	b0 93 e8 06 	sts	0x06E8, r27	; 0x8006e8 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     ab6:	84 81       	ldd	r24, Z+4	; 0x04
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	a0 e0       	ldi	r26, 0x00	; 0
     abc:	b0 e0       	ldi	r27, 0x00	; 0
     abe:	88 0f       	add	r24, r24
     ac0:	99 1f       	adc	r25, r25
     ac2:	aa 1f       	adc	r26, r26
     ac4:	bb 1f       	adc	r27, r27
     ac6:	88 0f       	add	r24, r24
     ac8:	99 1f       	adc	r25, r25
     aca:	aa 1f       	adc	r26, r26
     acc:	bb 1f       	adc	r27, r27
     ace:	88 0f       	add	r24, r24
     ad0:	99 1f       	adc	r25, r25
     ad2:	aa 1f       	adc	r26, r26
     ad4:	bb 1f       	adc	r27, r27
     ad6:	88 0f       	add	r24, r24
     ad8:	99 1f       	adc	r25, r25
     ada:	aa 1f       	adc	r26, r26
     adc:	bb 1f       	adc	r27, r27
     ade:	43 81       	ldd	r20, Z+3	; 0x03
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	60 e0       	ldi	r22, 0x00	; 0
     ae4:	70 e0       	ldi	r23, 0x00	; 0
     ae6:	03 2e       	mov	r0, r19
     ae8:	3c e0       	ldi	r19, 0x0C	; 12
     aea:	44 0f       	add	r20, r20
     aec:	55 1f       	adc	r21, r21
     aee:	66 1f       	adc	r22, r22
     af0:	77 1f       	adc	r23, r23
     af2:	3a 95       	dec	r19
     af4:	d1 f7       	brne	.-12     	; 0xaea <bme280basic_bulk_data_read+0x14c>
     af6:	30 2d       	mov	r19, r0
     af8:	84 2b       	or	r24, r20
     afa:	95 2b       	or	r25, r21
     afc:	a6 2b       	or	r26, r22
     afe:	b7 2b       	or	r27, r23
     b00:	25 81       	ldd	r18, Z+5	; 0x05
     b02:	22 95       	swap	r18
     b04:	2f 70       	andi	r18, 0x0F	; 15
     b06:	82 2b       	or	r24, r18
     b08:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <rawTemp>
     b0c:	90 93 ce 06 	sts	0x06CE, r25	; 0x8006ce <rawTemp+0x1>
     b10:	a0 93 cf 06 	sts	0x06CF, r26	; 0x8006cf <rawTemp+0x2>
     b14:	b0 93 d0 06 	sts	0x06D0, r27	; 0x8006d0 <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     b18:	86 81       	ldd	r24, Z+6	; 0x06
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	a0 e0       	ldi	r26, 0x00	; 0
     b1e:	b0 e0       	ldi	r27, 0x00	; 0
     b20:	ba 2f       	mov	r27, r26
     b22:	a9 2f       	mov	r26, r25
     b24:	98 2f       	mov	r25, r24
     b26:	88 27       	eor	r24, r24
     b28:	27 81       	ldd	r18, Z+7	; 0x07
     b2a:	82 2b       	or	r24, r18
     b2c:	80 93 e9 06 	sts	0x06E9, r24	; 0x8006e9 <rawHum>
     b30:	90 93 ea 06 	sts	0x06EA, r25	; 0x8006ea <rawHum+0x1>
     b34:	a0 93 eb 06 	sts	0x06EB, r26	; 0x8006eb <rawHum+0x2>
     b38:	b0 93 ec 06 	sts	0x06EC, r27	; 0x8006ec <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     b3c:	e6 e9       	ldi	r30, 0x96	; 150
     b3e:	f5 e0       	ldi	r31, 0x05	; 5
     b40:	8c ee       	ldi	r24, 0xEC	; 236
     b42:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b44:	84 ef       	ldi	r24, 0xF4	; 244
     b46:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b48:	81 e3       	ldi	r24, 0x31	; 49
     b4a:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b4c:	63 e0       	ldi	r22, 0x03	; 3
     b4e:	cf 01       	movw	r24, r30
     b50:	85 d6       	rcall	.+3338   	; 0x185c <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b52:	80 d6       	rcall	.+3328   	; 0x1854 <TWI_Transceiver_Busy>
     b54:	81 11       	cpse	r24, r1
     b56:	fd cf       	rjmp	.-6      	; 0xb52 <bme280basic_bulk_data_read+0x1b4>
	//  All done - and the next measurement cycle has  been kicked off!
}
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	ff 90       	pop	r15
     b62:	08 95       	ret

00000b64 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b64:	8f 92       	push	r8
     b66:	9f 92       	push	r9
     b68:	af 92       	push	r10
     b6a:	bf 92       	push	r11
     b6c:	cf 92       	push	r12
     b6e:	df 92       	push	r13
     b70:	ef 92       	push	r14
     b72:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b74:	20 91 99 06 	lds	r18, 0x0699	; 0x800699 <dig_T1>
     b78:	30 91 9a 06 	lds	r19, 0x069A	; 0x80069a <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b7c:	6b 01       	movw	r12, r22
     b7e:	7c 01       	movw	r14, r24
     b80:	68 94       	set
     b82:	13 f8       	bld	r1, 3
     b84:	f5 94       	asr	r15
     b86:	e7 94       	ror	r14
     b88:	d7 94       	ror	r13
     b8a:	c7 94       	ror	r12
     b8c:	16 94       	lsr	r1
     b8e:	d1 f7       	brne	.-12     	; 0xb84 <BME280_compensate_T_int32+0x20>
     b90:	c2 1a       	sub	r12, r18
     b92:	d3 0a       	sbc	r13, r19
     b94:	e1 08       	sbc	r14, r1
     b96:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b98:	dc 01       	movw	r26, r24
     b9a:	cb 01       	movw	r24, r22
     b9c:	68 94       	set
     b9e:	12 f8       	bld	r1, 2
     ba0:	b5 95       	asr	r27
     ba2:	a7 95       	ror	r26
     ba4:	97 95       	ror	r25
     ba6:	87 95       	ror	r24
     ba8:	16 94       	lsr	r1
     baa:	d1 f7       	brne	.-12     	; 0xba0 <BME280_compensate_T_int32+0x3c>
     bac:	22 0f       	add	r18, r18
     bae:	33 1f       	adc	r19, r19
     bb0:	4c 01       	movw	r8, r24
     bb2:	5d 01       	movw	r10, r26
     bb4:	82 1a       	sub	r8, r18
     bb6:	93 0a       	sbc	r9, r19
     bb8:	a1 08       	sbc	r10, r1
     bba:	b1 08       	sbc	r11, r1
     bbc:	a5 01       	movw	r20, r10
     bbe:	94 01       	movw	r18, r8
     bc0:	a0 91 9d 06 	lds	r26, 0x069D	; 0x80069d <dig_T2>
     bc4:	b0 91 9e 06 	lds	r27, 0x069E	; 0x80069e <dig_T2+0x1>
     bc8:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__mulshisi3>
     bcc:	4b 01       	movw	r8, r22
     bce:	5c 01       	movw	r10, r24
     bd0:	07 2e       	mov	r0, r23
     bd2:	7b e0       	ldi	r23, 0x0B	; 11
     bd4:	b5 94       	asr	r11
     bd6:	a7 94       	ror	r10
     bd8:	97 94       	ror	r9
     bda:	87 94       	ror	r8
     bdc:	7a 95       	dec	r23
     bde:	d1 f7       	brne	.-12     	; 0xbd4 <BME280_compensate_T_int32+0x70>
     be0:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     be2:	a7 01       	movw	r20, r14
     be4:	96 01       	movw	r18, r12
     be6:	c7 01       	movw	r24, r14
     be8:	b6 01       	movw	r22, r12
     bea:	fb d7       	rcall	.+4086   	; 0x1be2 <__mulsi3>
     bec:	9b 01       	movw	r18, r22
     bee:	ac 01       	movw	r20, r24
     bf0:	01 2e       	mov	r0, r17
     bf2:	1c e0       	ldi	r17, 0x0C	; 12
     bf4:	55 95       	asr	r21
     bf6:	47 95       	ror	r20
     bf8:	37 95       	ror	r19
     bfa:	27 95       	ror	r18
     bfc:	1a 95       	dec	r17
     bfe:	d1 f7       	brne	.-12     	; 0xbf4 <BME280_compensate_T_int32+0x90>
     c00:	10 2d       	mov	r17, r0
     c02:	a0 91 ff 06 	lds	r26, 0x06FF	; 0x8006ff <dig_T3>
     c06:	b0 91 00 07 	lds	r27, 0x0700	; 0x800700 <dig_T3+0x1>
     c0a:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__mulshisi3>
     c0e:	dc 01       	movw	r26, r24
     c10:	cb 01       	movw	r24, r22
     c12:	07 2e       	mov	r0, r23
     c14:	7e e0       	ldi	r23, 0x0E	; 14
     c16:	b5 95       	asr	r27
     c18:	a7 95       	ror	r26
     c1a:	97 95       	ror	r25
     c1c:	87 95       	ror	r24
     c1e:	7a 95       	dec	r23
     c20:	d1 f7       	brne	.-12     	; 0xc16 <BME280_compensate_T_int32+0xb2>
     c22:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     c24:	88 0d       	add	r24, r8
     c26:	99 1d       	adc	r25, r9
     c28:	aa 1d       	adc	r26, r10
     c2a:	bb 1d       	adc	r27, r11
     c2c:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <t_fine>
     c30:	90 93 06 07 	sts	0x0706, r25	; 0x800706 <t_fine+0x1>
     c34:	a0 93 07 07 	sts	0x0707, r26	; 0x800707 <t_fine+0x2>
     c38:	b0 93 08 07 	sts	0x0708, r27	; 0x800708 <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     c3c:	6c 01       	movw	r12, r24
     c3e:	7d 01       	movw	r14, r26
     c40:	cc 0c       	add	r12, r12
     c42:	dd 1c       	adc	r13, r13
     c44:	ee 1c       	adc	r14, r14
     c46:	ff 1c       	adc	r15, r15
     c48:	cc 0c       	add	r12, r12
     c4a:	dd 1c       	adc	r13, r13
     c4c:	ee 1c       	adc	r14, r14
     c4e:	ff 1c       	adc	r15, r15
     c50:	8c 0d       	add	r24, r12
     c52:	9d 1d       	adc	r25, r13
     c54:	ae 1d       	adc	r26, r14
     c56:	bf 1d       	adc	r27, r15
     c58:	80 58       	subi	r24, 0x80	; 128
     c5a:	9f 4f       	sbci	r25, 0xFF	; 255
     c5c:	af 4f       	sbci	r26, 0xFF	; 255
     c5e:	bf 4f       	sbci	r27, 0xFF	; 255
     c60:	69 2f       	mov	r22, r25
     c62:	7a 2f       	mov	r23, r26
     c64:	8b 2f       	mov	r24, r27
     c66:	99 27       	eor	r25, r25
     c68:	87 fd       	sbrc	r24, 7
     c6a:	9a 95       	dec	r25
	return T;
}
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	bf 90       	pop	r11
     c76:	af 90       	pop	r10
     c78:	9f 90       	pop	r9
     c7a:	8f 90       	pop	r8
     c7c:	08 95       	ret

00000c7e <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c7e:	2f 92       	push	r2
     c80:	3f 92       	push	r3
     c82:	4f 92       	push	r4
     c84:	5f 92       	push	r5
     c86:	6f 92       	push	r6
     c88:	7f 92       	push	r7
     c8a:	8f 92       	push	r8
     c8c:	9f 92       	push	r9
     c8e:	af 92       	push	r10
     c90:	bf 92       	push	r11
     c92:	cf 92       	push	r12
     c94:	df 92       	push	r13
     c96:	ef 92       	push	r14
     c98:	ff 92       	push	r15
     c9a:	0f 93       	push	r16
     c9c:	1f 93       	push	r17
     c9e:	cf 93       	push	r28
     ca0:	df 93       	push	r29
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
     ca6:	6e 97       	sbiw	r28, 0x1e	; 30
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	6e 8b       	std	Y+22, r22	; 0x16
     cb4:	7f 8b       	std	Y+23, r23	; 0x17
     cb6:	88 8f       	std	Y+24, r24	; 0x18
     cb8:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     cba:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <t_fine>
     cbe:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <t_fine+0x1>
     cc2:	a0 91 07 07 	lds	r26, 0x0707	; 0x800707 <t_fine+0x2>
     cc6:	b0 91 08 07 	lds	r27, 0x0708	; 0x800708 <t_fine+0x3>
     cca:	8c 01       	movw	r16, r24
     ccc:	9d 01       	movw	r18, r26
     cce:	14 5f       	subi	r17, 0xF4	; 244
     cd0:	21 40       	sbci	r18, 0x01	; 1
     cd2:	31 09       	sbc	r19, r1
     cd4:	09 83       	std	Y+1, r16	; 0x01
     cd6:	1a 83       	std	Y+2, r17	; 0x02
     cd8:	2b 83       	std	Y+3, r18	; 0x03
     cda:	3c 83       	std	Y+4, r19	; 0x04
     cdc:	33 0f       	add	r19, r19
     cde:	00 0b       	sbc	r16, r16
     ce0:	10 2f       	mov	r17, r16
     ce2:	98 01       	movw	r18, r16
     ce4:	0d 83       	std	Y+5, r16	; 0x05
     ce6:	1e 83       	std	Y+6, r17	; 0x06
     ce8:	2f 83       	std	Y+7, r18	; 0x07
     cea:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     cec:	a9 80       	ldd	r10, Y+1	; 0x01
     cee:	ba 80       	ldd	r11, Y+2	; 0x02
     cf0:	cb 80       	ldd	r12, Y+3	; 0x03
     cf2:	dc 80       	ldd	r13, Y+4	; 0x04
     cf4:	ed 80       	ldd	r14, Y+5	; 0x05
     cf6:	fe 2c       	mov	r15, r14
     cf8:	0e 2d       	mov	r16, r14
     cfa:	1e 2d       	mov	r17, r14
     cfc:	2a 2d       	mov	r18, r10
     cfe:	3b 2d       	mov	r19, r11
     d00:	4c 2d       	mov	r20, r12
     d02:	5d 2d       	mov	r21, r13
     d04:	60 2f       	mov	r22, r16
     d06:	70 2f       	mov	r23, r16
     d08:	80 2f       	mov	r24, r16
     d0a:	9e 2d       	mov	r25, r14
     d0c:	8f d7       	rcall	.+3870   	; 0x1c2c <__muldi3>
     d0e:	2d 87       	std	Y+13, r18	; 0x0d
     d10:	3e 87       	std	Y+14, r19	; 0x0e
     d12:	4f 87       	std	Y+15, r20	; 0x0f
     d14:	58 8b       	std	Y+16, r21	; 0x10
     d16:	69 8b       	std	Y+17, r22	; 0x11
     d18:	7a 8b       	std	Y+18, r23	; 0x12
     d1a:	8b 8b       	std	Y+19, r24	; 0x13
     d1c:	9c 8b       	std	Y+20, r25	; 0x14
     d1e:	10 91 01 07 	lds	r17, 0x0701	; 0x800701 <dig_P6>
     d22:	1a 8f       	std	Y+26, r17	; 0x1a
     d24:	20 91 02 07 	lds	r18, 0x0702	; 0x800702 <dig_P6+0x1>
     d28:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     d2a:	30 91 e2 06 	lds	r19, 0x06E2	; 0x8006e2 <dig_P5>
     d2e:	3b 8f       	std	Y+27, r19	; 0x1b
     d30:	40 91 e3 06 	lds	r20, 0x06E3	; 0x8006e3 <dig_P5+0x1>
     d34:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     d36:	50 91 d3 06 	lds	r21, 0x06D3	; 0x8006d3 <dig_P4>
     d3a:	5c 8f       	std	Y+28, r21	; 0x1c
     d3c:	80 91 d4 06 	lds	r24, 0x06D4	; 0x8006d4 <dig_P4+0x1>
     d40:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     d42:	30 91 d2 06 	lds	r19, 0x06D2	; 0x8006d2 <dig_P2+0x1>
     d46:	20 91 d1 06 	lds	r18, 0x06D1	; 0x8006d1 <dig_P2>
     d4a:	93 2f       	mov	r25, r19
     d4c:	99 0f       	add	r25, r25
     d4e:	99 0b       	sbc	r25, r25
     d50:	fe 2c       	mov	r15, r14
     d52:	0e 2d       	mov	r16, r14
     d54:	1e 2d       	mov	r17, r14
     d56:	49 2f       	mov	r20, r25
     d58:	59 2f       	mov	r21, r25
     d5a:	69 2f       	mov	r22, r25
     d5c:	79 2f       	mov	r23, r25
     d5e:	89 2f       	mov	r24, r25
     d60:	65 d7       	rcall	.+3786   	; 0x1c2c <__muldi3>
     d62:	0c e0       	ldi	r16, 0x0C	; 12
     d64:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <__ashldi3>
     d68:	42 2e       	mov	r4, r18
     d6a:	53 2e       	mov	r5, r19
     d6c:	64 2e       	mov	r6, r20
     d6e:	75 2e       	mov	r7, r21
     d70:	86 2e       	mov	r8, r22
     d72:	97 2e       	mov	r9, r23
     d74:	28 2e       	mov	r2, r24
     d76:	39 2e       	mov	r3, r25
     d78:	b0 90 f6 06 	lds	r11, 0x06F6	; 0x8006f6 <dig_P3+0x1>
     d7c:	a0 90 f5 06 	lds	r10, 0x06F5	; 0x8006f5 <dig_P3>
     d80:	1b 2d       	mov	r17, r11
     d82:	11 0f       	add	r17, r17
     d84:	11 0b       	sbc	r17, r17
     d86:	c1 2e       	mov	r12, r17
     d88:	d1 2e       	mov	r13, r17
     d8a:	e1 2e       	mov	r14, r17
     d8c:	f1 2e       	mov	r15, r17
     d8e:	01 2f       	mov	r16, r17
     d90:	2d 85       	ldd	r18, Y+13	; 0x0d
     d92:	3e 85       	ldd	r19, Y+14	; 0x0e
     d94:	4f 85       	ldd	r20, Y+15	; 0x0f
     d96:	58 89       	ldd	r21, Y+16	; 0x10
     d98:	69 89       	ldd	r22, Y+17	; 0x11
     d9a:	7a 89       	ldd	r23, Y+18	; 0x12
     d9c:	8b 89       	ldd	r24, Y+19	; 0x13
     d9e:	9c 89       	ldd	r25, Y+20	; 0x14
     da0:	45 d7       	rcall	.+3722   	; 0x1c2c <__muldi3>
     da2:	08 e0       	ldi	r16, 0x08	; 8
     da4:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <__ashrdi3>
     da8:	a4 2c       	mov	r10, r4
     daa:	b5 2c       	mov	r11, r5
     dac:	c6 2c       	mov	r12, r6
     dae:	d7 2c       	mov	r13, r7
     db0:	e8 2c       	mov	r14, r8
     db2:	f9 2c       	mov	r15, r9
     db4:	02 2d       	mov	r16, r2
     db6:	13 2d       	mov	r17, r3
     db8:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     dbc:	70 58       	subi	r23, 0x80	; 128
     dbe:	8f 4f       	sbci	r24, 0xFF	; 255
     dc0:	9f 4f       	sbci	r25, 0xFF	; 255
     dc2:	20 90 f3 06 	lds	r2, 0x06F3	; 0x8006f3 <dig_P1>
     dc6:	30 90 f4 06 	lds	r3, 0x06F4	; 0x8006f4 <dig_P1+0x1>
     dca:	a2 2c       	mov	r10, r2
     dcc:	b3 2c       	mov	r11, r3
     dce:	c1 2c       	mov	r12, r1
     dd0:	d1 2c       	mov	r13, r1
     dd2:	e1 2c       	mov	r14, r1
     dd4:	f1 2c       	mov	r15, r1
     dd6:	00 e0       	ldi	r16, 0x00	; 0
     dd8:	10 e0       	ldi	r17, 0x00	; 0
     dda:	28 d7       	rcall	.+3664   	; 0x1c2c <__muldi3>
     ddc:	01 e2       	ldi	r16, 0x21	; 33
     dde:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <__ashrdi3>
     de2:	29 87       	std	Y+9, r18	; 0x09
     de4:	3a 87       	std	Y+10, r19	; 0x0a
     de6:	4b 87       	std	Y+11, r20	; 0x0b
     de8:	45 2e       	mov	r4, r21
     dea:	56 2e       	mov	r5, r22
     dec:	7c 87       	std	Y+12, r23	; 0x0c
     dee:	38 2e       	mov	r3, r24
     df0:	29 2e       	mov	r2, r25
	if (var1 == 0)
     df2:	65 2d       	mov	r22, r5
     df4:	83 2d       	mov	r24, r3
     df6:	92 2d       	mov	r25, r2
     df8:	a0 e0       	ldi	r26, 0x00	; 0
     dfa:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <__cmpdi2_s8>
     dfe:	09 f4       	brne	.+2      	; 0xe02 <BME280_compensate_P_int64+0x184>
     e00:	6e c1       	rjmp	.+732    	; 0x10de <BME280_compensate_P_int64+0x460>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     e02:	aa 8c       	ldd	r10, Y+26	; 0x1a
     e04:	1e 8d       	ldd	r17, Y+30	; 0x1e
     e06:	11 0f       	add	r17, r17
     e08:	11 0b       	sbc	r17, r17
     e0a:	be 8c       	ldd	r11, Y+30	; 0x1e
     e0c:	c1 2e       	mov	r12, r17
     e0e:	d1 2e       	mov	r13, r17
     e10:	e1 2e       	mov	r14, r17
     e12:	f1 2e       	mov	r15, r17
     e14:	01 2f       	mov	r16, r17
     e16:	2d 85       	ldd	r18, Y+13	; 0x0d
     e18:	3e 85       	ldd	r19, Y+14	; 0x0e
     e1a:	4f 85       	ldd	r20, Y+15	; 0x0f
     e1c:	58 89       	ldd	r21, Y+16	; 0x10
     e1e:	69 89       	ldd	r22, Y+17	; 0x11
     e20:	7a 89       	ldd	r23, Y+18	; 0x12
     e22:	8b 89       	ldd	r24, Y+19	; 0x13
     e24:	9c 89       	ldd	r25, Y+20	; 0x14
     e26:	02 d7       	rcall	.+3588   	; 0x1c2c <__muldi3>
     e28:	2d 87       	std	Y+13, r18	; 0x0d
     e2a:	3e 87       	std	Y+14, r19	; 0x0e
     e2c:	64 2e       	mov	r6, r20
     e2e:	75 2e       	mov	r7, r21
     e30:	86 2e       	mov	r8, r22
     e32:	97 2e       	mov	r9, r23
     e34:	88 8b       	std	Y+16, r24	; 0x10
     e36:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     e38:	2b 8d       	ldd	r18, Y+27	; 0x1b
     e3a:	9d 8d       	ldd	r25, Y+29	; 0x1d
     e3c:	99 0f       	add	r25, r25
     e3e:	99 0b       	sbc	r25, r25
     e40:	a9 80       	ldd	r10, Y+1	; 0x01
     e42:	ba 80       	ldd	r11, Y+2	; 0x02
     e44:	cb 80       	ldd	r12, Y+3	; 0x03
     e46:	dc 80       	ldd	r13, Y+4	; 0x04
     e48:	ed 80       	ldd	r14, Y+5	; 0x05
     e4a:	fe 2c       	mov	r15, r14
     e4c:	0e 2d       	mov	r16, r14
     e4e:	1e 2d       	mov	r17, r14
     e50:	3d 8d       	ldd	r19, Y+29	; 0x1d
     e52:	49 2f       	mov	r20, r25
     e54:	59 2f       	mov	r21, r25
     e56:	69 2f       	mov	r22, r25
     e58:	79 2f       	mov	r23, r25
     e5a:	89 2f       	mov	r24, r25
     e5c:	e7 d6       	rcall	.+3534   	; 0x1c2c <__muldi3>
     e5e:	01 e1       	ldi	r16, 0x11	; 17
     e60:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <__ashldi3>
     e64:	ad 84       	ldd	r10, Y+13	; 0x0d
     e66:	be 84       	ldd	r11, Y+14	; 0x0e
     e68:	c6 2c       	mov	r12, r6
     e6a:	d7 2c       	mov	r13, r7
     e6c:	e8 2c       	mov	r14, r8
     e6e:	f9 2c       	mov	r15, r9
     e70:	08 89       	ldd	r16, Y+16	; 0x10
     e72:	1f 85       	ldd	r17, Y+15	; 0x0f
     e74:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <__adddi3>
     e78:	a2 2e       	mov	r10, r18
     e7a:	b3 2e       	mov	r11, r19
     e7c:	c4 2e       	mov	r12, r20
     e7e:	d5 2e       	mov	r13, r21
     e80:	e6 2e       	mov	r14, r22
     e82:	f7 2e       	mov	r15, r23
     e84:	e8 2f       	mov	r30, r24
     e86:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	a0 e1       	ldi	r26, 0x10	; 16
     e8e:	b0 e0       	ldi	r27, 0x00	; 0
     e90:	2e 89       	ldd	r18, Y+22	; 0x16
     e92:	3f 89       	ldd	r19, Y+23	; 0x17
     e94:	48 8d       	ldd	r20, Y+24	; 0x18
     e96:	59 8d       	ldd	r21, Y+25	; 0x19
     e98:	82 1b       	sub	r24, r18
     e9a:	93 0b       	sbc	r25, r19
     e9c:	a4 0b       	sbc	r26, r20
     e9e:	b5 0b       	sbc	r27, r21
     ea0:	3c 01       	movw	r6, r24
     ea2:	4d 01       	movw	r8, r26
     ea4:	99 0c       	add	r9, r9
     ea6:	66 08       	sbc	r6, r6
     ea8:	76 2c       	mov	r7, r6
     eaa:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     eac:	28 2f       	mov	r18, r24
     eae:	39 2f       	mov	r19, r25
     eb0:	4a 2f       	mov	r20, r26
     eb2:	5b 2f       	mov	r21, r27
     eb4:	66 2d       	mov	r22, r6
     eb6:	76 2d       	mov	r23, r6
     eb8:	86 2d       	mov	r24, r6
     eba:	96 2d       	mov	r25, r6
     ebc:	0f e1       	ldi	r16, 0x1F	; 31
     ebe:	d7 d7       	rcall	.+4014   	; 0x1e6e <__ashldi3>
     ec0:	82 2e       	mov	r8, r18
     ec2:	93 2e       	mov	r9, r19
     ec4:	f4 2f       	mov	r31, r20
     ec6:	75 2e       	mov	r7, r21
     ec8:	b6 2f       	mov	r27, r22
     eca:	a7 2f       	mov	r26, r23
     ecc:	68 2e       	mov	r6, r24
     ece:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     ed0:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ed2:	9d 89       	ldd	r25, Y+21	; 0x15
     ed4:	99 0f       	add	r25, r25
     ed6:	99 0b       	sbc	r25, r25
     ed8:	3d 89       	ldd	r19, Y+21	; 0x15
     eda:	49 2f       	mov	r20, r25
     edc:	59 2f       	mov	r21, r25
     ede:	69 2f       	mov	r22, r25
     ee0:	79 2f       	mov	r23, r25
     ee2:	89 2f       	mov	r24, r25
     ee4:	03 e2       	ldi	r16, 0x23	; 35
     ee6:	c3 d7       	rcall	.+3974   	; 0x1e6e <__ashldi3>
     ee8:	0e 2f       	mov	r16, r30
     eea:	f8 d7       	rcall	.+4080   	; 0x1edc <__adddi3>
     eec:	a2 2e       	mov	r10, r18
     eee:	b3 2e       	mov	r11, r19
     ef0:	c4 2e       	mov	r12, r20
     ef2:	d5 2e       	mov	r13, r21
     ef4:	e6 2e       	mov	r14, r22
     ef6:	f7 2e       	mov	r15, r23
     ef8:	08 2f       	mov	r16, r24
     efa:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     efc:	28 2d       	mov	r18, r8
     efe:	39 2d       	mov	r19, r9
     f00:	4f 2f       	mov	r20, r31
     f02:	57 2d       	mov	r21, r7
     f04:	6b 2f       	mov	r22, r27
     f06:	7a 2f       	mov	r23, r26
     f08:	86 2d       	mov	r24, r6
     f0a:	9d 81       	ldd	r25, Y+5	; 0x05
     f0c:	f0 d7       	rcall	.+4064   	; 0x1eee <__subdi3>
     f0e:	82 2e       	mov	r8, r18
     f10:	93 2e       	mov	r9, r19
     f12:	49 83       	std	Y+1, r20	; 0x01
     f14:	65 2e       	mov	r6, r21
     f16:	b6 2f       	mov	r27, r22
     f18:	a7 2f       	mov	r26, r23
     f1a:	f8 2f       	mov	r31, r24
     f1c:	e9 2f       	mov	r30, r25
     f1e:	03 e0       	ldi	r16, 0x03	; 3
     f20:	a6 d7       	rcall	.+3916   	; 0x1e6e <__ashldi3>
     f22:	a8 2c       	mov	r10, r8
     f24:	b9 2c       	mov	r11, r9
     f26:	c9 80       	ldd	r12, Y+1	; 0x01
     f28:	d6 2c       	mov	r13, r6
     f2a:	eb 2e       	mov	r14, r27
     f2c:	fa 2e       	mov	r15, r26
     f2e:	0f 2f       	mov	r16, r31
     f30:	1e 2f       	mov	r17, r30
     f32:	dd d7       	rcall	.+4026   	; 0x1eee <__subdi3>
     f34:	a2 2e       	mov	r10, r18
     f36:	b3 2e       	mov	r11, r19
     f38:	c4 2e       	mov	r12, r20
     f3a:	d5 2e       	mov	r13, r21
     f3c:	e6 2e       	mov	r14, r22
     f3e:	f7 2e       	mov	r15, r23
     f40:	78 2e       	mov	r7, r24
     f42:	19 2f       	mov	r17, r25
     f44:	03 e0       	ldi	r16, 0x03	; 3
     f46:	93 d7       	rcall	.+3878   	; 0x1e6e <__ashldi3>
     f48:	07 2d       	mov	r16, r7
     f4a:	d1 d7       	rcall	.+4002   	; 0x1eee <__subdi3>
     f4c:	03 e0       	ldi	r16, 0x03	; 3
     f4e:	8f d7       	rcall	.+3870   	; 0x1e6e <__ashldi3>
     f50:	a8 2c       	mov	r10, r8
     f52:	b9 2c       	mov	r11, r9
     f54:	c9 80       	ldd	r12, Y+1	; 0x01
     f56:	d6 2c       	mov	r13, r6
     f58:	eb 2e       	mov	r14, r27
     f5a:	fa 2e       	mov	r15, r26
     f5c:	0f 2f       	mov	r16, r31
     f5e:	1e 2f       	mov	r17, r30
     f60:	c6 d7       	rcall	.+3980   	; 0x1eee <__subdi3>
     f62:	02 e0       	ldi	r16, 0x02	; 2
     f64:	84 d7       	rcall	.+3848   	; 0x1e6e <__ashldi3>
     f66:	0f 2f       	mov	r16, r31
     f68:	c2 d7       	rcall	.+3972   	; 0x1eee <__subdi3>
     f6a:	01 e0       	ldi	r16, 0x01	; 1
     f6c:	80 d7       	rcall	.+3840   	; 0x1e6e <__ashldi3>
     f6e:	0f 2f       	mov	r16, r31
     f70:	be d7       	rcall	.+3964   	; 0x1eee <__subdi3>
     f72:	a9 84       	ldd	r10, Y+9	; 0x09
     f74:	ba 84       	ldd	r11, Y+10	; 0x0a
     f76:	cb 84       	ldd	r12, Y+11	; 0x0b
     f78:	d4 2c       	mov	r13, r4
     f7a:	e5 2c       	mov	r14, r5
     f7c:	fc 84       	ldd	r15, Y+12	; 0x0c
     f7e:	03 2d       	mov	r16, r3
     f80:	12 2d       	mov	r17, r2
     f82:	a7 d6       	rcall	.+3406   	; 0x1cd2 <__divdi3>
     f84:	2e 87       	std	Y+14, r18	; 0x0e
     f86:	3d 87       	std	Y+13, r19	; 0x0d
     f88:	49 83       	std	Y+1, r20	; 0x01
     f8a:	5d 83       	std	Y+5, r21	; 0x05
     f8c:	69 87       	std	Y+9, r22	; 0x09
     f8e:	7a 87       	std	Y+10, r23	; 0x0a
     f90:	8b 87       	std	Y+11, r24	; 0x0b
     f92:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     f94:	0d e0       	ldi	r16, 0x0D	; 13
     f96:	84 d7       	rcall	.+3848   	; 0x1ea0 <__ashrdi3>
     f98:	82 2e       	mov	r8, r18
     f9a:	93 2e       	mov	r9, r19
     f9c:	74 2e       	mov	r7, r20
     f9e:	65 2e       	mov	r6, r21
     fa0:	56 2e       	mov	r5, r22
     fa2:	47 2e       	mov	r4, r23
     fa4:	38 2e       	mov	r3, r24
     fa6:	29 2e       	mov	r2, r25
     fa8:	30 91 fe 06 	lds	r19, 0x06FE	; 0x8006fe <dig_P9+0x1>
     fac:	20 91 fd 06 	lds	r18, 0x06FD	; 0x8006fd <dig_P9>
     fb0:	93 2f       	mov	r25, r19
     fb2:	99 0f       	add	r25, r25
     fb4:	99 0b       	sbc	r25, r25
     fb6:	a8 2c       	mov	r10, r8
     fb8:	b9 2c       	mov	r11, r9
     fba:	c7 2c       	mov	r12, r7
     fbc:	d6 2c       	mov	r13, r6
     fbe:	e5 2c       	mov	r14, r5
     fc0:	f4 2c       	mov	r15, r4
     fc2:	03 2d       	mov	r16, r3
     fc4:	12 2d       	mov	r17, r2
     fc6:	49 2f       	mov	r20, r25
     fc8:	59 2f       	mov	r21, r25
     fca:	69 2f       	mov	r22, r25
     fcc:	79 2f       	mov	r23, r25
     fce:	89 2f       	mov	r24, r25
     fd0:	2d d6       	rcall	.+3162   	; 0x1c2c <__muldi3>
     fd2:	a2 2e       	mov	r10, r18
     fd4:	b3 2e       	mov	r11, r19
     fd6:	c4 2e       	mov	r12, r20
     fd8:	d5 2e       	mov	r13, r21
     fda:	e6 2e       	mov	r14, r22
     fdc:	f7 2e       	mov	r15, r23
     fde:	08 2f       	mov	r16, r24
     fe0:	19 2f       	mov	r17, r25
     fe2:	28 2d       	mov	r18, r8
     fe4:	39 2d       	mov	r19, r9
     fe6:	47 2d       	mov	r20, r7
     fe8:	56 2d       	mov	r21, r6
     fea:	65 2d       	mov	r22, r5
     fec:	74 2d       	mov	r23, r4
     fee:	83 2d       	mov	r24, r3
     ff0:	92 2d       	mov	r25, r2
     ff2:	1c d6       	rcall	.+3128   	; 0x1c2c <__muldi3>
     ff4:	09 e1       	ldi	r16, 0x19	; 25
     ff6:	54 d7       	rcall	.+3752   	; 0x1ea0 <__ashrdi3>
     ff8:	a2 2e       	mov	r10, r18
     ffa:	b3 2e       	mov	r11, r19
     ffc:	c4 2e       	mov	r12, r20
     ffe:	d5 2e       	mov	r13, r21
    1000:	e6 2e       	mov	r14, r22
    1002:	f7 2e       	mov	r15, r23
    1004:	08 2f       	mov	r16, r24
    1006:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1008:	2e 85       	ldd	r18, Y+14	; 0x0e
    100a:	3d 85       	ldd	r19, Y+13	; 0x0d
    100c:	49 81       	ldd	r20, Y+1	; 0x01
    100e:	5d 81       	ldd	r21, Y+5	; 0x05
    1010:	69 85       	ldd	r22, Y+9	; 0x09
    1012:	7a 85       	ldd	r23, Y+10	; 0x0a
    1014:	8b 85       	ldd	r24, Y+11	; 0x0b
    1016:	9c 85       	ldd	r25, Y+12	; 0x0c
    1018:	61 d7       	rcall	.+3778   	; 0x1edc <__adddi3>
    101a:	22 2e       	mov	r2, r18
    101c:	33 2e       	mov	r3, r19
    101e:	44 2e       	mov	r4, r20
    1020:	55 2e       	mov	r5, r21
    1022:	66 2e       	mov	r6, r22
    1024:	77 2e       	mov	r7, r23
    1026:	88 2e       	mov	r8, r24
    1028:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
    102a:	30 91 f8 06 	lds	r19, 0x06F8	; 0x8006f8 <dig_P8+0x1>
    102e:	20 91 f7 06 	lds	r18, 0x06F7	; 0x8006f7 <dig_P8>
    1032:	93 2f       	mov	r25, r19
    1034:	99 0f       	add	r25, r25
    1036:	99 0b       	sbc	r25, r25
    1038:	ae 84       	ldd	r10, Y+14	; 0x0e
    103a:	bd 84       	ldd	r11, Y+13	; 0x0d
    103c:	c9 80       	ldd	r12, Y+1	; 0x01
    103e:	dd 80       	ldd	r13, Y+5	; 0x05
    1040:	e9 84       	ldd	r14, Y+9	; 0x09
    1042:	fa 84       	ldd	r15, Y+10	; 0x0a
    1044:	0b 85       	ldd	r16, Y+11	; 0x0b
    1046:	1c 85       	ldd	r17, Y+12	; 0x0c
    1048:	49 2f       	mov	r20, r25
    104a:	59 2f       	mov	r21, r25
    104c:	69 2f       	mov	r22, r25
    104e:	79 2f       	mov	r23, r25
    1050:	89 2f       	mov	r24, r25
    1052:	ec d5       	rcall	.+3032   	; 0x1c2c <__muldi3>
    1054:	03 e1       	ldi	r16, 0x13	; 19
    1056:	24 d7       	rcall	.+3656   	; 0x1ea0 <__ashrdi3>
    1058:	a2 2e       	mov	r10, r18
    105a:	b3 2e       	mov	r11, r19
    105c:	c4 2e       	mov	r12, r20
    105e:	d5 2e       	mov	r13, r21
    1060:	e6 2e       	mov	r14, r22
    1062:	f7 2e       	mov	r15, r23
    1064:	08 2f       	mov	r16, r24
    1066:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1068:	22 2d       	mov	r18, r2
    106a:	33 2d       	mov	r19, r3
    106c:	44 2d       	mov	r20, r4
    106e:	55 2d       	mov	r21, r5
    1070:	66 2d       	mov	r22, r6
    1072:	77 2d       	mov	r23, r7
    1074:	88 2d       	mov	r24, r8
    1076:	99 2d       	mov	r25, r9
    1078:	31 d7       	rcall	.+3682   	; 0x1edc <__adddi3>
    107a:	08 e0       	ldi	r16, 0x08	; 8
    107c:	11 d7       	rcall	.+3618   	; 0x1ea0 <__ashrdi3>
    107e:	40 90 97 06 	lds	r4, 0x0697	; 0x800697 <dig_P7>
    1082:	50 90 98 06 	lds	r5, 0x0698	; 0x800698 <dig_P7+0x1>
    1086:	05 2c       	mov	r0, r5
    1088:	00 0c       	add	r0, r0
    108a:	66 08       	sbc	r6, r6
    108c:	77 08       	sbc	r7, r7
    108e:	44 0c       	add	r4, r4
    1090:	55 1c       	adc	r5, r5
    1092:	66 1c       	adc	r6, r6
    1094:	77 1c       	adc	r7, r7
    1096:	44 0c       	add	r4, r4
    1098:	55 1c       	adc	r5, r5
    109a:	66 1c       	adc	r6, r6
    109c:	77 1c       	adc	r7, r7
    109e:	44 0c       	add	r4, r4
    10a0:	55 1c       	adc	r5, r5
    10a2:	66 1c       	adc	r6, r6
    10a4:	77 1c       	adc	r7, r7
    10a6:	44 0c       	add	r4, r4
    10a8:	55 1c       	adc	r5, r5
    10aa:	66 1c       	adc	r6, r6
    10ac:	77 1c       	adc	r7, r7
    10ae:	83 01       	movw	r16, r6
    10b0:	72 01       	movw	r14, r4
    10b2:	11 0f       	add	r17, r17
    10b4:	ee 08       	sbc	r14, r14
    10b6:	fe 2c       	mov	r15, r14
    10b8:	87 01       	movw	r16, r14
    10ba:	e9 82       	std	Y+1, r14	; 0x01
    10bc:	fa 82       	std	Y+2, r15	; 0x02
    10be:	0b 83       	std	Y+3, r16	; 0x03
    10c0:	1c 83       	std	Y+4, r17	; 0x04
    10c2:	a4 2c       	mov	r10, r4
    10c4:	b5 2c       	mov	r11, r5
    10c6:	c6 2c       	mov	r12, r6
    10c8:	d7 2c       	mov	r13, r7
    10ca:	e9 80       	ldd	r14, Y+1	; 0x01
    10cc:	fe 2c       	mov	r15, r14
    10ce:	0e 2d       	mov	r16, r14
    10d0:	1e 2d       	mov	r17, r14
    10d2:	04 d7       	rcall	.+3592   	; 0x1edc <__adddi3>
	return(long)p;
    10d4:	62 2f       	mov	r22, r18
    10d6:	73 2f       	mov	r23, r19
    10d8:	84 2f       	mov	r24, r20
    10da:	95 2f       	mov	r25, r21
    10dc:	04 c0       	rjmp	.+8      	; 0x10e6 <BME280_compensate_P_int64+0x468>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    10de:	60 e0       	ldi	r22, 0x00	; 0
    10e0:	70 e0       	ldi	r23, 0x00	; 0
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    10e6:	6e 96       	adiw	r28, 0x1e	; 30
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	f8 94       	cli
    10ec:	de bf       	out	0x3e, r29	; 62
    10ee:	0f be       	out	0x3f, r0	; 63
    10f0:	cd bf       	out	0x3d, r28	; 61
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	1f 91       	pop	r17
    10f8:	0f 91       	pop	r16
    10fa:	ff 90       	pop	r15
    10fc:	ef 90       	pop	r14
    10fe:	df 90       	pop	r13
    1100:	cf 90       	pop	r12
    1102:	bf 90       	pop	r11
    1104:	af 90       	pop	r10
    1106:	9f 90       	pop	r9
    1108:	8f 90       	pop	r8
    110a:	7f 90       	pop	r7
    110c:	6f 90       	pop	r6
    110e:	5f 90       	pop	r5
    1110:	4f 90       	pop	r4
    1112:	3f 90       	pop	r3
    1114:	2f 90       	pop	r2
    1116:	08 95       	ret

00001118 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    1118:	2f 92       	push	r2
    111a:	3f 92       	push	r3
    111c:	4f 92       	push	r4
    111e:	5f 92       	push	r5
    1120:	6f 92       	push	r6
    1122:	7f 92       	push	r7
    1124:	8f 92       	push	r8
    1126:	9f 92       	push	r9
    1128:	af 92       	push	r10
    112a:	bf 92       	push	r11
    112c:	cf 92       	push	r12
    112e:	df 92       	push	r13
    1130:	ef 92       	push	r14
    1132:	ff 92       	push	r15
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
    1140:	67 97       	sbiw	r28, 0x17	; 23
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	2b 01       	movw	r4, r22
    114e:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    1150:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <t_fine>
    1154:	90 91 06 07 	lds	r25, 0x0706	; 0x800706 <t_fine+0x1>
    1158:	a0 91 07 07 	lds	r26, 0x0707	; 0x800707 <t_fine+0x2>
    115c:	b0 91 08 07 	lds	r27, 0x0708	; 0x800708 <t_fine+0x3>
    1160:	6c 01       	movw	r12, r24
    1162:	7d 01       	movw	r14, r26
    1164:	ff 0c       	add	r15, r15
    1166:	cc 08       	sbc	r12, r12
    1168:	dc 2c       	mov	r13, r12
    116a:	76 01       	movw	r14, r12
    116c:	28 2f       	mov	r18, r24
    116e:	39 2f       	mov	r19, r25
    1170:	4a 2f       	mov	r20, r26
    1172:	5b 2f       	mov	r21, r27
    1174:	6c 2d       	mov	r22, r12
    1176:	7c 2d       	mov	r23, r12
    1178:	8c 2d       	mov	r24, r12
    117a:	9c 2d       	mov	r25, r12
    117c:	3c 52       	subi	r19, 0x2C	; 44
    117e:	41 40       	sbci	r20, 0x01	; 1
    1180:	51 09       	sbc	r21, r1
    1182:	61 09       	sbc	r22, r1
    1184:	71 09       	sbc	r23, r1
    1186:	81 09       	sbc	r24, r1
    1188:	91 09       	sbc	r25, r1
    118a:	2f 8b       	std	Y+23, r18	; 0x17
    118c:	3e 8b       	std	Y+22, r19	; 0x16
    118e:	49 83       	std	Y+1, r20	; 0x01
    1190:	59 87       	std	Y+9, r21	; 0x09
    1192:	6a 87       	std	Y+10, r22	; 0x0a
    1194:	7b 87       	std	Y+11, r23	; 0x0b
    1196:	8c 87       	std	Y+12, r24	; 0x0c
    1198:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    119a:	03 2e       	mov	r0, r19
    119c:	3e e0       	ldi	r19, 0x0E	; 14
    119e:	44 0c       	add	r4, r4
    11a0:	55 1c       	adc	r5, r5
    11a2:	66 1c       	adc	r6, r6
    11a4:	77 1c       	adc	r7, r7
    11a6:	3a 95       	dec	r19
    11a8:	d1 f7       	brne	.-12     	; 0x119e <bme280_compensate_H_int32+0x86>
    11aa:	30 2d       	mov	r19, r0
    11ac:	53 01       	movw	r10, r6
    11ae:	42 01       	movw	r8, r4
    11b0:	bb 0c       	add	r11, r11
    11b2:	88 08       	sbc	r8, r8
    11b4:	98 2c       	mov	r9, r8
    11b6:	54 01       	movw	r10, r8
    11b8:	30 91 9c 06 	lds	r19, 0x069C	; 0x80069c <dig_H4+0x1>
    11bc:	20 91 9b 06 	lds	r18, 0x069B	; 0x80069b <dig_H4>
    11c0:	93 2f       	mov	r25, r19
    11c2:	99 0f       	add	r25, r25
    11c4:	99 0b       	sbc	r25, r25
    11c6:	49 2f       	mov	r20, r25
    11c8:	59 2f       	mov	r21, r25
    11ca:	69 2f       	mov	r22, r25
    11cc:	79 2f       	mov	r23, r25
    11ce:	89 2f       	mov	r24, r25
    11d0:	04 e1       	ldi	r16, 0x14	; 20
    11d2:	4d d6       	rcall	.+3226   	; 0x1e6e <__ashldi3>
    11d4:	f2 2f       	mov	r31, r18
    11d6:	e3 2f       	mov	r30, r19
    11d8:	c4 2e       	mov	r12, r20
    11da:	d5 2e       	mov	r13, r21
    11dc:	e6 2e       	mov	r14, r22
    11de:	f7 2e       	mov	r15, r23
    11e0:	08 2f       	mov	r16, r24
    11e2:	19 2f       	mov	r17, r25
    11e4:	24 2d       	mov	r18, r4
    11e6:	35 2d       	mov	r19, r5
    11e8:	46 2d       	mov	r20, r6
    11ea:	57 2d       	mov	r21, r7
    11ec:	68 2d       	mov	r22, r8
    11ee:	78 2d       	mov	r23, r8
    11f0:	88 2d       	mov	r24, r8
    11f2:	98 2d       	mov	r25, r8
    11f4:	af 2e       	mov	r10, r31
    11f6:	be 2e       	mov	r11, r30
    11f8:	7a d6       	rcall	.+3316   	; 0x1eee <__subdi3>
    11fa:	22 2e       	mov	r2, r18
    11fc:	33 2e       	mov	r3, r19
    11fe:	44 2e       	mov	r4, r20
    1200:	55 2e       	mov	r5, r21
    1202:	66 2e       	mov	r6, r22
    1204:	77 2e       	mov	r7, r23
    1206:	88 2e       	mov	r8, r24
    1208:	99 2e       	mov	r9, r25
    120a:	30 91 fa 06 	lds	r19, 0x06FA	; 0x8006fa <dig_H5+0x1>
    120e:	20 91 f9 06 	lds	r18, 0x06F9	; 0x8006f9 <dig_H5>
    1212:	93 2f       	mov	r25, r19
    1214:	99 0f       	add	r25, r25
    1216:	99 0b       	sbc	r25, r25
    1218:	af 88       	ldd	r10, Y+23	; 0x17
    121a:	be 88       	ldd	r11, Y+22	; 0x16
    121c:	c9 80       	ldd	r12, Y+1	; 0x01
    121e:	d9 84       	ldd	r13, Y+9	; 0x09
    1220:	ea 84       	ldd	r14, Y+10	; 0x0a
    1222:	fb 84       	ldd	r15, Y+11	; 0x0b
    1224:	0c 85       	ldd	r16, Y+12	; 0x0c
    1226:	1d 85       	ldd	r17, Y+13	; 0x0d
    1228:	49 2f       	mov	r20, r25
    122a:	59 2f       	mov	r21, r25
    122c:	69 2f       	mov	r22, r25
    122e:	79 2f       	mov	r23, r25
    1230:	89 2f       	mov	r24, r25
    1232:	fc d4       	rcall	.+2552   	; 0x1c2c <__muldi3>
    1234:	a2 2e       	mov	r10, r18
    1236:	b3 2e       	mov	r11, r19
    1238:	c4 2e       	mov	r12, r20
    123a:	d5 2e       	mov	r13, r21
    123c:	e6 2e       	mov	r14, r22
    123e:	f7 2e       	mov	r15, r23
    1240:	08 2f       	mov	r16, r24
    1242:	19 2f       	mov	r17, r25
    1244:	22 2d       	mov	r18, r2
    1246:	33 2d       	mov	r19, r3
    1248:	44 2d       	mov	r20, r4
    124a:	55 2d       	mov	r21, r5
    124c:	66 2d       	mov	r22, r6
    124e:	77 2d       	mov	r23, r7
    1250:	88 2d       	mov	r24, r8
    1252:	99 2d       	mov	r25, r9
    1254:	4c d6       	rcall	.+3224   	; 0x1eee <__subdi3>
    1256:	30 5c       	subi	r19, 0xC0	; 192
    1258:	4f 4f       	sbci	r20, 0xFF	; 255
    125a:	5f 4f       	sbci	r21, 0xFF	; 255
    125c:	6f 4f       	sbci	r22, 0xFF	; 255
    125e:	7f 4f       	sbci	r23, 0xFF	; 255
    1260:	8f 4f       	sbci	r24, 0xFF	; 255
    1262:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1264:	0f e0       	ldi	r16, 0x0F	; 15
    1266:	1c d6       	rcall	.+3128   	; 0x1ea0 <__ashrdi3>
    1268:	2e 87       	std	Y+14, r18	; 0x0e
    126a:	3f 87       	std	Y+15, r19	; 0x0f
    126c:	48 8b       	std	Y+16, r20	; 0x10
    126e:	59 8b       	std	Y+17, r21	; 0x11
    1270:	6a 8b       	std	Y+18, r22	; 0x12
    1272:	7b 8b       	std	Y+19, r23	; 0x13
    1274:	8c 8b       	std	Y+20, r24	; 0x14
    1276:	9d 8b       	std	Y+21, r25	; 0x15
    1278:	30 91 dd 06 	lds	r19, 0x06DD	; 0x8006dd <dig_H6+0x1>
    127c:	20 91 dc 06 	lds	r18, 0x06DC	; 0x8006dc <dig_H6>
    1280:	93 2f       	mov	r25, r19
    1282:	99 0f       	add	r25, r25
    1284:	99 0b       	sbc	r25, r25
    1286:	af 88       	ldd	r10, Y+23	; 0x17
    1288:	be 88       	ldd	r11, Y+22	; 0x16
    128a:	c9 80       	ldd	r12, Y+1	; 0x01
    128c:	d9 84       	ldd	r13, Y+9	; 0x09
    128e:	ea 84       	ldd	r14, Y+10	; 0x0a
    1290:	fb 84       	ldd	r15, Y+11	; 0x0b
    1292:	0c 85       	ldd	r16, Y+12	; 0x0c
    1294:	1d 85       	ldd	r17, Y+13	; 0x0d
    1296:	49 2f       	mov	r20, r25
    1298:	59 2f       	mov	r21, r25
    129a:	69 2f       	mov	r22, r25
    129c:	79 2f       	mov	r23, r25
    129e:	89 2f       	mov	r24, r25
    12a0:	c5 d4       	rcall	.+2442   	; 0x1c2c <__muldi3>
    12a2:	0a e0       	ldi	r16, 0x0A	; 10
    12a4:	fd d5       	rcall	.+3066   	; 0x1ea0 <__ashrdi3>
    12a6:	82 2e       	mov	r8, r18
    12a8:	93 2e       	mov	r9, r19
    12aa:	74 2e       	mov	r7, r20
    12ac:	65 2e       	mov	r6, r21
    12ae:	56 2e       	mov	r5, r22
    12b0:	47 2e       	mov	r4, r23
    12b2:	38 2e       	mov	r3, r24
    12b4:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12b6:	40 91 fb 06 	lds	r20, 0x06FB	; 0x8006fb <dig_H3>
    12ba:	50 91 fc 06 	lds	r21, 0x06FC	; 0x8006fc <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12be:	0c 85       	ldd	r16, Y+12	; 0x0c
    12c0:	24 2f       	mov	r18, r20
    12c2:	35 2f       	mov	r19, r21
    12c4:	40 e0       	ldi	r20, 0x00	; 0
    12c6:	50 e0       	ldi	r21, 0x00	; 0
    12c8:	60 e0       	ldi	r22, 0x00	; 0
    12ca:	70 e0       	ldi	r23, 0x00	; 0
    12cc:	80 e0       	ldi	r24, 0x00	; 0
    12ce:	90 e0       	ldi	r25, 0x00	; 0
    12d0:	ad d4       	rcall	.+2394   	; 0x1c2c <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12d2:	0b e0       	ldi	r16, 0x0B	; 11
    12d4:	e5 d5       	rcall	.+3018   	; 0x1ea0 <__ashrdi3>
    12d6:	30 58       	subi	r19, 0x80	; 128
    12d8:	4f 4f       	sbci	r20, 0xFF	; 255
    12da:	5f 4f       	sbci	r21, 0xFF	; 255
    12dc:	6f 4f       	sbci	r22, 0xFF	; 255
    12de:	7f 4f       	sbci	r23, 0xFF	; 255
    12e0:	8f 4f       	sbci	r24, 0xFF	; 255
    12e2:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12e4:	a2 2e       	mov	r10, r18
    12e6:	b3 2e       	mov	r11, r19
    12e8:	c4 2e       	mov	r12, r20
    12ea:	d5 2e       	mov	r13, r21
    12ec:	e6 2e       	mov	r14, r22
    12ee:	f7 2e       	mov	r15, r23
    12f0:	08 2f       	mov	r16, r24
    12f2:	19 2f       	mov	r17, r25
    12f4:	28 2d       	mov	r18, r8
    12f6:	39 2d       	mov	r19, r9
    12f8:	47 2d       	mov	r20, r7
    12fa:	56 2d       	mov	r21, r6
    12fc:	65 2d       	mov	r22, r5
    12fe:	74 2d       	mov	r23, r4
    1300:	83 2d       	mov	r24, r3
    1302:	92 2d       	mov	r25, r2
    1304:	93 d4       	rcall	.+2342   	; 0x1c2c <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1306:	0a e0       	ldi	r16, 0x0A	; 10
    1308:	cb d5       	rcall	.+2966   	; 0x1ea0 <__ashrdi3>
    130a:	40 5e       	subi	r20, 0xE0	; 224
    130c:	5f 4f       	sbci	r21, 0xFF	; 255
    130e:	6f 4f       	sbci	r22, 0xFF	; 255
    1310:	7f 4f       	sbci	r23, 0xFF	; 255
    1312:	8f 4f       	sbci	r24, 0xFF	; 255
    1314:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
    1316:	b0 90 04 07 	lds	r11, 0x0704	; 0x800704 <dig_H2+0x1>
    131a:	a0 90 03 07 	lds	r10, 0x0703	; 0x800703 <dig_H2>
    131e:	1b 2d       	mov	r17, r11
    1320:	11 0f       	add	r17, r17
    1322:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1324:	c1 2e       	mov	r12, r17
    1326:	d1 2e       	mov	r13, r17
    1328:	e1 2e       	mov	r14, r17
    132a:	f1 2e       	mov	r15, r17
    132c:	01 2f       	mov	r16, r17
    132e:	7e d4       	rcall	.+2300   	; 0x1c2c <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    1330:	30 5e       	subi	r19, 0xE0	; 224
    1332:	4f 4f       	sbci	r20, 0xFF	; 255
    1334:	5f 4f       	sbci	r21, 0xFF	; 255
    1336:	6f 4f       	sbci	r22, 0xFF	; 255
    1338:	7f 4f       	sbci	r23, 0xFF	; 255
    133a:	8f 4f       	sbci	r24, 0xFF	; 255
    133c:	9f 4f       	sbci	r25, 0xFF	; 255
    133e:	0e e0       	ldi	r16, 0x0E	; 14
    1340:	af d5       	rcall	.+2910   	; 0x1ea0 <__ashrdi3>
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1342:	a2 2e       	mov	r10, r18
    1344:	b3 2e       	mov	r11, r19
    1346:	c4 2e       	mov	r12, r20
    1348:	d5 2e       	mov	r13, r21
    134a:	e6 2e       	mov	r14, r22
    134c:	f7 2e       	mov	r15, r23
    134e:	08 2f       	mov	r16, r24
    1350:	19 2f       	mov	r17, r25
    1352:	2e 85       	ldd	r18, Y+14	; 0x0e
    1354:	3f 85       	ldd	r19, Y+15	; 0x0f
    1356:	48 89       	ldd	r20, Y+16	; 0x10
    1358:	59 89       	ldd	r21, Y+17	; 0x11
    135a:	6a 89       	ldd	r22, Y+18	; 0x12
    135c:	7b 89       	ldd	r23, Y+19	; 0x13
    135e:	8c 89       	ldd	r24, Y+20	; 0x14
    1360:	9d 89       	ldd	r25, Y+21	; 0x15
    1362:	64 d4       	rcall	.+2248   	; 0x1c2c <__muldi3>
    1364:	42 2e       	mov	r4, r18
    1366:	53 2e       	mov	r5, r19
    1368:	64 2e       	mov	r6, r20
    136a:	75 2e       	mov	r7, r21
    136c:	86 2e       	mov	r8, r22
    136e:	97 2e       	mov	r9, r23
    1370:	28 2e       	mov	r2, r24
    1372:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1374:	0f e0       	ldi	r16, 0x0F	; 15
    1376:	94 d5       	rcall	.+2856   	; 0x1ea0 <__ashrdi3>
    1378:	a2 2e       	mov	r10, r18
    137a:	b3 2e       	mov	r11, r19
    137c:	c4 2e       	mov	r12, r20
    137e:	d5 2e       	mov	r13, r21
    1380:	e6 2e       	mov	r14, r22
    1382:	f7 2e       	mov	r15, r23
    1384:	08 2f       	mov	r16, r24
    1386:	19 2f       	mov	r17, r25
    1388:	51 d4       	rcall	.+2210   	; 0x1c2c <__muldi3>
    138a:	07 e0       	ldi	r16, 0x07	; 7
    138c:	89 d5       	rcall	.+2834   	; 0x1ea0 <__ashrdi3>
    138e:	e0 91 cb 06 	lds	r30, 0x06CB	; 0x8006cb <dig_H1>
    1392:	f0 91 cc 06 	lds	r31, 0x06CC	; 0x8006cc <dig_H1+0x1>
    1396:	5f 01       	movw	r10, r30
    1398:	c1 2c       	mov	r12, r1
    139a:	d1 2c       	mov	r13, r1
    139c:	e1 2c       	mov	r14, r1
    139e:	f1 2c       	mov	r15, r1
    13a0:	87 01       	movw	r16, r14
    13a2:	e9 83       	std	Y+1, r30	; 0x01
    13a4:	ba 82       	std	Y+2, r11	; 0x02
    13a6:	cb 82       	std	Y+3, r12	; 0x03
    13a8:	dc 82       	std	Y+4, r13	; 0x04
    13aa:	ed 82       	std	Y+5, r14	; 0x05
    13ac:	fe 82       	std	Y+6, r15	; 0x06
    13ae:	0f 83       	std	Y+7, r16	; 0x07
    13b0:	18 87       	std	Y+8, r17	; 0x08
    13b2:	c1 2c       	mov	r12, r1
    13b4:	d1 2c       	mov	r13, r1
    13b6:	e1 2c       	mov	r14, r1
    13b8:	f1 2c       	mov	r15, r1
    13ba:	00 e0       	ldi	r16, 0x00	; 0
    13bc:	10 e0       	ldi	r17, 0x00	; 0
    13be:	36 d4       	rcall	.+2156   	; 0x1c2c <__muldi3>
    13c0:	04 e0       	ldi	r16, 0x04	; 4
    13c2:	6e d5       	rcall	.+2780   	; 0x1ea0 <__ashrdi3>
    13c4:	a2 2e       	mov	r10, r18
    13c6:	b3 2e       	mov	r11, r19
    13c8:	c4 2e       	mov	r12, r20
    13ca:	d5 2e       	mov	r13, r21
    13cc:	e6 2e       	mov	r14, r22
    13ce:	f7 2e       	mov	r15, r23
    13d0:	08 2f       	mov	r16, r24
    13d2:	19 2f       	mov	r17, r25
    13d4:	24 2d       	mov	r18, r4
    13d6:	35 2d       	mov	r19, r5
    13d8:	46 2d       	mov	r20, r6
    13da:	57 2d       	mov	r21, r7
    13dc:	68 2d       	mov	r22, r8
    13de:	79 2d       	mov	r23, r9
    13e0:	82 2d       	mov	r24, r2
    13e2:	93 2d       	mov	r25, r3
    13e4:	84 d5       	rcall	.+2824   	; 0x1eee <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    13e6:	f2 2e       	mov	r15, r18
    13e8:	03 2f       	mov	r16, r19
    13ea:	14 2f       	mov	r17, r20
    13ec:	65 2e       	mov	r6, r21
    13ee:	76 2e       	mov	r7, r22
    13f0:	b7 2f       	mov	r27, r23
    13f2:	f8 2f       	mov	r31, r24
    13f4:	e9 2f       	mov	r30, r25
    13f6:	a0 e0       	ldi	r26, 0x00	; 0
    13f8:	83 d5       	rcall	.+2822   	; 0x1f00 <__cmpdi2_s8>
    13fa:	44 f4       	brge	.+16     	; 0x140c <bme280_compensate_H_int32+0x2f4>
    13fc:	f1 2c       	mov	r15, r1
    13fe:	00 e0       	ldi	r16, 0x00	; 0
    1400:	10 e0       	ldi	r17, 0x00	; 0
    1402:	61 2c       	mov	r6, r1
    1404:	71 2c       	mov	r7, r1
    1406:	b0 e0       	ldi	r27, 0x00	; 0
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    140c:	8f 2c       	mov	r8, r15
    140e:	90 2e       	mov	r9, r16
    1410:	a1 2e       	mov	r10, r17
    1412:	b6 2c       	mov	r11, r6
    1414:	c7 2c       	mov	r12, r7
    1416:	db 2e       	mov	r13, r27
    1418:	ef 2e       	mov	r14, r31
    141a:	ae 2f       	mov	r26, r30
    141c:	2f 2d       	mov	r18, r15
    141e:	30 2f       	mov	r19, r16
    1420:	41 2f       	mov	r20, r17
    1422:	56 2d       	mov	r21, r6
    1424:	67 2d       	mov	r22, r7
    1426:	7b 2f       	mov	r23, r27
    1428:	8f 2f       	mov	r24, r31
    142a:	9e 2f       	mov	r25, r30
    142c:	21 15       	cp	r18, r1
    142e:	31 05       	cpc	r19, r1
    1430:	41 05       	cpc	r20, r1
    1432:	59 41       	sbci	r21, 0x19	; 25
    1434:	61 05       	cpc	r22, r1
    1436:	71 05       	cpc	r23, r1
    1438:	81 05       	cpc	r24, r1
    143a:	91 05       	cpc	r25, r1
    143c:	61 f0       	breq	.+24     	; 0x1456 <bme280_compensate_H_int32+0x33e>
    143e:	5c f0       	brlt	.+22     	; 0x1456 <bme280_compensate_H_int32+0x33e>
    1440:	81 2c       	mov	r8, r1
    1442:	91 2c       	mov	r9, r1
    1444:	a1 2c       	mov	r10, r1
    1446:	0f 2e       	mov	r0, r31
    1448:	f9 e1       	ldi	r31, 0x19	; 25
    144a:	bf 2e       	mov	r11, r31
    144c:	f0 2d       	mov	r31, r0
    144e:	c1 2c       	mov	r12, r1
    1450:	d1 2c       	mov	r13, r1
    1452:	e1 2c       	mov	r14, r1
    1454:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    1456:	28 2d       	mov	r18, r8
    1458:	39 2d       	mov	r19, r9
    145a:	4a 2d       	mov	r20, r10
    145c:	5b 2d       	mov	r21, r11
    145e:	6c 2d       	mov	r22, r12
    1460:	7d 2d       	mov	r23, r13
    1462:	8e 2d       	mov	r24, r14
    1464:	9a 2f       	mov	r25, r26
    1466:	0c e0       	ldi	r16, 0x0C	; 12
    1468:	1b d5       	rcall	.+2614   	; 0x1ea0 <__ashrdi3>
    146a:	62 2f       	mov	r22, r18
    146c:	73 2f       	mov	r23, r19
    146e:	84 2f       	mov	r24, r20
    1470:	95 2f       	mov	r25, r21
}
    1472:	67 96       	adiw	r28, 0x17	; 23
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	f8 94       	cli
    1478:	de bf       	out	0x3e, r29	; 62
    147a:	0f be       	out	0x3f, r0	; 63
    147c:	cd bf       	out	0x3d, r28	; 61
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	1f 91       	pop	r17
    1484:	0f 91       	pop	r16
    1486:	ff 90       	pop	r15
    1488:	ef 90       	pop	r14
    148a:	df 90       	pop	r13
    148c:	cf 90       	pop	r12
    148e:	bf 90       	pop	r11
    1490:	af 90       	pop	r10
    1492:	9f 90       	pop	r9
    1494:	8f 90       	pop	r8
    1496:	7f 90       	pop	r7
    1498:	6f 90       	pop	r6
    149a:	5f 90       	pop	r5
    149c:	4f 90       	pop	r4
    149e:	3f 90       	pop	r3
    14a0:	2f 90       	pop	r2
    14a2:	08 95       	ret

000014a4 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    14a4:	0e 94 54 01 	call	0x2a8	; 0x2a8 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    14a8:	10 92 f2 06 	sts	0x06F2, r1	; 0x8006f2 <seconds+0x1>
    14ac:	10 92 f1 06 	sts	0x06F1, r1	; 0x8006f1 <seconds>
	ItsTime=0;
    14b0:	10 92 52 05 	sts	0x0552, r1	; 0x800552 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout0;
    14b4:	8b e2       	ldi	r24, 0x2B	; 43
    14b6:	91 e0       	ldi	r25, 0x01	; 1
    14b8:	90 93 0c 09 	sts	0x090C, r25	; 0x80090c <__iob+0x3>
    14bc:	80 93 0b 09 	sts	0x090B, r24	; 0x80090b <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
    14c0:	9c d1       	rcall	.+824    	; 0x17fa <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    14c2:	81 e8       	ldi	r24, 0x81	; 129
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	95 d2       	rcall	.+1322   	; 0x19f2 <USART0_init>
	USART1_init(MYUBRR1);
    14c8:	81 e8       	ldi	r24, 0x81	; 129
    14ca:	90 e0       	ldi	r25, 0x00	; 0
    14cc:	06 d3       	rcall	.+1548   	; 0x1ada <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    14ce:	b8 d1       	rcall	.+880    	; 0x1840 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    14d0:	0e 94 b6 00 	call	0x16c	; 0x16c <ADC_init>
	//
	// FOR DEBUG ONLY: Initialize the RGB sensor - Craig uses this to ensure I2C is working
//	RGBsensor_init();
	//
 	// initialize the gas sensors
	gas_sensors_init();
    14d4:	0e 94 a1 01 	call	0x342	; 0x342 <gas_sensors_init>
	// 
	// Start all interrupts
	sei();
    14d8:	78 94       	sei
	//
	// Initialize the pressure / temperature /  humidity sensor
	// BME280_init(); 
	//
	// Check the BME interface...
	bme280basic_init();
    14da:	05 da       	rcall	.-3062   	; 0x8e6 <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    14dc:	81 e0       	ldi	r24, 0x01	; 1
    14de:	91 e0       	ldi	r25, 0x01	; 1
    14e0:	c5 d2       	rcall	.+1418   	; 0x1a6c <USART0_putstring>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14e2:	2f e7       	ldi	r18, 0x7F	; 127
    14e4:	84 e8       	ldi	r24, 0x84	; 132
    14e6:	9e e1       	ldi	r25, 0x1E	; 30
    14e8:	21 50       	subi	r18, 0x01	; 1
    14ea:	80 40       	sbci	r24, 0x00	; 0
    14ec:	90 40       	sbci	r25, 0x00	; 0
    14ee:	e1 f7       	brne	.-8      	; 0x14e8 <main+0x44>
    14f0:	00 c0       	rjmp	.+0      	; 0x14f2 <main+0x4e>
    14f2:	00 00       	nop
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
    printf("hi ");
    14f4:	8a e3       	ldi	r24, 0x3A	; 58
    14f6:	91 e0       	ldi	r25, 0x01	; 1
    14f8:	9f 93       	push	r25
    14fa:	8f 93       	push	r24
    14fc:	1c d5       	rcall	.+2616   	; 0x1f36 <printf>
    14fe:	0f 90       	pop	r0
    1500:	0f 90       	pop	r0
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u \n", seconds);
    1502:	0f 2e       	mov	r0, r31
    1504:	fe e3       	ldi	r31, 0x3E	; 62
    1506:	af 2e       	mov	r10, r31
    1508:	f1 e0       	ldi	r31, 0x01	; 1
    150a:	bf 2e       	mov	r11, r31
    150c:	f0 2d       	mov	r31, r0
    150e:	c1 e5       	ldi	r28, 0x51	; 81
    1510:	d8 e0       	ldi	r29, 0x08	; 8
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
    1512:	0f 2e       	mov	r0, r31
    1514:	fe e4       	ldi	r31, 0x4E	; 78
    1516:	8f 2e       	mov	r8, r31
    1518:	f1 e0       	ldi	r31, 0x01	; 1
    151a:	9f 2e       	mov	r9, r31
    151c:	f0 2d       	mov	r31, r0
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
    151e:	0f 2e       	mov	r0, r31
    1520:	f3 e6       	ldi	r31, 0x63	; 99
    1522:	6f 2e       	mov	r6, r31
    1524:	f1 e0       	ldi	r31, 0x01	; 1
    1526:	7f 2e       	mov	r7, r31
    1528:	f0 2d       	mov	r31, r0
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    152a:	0f 2e       	mov	r0, r31
    152c:	f2 e7       	ldi	r31, 0x72	; 114
    152e:	ef 2e       	mov	r14, r31
    1530:	f5 e0       	ldi	r31, 0x05	; 5
    1532:	ff 2e       	mov	r15, r31
    1534:	f0 2d       	mov	r31, r0
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
			tempCelsius = BME280_compensate_T_int32(rawTemp);
			sprintf(temperatureBuf, "%lu", tempCelsius);
    1536:	0f 2e       	mov	r0, r31
    1538:	fe e2       	ldi	r31, 0x2E	; 46
    153a:	cf 2e       	mov	r12, r31
    153c:	f2 e0       	ldi	r31, 0x02	; 2
    153e:	df 2e       	mov	r13, r31
    1540:	f0 2d       	mov	r31, r0
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
    1542:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <ItsTime>
    1546:	81 30       	cpi	r24, 0x01	; 1
    1548:	e1 f7       	brne	.-8      	; 0x1542 <main+0x9e>
			ItsTime = 0; 
    154a:	10 92 52 05 	sts	0x0552, r1	; 0x800552 <ItsTime>
			seconds++;
    154e:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <seconds>
    1552:	90 91 f2 06 	lds	r25, 0x06F2	; 0x8006f2 <seconds+0x1>
    1556:	01 96       	adiw	r24, 0x01	; 1
    1558:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <seconds+0x1>
    155c:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <seconds>
			printf("\nSeconds = %u \n", seconds);
    1560:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <seconds>
    1564:	90 91 f2 06 	lds	r25, 0x06F2	; 0x8006f2 <seconds+0x1>
    1568:	9f 93       	push	r25
    156a:	8f 93       	push	r24
    156c:	bf 92       	push	r11
    156e:	af 92       	push	r10
    1570:	e2 d4       	rcall	.+2500   	; 0x1f36 <printf>
    1572:	09 e0       	ldi	r16, 0x09	; 9
    1574:	18 e0       	ldi	r17, 0x08	; 8
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	0f 90       	pop	r0
    157c:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
			{
				USART0_TransmitByte(messageWant[i]);
    157e:	d8 01       	movw	r26, r16
    1580:	8d 91       	ld	r24, X+
    1582:	8d 01       	movw	r16, r26
    1584:	49 d2       	rcall	.+1170   	; 0x1a18 <USART0_TransmitByte>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
    1586:	0c 17       	cp	r16, r28
    1588:	1d 07       	cpc	r17, r29
    158a:	c9 f7       	brne	.-14     	; 0x157e <main+0xda>
			printf("\n=================");
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
    158c:	0e 94 c0 02 	call	0x580	; 0x580 <LIDAR_distance>
    1590:	80 93 6d 05 	sts	0x056D, r24	; 0x80056d <distance>
    1594:	90 93 6e 05 	sts	0x056E, r25	; 0x80056e <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
    1598:	9f 93       	push	r25
    159a:	8f 93       	push	r24
    159c:	9f 92       	push	r9
    159e:	8f 92       	push	r8
    15a0:	ca d4       	rcall	.+2452   	; 0x1f36 <printf>
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
    15a2:	80 91 6e 05 	lds	r24, 0x056E	; 0x80056e <distance+0x1>
    15a6:	8f 93       	push	r24
    15a8:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <distance>
    15ac:	8f 93       	push	r24
    15ae:	7f 92       	push	r7
    15b0:	6f 92       	push	r6
    15b2:	c1 d4       	rcall	.+2434   	; 0x1f36 <printf>
			for (uint8_t i = 8; i<= 13; i++)//adds in time
			{
				USART0_TransmitByte(messageWant[i]);
    15b4:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <messageWant+0x8>
    15b8:	2f d2       	rcall	.+1118   	; 0x1a18 <USART0_TransmitByte>
    15ba:	0f 2e       	mov	r0, r31
    15bc:	f2 e1       	ldi	r31, 0x12	; 18
    15be:	4f 2e       	mov	r4, r31
    15c0:	f8 e0       	ldi	r31, 0x08	; 8
    15c2:	5f 2e       	mov	r5, r31
    15c4:	f0 2d       	mov	r31, r0
    15c6:	ed b7       	in	r30, 0x3d	; 61
    15c8:	fe b7       	in	r31, 0x3e	; 62
    15ca:	38 96       	adiw	r30, 0x08	; 8
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	fe bf       	out	0x3e, r31	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	ed bf       	out	0x3d, r30	; 61
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    15d6:	18 e0       	ldi	r17, 0x08	; 8
    15d8:	09 c0       	rjmp	.+18     	; 0x15ec <main+0x148>
			{
				USART0_TransmitByte(messageWant[i]);
    15da:	d2 01       	movw	r26, r4
    15dc:	8d 91       	ld	r24, X+
    15de:	2d 01       	movw	r4, r26
    15e0:	1b d2       	rcall	.+1078   	; 0x1a18 <USART0_TransmitByte>
				if (i%2 ==1)
    15e2:	10 ff       	sbrs	r17, 0
    15e4:	03 c0       	rjmp	.+6      	; 0x15ec <main+0x148>
				{
					printf(":");
    15e6:	8a e3       	ldi	r24, 0x3A	; 58
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	b8 d4       	rcall	.+2416   	; 0x1f5c <putchar>
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    15ec:	1f 5f       	subi	r17, 0xFF	; 255
    15ee:	1e 30       	cpi	r17, 0x0E	; 14
    15f0:	a1 f7       	brne	.-24     	; 0x15da <main+0x136>
				if (i%2 ==1)
				{
					printf(":");
				}
			}
			printf("Z");
    15f2:	8a e5       	ldi	r24, 0x5A	; 90
    15f4:	90 e0       	ldi	r25, 0x00	; 0
    15f6:	b2 d4       	rcall	.+2404   	; 0x1f5c <putchar>
			// Davita has this routine specified in the notebook.
			//============================
			//
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    15f8:	0e 94 20 02 	call	0x440	; 0x440 <start_gas_sensor_read>
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    15fc:	f7 01       	movw	r30, r14
    15fe:	81 81       	ldd	r24, Z+1	; 0x01
    1600:	8f 93       	push	r24
    1602:	80 81       	ld	r24, Z
    1604:	8f 93       	push	r24
    1606:	a0 ee       	ldi	r26, 0xE0	; 224
    1608:	b1 e0       	ldi	r27, 0x01	; 1
    160a:	bf 93       	push	r27
    160c:	af 93       	push	r26
    160e:	93 d4       	rcall	.+2342   	; 0x1f36 <printf>
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
    1610:	d7 01       	movw	r26, r14
    1612:	13 96       	adiw	r26, 0x03	; 3
    1614:	8c 91       	ld	r24, X
    1616:	13 97       	sbiw	r26, 0x03	; 3
    1618:	8f 93       	push	r24
    161a:	12 96       	adiw	r26, 0x02	; 2
    161c:	8c 91       	ld	r24, X
    161e:	8f 93       	push	r24
    1620:	a6 ef       	ldi	r26, 0xF6	; 246
    1622:	b1 e0       	ldi	r27, 0x01	; 1
    1624:	bf 93       	push	r27
    1626:	af 93       	push	r26
    1628:	86 d4       	rcall	.+2316   	; 0x1f36 <printf>
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
    162a:	d7 01       	movw	r26, r14
    162c:	15 96       	adiw	r26, 0x05	; 5
    162e:	8c 91       	ld	r24, X
    1630:	15 97       	sbiw	r26, 0x05	; 5
    1632:	8f 93       	push	r24
    1634:	14 96       	adiw	r26, 0x04	; 4
    1636:	8c 91       	ld	r24, X
    1638:	8f 93       	push	r24
    163a:	a5 e0       	ldi	r26, 0x05	; 5
    163c:	b2 e0       	ldi	r27, 0x02	; 2
    163e:	bf 93       	push	r27
    1640:	af 93       	push	r26
    1642:	79 d4       	rcall	.+2290   	; 0x1f36 <printf>
 			printf("\nMethane = %u", raw_gas_vector[3]);
    1644:	d7 01       	movw	r26, r14
    1646:	17 96       	adiw	r26, 0x07	; 7
    1648:	8c 91       	ld	r24, X
    164a:	17 97       	sbiw	r26, 0x07	; 7
    164c:	8f 93       	push	r24
    164e:	16 96       	adiw	r26, 0x06	; 6
    1650:	8c 91       	ld	r24, X
    1652:	8f 93       	push	r24
    1654:	a3 e1       	ldi	r26, 0x13	; 19
    1656:	b2 e0       	ldi	r27, 0x02	; 2
    1658:	bf 93       	push	r27
    165a:	af 93       	push	r26
    165c:	6c d4       	rcall	.+2264   	; 0x1f36 <printf>
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
    165e:	d7 01       	movw	r26, r14
    1660:	19 96       	adiw	r26, 0x09	; 9
    1662:	8c 91       	ld	r24, X
    1664:	19 97       	sbiw	r26, 0x09	; 9
    1666:	8f 93       	push	r24
    1668:	18 96       	adiw	r26, 0x08	; 8
    166a:	8c 91       	ld	r24, X
    166c:	8f 93       	push	r24
    166e:	a1 e2       	ldi	r26, 0x21	; 33
    1670:	b2 e0       	ldi	r27, 0x02	; 2
    1672:	bf 93       	push	r27
    1674:	af 93       	push	r26
    1676:	5f d4       	rcall	.+2238   	; 0x1f36 <printf>
			// Now test the BME interface...
			// THIS ROUTINE NOT YET WRITTEN
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
    1678:	92 d9       	rcall	.-3292   	; 0x99e <bme280basic_bulk_data_read>
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    167a:	60 91 cd 06 	lds	r22, 0x06CD	; 0x8006cd <rawTemp>
    167e:	70 91 ce 06 	lds	r23, 0x06CE	; 0x8006ce <rawTemp+0x1>
    1682:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <rawTemp+0x2>
    1686:	90 91 d0 06 	lds	r25, 0x06D0	; 0x8006d0 <rawTemp+0x3>
    168a:	6c da       	rcall	.-2856   	; 0xb64 <BME280_compensate_T_int32>
    168c:	60 93 c7 06 	sts	0x06C7, r22	; 0x8006c7 <tempCelsius>
    1690:	70 93 c8 06 	sts	0x06C8, r23	; 0x8006c8 <tempCelsius+0x1>
    1694:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <tempCelsius+0x2>
    1698:	90 93 ca 06 	sts	0x06CA, r25	; 0x8006ca <tempCelsius+0x3>
			sprintf(temperatureBuf, "%lu", tempCelsius);
    169c:	9f 93       	push	r25
    169e:	8f 93       	push	r24
    16a0:	7f 93       	push	r23
    16a2:	6f 93       	push	r22
    16a4:	df 92       	push	r13
    16a6:	cf 92       	push	r12
    16a8:	8d ee       	ldi	r24, 0xED	; 237
    16aa:	96 e0       	ldi	r25, 0x06	; 6
    16ac:	9f 93       	push	r25
    16ae:	8f 93       	push	r24
    16b0:	5a d4       	rcall	.+2228   	; 0x1f66 <sprintf>
 			printf("\nCelsius = %lu\n", tempCelsius);
    16b2:	80 91 ca 06 	lds	r24, 0x06CA	; 0x8006ca <tempCelsius+0x3>
    16b6:	8f 93       	push	r24
    16b8:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <tempCelsius+0x2>
    16bc:	8f 93       	push	r24
    16be:	80 91 c8 06 	lds	r24, 0x06C8	; 0x8006c8 <tempCelsius+0x1>
    16c2:	8f 93       	push	r24
    16c4:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <tempCelsius>
    16c8:	8f 93       	push	r24
    16ca:	82 e3       	ldi	r24, 0x32	; 50
    16cc:	92 e0       	ldi	r25, 0x02	; 2
    16ce:	9f 93       	push	r25
    16d0:	8f 93       	push	r24
    16d2:	31 d4       	rcall	.+2146   	; 0x1f36 <printf>
			pressure = BME280_compensate_P_int64(rawPress);
    16d4:	8d b7       	in	r24, 0x3d	; 61
    16d6:	9e b7       	in	r25, 0x3e	; 62
    16d8:	82 96       	adiw	r24, 0x22	; 34
    16da:	0f b6       	in	r0, 0x3f	; 63
    16dc:	f8 94       	cli
    16de:	9e bf       	out	0x3e, r25	; 62
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	8d bf       	out	0x3d, r24	; 61
    16e4:	60 91 e5 06 	lds	r22, 0x06E5	; 0x8006e5 <rawPress>
    16e8:	70 91 e6 06 	lds	r23, 0x06E6	; 0x8006e6 <rawPress+0x1>
    16ec:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <rawPress+0x2>
    16f0:	90 91 e8 06 	lds	r25, 0x06E8	; 0x8006e8 <rawPress+0x3>
    16f4:	c4 da       	rcall	.-2680   	; 0xc7e <BME280_compensate_P_int64>
    16f6:	60 93 d6 06 	sts	0x06D6, r22	; 0x8006d6 <pressure>
    16fa:	70 93 d7 06 	sts	0x06D7, r23	; 0x8006d7 <pressure+0x1>
    16fe:	80 93 d8 06 	sts	0x06D8, r24	; 0x8006d8 <pressure+0x2>
    1702:	90 93 d9 06 	sts	0x06D9, r25	; 0x8006d9 <pressure+0x3>
			printf("\nPressure in Pa = %lu\n", pressure>>8);
    1706:	bb 27       	eor	r27, r27
    1708:	97 fd       	sbrc	r25, 7
    170a:	ba 95       	dec	r27
    170c:	a9 2f       	mov	r26, r25
    170e:	98 2f       	mov	r25, r24
    1710:	87 2f       	mov	r24, r23
    1712:	bf 93       	push	r27
    1714:	af 93       	push	r26
    1716:	9f 93       	push	r25
    1718:	8f 93       	push	r24
    171a:	82 e4       	ldi	r24, 0x42	; 66
    171c:	92 e0       	ldi	r25, 0x02	; 2
    171e:	9f 93       	push	r25
    1720:	8f 93       	push	r24
    1722:	09 d4       	rcall	.+2066   	; 0x1f36 <printf>
			humidity = bme280_compensate_H_int32(rawHum);
    1724:	60 91 e9 06 	lds	r22, 0x06E9	; 0x8006e9 <rawHum>
    1728:	70 91 ea 06 	lds	r23, 0x06EA	; 0x8006ea <rawHum+0x1>
    172c:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <rawHum+0x2>
    1730:	90 91 ec 06 	lds	r25, 0x06EC	; 0x8006ec <rawHum+0x3>
    1734:	f1 dc       	rcall	.-1566   	; 0x1118 <bme280_compensate_H_int32>
    1736:	1b 01       	movw	r2, r22
    1738:	2c 01       	movw	r4, r24
    173a:	60 93 de 06 	sts	0x06DE, r22	; 0x8006de <humidity>
    173e:	70 93 df 06 	sts	0x06DF, r23	; 0x8006df <humidity+0x1>
    1742:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <humidity+0x2>
    1746:	90 93 e1 06 	sts	0x06E1, r25	; 0x8006e1 <humidity+0x3>
			printf("\n Humidity in percent relative humidity= %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    174a:	a8 ee       	ldi	r26, 0xE8	; 232
    174c:	b3 e0       	ldi	r27, 0x03	; 3
    174e:	9b 01       	movw	r18, r22
    1750:	ac 01       	movw	r20, r24
    1752:	5c d2       	rcall	.+1208   	; 0x1c0c <__muluhisi3>
    1754:	dc 01       	movw	r26, r24
    1756:	cb 01       	movw	r24, r22
    1758:	07 2e       	mov	r0, r23
    175a:	7a e0       	ldi	r23, 0x0A	; 10
    175c:	b5 95       	asr	r27
    175e:	a7 95       	ror	r26
    1760:	97 95       	ror	r25
    1762:	87 95       	ror	r24
    1764:	7a 95       	dec	r23
    1766:	d1 f7       	brne	.-12     	; 0x175c <main+0x2b8>
    1768:	70 2d       	mov	r23, r0
    176a:	bf 93       	push	r27
    176c:	af 93       	push	r26
    176e:	9f 93       	push	r25
    1770:	8f 93       	push	r24
    1772:	d2 01       	movw	r26, r4
    1774:	c1 01       	movw	r24, r2
    1776:	07 2e       	mov	r0, r23
    1778:	7a e0       	ldi	r23, 0x0A	; 10
    177a:	b5 95       	asr	r27
    177c:	a7 95       	ror	r26
    177e:	97 95       	ror	r25
    1780:	87 95       	ror	r24
    1782:	7a 95       	dec	r23
    1784:	d1 f7       	brne	.-12     	; 0x177a <main+0x2d6>
    1786:	70 2d       	mov	r23, r0
    1788:	bf 93       	push	r27
    178a:	af 93       	push	r26
    178c:	9f 93       	push	r25
    178e:	8f 93       	push	r24
    1790:	89 e5       	ldi	r24, 0x59	; 89
    1792:	92 e0       	ldi	r25, 0x02	; 2
    1794:	9f 93       	push	r25
    1796:	8f 93       	push	r24
    1798:	ce d3       	rcall	.+1948   	; 0x1f36 <printf>
			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb", temp, temp+2, pressure, humidity); //need key
    179a:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <temp>
    179e:	20 91 6a 05 	lds	r18, 0x056A	; 0x80056a <temp>
    17a2:	90 91 e1 06 	lds	r25, 0x06E1	; 0x8006e1 <humidity+0x3>
    17a6:	9f 93       	push	r25
    17a8:	90 91 e0 06 	lds	r25, 0x06E0	; 0x8006e0 <humidity+0x2>
    17ac:	9f 93       	push	r25
    17ae:	90 91 df 06 	lds	r25, 0x06DF	; 0x8006df <humidity+0x1>
    17b2:	9f 93       	push	r25
    17b4:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <humidity>
    17b8:	9f 93       	push	r25
    17ba:	90 91 d9 06 	lds	r25, 0x06D9	; 0x8006d9 <pressure+0x3>
    17be:	9f 93       	push	r25
    17c0:	90 91 d8 06 	lds	r25, 0x06D8	; 0x8006d8 <pressure+0x2>
    17c4:	9f 93       	push	r25
    17c6:	90 91 d7 06 	lds	r25, 0x06D7	; 0x8006d7 <pressure+0x1>
    17ca:	9f 93       	push	r25
    17cc:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <pressure>
    17d0:	9f 93       	push	r25
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	02 96       	adiw	r24, 0x02	; 2
    17d6:	9f 93       	push	r25
    17d8:	8f 93       	push	r24
    17da:	1f 92       	push	r1
    17dc:	2f 93       	push	r18
    17de:	8b e8       	ldi	r24, 0x8B	; 139
    17e0:	92 e0       	ldi	r25, 0x02	; 2
    17e2:	9f 93       	push	r25
    17e4:	8f 93       	push	r24
    17e6:	a7 d3       	rcall	.+1870   	; 0x1f36 <printf>
    17e8:	ad b7       	in	r26, 0x3d	; 61
    17ea:	be b7       	in	r27, 0x3e	; 62
    17ec:	5e 96       	adiw	r26, 0x1e	; 30
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	f8 94       	cli
    17f2:	be bf       	out	0x3e, r27	; 62
    17f4:	0f be       	out	0x3f, r0	; 63
    17f6:	ad bf       	out	0x3d, r26	; 61
    17f8:	a4 ce       	rjmp	.-696    	; 0x1542 <main+0x9e>

000017fa <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    17fa:	8d e0       	ldi	r24, 0x0D	; 13
    17fc:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    1800:	8a e4       	ldi	r24, 0x4A	; 74
    1802:	9c e4       	ldi	r25, 0x4C	; 76
    1804:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1808:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
    180c:	82 e0       	ldi	r24, 0x02	; 2
    180e:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    1812:	08 95       	ret

00001814 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    1814:	18 95       	reti

00001816 <__vector_13>:
}
*/


ISR(TIMER1_COMPA_vect)
{
    1816:	1f 92       	push	r1
    1818:	0f 92       	push	r0
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	0f 92       	push	r0
    181e:	11 24       	eor	r1, r1
    1820:	8f 93       	push	r24
    1822:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    1824:	95 b1       	in	r25, 0x05	; 5
    1826:	82 e0       	ldi	r24, 0x02	; 2
    1828:	89 27       	eor	r24, r25
    182a:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	80 93 52 05 	sts	0x0552, r24	; 0x800552 <ItsTime>
}
    1832:	9f 91       	pop	r25
    1834:	8f 91       	pop	r24
    1836:	0f 90       	pop	r0
    1838:	0f be       	out	0x3f, r0	; 63
    183a:	0f 90       	pop	r0
    183c:	1f 90       	pop	r1
    183e:	18 95       	reti

00001840 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1840:	81 e1       	ldi	r24, 0x11	; 17
    1842:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    1846:	8f ef       	ldi	r24, 0xFF	; 255
    1848:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    184c:	84 e0       	ldi	r24, 0x04	; 4
    184e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1852:	08 95       	ret

00001854 <TWI_Transceiver_Busy>:
    1854:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1858:	81 78       	andi	r24, 0x81	; 129
    185a:	08 95       	ret

0000185c <TWI_Start_Transceiver_With_Data>:
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	ec 01       	movw	r28, r24
    1862:	ec eb       	ldi	r30, 0xBC	; 188
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	90 81       	ld	r25, Z
    1868:	91 78       	andi	r25, 0x81	; 129
    186a:	e9 f7       	brne	.-6      	; 0x1866 <TWI_Start_Transceiver_With_Data+0xa>
    186c:	60 93 24 03 	sts	0x0324, r22	; 0x800324 <TWI_msgSize>
    1870:	88 81       	ld	r24, Y
    1872:	80 93 25 03 	sts	0x0325, r24	; 0x800325 <TWI_buf>
    1876:	80 fd       	sbrc	r24, 0
    1878:	12 c0       	rjmp	.+36     	; 0x189e <TWI_Start_Transceiver_With_Data+0x42>
    187a:	62 30       	cpi	r22, 0x02	; 2
    187c:	80 f0       	brcs	.+32     	; 0x189e <TWI_Start_Transceiver_With_Data+0x42>
    187e:	fe 01       	movw	r30, r28
    1880:	31 96       	adiw	r30, 0x01	; 1
    1882:	a6 e2       	ldi	r26, 0x26	; 38
    1884:	b3 e0       	ldi	r27, 0x03	; 3
    1886:	62 50       	subi	r22, 0x02	; 2
    1888:	26 2f       	mov	r18, r22
    188a:	30 e0       	ldi	r19, 0x00	; 0
    188c:	2e 5f       	subi	r18, 0xFE	; 254
    188e:	3f 4f       	sbci	r19, 0xFF	; 255
    1890:	2c 0f       	add	r18, r28
    1892:	3d 1f       	adc	r19, r29
    1894:	91 91       	ld	r25, Z+
    1896:	9d 93       	st	X+, r25
    1898:	e2 17       	cp	r30, r18
    189a:	f3 07       	cpc	r31, r19
    189c:	d9 f7       	brne	.-10     	; 0x1894 <TWI_Start_Transceiver_With_Data+0x38>
    189e:	10 92 23 03 	sts	0x0323, r1	; 0x800323 <TWI_statusReg>
    18a2:	88 ef       	ldi	r24, 0xF8	; 248
    18a4:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    18a8:	85 ea       	ldi	r24, 0xA5	; 165
    18aa:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	08 95       	ret

000018b4 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    18b4:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    18b6:	ec eb       	ldi	r30, 0xBC	; 188
    18b8:	f0 e0       	ldi	r31, 0x00	; 0
    18ba:	90 81       	ld	r25, Z
    18bc:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    18be:	e9 f7       	brne	.-6      	; 0x18ba <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    18c0:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <TWI_statusReg>
    18c4:	80 ff       	sbrs	r24, 0
    18c6:	11 c0       	rjmp	.+34     	; 0x18ea <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    18c8:	66 23       	and	r22, r22
    18ca:	79 f0       	breq	.+30     	; 0x18ea <TWI_Get_Data_From_Transceiver+0x36>
    18cc:	a5 e2       	ldi	r26, 0x25	; 37
    18ce:	b3 e0       	ldi	r27, 0x03	; 3
    18d0:	fa 01       	movw	r30, r20
    18d2:	61 50       	subi	r22, 0x01	; 1
    18d4:	26 2f       	mov	r18, r22
    18d6:	30 e0       	ldi	r19, 0x00	; 0
    18d8:	2f 5f       	subi	r18, 0xFF	; 255
    18da:	3f 4f       	sbci	r19, 0xFF	; 255
    18dc:	24 0f       	add	r18, r20
    18de:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    18e0:	9d 91       	ld	r25, X+
    18e2:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    18e4:	e2 17       	cp	r30, r18
    18e6:	f3 07       	cpc	r31, r19
    18e8:	d9 f7       	brne	.-10     	; 0x18e0 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    18ea:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <TWI_statusReg>
}
    18ee:	81 70       	andi	r24, 0x01	; 1
    18f0:	08 95       	ret

000018f2 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    18f2:	1f 92       	push	r1
    18f4:	0f 92       	push	r0
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	0f 92       	push	r0
    18fa:	11 24       	eor	r1, r1
    18fc:	2f 93       	push	r18
    18fe:	3f 93       	push	r19
    1900:	8f 93       	push	r24
    1902:	9f 93       	push	r25
    1904:	af 93       	push	r26
    1906:	bf 93       	push	r27
    1908:	ef 93       	push	r30
    190a:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    190c:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1910:	8e 2f       	mov	r24, r30
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	fc 01       	movw	r30, r24
    1916:	38 97       	sbiw	r30, 0x08	; 8
    1918:	e1 35       	cpi	r30, 0x51	; 81
    191a:	f1 05       	cpc	r31, r1
    191c:	08 f0       	brcs	.+2      	; 0x1920 <__vector_26+0x2e>
    191e:	55 c0       	rjmp	.+170    	; 0x19ca <__vector_26+0xd8>
    1920:	e2 5c       	subi	r30, 0xC2	; 194
    1922:	ff 4f       	sbci	r31, 0xFF	; 255
    1924:	6d c1       	rjmp	.+730    	; 0x1c00 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    1926:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    192a:	e0 91 22 03 	lds	r30, 0x0322	; 0x800322 <TWI_bufPtr.1555>
    192e:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <TWI_msgSize>
    1932:	e8 17       	cp	r30, r24
    1934:	70 f4       	brcc	.+28     	; 0x1952 <__vector_26+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	8e 0f       	add	r24, r30
    193a:	80 93 22 03 	sts	0x0322, r24	; 0x800322 <TWI_bufPtr.1555>
    193e:	f0 e0       	ldi	r31, 0x00	; 0
    1940:	eb 5d       	subi	r30, 0xDB	; 219
    1942:	fc 4f       	sbci	r31, 0xFC	; 252
    1944:	80 81       	ld	r24, Z
    1946:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    194a:	85 e8       	ldi	r24, 0x85	; 133
    194c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1950:	43 c0       	rjmp	.+134    	; 0x19d8 <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1952:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <TWI_statusReg>
    1956:	81 60       	ori	r24, 0x01	; 1
    1958:	80 93 23 03 	sts	0x0323, r24	; 0x800323 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    195c:	84 e9       	ldi	r24, 0x94	; 148
    195e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1962:	3a c0       	rjmp	.+116    	; 0x19d8 <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    1964:	e0 91 22 03 	lds	r30, 0x0322	; 0x800322 <TWI_bufPtr.1555>
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	8e 0f       	add	r24, r30
    196c:	80 93 22 03 	sts	0x0322, r24	; 0x800322 <TWI_bufPtr.1555>
    1970:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1974:	f0 e0       	ldi	r31, 0x00	; 0
    1976:	eb 5d       	subi	r30, 0xDB	; 219
    1978:	fc 4f       	sbci	r31, 0xFC	; 252
    197a:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    197c:	20 91 22 03 	lds	r18, 0x0322	; 0x800322 <TWI_bufPtr.1555>
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	80 91 24 03 	lds	r24, 0x0324	; 0x800324 <TWI_msgSize>
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	01 97       	sbiw	r24, 0x01	; 1
    198a:	28 17       	cp	r18, r24
    198c:	39 07       	cpc	r19, r25
    198e:	24 f4       	brge	.+8      	; 0x1998 <__vector_26+0xa6>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1990:	85 ec       	ldi	r24, 0xC5	; 197
    1992:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1996:	20 c0       	rjmp	.+64     	; 0x19d8 <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1998:	85 e8       	ldi	r24, 0x85	; 133
    199a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    199e:	1c c0       	rjmp	.+56     	; 0x19d8 <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    19a0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    19a4:	e0 91 22 03 	lds	r30, 0x0322	; 0x800322 <TWI_bufPtr.1555>
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	eb 5d       	subi	r30, 0xDB	; 219
    19ac:	fc 4f       	sbci	r31, 0xFC	; 252
    19ae:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    19b0:	80 91 23 03 	lds	r24, 0x0323	; 0x800323 <TWI_statusReg>
    19b4:	81 60       	ori	r24, 0x01	; 1
    19b6:	80 93 23 03 	sts	0x0323, r24	; 0x800323 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19ba:	84 e9       	ldi	r24, 0x94	; 148
    19bc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    19c0:	0b c0       	rjmp	.+22     	; 0x19d8 <__vector_26+0xe6>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    19c2:	85 ea       	ldi	r24, 0xA5	; 165
    19c4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    19c8:	07 c0       	rjmp	.+14     	; 0x19d8 <__vector_26+0xe6>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    19ca:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    19ce:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    19d2:	84 e0       	ldi	r24, 0x04	; 4
    19d4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    19d8:	ff 91       	pop	r31
    19da:	ef 91       	pop	r30
    19dc:	bf 91       	pop	r27
    19de:	af 91       	pop	r26
    19e0:	9f 91       	pop	r25
    19e2:	8f 91       	pop	r24
    19e4:	3f 91       	pop	r19
    19e6:	2f 91       	pop	r18
    19e8:	0f 90       	pop	r0
    19ea:	0f be       	out	0x3f, r0	; 63
    19ec:	0f 90       	pop	r0
    19ee:	1f 90       	pop	r1
    19f0:	18 95       	reti

000019f2 <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    19f2:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    19f6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    19fa:	88 e9       	ldi	r24, 0x98	; 152
    19fc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1a00:	8e e0       	ldi	r24, 0x0E	; 14
    1a02:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1a06:	10 92 37 04 	sts	0x0437, r1	; 0x800437 <UART0_RxTail>
    1a0a:	10 92 38 04 	sts	0x0438, r1	; 0x800438 <UART0_RxHead>
    1a0e:	10 92 35 03 	sts	0x0335, r1	; 0x800335 <UART0_TxTail>
    1a12:	10 92 36 03 	sts	0x0336, r1	; 0x800336 <UART0_TxHead>
    1a16:	08 95       	ret

00001a18 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1a18:	20 91 36 03 	lds	r18, 0x0336	; 0x800336 <UART0_TxHead>
    1a1c:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1a1e:	90 91 35 03 	lds	r25, 0x0335	; 0x800335 <UART0_TxTail>
    1a22:	29 17       	cp	r18, r25
    1a24:	e1 f3       	breq	.-8      	; 0x1a1e <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    1a26:	e2 2f       	mov	r30, r18
    1a28:	f0 e0       	ldi	r31, 0x00	; 0
    1a2a:	e9 5c       	subi	r30, 0xC9	; 201
    1a2c:	fc 4f       	sbci	r31, 0xFC	; 252
    1a2e:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    1a30:	20 93 36 03 	sts	0x0336, r18	; 0x800336 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    1a34:	e1 ec       	ldi	r30, 0xC1	; 193
    1a36:	f0 e0       	ldi	r31, 0x00	; 0
    1a38:	80 81       	ld	r24, Z
    1a3a:	80 62       	ori	r24, 0x20	; 32
    1a3c:	80 83       	st	Z, r24
    1a3e:	08 95       	ret

00001a40 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1a40:	20 91 36 03 	lds	r18, 0x0336	; 0x800336 <UART0_TxHead>
    1a44:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1a46:	90 91 35 03 	lds	r25, 0x0335	; 0x800335 <UART0_TxTail>
    1a4a:	29 17       	cp	r18, r25
    1a4c:	e1 f3       	breq	.-8      	; 0x1a46 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    1a4e:	e2 2f       	mov	r30, r18
    1a50:	f0 e0       	ldi	r31, 0x00	; 0
    1a52:	e9 5c       	subi	r30, 0xC9	; 201
    1a54:	fc 4f       	sbci	r31, 0xFC	; 252
    1a56:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    1a58:	20 93 36 03 	sts	0x0336, r18	; 0x800336 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    1a5c:	e1 ec       	ldi	r30, 0xC1	; 193
    1a5e:	f0 e0       	ldi	r31, 0x00	; 0
    1a60:	80 81       	ld	r24, Z
    1a62:	80 62       	ori	r24, 0x20	; 32
    1a64:	80 83       	st	Z, r24
	return(0);
}
    1a66:	80 e0       	ldi	r24, 0x00	; 0
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	08 95       	ret

00001a6c <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    1a6c:	cf 93       	push	r28
    1a6e:	df 93       	push	r29
    1a70:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    1a72:	88 81       	ld	r24, Y
    1a74:	88 23       	and	r24, r24
    1a76:	29 f0       	breq	.+10     	; 0x1a82 <USART0_putstring+0x16>
    1a78:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    1a7a:	ce df       	rcall	.-100    	; 0x1a18 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    1a7c:	89 91       	ld	r24, Y+
    1a7e:	81 11       	cpse	r24, r1
    1a80:	fc cf       	rjmp	.-8      	; 0x1a7a <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	08 95       	ret

00001a88 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1a88:	1f 92       	push	r1
    1a8a:	0f 92       	push	r0
    1a8c:	0f b6       	in	r0, 0x3f	; 63
    1a8e:	0f 92       	push	r0
    1a90:	11 24       	eor	r1, r1
    1a92:	8f 93       	push	r24
    1a94:	9f 93       	push	r25
    1a96:	ef 93       	push	r30
    1a98:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1a9a:	90 91 36 03 	lds	r25, 0x0336	; 0x800336 <UART0_TxHead>
    1a9e:	80 91 35 03 	lds	r24, 0x0335	; 0x800335 <UART0_TxTail>
    1aa2:	98 17       	cp	r25, r24
    1aa4:	61 f0       	breq	.+24     	; 0x1abe <__vector_21+0x36>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1aa6:	e0 91 35 03 	lds	r30, 0x0335	; 0x800335 <UART0_TxTail>
    1aaa:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1aac:	e0 93 35 03 	sts	0x0335, r30	; 0x800335 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1ab0:	f0 e0       	ldi	r31, 0x00	; 0
    1ab2:	e9 5c       	subi	r30, 0xC9	; 201
    1ab4:	fc 4f       	sbci	r31, 0xFC	; 252
    1ab6:	80 81       	ld	r24, Z
    1ab8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1abc:	05 c0       	rjmp	.+10     	; 0x1ac8 <__vector_21+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1abe:	e1 ec       	ldi	r30, 0xC1	; 193
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	80 81       	ld	r24, Z
    1ac4:	8f 7d       	andi	r24, 0xDF	; 223
    1ac6:	80 83       	st	Z, r24
	}
    1ac8:	ff 91       	pop	r31
    1aca:	ef 91       	pop	r30
    1acc:	9f 91       	pop	r25
    1ace:	8f 91       	pop	r24
    1ad0:	0f 90       	pop	r0
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	0f 90       	pop	r0
    1ad6:	1f 90       	pop	r1
    1ad8:	18 95       	reti

00001ada <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1ada:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1ade:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1ae2:	88 e9       	ldi	r24, 0x98	; 152
    1ae4:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1ae8:	86 e0       	ldi	r24, 0x06	; 6
    1aea:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1aee:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <UART1_RxTail>
    1af2:	10 92 3c 05 	sts	0x053C, r1	; 0x80053c <UART1_RxHead>
    1af6:	10 92 39 04 	sts	0x0439, r1	; 0x800439 <UART1_TxTail>
    1afa:	10 92 3a 04 	sts	0x043A, r1	; 0x80043a <UART1_TxHead>
    1afe:	08 95       	ret

00001b00 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1b00:	1f 92       	push	r1
    1b02:	0f 92       	push	r0
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	0f 92       	push	r0
    1b08:	11 24       	eor	r1, r1
    1b0a:	2f 93       	push	r18
    1b0c:	3f 93       	push	r19
    1b0e:	8f 93       	push	r24
    1b10:	9f 93       	push	r25
    1b12:	af 93       	push	r26
    1b14:	bf 93       	push	r27
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	ef 93       	push	r30
    1b1c:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1b1e:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1b22:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <UART1_RxHead>
    1b26:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1b28:	80 93 3c 05 	sts	0x053C, r24	; 0x80053c <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1b2c:	20 91 3b 05 	lds	r18, 0x053B	; 0x80053b <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1b30:	e8 2f       	mov	r30, r24
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	e7 5f       	subi	r30, 0xF7	; 247
    1b36:	f8 4f       	sbci	r31, 0xF8	; 248
    1b38:	90 83       	st	Z, r25
	
	if (data == 10)
    1b3a:	9a 30       	cpi	r25, 0x0A	; 10
    1b3c:	d1 f4       	brne	.+52     	; 0x1b72 <__vector_28+0x72>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1b3e:	90 91 0e 07 	lds	r25, 0x070E	; 0x80070e <UART1_RxBuf+0x5>
    1b42:	97 34       	cpi	r25, 0x47	; 71
    1b44:	91 f4       	brne	.+36     	; 0x1b6a <__vector_28+0x6a>
    1b46:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
    1b48:	2e 2f       	mov	r18, r30
    1b4a:	30 e0       	ldi	r19, 0x00	; 0
    1b4c:	d9 01       	movw	r26, r18
    1b4e:	a7 5f       	subi	r26, 0xF7	; 247
    1b50:	b7 4f       	sbci	r27, 0xF7	; 247
    1b52:	e9 01       	movw	r28, r18
    1b54:	c7 5f       	subi	r28, 0xF7	; 247
    1b56:	d8 4f       	sbci	r29, 0xF8	; 248
    1b58:	98 81       	ld	r25, Y
    1b5a:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1b5c:	ef 5f       	subi	r30, 0xFF	; 255
    1b5e:	8e 17       	cp	r24, r30
    1b60:	98 f7       	brcc	.-26     	; 0x1b48 <__vector_28+0x48>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
    1b62:	f0 e0       	ldi	r31, 0x00	; 0
    1b64:	e7 5f       	subi	r30, 0xF7	; 247
    1b66:	f7 4f       	sbci	r31, 0xF7	; 247
    1b68:	11 82       	std	Z+1, r1	; 0x01
		}
		UART1_RxTail = 0;
    1b6a:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <UART1_RxTail>
		UART1_RxHead = 0;
    1b6e:	10 92 3c 05 	sts	0x053C, r1	; 0x80053c <UART1_RxHead>
	}
}
    1b72:	ff 91       	pop	r31
    1b74:	ef 91       	pop	r30
    1b76:	df 91       	pop	r29
    1b78:	cf 91       	pop	r28
    1b7a:	bf 91       	pop	r27
    1b7c:	af 91       	pop	r26
    1b7e:	9f 91       	pop	r25
    1b80:	8f 91       	pop	r24
    1b82:	3f 91       	pop	r19
    1b84:	2f 91       	pop	r18
    1b86:	0f 90       	pop	r0
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	0f 90       	pop	r0
    1b8c:	1f 90       	pop	r1
    1b8e:	18 95       	reti

00001b90 <__vector_29>:

ISR(USART1_UDRE_vect)
{
    1b90:	1f 92       	push	r1
    1b92:	0f 92       	push	r0
    1b94:	0f b6       	in	r0, 0x3f	; 63
    1b96:	0f 92       	push	r0
    1b98:	11 24       	eor	r1, r1
    1b9a:	8f 93       	push	r24
    1b9c:	9f 93       	push	r25
    1b9e:	ef 93       	push	r30
    1ba0:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
    1ba2:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <UART1_TxHead>
    1ba6:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <UART1_TxTail>
    1baa:	98 17       	cp	r25, r24
    1bac:	61 f0       	breq	.+24     	; 0x1bc6 <__vector_29+0x36>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
    1bae:	e0 91 39 04 	lds	r30, 0x0439	; 0x800439 <UART1_TxTail>
    1bb2:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
    1bb4:	e0 93 39 04 	sts	0x0439, r30	; 0x800439 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
    1bb8:	f0 e0       	ldi	r31, 0x00	; 0
    1bba:	e5 5c       	subi	r30, 0xC5	; 197
    1bbc:	fb 4f       	sbci	r31, 0xFB	; 251
    1bbe:	80 81       	ld	r24, Z
    1bc0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1bc4:	05 c0       	rjmp	.+10     	; 0x1bd0 <__vector_29+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
    1bc6:	e9 ec       	ldi	r30, 0xC9	; 201
    1bc8:	f0 e0       	ldi	r31, 0x00	; 0
    1bca:	80 81       	ld	r24, Z
    1bcc:	8f 7d       	andi	r24, 0xDF	; 223
    1bce:	80 83       	st	Z, r24
	}
    1bd0:	ff 91       	pop	r31
    1bd2:	ef 91       	pop	r30
    1bd4:	9f 91       	pop	r25
    1bd6:	8f 91       	pop	r24
    1bd8:	0f 90       	pop	r0
    1bda:	0f be       	out	0x3f, r0	; 63
    1bdc:	0f 90       	pop	r0
    1bde:	1f 90       	pop	r1
    1be0:	18 95       	reti

00001be2 <__mulsi3>:
    1be2:	db 01       	movw	r26, r22
    1be4:	8f 93       	push	r24
    1be6:	9f 93       	push	r25
    1be8:	11 d0       	rcall	.+34     	; 0x1c0c <__muluhisi3>
    1bea:	bf 91       	pop	r27
    1bec:	af 91       	pop	r26
    1bee:	a2 9f       	mul	r26, r18
    1bf0:	80 0d       	add	r24, r0
    1bf2:	91 1d       	adc	r25, r1
    1bf4:	a3 9f       	mul	r26, r19
    1bf6:	90 0d       	add	r25, r0
    1bf8:	b2 9f       	mul	r27, r18
    1bfa:	90 0d       	add	r25, r0
    1bfc:	11 24       	eor	r1, r1
    1bfe:	08 95       	ret

00001c00 <__tablejump2__>:
    1c00:	ee 0f       	add	r30, r30
    1c02:	ff 1f       	adc	r31, r31
    1c04:	05 90       	lpm	r0, Z+
    1c06:	f4 91       	lpm	r31, Z
    1c08:	e0 2d       	mov	r30, r0
    1c0a:	09 94       	ijmp

00001c0c <__muluhisi3>:
    1c0c:	85 d1       	rcall	.+778    	; 0x1f18 <__umulhisi3>
    1c0e:	a5 9f       	mul	r26, r21
    1c10:	90 0d       	add	r25, r0
    1c12:	b4 9f       	mul	r27, r20
    1c14:	90 0d       	add	r25, r0
    1c16:	a4 9f       	mul	r26, r20
    1c18:	80 0d       	add	r24, r0
    1c1a:	91 1d       	adc	r25, r1
    1c1c:	11 24       	eor	r1, r1
    1c1e:	08 95       	ret

00001c20 <__mulshisi3>:
    1c20:	b7 ff       	sbrs	r27, 7
    1c22:	f4 cf       	rjmp	.-24     	; 0x1c0c <__muluhisi3>

00001c24 <__mulohisi3>:
    1c24:	f3 df       	rcall	.-26     	; 0x1c0c <__muluhisi3>
    1c26:	82 1b       	sub	r24, r18
    1c28:	93 0b       	sbc	r25, r19
    1c2a:	08 95       	ret

00001c2c <__muldi3>:
    1c2c:	df 93       	push	r29
    1c2e:	cf 93       	push	r28
    1c30:	1f 93       	push	r17
    1c32:	0f 93       	push	r16
    1c34:	9a 9d       	mul	r25, r10
    1c36:	f0 2d       	mov	r31, r0
    1c38:	21 9f       	mul	r18, r17
    1c3a:	f0 0d       	add	r31, r0
    1c3c:	8b 9d       	mul	r24, r11
    1c3e:	f0 0d       	add	r31, r0
    1c40:	8a 9d       	mul	r24, r10
    1c42:	e0 2d       	mov	r30, r0
    1c44:	f1 0d       	add	r31, r1
    1c46:	03 9f       	mul	r16, r19
    1c48:	f0 0d       	add	r31, r0
    1c4a:	02 9f       	mul	r16, r18
    1c4c:	e0 0d       	add	r30, r0
    1c4e:	f1 1d       	adc	r31, r1
    1c50:	4e 9d       	mul	r20, r14
    1c52:	e0 0d       	add	r30, r0
    1c54:	f1 1d       	adc	r31, r1
    1c56:	5e 9d       	mul	r21, r14
    1c58:	f0 0d       	add	r31, r0
    1c5a:	4f 9d       	mul	r20, r15
    1c5c:	f0 0d       	add	r31, r0
    1c5e:	7f 93       	push	r23
    1c60:	6f 93       	push	r22
    1c62:	bf 92       	push	r11
    1c64:	af 92       	push	r10
    1c66:	5f 93       	push	r21
    1c68:	4f 93       	push	r20
    1c6a:	d5 01       	movw	r26, r10
    1c6c:	55 d1       	rcall	.+682    	; 0x1f18 <__umulhisi3>
    1c6e:	8b 01       	movw	r16, r22
    1c70:	ac 01       	movw	r20, r24
    1c72:	d7 01       	movw	r26, r14
    1c74:	51 d1       	rcall	.+674    	; 0x1f18 <__umulhisi3>
    1c76:	eb 01       	movw	r28, r22
    1c78:	e8 0f       	add	r30, r24
    1c7a:	f9 1f       	adc	r31, r25
    1c7c:	d6 01       	movw	r26, r12
    1c7e:	1f d0       	rcall	.+62     	; 0x1cbe <__muldi3_6>
    1c80:	2f 91       	pop	r18
    1c82:	3f 91       	pop	r19
    1c84:	d6 01       	movw	r26, r12
    1c86:	48 d1       	rcall	.+656    	; 0x1f18 <__umulhisi3>
    1c88:	c6 0f       	add	r28, r22
    1c8a:	d7 1f       	adc	r29, r23
    1c8c:	e8 1f       	adc	r30, r24
    1c8e:	f9 1f       	adc	r31, r25
    1c90:	af 91       	pop	r26
    1c92:	bf 91       	pop	r27
    1c94:	14 d0       	rcall	.+40     	; 0x1cbe <__muldi3_6>
    1c96:	2f 91       	pop	r18
    1c98:	3f 91       	pop	r19
    1c9a:	3e d1       	rcall	.+636    	; 0x1f18 <__umulhisi3>
    1c9c:	c6 0f       	add	r28, r22
    1c9e:	d7 1f       	adc	r29, r23
    1ca0:	e8 1f       	adc	r30, r24
    1ca2:	f9 1f       	adc	r31, r25
    1ca4:	d6 01       	movw	r26, r12
    1ca6:	38 d1       	rcall	.+624    	; 0x1f18 <__umulhisi3>
    1ca8:	e6 0f       	add	r30, r22
    1caa:	f7 1f       	adc	r31, r23
    1cac:	98 01       	movw	r18, r16
    1cae:	be 01       	movw	r22, r28
    1cb0:	cf 01       	movw	r24, r30
    1cb2:	11 24       	eor	r1, r1
    1cb4:	0f 91       	pop	r16
    1cb6:	1f 91       	pop	r17
    1cb8:	cf 91       	pop	r28
    1cba:	df 91       	pop	r29
    1cbc:	08 95       	ret

00001cbe <__muldi3_6>:
    1cbe:	2c d1       	rcall	.+600    	; 0x1f18 <__umulhisi3>
    1cc0:	46 0f       	add	r20, r22
    1cc2:	57 1f       	adc	r21, r23
    1cc4:	c8 1f       	adc	r28, r24
    1cc6:	d9 1f       	adc	r29, r25
    1cc8:	08 f4       	brcc	.+2      	; 0x1ccc <__muldi3_6+0xe>
    1cca:	31 96       	adiw	r30, 0x01	; 1
    1ccc:	08 95       	ret

00001cce <__moddi3>:
    1cce:	68 94       	set
    1cd0:	01 c0       	rjmp	.+2      	; 0x1cd4 <__divdi3_moddi3>

00001cd2 <__divdi3>:
    1cd2:	e8 94       	clt

00001cd4 <__divdi3_moddi3>:
    1cd4:	f9 2f       	mov	r31, r25
    1cd6:	f1 2b       	or	r31, r17
    1cd8:	0a f0       	brmi	.+2      	; 0x1cdc <__divdi3_moddi3+0x8>
    1cda:	27 c0       	rjmp	.+78     	; 0x1d2a <__udivdi3_umoddi3>
    1cdc:	a0 e0       	ldi	r26, 0x00	; 0
    1cde:	b0 e0       	ldi	r27, 0x00	; 0
    1ce0:	e3 e7       	ldi	r30, 0x73	; 115
    1ce2:	fe e0       	ldi	r31, 0x0E	; 14
    1ce4:	93 c0       	rjmp	.+294    	; 0x1e0c <__prologue_saves__+0xc>
    1ce6:	09 2e       	mov	r0, r25
    1ce8:	05 94       	asr	r0
    1cea:	1a f4       	brpl	.+6      	; 0x1cf2 <__divdi3_moddi3+0x1e>
    1cec:	79 d0       	rcall	.+242    	; 0x1de0 <__negdi2>
    1cee:	11 23       	and	r17, r17
    1cf0:	92 f4       	brpl	.+36     	; 0x1d16 <__divdi3_moddi3+0x42>
    1cf2:	f0 e8       	ldi	r31, 0x80	; 128
    1cf4:	0f 26       	eor	r0, r31
    1cf6:	ff ef       	ldi	r31, 0xFF	; 255
    1cf8:	e0 94       	com	r14
    1cfa:	f0 94       	com	r15
    1cfc:	00 95       	com	r16
    1cfe:	10 95       	com	r17
    1d00:	b0 94       	com	r11
    1d02:	c0 94       	com	r12
    1d04:	d0 94       	com	r13
    1d06:	a1 94       	neg	r10
    1d08:	bf 0a       	sbc	r11, r31
    1d0a:	cf 0a       	sbc	r12, r31
    1d0c:	df 0a       	sbc	r13, r31
    1d0e:	ef 0a       	sbc	r14, r31
    1d10:	ff 0a       	sbc	r15, r31
    1d12:	0f 0b       	sbc	r16, r31
    1d14:	1f 0b       	sbc	r17, r31
    1d16:	13 d0       	rcall	.+38     	; 0x1d3e <__udivmod64>
    1d18:	07 fc       	sbrc	r0, 7
    1d1a:	62 d0       	rcall	.+196    	; 0x1de0 <__negdi2>
    1d1c:	cd b7       	in	r28, 0x3d	; 61
    1d1e:	de b7       	in	r29, 0x3e	; 62
    1d20:	ec e0       	ldi	r30, 0x0C	; 12
    1d22:	90 c0       	rjmp	.+288    	; 0x1e44 <__epilogue_restores__+0xc>

00001d24 <__umoddi3>:
    1d24:	68 94       	set
    1d26:	01 c0       	rjmp	.+2      	; 0x1d2a <__udivdi3_umoddi3>

00001d28 <__udivdi3>:
    1d28:	e8 94       	clt

00001d2a <__udivdi3_umoddi3>:
    1d2a:	8f 92       	push	r8
    1d2c:	9f 92       	push	r9
    1d2e:	cf 93       	push	r28
    1d30:	df 93       	push	r29
    1d32:	05 d0       	rcall	.+10     	; 0x1d3e <__udivmod64>
    1d34:	df 91       	pop	r29
    1d36:	cf 91       	pop	r28
    1d38:	9f 90       	pop	r9
    1d3a:	8f 90       	pop	r8
    1d3c:	08 95       	ret

00001d3e <__udivmod64>:
    1d3e:	88 24       	eor	r8, r8
    1d40:	99 24       	eor	r9, r9
    1d42:	f4 01       	movw	r30, r8
    1d44:	e4 01       	movw	r28, r8
    1d46:	b0 e4       	ldi	r27, 0x40	; 64
    1d48:	9f 93       	push	r25
    1d4a:	aa 27       	eor	r26, r26
    1d4c:	9a 15       	cp	r25, r10
    1d4e:	8b 04       	cpc	r8, r11
    1d50:	9c 04       	cpc	r9, r12
    1d52:	ed 05       	cpc	r30, r13
    1d54:	fe 05       	cpc	r31, r14
    1d56:	cf 05       	cpc	r28, r15
    1d58:	d0 07       	cpc	r29, r16
    1d5a:	a1 07       	cpc	r26, r17
    1d5c:	98 f4       	brcc	.+38     	; 0x1d84 <__udivmod64+0x46>
    1d5e:	ad 2f       	mov	r26, r29
    1d60:	dc 2f       	mov	r29, r28
    1d62:	cf 2f       	mov	r28, r31
    1d64:	fe 2f       	mov	r31, r30
    1d66:	e9 2d       	mov	r30, r9
    1d68:	98 2c       	mov	r9, r8
    1d6a:	89 2e       	mov	r8, r25
    1d6c:	98 2f       	mov	r25, r24
    1d6e:	87 2f       	mov	r24, r23
    1d70:	76 2f       	mov	r23, r22
    1d72:	65 2f       	mov	r22, r21
    1d74:	54 2f       	mov	r21, r20
    1d76:	43 2f       	mov	r20, r19
    1d78:	32 2f       	mov	r19, r18
    1d7a:	22 27       	eor	r18, r18
    1d7c:	b8 50       	subi	r27, 0x08	; 8
    1d7e:	31 f7       	brne	.-52     	; 0x1d4c <__udivmod64+0xe>
    1d80:	bf 91       	pop	r27
    1d82:	27 c0       	rjmp	.+78     	; 0x1dd2 <__udivmod64+0x94>
    1d84:	1b 2e       	mov	r1, r27
    1d86:	bf 91       	pop	r27
    1d88:	bb 27       	eor	r27, r27
    1d8a:	22 0f       	add	r18, r18
    1d8c:	33 1f       	adc	r19, r19
    1d8e:	44 1f       	adc	r20, r20
    1d90:	55 1f       	adc	r21, r21
    1d92:	66 1f       	adc	r22, r22
    1d94:	77 1f       	adc	r23, r23
    1d96:	88 1f       	adc	r24, r24
    1d98:	99 1f       	adc	r25, r25
    1d9a:	88 1c       	adc	r8, r8
    1d9c:	99 1c       	adc	r9, r9
    1d9e:	ee 1f       	adc	r30, r30
    1da0:	ff 1f       	adc	r31, r31
    1da2:	cc 1f       	adc	r28, r28
    1da4:	dd 1f       	adc	r29, r29
    1da6:	aa 1f       	adc	r26, r26
    1da8:	bb 1f       	adc	r27, r27
    1daa:	8a 14       	cp	r8, r10
    1dac:	9b 04       	cpc	r9, r11
    1dae:	ec 05       	cpc	r30, r12
    1db0:	fd 05       	cpc	r31, r13
    1db2:	ce 05       	cpc	r28, r14
    1db4:	df 05       	cpc	r29, r15
    1db6:	a0 07       	cpc	r26, r16
    1db8:	b1 07       	cpc	r27, r17
    1dba:	48 f0       	brcs	.+18     	; 0x1dce <__udivmod64+0x90>
    1dbc:	8a 18       	sub	r8, r10
    1dbe:	9b 08       	sbc	r9, r11
    1dc0:	ec 09       	sbc	r30, r12
    1dc2:	fd 09       	sbc	r31, r13
    1dc4:	ce 09       	sbc	r28, r14
    1dc6:	df 09       	sbc	r29, r15
    1dc8:	a0 0b       	sbc	r26, r16
    1dca:	b1 0b       	sbc	r27, r17
    1dcc:	21 60       	ori	r18, 0x01	; 1
    1dce:	1a 94       	dec	r1
    1dd0:	e1 f6       	brne	.-72     	; 0x1d8a <__udivmod64+0x4c>
    1dd2:	2e f4       	brtc	.+10     	; 0x1dde <__udivmod64+0xa0>
    1dd4:	94 01       	movw	r18, r8
    1dd6:	af 01       	movw	r20, r30
    1dd8:	be 01       	movw	r22, r28
    1dda:	cd 01       	movw	r24, r26
    1ddc:	00 0c       	add	r0, r0
    1dde:	08 95       	ret

00001de0 <__negdi2>:
    1de0:	60 95       	com	r22
    1de2:	70 95       	com	r23
    1de4:	80 95       	com	r24
    1de6:	90 95       	com	r25
    1de8:	30 95       	com	r19
    1dea:	40 95       	com	r20
    1dec:	50 95       	com	r21
    1dee:	21 95       	neg	r18
    1df0:	3f 4f       	sbci	r19, 0xFF	; 255
    1df2:	4f 4f       	sbci	r20, 0xFF	; 255
    1df4:	5f 4f       	sbci	r21, 0xFF	; 255
    1df6:	6f 4f       	sbci	r22, 0xFF	; 255
    1df8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dfa:	8f 4f       	sbci	r24, 0xFF	; 255
    1dfc:	9f 4f       	sbci	r25, 0xFF	; 255
    1dfe:	08 95       	ret

00001e00 <__prologue_saves__>:
    1e00:	2f 92       	push	r2
    1e02:	3f 92       	push	r3
    1e04:	4f 92       	push	r4
    1e06:	5f 92       	push	r5
    1e08:	6f 92       	push	r6
    1e0a:	7f 92       	push	r7
    1e0c:	8f 92       	push	r8
    1e0e:	9f 92       	push	r9
    1e10:	af 92       	push	r10
    1e12:	bf 92       	push	r11
    1e14:	cf 92       	push	r12
    1e16:	df 92       	push	r13
    1e18:	ef 92       	push	r14
    1e1a:	ff 92       	push	r15
    1e1c:	0f 93       	push	r16
    1e1e:	1f 93       	push	r17
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	cd b7       	in	r28, 0x3d	; 61
    1e26:	de b7       	in	r29, 0x3e	; 62
    1e28:	ca 1b       	sub	r28, r26
    1e2a:	db 0b       	sbc	r29, r27
    1e2c:	0f b6       	in	r0, 0x3f	; 63
    1e2e:	f8 94       	cli
    1e30:	de bf       	out	0x3e, r29	; 62
    1e32:	0f be       	out	0x3f, r0	; 63
    1e34:	cd bf       	out	0x3d, r28	; 61
    1e36:	09 94       	ijmp

00001e38 <__epilogue_restores__>:
    1e38:	2a 88       	ldd	r2, Y+18	; 0x12
    1e3a:	39 88       	ldd	r3, Y+17	; 0x11
    1e3c:	48 88       	ldd	r4, Y+16	; 0x10
    1e3e:	5f 84       	ldd	r5, Y+15	; 0x0f
    1e40:	6e 84       	ldd	r6, Y+14	; 0x0e
    1e42:	7d 84       	ldd	r7, Y+13	; 0x0d
    1e44:	8c 84       	ldd	r8, Y+12	; 0x0c
    1e46:	9b 84       	ldd	r9, Y+11	; 0x0b
    1e48:	aa 84       	ldd	r10, Y+10	; 0x0a
    1e4a:	b9 84       	ldd	r11, Y+9	; 0x09
    1e4c:	c8 84       	ldd	r12, Y+8	; 0x08
    1e4e:	df 80       	ldd	r13, Y+7	; 0x07
    1e50:	ee 80       	ldd	r14, Y+6	; 0x06
    1e52:	fd 80       	ldd	r15, Y+5	; 0x05
    1e54:	0c 81       	ldd	r16, Y+4	; 0x04
    1e56:	1b 81       	ldd	r17, Y+3	; 0x03
    1e58:	aa 81       	ldd	r26, Y+2	; 0x02
    1e5a:	b9 81       	ldd	r27, Y+1	; 0x01
    1e5c:	ce 0f       	add	r28, r30
    1e5e:	d1 1d       	adc	r29, r1
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	de bf       	out	0x3e, r29	; 62
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	cd bf       	out	0x3d, r28	; 61
    1e6a:	ed 01       	movw	r28, r26
    1e6c:	08 95       	ret

00001e6e <__ashldi3>:
    1e6e:	0f 93       	push	r16
    1e70:	08 30       	cpi	r16, 0x08	; 8
    1e72:	90 f0       	brcs	.+36     	; 0x1e98 <__ashldi3+0x2a>
    1e74:	98 2f       	mov	r25, r24
    1e76:	87 2f       	mov	r24, r23
    1e78:	76 2f       	mov	r23, r22
    1e7a:	65 2f       	mov	r22, r21
    1e7c:	54 2f       	mov	r21, r20
    1e7e:	43 2f       	mov	r20, r19
    1e80:	32 2f       	mov	r19, r18
    1e82:	22 27       	eor	r18, r18
    1e84:	08 50       	subi	r16, 0x08	; 8
    1e86:	f4 cf       	rjmp	.-24     	; 0x1e70 <__ashldi3+0x2>
    1e88:	22 0f       	add	r18, r18
    1e8a:	33 1f       	adc	r19, r19
    1e8c:	44 1f       	adc	r20, r20
    1e8e:	55 1f       	adc	r21, r21
    1e90:	66 1f       	adc	r22, r22
    1e92:	77 1f       	adc	r23, r23
    1e94:	88 1f       	adc	r24, r24
    1e96:	99 1f       	adc	r25, r25
    1e98:	0a 95       	dec	r16
    1e9a:	b2 f7       	brpl	.-20     	; 0x1e88 <__ashldi3+0x1a>
    1e9c:	0f 91       	pop	r16
    1e9e:	08 95       	ret

00001ea0 <__ashrdi3>:
    1ea0:	97 fb       	bst	r25, 7
    1ea2:	10 f8       	bld	r1, 0

00001ea4 <__lshrdi3>:
    1ea4:	16 94       	lsr	r1
    1ea6:	00 08       	sbc	r0, r0
    1ea8:	0f 93       	push	r16
    1eaa:	08 30       	cpi	r16, 0x08	; 8
    1eac:	98 f0       	brcs	.+38     	; 0x1ed4 <__lshrdi3+0x30>
    1eae:	08 50       	subi	r16, 0x08	; 8
    1eb0:	23 2f       	mov	r18, r19
    1eb2:	34 2f       	mov	r19, r20
    1eb4:	45 2f       	mov	r20, r21
    1eb6:	56 2f       	mov	r21, r22
    1eb8:	67 2f       	mov	r22, r23
    1eba:	78 2f       	mov	r23, r24
    1ebc:	89 2f       	mov	r24, r25
    1ebe:	90 2d       	mov	r25, r0
    1ec0:	f4 cf       	rjmp	.-24     	; 0x1eaa <__lshrdi3+0x6>
    1ec2:	05 94       	asr	r0
    1ec4:	97 95       	ror	r25
    1ec6:	87 95       	ror	r24
    1ec8:	77 95       	ror	r23
    1eca:	67 95       	ror	r22
    1ecc:	57 95       	ror	r21
    1ece:	47 95       	ror	r20
    1ed0:	37 95       	ror	r19
    1ed2:	27 95       	ror	r18
    1ed4:	0a 95       	dec	r16
    1ed6:	aa f7       	brpl	.-22     	; 0x1ec2 <__lshrdi3+0x1e>
    1ed8:	0f 91       	pop	r16
    1eda:	08 95       	ret

00001edc <__adddi3>:
    1edc:	2a 0d       	add	r18, r10
    1ede:	3b 1d       	adc	r19, r11
    1ee0:	4c 1d       	adc	r20, r12
    1ee2:	5d 1d       	adc	r21, r13
    1ee4:	6e 1d       	adc	r22, r14
    1ee6:	7f 1d       	adc	r23, r15
    1ee8:	80 1f       	adc	r24, r16
    1eea:	91 1f       	adc	r25, r17
    1eec:	08 95       	ret

00001eee <__subdi3>:
    1eee:	2a 19       	sub	r18, r10
    1ef0:	3b 09       	sbc	r19, r11
    1ef2:	4c 09       	sbc	r20, r12
    1ef4:	5d 09       	sbc	r21, r13
    1ef6:	6e 09       	sbc	r22, r14
    1ef8:	7f 09       	sbc	r23, r15
    1efa:	80 0b       	sbc	r24, r16
    1efc:	91 0b       	sbc	r25, r17
    1efe:	08 95       	ret

00001f00 <__cmpdi2_s8>:
    1f00:	00 24       	eor	r0, r0
    1f02:	a7 fd       	sbrc	r26, 7
    1f04:	00 94       	com	r0
    1f06:	2a 17       	cp	r18, r26
    1f08:	30 05       	cpc	r19, r0
    1f0a:	40 05       	cpc	r20, r0
    1f0c:	50 05       	cpc	r21, r0
    1f0e:	60 05       	cpc	r22, r0
    1f10:	70 05       	cpc	r23, r0
    1f12:	80 05       	cpc	r24, r0
    1f14:	90 05       	cpc	r25, r0
    1f16:	08 95       	ret

00001f18 <__umulhisi3>:
    1f18:	a2 9f       	mul	r26, r18
    1f1a:	b0 01       	movw	r22, r0
    1f1c:	b3 9f       	mul	r27, r19
    1f1e:	c0 01       	movw	r24, r0
    1f20:	a3 9f       	mul	r26, r19
    1f22:	70 0d       	add	r23, r0
    1f24:	81 1d       	adc	r24, r1
    1f26:	11 24       	eor	r1, r1
    1f28:	91 1d       	adc	r25, r1
    1f2a:	b2 9f       	mul	r27, r18
    1f2c:	70 0d       	add	r23, r0
    1f2e:	81 1d       	adc	r24, r1
    1f30:	11 24       	eor	r1, r1
    1f32:	91 1d       	adc	r25, r1
    1f34:	08 95       	ret

00001f36 <printf>:
    1f36:	a0 e0       	ldi	r26, 0x00	; 0
    1f38:	b0 e0       	ldi	r27, 0x00	; 0
    1f3a:	e0 ea       	ldi	r30, 0xA0	; 160
    1f3c:	ff e0       	ldi	r31, 0x0F	; 15
    1f3e:	70 cf       	rjmp	.-288    	; 0x1e20 <__prologue_saves__+0x20>
    1f40:	ae 01       	movw	r20, r28
    1f42:	4b 5f       	subi	r20, 0xFB	; 251
    1f44:	5f 4f       	sbci	r21, 0xFF	; 255
    1f46:	fa 01       	movw	r30, r20
    1f48:	61 91       	ld	r22, Z+
    1f4a:	71 91       	ld	r23, Z+
    1f4c:	af 01       	movw	r20, r30
    1f4e:	80 91 0b 09 	lds	r24, 0x090B	; 0x80090b <__iob+0x2>
    1f52:	90 91 0c 09 	lds	r25, 0x090C	; 0x80090c <__iob+0x3>
    1f56:	27 d0       	rcall	.+78     	; 0x1fa6 <vfprintf>
    1f58:	e2 e0       	ldi	r30, 0x02	; 2
    1f5a:	7e cf       	rjmp	.-260    	; 0x1e58 <__epilogue_restores__+0x20>

00001f5c <putchar>:
    1f5c:	60 91 0b 09 	lds	r22, 0x090B	; 0x80090b <__iob+0x2>
    1f60:	70 91 0c 09 	lds	r23, 0x090C	; 0x80090c <__iob+0x3>
    1f64:	f9 c1       	rjmp	.+1010   	; 0x2358 <fputc>

00001f66 <sprintf>:
    1f66:	ae e0       	ldi	r26, 0x0E	; 14
    1f68:	b0 e0       	ldi	r27, 0x00	; 0
    1f6a:	e8 eb       	ldi	r30, 0xB8	; 184
    1f6c:	ff e0       	ldi	r31, 0x0F	; 15
    1f6e:	56 cf       	rjmp	.-340    	; 0x1e1c <__prologue_saves__+0x1c>
    1f70:	0d 89       	ldd	r16, Y+21	; 0x15
    1f72:	1e 89       	ldd	r17, Y+22	; 0x16
    1f74:	86 e0       	ldi	r24, 0x06	; 6
    1f76:	8c 83       	std	Y+4, r24	; 0x04
    1f78:	1a 83       	std	Y+2, r17	; 0x02
    1f7a:	09 83       	std	Y+1, r16	; 0x01
    1f7c:	8f ef       	ldi	r24, 0xFF	; 255
    1f7e:	9f e7       	ldi	r25, 0x7F	; 127
    1f80:	9e 83       	std	Y+6, r25	; 0x06
    1f82:	8d 83       	std	Y+5, r24	; 0x05
    1f84:	ae 01       	movw	r20, r28
    1f86:	47 5e       	subi	r20, 0xE7	; 231
    1f88:	5f 4f       	sbci	r21, 0xFF	; 255
    1f8a:	6f 89       	ldd	r22, Y+23	; 0x17
    1f8c:	78 8d       	ldd	r23, Y+24	; 0x18
    1f8e:	ce 01       	movw	r24, r28
    1f90:	01 96       	adiw	r24, 0x01	; 1
    1f92:	09 d0       	rcall	.+18     	; 0x1fa6 <vfprintf>
    1f94:	2f 81       	ldd	r18, Y+7	; 0x07
    1f96:	38 85       	ldd	r19, Y+8	; 0x08
    1f98:	f8 01       	movw	r30, r16
    1f9a:	e2 0f       	add	r30, r18
    1f9c:	f3 1f       	adc	r31, r19
    1f9e:	10 82       	st	Z, r1
    1fa0:	2e 96       	adiw	r28, 0x0e	; 14
    1fa2:	e4 e0       	ldi	r30, 0x04	; 4
    1fa4:	57 cf       	rjmp	.-338    	; 0x1e54 <__epilogue_restores__+0x1c>

00001fa6 <vfprintf>:
    1fa6:	ac e0       	ldi	r26, 0x0C	; 12
    1fa8:	b0 e0       	ldi	r27, 0x00	; 0
    1faa:	e8 ed       	ldi	r30, 0xD8	; 216
    1fac:	ff e0       	ldi	r31, 0x0F	; 15
    1fae:	28 cf       	rjmp	.-432    	; 0x1e00 <__prologue_saves__>
    1fb0:	7c 01       	movw	r14, r24
    1fb2:	6b 01       	movw	r12, r22
    1fb4:	8a 01       	movw	r16, r20
    1fb6:	fc 01       	movw	r30, r24
    1fb8:	17 82       	std	Z+7, r1	; 0x07
    1fba:	16 82       	std	Z+6, r1	; 0x06
    1fbc:	83 81       	ldd	r24, Z+3	; 0x03
    1fbe:	81 ff       	sbrs	r24, 1
    1fc0:	b0 c1       	rjmp	.+864    	; 0x2322 <vfprintf+0x37c>
    1fc2:	ce 01       	movw	r24, r28
    1fc4:	01 96       	adiw	r24, 0x01	; 1
    1fc6:	4c 01       	movw	r8, r24
    1fc8:	f7 01       	movw	r30, r14
    1fca:	93 81       	ldd	r25, Z+3	; 0x03
    1fcc:	f6 01       	movw	r30, r12
    1fce:	93 fd       	sbrc	r25, 3
    1fd0:	85 91       	lpm	r24, Z+
    1fd2:	93 ff       	sbrs	r25, 3
    1fd4:	81 91       	ld	r24, Z+
    1fd6:	6f 01       	movw	r12, r30
    1fd8:	88 23       	and	r24, r24
    1fda:	09 f4       	brne	.+2      	; 0x1fde <vfprintf+0x38>
    1fdc:	9e c1       	rjmp	.+828    	; 0x231a <vfprintf+0x374>
    1fde:	85 32       	cpi	r24, 0x25	; 37
    1fe0:	39 f4       	brne	.+14     	; 0x1ff0 <vfprintf+0x4a>
    1fe2:	93 fd       	sbrc	r25, 3
    1fe4:	85 91       	lpm	r24, Z+
    1fe6:	93 ff       	sbrs	r25, 3
    1fe8:	81 91       	ld	r24, Z+
    1fea:	6f 01       	movw	r12, r30
    1fec:	85 32       	cpi	r24, 0x25	; 37
    1fee:	21 f4       	brne	.+8      	; 0x1ff8 <vfprintf+0x52>
    1ff0:	b7 01       	movw	r22, r14
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	b1 d1       	rcall	.+866    	; 0x2358 <fputc>
    1ff6:	e8 cf       	rjmp	.-48     	; 0x1fc8 <vfprintf+0x22>
    1ff8:	51 2c       	mov	r5, r1
    1ffa:	31 2c       	mov	r3, r1
    1ffc:	20 e0       	ldi	r18, 0x00	; 0
    1ffe:	20 32       	cpi	r18, 0x20	; 32
    2000:	a0 f4       	brcc	.+40     	; 0x202a <vfprintf+0x84>
    2002:	8b 32       	cpi	r24, 0x2B	; 43
    2004:	69 f0       	breq	.+26     	; 0x2020 <vfprintf+0x7a>
    2006:	30 f4       	brcc	.+12     	; 0x2014 <vfprintf+0x6e>
    2008:	80 32       	cpi	r24, 0x20	; 32
    200a:	59 f0       	breq	.+22     	; 0x2022 <vfprintf+0x7c>
    200c:	83 32       	cpi	r24, 0x23	; 35
    200e:	69 f4       	brne	.+26     	; 0x202a <vfprintf+0x84>
    2010:	20 61       	ori	r18, 0x10	; 16
    2012:	2c c0       	rjmp	.+88     	; 0x206c <vfprintf+0xc6>
    2014:	8d 32       	cpi	r24, 0x2D	; 45
    2016:	39 f0       	breq	.+14     	; 0x2026 <vfprintf+0x80>
    2018:	80 33       	cpi	r24, 0x30	; 48
    201a:	39 f4       	brne	.+14     	; 0x202a <vfprintf+0x84>
    201c:	21 60       	ori	r18, 0x01	; 1
    201e:	26 c0       	rjmp	.+76     	; 0x206c <vfprintf+0xc6>
    2020:	22 60       	ori	r18, 0x02	; 2
    2022:	24 60       	ori	r18, 0x04	; 4
    2024:	23 c0       	rjmp	.+70     	; 0x206c <vfprintf+0xc6>
    2026:	28 60       	ori	r18, 0x08	; 8
    2028:	21 c0       	rjmp	.+66     	; 0x206c <vfprintf+0xc6>
    202a:	27 fd       	sbrc	r18, 7
    202c:	27 c0       	rjmp	.+78     	; 0x207c <vfprintf+0xd6>
    202e:	30 ed       	ldi	r19, 0xD0	; 208
    2030:	38 0f       	add	r19, r24
    2032:	3a 30       	cpi	r19, 0x0A	; 10
    2034:	78 f4       	brcc	.+30     	; 0x2054 <vfprintf+0xae>
    2036:	26 ff       	sbrs	r18, 6
    2038:	06 c0       	rjmp	.+12     	; 0x2046 <vfprintf+0xa0>
    203a:	fa e0       	ldi	r31, 0x0A	; 10
    203c:	5f 9e       	mul	r5, r31
    203e:	30 0d       	add	r19, r0
    2040:	11 24       	eor	r1, r1
    2042:	53 2e       	mov	r5, r19
    2044:	13 c0       	rjmp	.+38     	; 0x206c <vfprintf+0xc6>
    2046:	8a e0       	ldi	r24, 0x0A	; 10
    2048:	38 9e       	mul	r3, r24
    204a:	30 0d       	add	r19, r0
    204c:	11 24       	eor	r1, r1
    204e:	33 2e       	mov	r3, r19
    2050:	20 62       	ori	r18, 0x20	; 32
    2052:	0c c0       	rjmp	.+24     	; 0x206c <vfprintf+0xc6>
    2054:	8e 32       	cpi	r24, 0x2E	; 46
    2056:	21 f4       	brne	.+8      	; 0x2060 <vfprintf+0xba>
    2058:	26 fd       	sbrc	r18, 6
    205a:	5f c1       	rjmp	.+702    	; 0x231a <vfprintf+0x374>
    205c:	20 64       	ori	r18, 0x40	; 64
    205e:	06 c0       	rjmp	.+12     	; 0x206c <vfprintf+0xc6>
    2060:	8c 36       	cpi	r24, 0x6C	; 108
    2062:	11 f4       	brne	.+4      	; 0x2068 <vfprintf+0xc2>
    2064:	20 68       	ori	r18, 0x80	; 128
    2066:	02 c0       	rjmp	.+4      	; 0x206c <vfprintf+0xc6>
    2068:	88 36       	cpi	r24, 0x68	; 104
    206a:	41 f4       	brne	.+16     	; 0x207c <vfprintf+0xd6>
    206c:	f6 01       	movw	r30, r12
    206e:	93 fd       	sbrc	r25, 3
    2070:	85 91       	lpm	r24, Z+
    2072:	93 ff       	sbrs	r25, 3
    2074:	81 91       	ld	r24, Z+
    2076:	6f 01       	movw	r12, r30
    2078:	81 11       	cpse	r24, r1
    207a:	c1 cf       	rjmp	.-126    	; 0x1ffe <vfprintf+0x58>
    207c:	98 2f       	mov	r25, r24
    207e:	9f 7d       	andi	r25, 0xDF	; 223
    2080:	95 54       	subi	r25, 0x45	; 69
    2082:	93 30       	cpi	r25, 0x03	; 3
    2084:	28 f4       	brcc	.+10     	; 0x2090 <vfprintf+0xea>
    2086:	0c 5f       	subi	r16, 0xFC	; 252
    2088:	1f 4f       	sbci	r17, 0xFF	; 255
    208a:	ff e3       	ldi	r31, 0x3F	; 63
    208c:	f9 83       	std	Y+1, r31	; 0x01
    208e:	0d c0       	rjmp	.+26     	; 0x20aa <vfprintf+0x104>
    2090:	83 36       	cpi	r24, 0x63	; 99
    2092:	31 f0       	breq	.+12     	; 0x20a0 <vfprintf+0xfa>
    2094:	83 37       	cpi	r24, 0x73	; 115
    2096:	71 f0       	breq	.+28     	; 0x20b4 <vfprintf+0x10e>
    2098:	83 35       	cpi	r24, 0x53	; 83
    209a:	09 f0       	breq	.+2      	; 0x209e <vfprintf+0xf8>
    209c:	57 c0       	rjmp	.+174    	; 0x214c <vfprintf+0x1a6>
    209e:	21 c0       	rjmp	.+66     	; 0x20e2 <vfprintf+0x13c>
    20a0:	f8 01       	movw	r30, r16
    20a2:	80 81       	ld	r24, Z
    20a4:	89 83       	std	Y+1, r24	; 0x01
    20a6:	0e 5f       	subi	r16, 0xFE	; 254
    20a8:	1f 4f       	sbci	r17, 0xFF	; 255
    20aa:	44 24       	eor	r4, r4
    20ac:	43 94       	inc	r4
    20ae:	51 2c       	mov	r5, r1
    20b0:	54 01       	movw	r10, r8
    20b2:	14 c0       	rjmp	.+40     	; 0x20dc <vfprintf+0x136>
    20b4:	38 01       	movw	r6, r16
    20b6:	f2 e0       	ldi	r31, 0x02	; 2
    20b8:	6f 0e       	add	r6, r31
    20ba:	71 1c       	adc	r7, r1
    20bc:	f8 01       	movw	r30, r16
    20be:	a0 80       	ld	r10, Z
    20c0:	b1 80       	ldd	r11, Z+1	; 0x01
    20c2:	26 ff       	sbrs	r18, 6
    20c4:	03 c0       	rjmp	.+6      	; 0x20cc <vfprintf+0x126>
    20c6:	65 2d       	mov	r22, r5
    20c8:	70 e0       	ldi	r23, 0x00	; 0
    20ca:	02 c0       	rjmp	.+4      	; 0x20d0 <vfprintf+0x12a>
    20cc:	6f ef       	ldi	r22, 0xFF	; 255
    20ce:	7f ef       	ldi	r23, 0xFF	; 255
    20d0:	c5 01       	movw	r24, r10
    20d2:	2c 87       	std	Y+12, r18	; 0x0c
    20d4:	36 d1       	rcall	.+620    	; 0x2342 <strnlen>
    20d6:	2c 01       	movw	r4, r24
    20d8:	83 01       	movw	r16, r6
    20da:	2c 85       	ldd	r18, Y+12	; 0x0c
    20dc:	2f 77       	andi	r18, 0x7F	; 127
    20de:	22 2e       	mov	r2, r18
    20e0:	16 c0       	rjmp	.+44     	; 0x210e <vfprintf+0x168>
    20e2:	38 01       	movw	r6, r16
    20e4:	f2 e0       	ldi	r31, 0x02	; 2
    20e6:	6f 0e       	add	r6, r31
    20e8:	71 1c       	adc	r7, r1
    20ea:	f8 01       	movw	r30, r16
    20ec:	a0 80       	ld	r10, Z
    20ee:	b1 80       	ldd	r11, Z+1	; 0x01
    20f0:	26 ff       	sbrs	r18, 6
    20f2:	03 c0       	rjmp	.+6      	; 0x20fa <vfprintf+0x154>
    20f4:	65 2d       	mov	r22, r5
    20f6:	70 e0       	ldi	r23, 0x00	; 0
    20f8:	02 c0       	rjmp	.+4      	; 0x20fe <vfprintf+0x158>
    20fa:	6f ef       	ldi	r22, 0xFF	; 255
    20fc:	7f ef       	ldi	r23, 0xFF	; 255
    20fe:	c5 01       	movw	r24, r10
    2100:	2c 87       	std	Y+12, r18	; 0x0c
    2102:	14 d1       	rcall	.+552    	; 0x232c <strnlen_P>
    2104:	2c 01       	movw	r4, r24
    2106:	2c 85       	ldd	r18, Y+12	; 0x0c
    2108:	20 68       	ori	r18, 0x80	; 128
    210a:	22 2e       	mov	r2, r18
    210c:	83 01       	movw	r16, r6
    210e:	23 fc       	sbrc	r2, 3
    2110:	19 c0       	rjmp	.+50     	; 0x2144 <vfprintf+0x19e>
    2112:	83 2d       	mov	r24, r3
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	48 16       	cp	r4, r24
    2118:	59 06       	cpc	r5, r25
    211a:	a0 f4       	brcc	.+40     	; 0x2144 <vfprintf+0x19e>
    211c:	b7 01       	movw	r22, r14
    211e:	80 e2       	ldi	r24, 0x20	; 32
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	1a d1       	rcall	.+564    	; 0x2358 <fputc>
    2124:	3a 94       	dec	r3
    2126:	f5 cf       	rjmp	.-22     	; 0x2112 <vfprintf+0x16c>
    2128:	f5 01       	movw	r30, r10
    212a:	27 fc       	sbrc	r2, 7
    212c:	85 91       	lpm	r24, Z+
    212e:	27 fe       	sbrs	r2, 7
    2130:	81 91       	ld	r24, Z+
    2132:	5f 01       	movw	r10, r30
    2134:	b7 01       	movw	r22, r14
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	0f d1       	rcall	.+542    	; 0x2358 <fputc>
    213a:	31 10       	cpse	r3, r1
    213c:	3a 94       	dec	r3
    213e:	f1 e0       	ldi	r31, 0x01	; 1
    2140:	4f 1a       	sub	r4, r31
    2142:	51 08       	sbc	r5, r1
    2144:	41 14       	cp	r4, r1
    2146:	51 04       	cpc	r5, r1
    2148:	79 f7       	brne	.-34     	; 0x2128 <vfprintf+0x182>
    214a:	de c0       	rjmp	.+444    	; 0x2308 <vfprintf+0x362>
    214c:	84 36       	cpi	r24, 0x64	; 100
    214e:	11 f0       	breq	.+4      	; 0x2154 <vfprintf+0x1ae>
    2150:	89 36       	cpi	r24, 0x69	; 105
    2152:	31 f5       	brne	.+76     	; 0x21a0 <vfprintf+0x1fa>
    2154:	f8 01       	movw	r30, r16
    2156:	27 ff       	sbrs	r18, 7
    2158:	07 c0       	rjmp	.+14     	; 0x2168 <vfprintf+0x1c2>
    215a:	60 81       	ld	r22, Z
    215c:	71 81       	ldd	r23, Z+1	; 0x01
    215e:	82 81       	ldd	r24, Z+2	; 0x02
    2160:	93 81       	ldd	r25, Z+3	; 0x03
    2162:	0c 5f       	subi	r16, 0xFC	; 252
    2164:	1f 4f       	sbci	r17, 0xFF	; 255
    2166:	08 c0       	rjmp	.+16     	; 0x2178 <vfprintf+0x1d2>
    2168:	60 81       	ld	r22, Z
    216a:	71 81       	ldd	r23, Z+1	; 0x01
    216c:	07 2e       	mov	r0, r23
    216e:	00 0c       	add	r0, r0
    2170:	88 0b       	sbc	r24, r24
    2172:	99 0b       	sbc	r25, r25
    2174:	0e 5f       	subi	r16, 0xFE	; 254
    2176:	1f 4f       	sbci	r17, 0xFF	; 255
    2178:	2f 76       	andi	r18, 0x6F	; 111
    217a:	72 2e       	mov	r7, r18
    217c:	97 ff       	sbrs	r25, 7
    217e:	09 c0       	rjmp	.+18     	; 0x2192 <vfprintf+0x1ec>
    2180:	90 95       	com	r25
    2182:	80 95       	com	r24
    2184:	70 95       	com	r23
    2186:	61 95       	neg	r22
    2188:	7f 4f       	sbci	r23, 0xFF	; 255
    218a:	8f 4f       	sbci	r24, 0xFF	; 255
    218c:	9f 4f       	sbci	r25, 0xFF	; 255
    218e:	20 68       	ori	r18, 0x80	; 128
    2190:	72 2e       	mov	r7, r18
    2192:	2a e0       	ldi	r18, 0x0A	; 10
    2194:	30 e0       	ldi	r19, 0x00	; 0
    2196:	a4 01       	movw	r20, r8
    2198:	17 d1       	rcall	.+558    	; 0x23c8 <__ultoa_invert>
    219a:	a8 2e       	mov	r10, r24
    219c:	a8 18       	sub	r10, r8
    219e:	43 c0       	rjmp	.+134    	; 0x2226 <vfprintf+0x280>
    21a0:	85 37       	cpi	r24, 0x75	; 117
    21a2:	29 f4       	brne	.+10     	; 0x21ae <vfprintf+0x208>
    21a4:	2f 7e       	andi	r18, 0xEF	; 239
    21a6:	b2 2e       	mov	r11, r18
    21a8:	2a e0       	ldi	r18, 0x0A	; 10
    21aa:	30 e0       	ldi	r19, 0x00	; 0
    21ac:	25 c0       	rjmp	.+74     	; 0x21f8 <vfprintf+0x252>
    21ae:	f2 2f       	mov	r31, r18
    21b0:	f9 7f       	andi	r31, 0xF9	; 249
    21b2:	bf 2e       	mov	r11, r31
    21b4:	8f 36       	cpi	r24, 0x6F	; 111
    21b6:	c1 f0       	breq	.+48     	; 0x21e8 <vfprintf+0x242>
    21b8:	18 f4       	brcc	.+6      	; 0x21c0 <vfprintf+0x21a>
    21ba:	88 35       	cpi	r24, 0x58	; 88
    21bc:	79 f0       	breq	.+30     	; 0x21dc <vfprintf+0x236>
    21be:	ad c0       	rjmp	.+346    	; 0x231a <vfprintf+0x374>
    21c0:	80 37       	cpi	r24, 0x70	; 112
    21c2:	19 f0       	breq	.+6      	; 0x21ca <vfprintf+0x224>
    21c4:	88 37       	cpi	r24, 0x78	; 120
    21c6:	21 f0       	breq	.+8      	; 0x21d0 <vfprintf+0x22a>
    21c8:	a8 c0       	rjmp	.+336    	; 0x231a <vfprintf+0x374>
    21ca:	2f 2f       	mov	r18, r31
    21cc:	20 61       	ori	r18, 0x10	; 16
    21ce:	b2 2e       	mov	r11, r18
    21d0:	b4 fe       	sbrs	r11, 4
    21d2:	0d c0       	rjmp	.+26     	; 0x21ee <vfprintf+0x248>
    21d4:	8b 2d       	mov	r24, r11
    21d6:	84 60       	ori	r24, 0x04	; 4
    21d8:	b8 2e       	mov	r11, r24
    21da:	09 c0       	rjmp	.+18     	; 0x21ee <vfprintf+0x248>
    21dc:	24 ff       	sbrs	r18, 4
    21de:	0a c0       	rjmp	.+20     	; 0x21f4 <vfprintf+0x24e>
    21e0:	9f 2f       	mov	r25, r31
    21e2:	96 60       	ori	r25, 0x06	; 6
    21e4:	b9 2e       	mov	r11, r25
    21e6:	06 c0       	rjmp	.+12     	; 0x21f4 <vfprintf+0x24e>
    21e8:	28 e0       	ldi	r18, 0x08	; 8
    21ea:	30 e0       	ldi	r19, 0x00	; 0
    21ec:	05 c0       	rjmp	.+10     	; 0x21f8 <vfprintf+0x252>
    21ee:	20 e1       	ldi	r18, 0x10	; 16
    21f0:	30 e0       	ldi	r19, 0x00	; 0
    21f2:	02 c0       	rjmp	.+4      	; 0x21f8 <vfprintf+0x252>
    21f4:	20 e1       	ldi	r18, 0x10	; 16
    21f6:	32 e0       	ldi	r19, 0x02	; 2
    21f8:	f8 01       	movw	r30, r16
    21fa:	b7 fe       	sbrs	r11, 7
    21fc:	07 c0       	rjmp	.+14     	; 0x220c <vfprintf+0x266>
    21fe:	60 81       	ld	r22, Z
    2200:	71 81       	ldd	r23, Z+1	; 0x01
    2202:	82 81       	ldd	r24, Z+2	; 0x02
    2204:	93 81       	ldd	r25, Z+3	; 0x03
    2206:	0c 5f       	subi	r16, 0xFC	; 252
    2208:	1f 4f       	sbci	r17, 0xFF	; 255
    220a:	06 c0       	rjmp	.+12     	; 0x2218 <vfprintf+0x272>
    220c:	60 81       	ld	r22, Z
    220e:	71 81       	ldd	r23, Z+1	; 0x01
    2210:	80 e0       	ldi	r24, 0x00	; 0
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	0e 5f       	subi	r16, 0xFE	; 254
    2216:	1f 4f       	sbci	r17, 0xFF	; 255
    2218:	a4 01       	movw	r20, r8
    221a:	d6 d0       	rcall	.+428    	; 0x23c8 <__ultoa_invert>
    221c:	a8 2e       	mov	r10, r24
    221e:	a8 18       	sub	r10, r8
    2220:	fb 2d       	mov	r31, r11
    2222:	ff 77       	andi	r31, 0x7F	; 127
    2224:	7f 2e       	mov	r7, r31
    2226:	76 fe       	sbrs	r7, 6
    2228:	0b c0       	rjmp	.+22     	; 0x2240 <vfprintf+0x29a>
    222a:	37 2d       	mov	r19, r7
    222c:	3e 7f       	andi	r19, 0xFE	; 254
    222e:	a5 14       	cp	r10, r5
    2230:	50 f4       	brcc	.+20     	; 0x2246 <vfprintf+0x2a0>
    2232:	74 fe       	sbrs	r7, 4
    2234:	0a c0       	rjmp	.+20     	; 0x224a <vfprintf+0x2a4>
    2236:	72 fc       	sbrc	r7, 2
    2238:	08 c0       	rjmp	.+16     	; 0x224a <vfprintf+0x2a4>
    223a:	37 2d       	mov	r19, r7
    223c:	3e 7e       	andi	r19, 0xEE	; 238
    223e:	05 c0       	rjmp	.+10     	; 0x224a <vfprintf+0x2a4>
    2240:	ba 2c       	mov	r11, r10
    2242:	37 2d       	mov	r19, r7
    2244:	03 c0       	rjmp	.+6      	; 0x224c <vfprintf+0x2a6>
    2246:	ba 2c       	mov	r11, r10
    2248:	01 c0       	rjmp	.+2      	; 0x224c <vfprintf+0x2a6>
    224a:	b5 2c       	mov	r11, r5
    224c:	34 ff       	sbrs	r19, 4
    224e:	0d c0       	rjmp	.+26     	; 0x226a <vfprintf+0x2c4>
    2250:	fe 01       	movw	r30, r28
    2252:	ea 0d       	add	r30, r10
    2254:	f1 1d       	adc	r31, r1
    2256:	80 81       	ld	r24, Z
    2258:	80 33       	cpi	r24, 0x30	; 48
    225a:	11 f4       	brne	.+4      	; 0x2260 <vfprintf+0x2ba>
    225c:	39 7e       	andi	r19, 0xE9	; 233
    225e:	09 c0       	rjmp	.+18     	; 0x2272 <vfprintf+0x2cc>
    2260:	32 ff       	sbrs	r19, 2
    2262:	06 c0       	rjmp	.+12     	; 0x2270 <vfprintf+0x2ca>
    2264:	b3 94       	inc	r11
    2266:	b3 94       	inc	r11
    2268:	04 c0       	rjmp	.+8      	; 0x2272 <vfprintf+0x2cc>
    226a:	83 2f       	mov	r24, r19
    226c:	86 78       	andi	r24, 0x86	; 134
    226e:	09 f0       	breq	.+2      	; 0x2272 <vfprintf+0x2cc>
    2270:	b3 94       	inc	r11
    2272:	33 fd       	sbrc	r19, 3
    2274:	12 c0       	rjmp	.+36     	; 0x229a <vfprintf+0x2f4>
    2276:	30 ff       	sbrs	r19, 0
    2278:	06 c0       	rjmp	.+12     	; 0x2286 <vfprintf+0x2e0>
    227a:	5a 2c       	mov	r5, r10
    227c:	b3 14       	cp	r11, r3
    227e:	18 f4       	brcc	.+6      	; 0x2286 <vfprintf+0x2e0>
    2280:	53 0c       	add	r5, r3
    2282:	5b 18       	sub	r5, r11
    2284:	b3 2c       	mov	r11, r3
    2286:	b3 14       	cp	r11, r3
    2288:	60 f4       	brcc	.+24     	; 0x22a2 <vfprintf+0x2fc>
    228a:	b7 01       	movw	r22, r14
    228c:	80 e2       	ldi	r24, 0x20	; 32
    228e:	90 e0       	ldi	r25, 0x00	; 0
    2290:	3c 87       	std	Y+12, r19	; 0x0c
    2292:	62 d0       	rcall	.+196    	; 0x2358 <fputc>
    2294:	b3 94       	inc	r11
    2296:	3c 85       	ldd	r19, Y+12	; 0x0c
    2298:	f6 cf       	rjmp	.-20     	; 0x2286 <vfprintf+0x2e0>
    229a:	b3 14       	cp	r11, r3
    229c:	10 f4       	brcc	.+4      	; 0x22a2 <vfprintf+0x2fc>
    229e:	3b 18       	sub	r3, r11
    22a0:	01 c0       	rjmp	.+2      	; 0x22a4 <vfprintf+0x2fe>
    22a2:	31 2c       	mov	r3, r1
    22a4:	34 ff       	sbrs	r19, 4
    22a6:	11 c0       	rjmp	.+34     	; 0x22ca <vfprintf+0x324>
    22a8:	b7 01       	movw	r22, r14
    22aa:	80 e3       	ldi	r24, 0x30	; 48
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	3c 87       	std	Y+12, r19	; 0x0c
    22b0:	53 d0       	rcall	.+166    	; 0x2358 <fputc>
    22b2:	3c 85       	ldd	r19, Y+12	; 0x0c
    22b4:	32 ff       	sbrs	r19, 2
    22b6:	16 c0       	rjmp	.+44     	; 0x22e4 <vfprintf+0x33e>
    22b8:	31 fd       	sbrc	r19, 1
    22ba:	03 c0       	rjmp	.+6      	; 0x22c2 <vfprintf+0x31c>
    22bc:	88 e7       	ldi	r24, 0x78	; 120
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	02 c0       	rjmp	.+4      	; 0x22c6 <vfprintf+0x320>
    22c2:	88 e5       	ldi	r24, 0x58	; 88
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	b7 01       	movw	r22, r14
    22c8:	0c c0       	rjmp	.+24     	; 0x22e2 <vfprintf+0x33c>
    22ca:	83 2f       	mov	r24, r19
    22cc:	86 78       	andi	r24, 0x86	; 134
    22ce:	51 f0       	breq	.+20     	; 0x22e4 <vfprintf+0x33e>
    22d0:	31 ff       	sbrs	r19, 1
    22d2:	02 c0       	rjmp	.+4      	; 0x22d8 <vfprintf+0x332>
    22d4:	8b e2       	ldi	r24, 0x2B	; 43
    22d6:	01 c0       	rjmp	.+2      	; 0x22da <vfprintf+0x334>
    22d8:	80 e2       	ldi	r24, 0x20	; 32
    22da:	37 fd       	sbrc	r19, 7
    22dc:	8d e2       	ldi	r24, 0x2D	; 45
    22de:	b7 01       	movw	r22, r14
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	3a d0       	rcall	.+116    	; 0x2358 <fputc>
    22e4:	a5 14       	cp	r10, r5
    22e6:	30 f4       	brcc	.+12     	; 0x22f4 <vfprintf+0x34e>
    22e8:	b7 01       	movw	r22, r14
    22ea:	80 e3       	ldi	r24, 0x30	; 48
    22ec:	90 e0       	ldi	r25, 0x00	; 0
    22ee:	34 d0       	rcall	.+104    	; 0x2358 <fputc>
    22f0:	5a 94       	dec	r5
    22f2:	f8 cf       	rjmp	.-16     	; 0x22e4 <vfprintf+0x33e>
    22f4:	aa 94       	dec	r10
    22f6:	f4 01       	movw	r30, r8
    22f8:	ea 0d       	add	r30, r10
    22fa:	f1 1d       	adc	r31, r1
    22fc:	80 81       	ld	r24, Z
    22fe:	b7 01       	movw	r22, r14
    2300:	90 e0       	ldi	r25, 0x00	; 0
    2302:	2a d0       	rcall	.+84     	; 0x2358 <fputc>
    2304:	a1 10       	cpse	r10, r1
    2306:	f6 cf       	rjmp	.-20     	; 0x22f4 <vfprintf+0x34e>
    2308:	33 20       	and	r3, r3
    230a:	09 f4       	brne	.+2      	; 0x230e <vfprintf+0x368>
    230c:	5d ce       	rjmp	.-838    	; 0x1fc8 <vfprintf+0x22>
    230e:	b7 01       	movw	r22, r14
    2310:	80 e2       	ldi	r24, 0x20	; 32
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	21 d0       	rcall	.+66     	; 0x2358 <fputc>
    2316:	3a 94       	dec	r3
    2318:	f7 cf       	rjmp	.-18     	; 0x2308 <vfprintf+0x362>
    231a:	f7 01       	movw	r30, r14
    231c:	86 81       	ldd	r24, Z+6	; 0x06
    231e:	97 81       	ldd	r25, Z+7	; 0x07
    2320:	02 c0       	rjmp	.+4      	; 0x2326 <vfprintf+0x380>
    2322:	8f ef       	ldi	r24, 0xFF	; 255
    2324:	9f ef       	ldi	r25, 0xFF	; 255
    2326:	2c 96       	adiw	r28, 0x0c	; 12
    2328:	e2 e1       	ldi	r30, 0x12	; 18
    232a:	86 cd       	rjmp	.-1268   	; 0x1e38 <__epilogue_restores__>

0000232c <strnlen_P>:
    232c:	fc 01       	movw	r30, r24
    232e:	05 90       	lpm	r0, Z+
    2330:	61 50       	subi	r22, 0x01	; 1
    2332:	70 40       	sbci	r23, 0x00	; 0
    2334:	01 10       	cpse	r0, r1
    2336:	d8 f7       	brcc	.-10     	; 0x232e <strnlen_P+0x2>
    2338:	80 95       	com	r24
    233a:	90 95       	com	r25
    233c:	8e 0f       	add	r24, r30
    233e:	9f 1f       	adc	r25, r31
    2340:	08 95       	ret

00002342 <strnlen>:
    2342:	fc 01       	movw	r30, r24
    2344:	61 50       	subi	r22, 0x01	; 1
    2346:	70 40       	sbci	r23, 0x00	; 0
    2348:	01 90       	ld	r0, Z+
    234a:	01 10       	cpse	r0, r1
    234c:	d8 f7       	brcc	.-10     	; 0x2344 <strnlen+0x2>
    234e:	80 95       	com	r24
    2350:	90 95       	com	r25
    2352:	8e 0f       	add	r24, r30
    2354:	9f 1f       	adc	r25, r31
    2356:	08 95       	ret

00002358 <fputc>:
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
    235c:	cf 93       	push	r28
    235e:	df 93       	push	r29
    2360:	fb 01       	movw	r30, r22
    2362:	23 81       	ldd	r18, Z+3	; 0x03
    2364:	21 fd       	sbrc	r18, 1
    2366:	03 c0       	rjmp	.+6      	; 0x236e <fputc+0x16>
    2368:	8f ef       	ldi	r24, 0xFF	; 255
    236a:	9f ef       	ldi	r25, 0xFF	; 255
    236c:	28 c0       	rjmp	.+80     	; 0x23be <fputc+0x66>
    236e:	22 ff       	sbrs	r18, 2
    2370:	16 c0       	rjmp	.+44     	; 0x239e <fputc+0x46>
    2372:	46 81       	ldd	r20, Z+6	; 0x06
    2374:	57 81       	ldd	r21, Z+7	; 0x07
    2376:	24 81       	ldd	r18, Z+4	; 0x04
    2378:	35 81       	ldd	r19, Z+5	; 0x05
    237a:	42 17       	cp	r20, r18
    237c:	53 07       	cpc	r21, r19
    237e:	44 f4       	brge	.+16     	; 0x2390 <fputc+0x38>
    2380:	a0 81       	ld	r26, Z
    2382:	b1 81       	ldd	r27, Z+1	; 0x01
    2384:	9d 01       	movw	r18, r26
    2386:	2f 5f       	subi	r18, 0xFF	; 255
    2388:	3f 4f       	sbci	r19, 0xFF	; 255
    238a:	31 83       	std	Z+1, r19	; 0x01
    238c:	20 83       	st	Z, r18
    238e:	8c 93       	st	X, r24
    2390:	26 81       	ldd	r18, Z+6	; 0x06
    2392:	37 81       	ldd	r19, Z+7	; 0x07
    2394:	2f 5f       	subi	r18, 0xFF	; 255
    2396:	3f 4f       	sbci	r19, 0xFF	; 255
    2398:	37 83       	std	Z+7, r19	; 0x07
    239a:	26 83       	std	Z+6, r18	; 0x06
    239c:	10 c0       	rjmp	.+32     	; 0x23be <fputc+0x66>
    239e:	eb 01       	movw	r28, r22
    23a0:	09 2f       	mov	r16, r25
    23a2:	18 2f       	mov	r17, r24
    23a4:	00 84       	ldd	r0, Z+8	; 0x08
    23a6:	f1 85       	ldd	r31, Z+9	; 0x09
    23a8:	e0 2d       	mov	r30, r0
    23aa:	09 95       	icall
    23ac:	89 2b       	or	r24, r25
    23ae:	e1 f6       	brne	.-72     	; 0x2368 <fputc+0x10>
    23b0:	8e 81       	ldd	r24, Y+6	; 0x06
    23b2:	9f 81       	ldd	r25, Y+7	; 0x07
    23b4:	01 96       	adiw	r24, 0x01	; 1
    23b6:	9f 83       	std	Y+7, r25	; 0x07
    23b8:	8e 83       	std	Y+6, r24	; 0x06
    23ba:	81 2f       	mov	r24, r17
    23bc:	90 2f       	mov	r25, r16
    23be:	df 91       	pop	r29
    23c0:	cf 91       	pop	r28
    23c2:	1f 91       	pop	r17
    23c4:	0f 91       	pop	r16
    23c6:	08 95       	ret

000023c8 <__ultoa_invert>:
    23c8:	fa 01       	movw	r30, r20
    23ca:	aa 27       	eor	r26, r26
    23cc:	28 30       	cpi	r18, 0x08	; 8
    23ce:	51 f1       	breq	.+84     	; 0x2424 <__ultoa_invert+0x5c>
    23d0:	20 31       	cpi	r18, 0x10	; 16
    23d2:	81 f1       	breq	.+96     	; 0x2434 <__ultoa_invert+0x6c>
    23d4:	e8 94       	clt
    23d6:	6f 93       	push	r22
    23d8:	6e 7f       	andi	r22, 0xFE	; 254
    23da:	6e 5f       	subi	r22, 0xFE	; 254
    23dc:	7f 4f       	sbci	r23, 0xFF	; 255
    23de:	8f 4f       	sbci	r24, 0xFF	; 255
    23e0:	9f 4f       	sbci	r25, 0xFF	; 255
    23e2:	af 4f       	sbci	r26, 0xFF	; 255
    23e4:	b1 e0       	ldi	r27, 0x01	; 1
    23e6:	3e d0       	rcall	.+124    	; 0x2464 <__ultoa_invert+0x9c>
    23e8:	b4 e0       	ldi	r27, 0x04	; 4
    23ea:	3c d0       	rcall	.+120    	; 0x2464 <__ultoa_invert+0x9c>
    23ec:	67 0f       	add	r22, r23
    23ee:	78 1f       	adc	r23, r24
    23f0:	89 1f       	adc	r24, r25
    23f2:	9a 1f       	adc	r25, r26
    23f4:	a1 1d       	adc	r26, r1
    23f6:	68 0f       	add	r22, r24
    23f8:	79 1f       	adc	r23, r25
    23fa:	8a 1f       	adc	r24, r26
    23fc:	91 1d       	adc	r25, r1
    23fe:	a1 1d       	adc	r26, r1
    2400:	6a 0f       	add	r22, r26
    2402:	71 1d       	adc	r23, r1
    2404:	81 1d       	adc	r24, r1
    2406:	91 1d       	adc	r25, r1
    2408:	a1 1d       	adc	r26, r1
    240a:	20 d0       	rcall	.+64     	; 0x244c <__ultoa_invert+0x84>
    240c:	09 f4       	brne	.+2      	; 0x2410 <__ultoa_invert+0x48>
    240e:	68 94       	set
    2410:	3f 91       	pop	r19
    2412:	2a e0       	ldi	r18, 0x0A	; 10
    2414:	26 9f       	mul	r18, r22
    2416:	11 24       	eor	r1, r1
    2418:	30 19       	sub	r19, r0
    241a:	30 5d       	subi	r19, 0xD0	; 208
    241c:	31 93       	st	Z+, r19
    241e:	de f6       	brtc	.-74     	; 0x23d6 <__ultoa_invert+0xe>
    2420:	cf 01       	movw	r24, r30
    2422:	08 95       	ret
    2424:	46 2f       	mov	r20, r22
    2426:	47 70       	andi	r20, 0x07	; 7
    2428:	40 5d       	subi	r20, 0xD0	; 208
    242a:	41 93       	st	Z+, r20
    242c:	b3 e0       	ldi	r27, 0x03	; 3
    242e:	0f d0       	rcall	.+30     	; 0x244e <__ultoa_invert+0x86>
    2430:	c9 f7       	brne	.-14     	; 0x2424 <__ultoa_invert+0x5c>
    2432:	f6 cf       	rjmp	.-20     	; 0x2420 <__ultoa_invert+0x58>
    2434:	46 2f       	mov	r20, r22
    2436:	4f 70       	andi	r20, 0x0F	; 15
    2438:	40 5d       	subi	r20, 0xD0	; 208
    243a:	4a 33       	cpi	r20, 0x3A	; 58
    243c:	18 f0       	brcs	.+6      	; 0x2444 <__ultoa_invert+0x7c>
    243e:	49 5d       	subi	r20, 0xD9	; 217
    2440:	31 fd       	sbrc	r19, 1
    2442:	40 52       	subi	r20, 0x20	; 32
    2444:	41 93       	st	Z+, r20
    2446:	02 d0       	rcall	.+4      	; 0x244c <__ultoa_invert+0x84>
    2448:	a9 f7       	brne	.-22     	; 0x2434 <__ultoa_invert+0x6c>
    244a:	ea cf       	rjmp	.-44     	; 0x2420 <__ultoa_invert+0x58>
    244c:	b4 e0       	ldi	r27, 0x04	; 4
    244e:	a6 95       	lsr	r26
    2450:	97 95       	ror	r25
    2452:	87 95       	ror	r24
    2454:	77 95       	ror	r23
    2456:	67 95       	ror	r22
    2458:	ba 95       	dec	r27
    245a:	c9 f7       	brne	.-14     	; 0x244e <__ultoa_invert+0x86>
    245c:	00 97       	sbiw	r24, 0x00	; 0
    245e:	61 05       	cpc	r22, r1
    2460:	71 05       	cpc	r23, r1
    2462:	08 95       	ret
    2464:	9b 01       	movw	r18, r22
    2466:	ac 01       	movw	r20, r24
    2468:	0a 2e       	mov	r0, r26
    246a:	06 94       	lsr	r0
    246c:	57 95       	ror	r21
    246e:	47 95       	ror	r20
    2470:	37 95       	ror	r19
    2472:	27 95       	ror	r18
    2474:	ba 95       	dec	r27
    2476:	c9 f7       	brne	.-14     	; 0x246a <__ultoa_invert+0xa2>
    2478:	62 0f       	add	r22, r18
    247a:	73 1f       	adc	r23, r19
    247c:	84 1f       	adc	r24, r20
    247e:	95 1f       	adc	r25, r21
    2480:	a0 1d       	adc	r26, r0
    2482:	08 95       	ret

00002484 <eeprom_read_word>:
    2484:	a8 e1       	ldi	r26, 0x18	; 24
    2486:	b0 e0       	ldi	r27, 0x00	; 0
    2488:	42 e0       	ldi	r20, 0x02	; 2
    248a:	50 e0       	ldi	r21, 0x00	; 0
    248c:	02 c0       	rjmp	.+4      	; 0x2492 <eeprom_read_blraw>

0000248e <eeprom_read_block>:
    248e:	dc 01       	movw	r26, r24
    2490:	cb 01       	movw	r24, r22

00002492 <eeprom_read_blraw>:
    2492:	fc 01       	movw	r30, r24
    2494:	f9 99       	sbic	0x1f, 1	; 31
    2496:	fe cf       	rjmp	.-4      	; 0x2494 <eeprom_read_blraw+0x2>
    2498:	06 c0       	rjmp	.+12     	; 0x24a6 <eeprom_read_blraw+0x14>
    249a:	f2 bd       	out	0x22, r31	; 34
    249c:	e1 bd       	out	0x21, r30	; 33
    249e:	f8 9a       	sbi	0x1f, 0	; 31
    24a0:	31 96       	adiw	r30, 0x01	; 1
    24a2:	00 b4       	in	r0, 0x20	; 32
    24a4:	0d 92       	st	X+, r0
    24a6:	41 50       	subi	r20, 0x01	; 1
    24a8:	50 40       	sbci	r21, 0x00	; 0
    24aa:	b8 f7       	brcc	.-18     	; 0x249a <eeprom_read_blraw+0x8>
    24ac:	08 95       	ret

000024ae <_exit>:
    24ae:	f8 94       	cli

000024b0 <__stop_program>:
    24b0:	ff cf       	rjmp	.-2      	; 0x24b0 <__stop_program>
