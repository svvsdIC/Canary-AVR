
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001dc  00800100  0000255e  000025f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000255e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000042b  008002dc  008002dc  000027ce  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000027ce  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000282c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  00002870  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000049c2  00000000  00000000  00002ad0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000164e  00000000  00000000  00007492  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001ae8  00000000  00000000  00008ae0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006c8  00000000  00000000  0000a5c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c6a  00000000  00000000  0000ac90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001b3e  00000000  00000000  0000b8fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a8  00000000  00000000  0000d438  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 73 0c 	jmp	0x18e6	; 0x18e6 <__vector_13>
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 72 0c 	jmp	0x18e4	; 0x18e4 <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 91 0d 	jmp	0x1b22	; 0x1b22 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 e1 0c 	jmp	0x19c2	; 0x19c2 <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 d3 0d 	jmp	0x1ba6	; 0x1ba6 <__vector_28>
      74:	7b c0       	rjmp	.+246    	; 0x16c <__bad_interrupt>
      76:	00 00       	nop
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fd 0c       	add	r15, r13
      8e:	4f 0d       	add	r20, r15
      90:	4f 0d       	add	r20, r15
      92:	4f 0d       	add	r20, r15
      94:	4f 0d       	add	r20, r15
      96:	4f 0d       	add	r20, r15
      98:	4f 0d       	add	r20, r15
      9a:	4f 0d       	add	r20, r15
      9c:	fd 0c       	add	r15, r13
      9e:	4f 0d       	add	r20, r15
      a0:	4f 0d       	add	r20, r15
      a2:	4f 0d       	add	r20, r15
      a4:	4f 0d       	add	r20, r15
      a6:	4f 0d       	add	r20, r15
      a8:	4f 0d       	add	r20, r15
      aa:	4f 0d       	add	r20, r15
      ac:	ff 0c       	add	r15, r15
      ae:	4f 0d       	add	r20, r15
      b0:	4f 0d       	add	r20, r15
      b2:	4f 0d       	add	r20, r15
      b4:	4f 0d       	add	r20, r15
      b6:	4f 0d       	add	r20, r15
      b8:	4f 0d       	add	r20, r15
      ba:	4f 0d       	add	r20, r15
      bc:	4f 0d       	add	r20, r15
      be:	4f 0d       	add	r20, r15
      c0:	4f 0d       	add	r20, r15
      c2:	4f 0d       	add	r20, r15
      c4:	4f 0d       	add	r20, r15
      c6:	4f 0d       	add	r20, r15
      c8:	4f 0d       	add	r20, r15
      ca:	4f 0d       	add	r20, r15
      cc:	ff 0c       	add	r15, r15
      ce:	4f 0d       	add	r20, r15
      d0:	4f 0d       	add	r20, r15
      d2:	4f 0d       	add	r20, r15
      d4:	4f 0d       	add	r20, r15
      d6:	4f 0d       	add	r20, r15
      d8:	4f 0d       	add	r20, r15
      da:	4f 0d       	add	r20, r15
      dc:	4f 0d       	add	r20, r15
      de:	4f 0d       	add	r20, r15
      e0:	4f 0d       	add	r20, r15
      e2:	4f 0d       	add	r20, r15
      e4:	4f 0d       	add	r20, r15
      e6:	4f 0d       	add	r20, r15
      e8:	4f 0d       	add	r20, r15
      ea:	4f 0d       	add	r20, r15
      ec:	4b 0d       	add	r20, r11
      ee:	4f 0d       	add	r20, r15
      f0:	4f 0d       	add	r20, r15
      f2:	4f 0d       	add	r20, r15
      f4:	4f 0d       	add	r20, r15
      f6:	4f 0d       	add	r20, r15
      f8:	4f 0d       	add	r20, r15
      fa:	4f 0d       	add	r20, r15
      fc:	28 0d       	add	r18, r8
      fe:	4f 0d       	add	r20, r15
     100:	4f 0d       	add	r20, r15
     102:	4f 0d       	add	r20, r15
     104:	4f 0d       	add	r20, r15
     106:	4f 0d       	add	r20, r15
     108:	4f 0d       	add	r20, r15
     10a:	4f 0d       	add	r20, r15
     10c:	4f 0d       	add	r20, r15
     10e:	4f 0d       	add	r20, r15
     110:	4f 0d       	add	r20, r15
     112:	4f 0d       	add	r20, r15
     114:	4f 0d       	add	r20, r15
     116:	4f 0d       	add	r20, r15
     118:	4f 0d       	add	r20, r15
     11a:	4f 0d       	add	r20, r15
     11c:	1c 0d       	add	r17, r12
     11e:	4f 0d       	add	r20, r15
     120:	4f 0d       	add	r20, r15
     122:	4f 0d       	add	r20, r15
     124:	4f 0d       	add	r20, r15
     126:	4f 0d       	add	r20, r15
     128:	4f 0d       	add	r20, r15
     12a:	4f 0d       	add	r20, r15
     12c:	3a 0d       	add	r19, r10

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	12 e0       	ldi	r17, 0x02	; 2
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ee e5       	ldi	r30, 0x5E	; 94
     142:	f5 e2       	ldi	r31, 0x25	; 37
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	ac 3d       	cpi	r26, 0xDC	; 220
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	27 e0       	ldi	r18, 0x07	; 7
     156:	ac ed       	ldi	r26, 0xDC	; 220
     158:	b2 e0       	ldi	r27, 0x02	; 2
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a7 30       	cpi	r26, 0x07	; 7
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 1c 0b 	call	0x1638	; 0x1638 <main>
     168:	0c 94 ad 12 	jmp	0x255a	; 0x255a <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 5d 0c 	jmp	0x18ba	; 0x18ba <__vector_default>

00000170 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	90 81       	ld	r25, Z
     176:	90 7e       	andi	r25, 0xE0	; 224
     178:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     17a:	90 81       	ld	r25, Z
     17c:	89 2b       	or	r24, r25
     17e:	80 83       	st	Z, r24
     180:	08 95       	ret

00000182 <ADC_init>:
}

void ADC_init(void)
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     186:	ec e7       	ldi	r30, 0x7C	; 124
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	80 64       	ori	r24, 0x40	; 64
     18e:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     190:	ca e7       	ldi	r28, 0x7A	; 122
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	88 81       	ld	r24, Y
     196:	81 60       	ori	r24, 0x01	; 1
     198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     19a:	88 81       	ld	r24, Y
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     1a0:	88 81       	ld	r24, Y
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a6:	a4 e6       	ldi	r26, 0x64	; 100
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	8c 91       	ld	r24, X
     1ac:	8e 7f       	andi	r24, 0xFE	; 254
     1ae:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 7d       	andi	r24, 0xDF	; 223
     1b4:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b6:	8f e3       	ldi	r24, 0x3F	; 63
     1b8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1bc:	88 81       	ld	r24, Y
     1be:	80 68       	ori	r24, 0x80	; 128
     1c0:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c2:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c6:	8f e1       	ldi	r24, 0x1F	; 31
     1c8:	d3 df       	rcall	.-90     	; 0x170 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1ca:	88 81       	ld	r24, Y
     1cc:	80 64       	ori	r24, 0x40	; 64
     1ce:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1d0:	ea e7       	ldi	r30, 0x7A	; 122
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	84 ff       	sbrs	r24, 4
     1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1da:	ea e7       	ldi	r30, 0x7A	; 122
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	80 64       	ori	r24, 0x40	; 64
     1e2:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e4:	80 81       	ld	r24, Z
     1e6:	84 ff       	sbrs	r24, 4
     1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1ea:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <__data_end+0x1>
     1f4:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fc:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <__data_end>
     200:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <__data_end+0x1>
     204:	89 2f       	mov	r24, r25
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	98 2f       	mov	r25, r24
     20a:	88 27       	eor	r24, r24
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <__data_end+0x1>
     214:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     218:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <__data_end>
     21c:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <__data_end+0x1>
     220:	99 23       	and	r25, r25
     222:	1c f4       	brge	.+6      	; 0x22a <ADC_init+0xa8>
     224:	91 95       	neg	r25
     226:	81 95       	neg	r24
     228:	91 09       	sbc	r25, r1
     22a:	05 97       	sbiw	r24, 0x05	; 5
     22c:	2c f0       	brlt	.+10     	; 0x238 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22e:	80 91 cc 04 	lds	r24, 0x04CC	; 0x8004cc <gas_sensor_initialization_errors>
     232:	81 60       	ori	r24, 0x01	; 1
     234:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     238:	8e e1       	ldi	r24, 0x1E	; 30
     23a:	9a df       	rcall	.-204    	; 0x170 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23c:	ea e7       	ldi	r30, 0x7A	; 122
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	80 64       	ori	r24, 0x40	; 64
     244:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     246:	80 81       	ld	r24, Z
     248:	84 ff       	sbrs	r24, 4
     24a:	fd cf       	rjmp	.-6      	; 0x246 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <__data_end+0x1>
     256:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     25a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25e:	20 91 dc 02 	lds	r18, 0x02DC	; 0x8002dc <__data_end>
     262:	30 91 dd 02 	lds	r19, 0x02DD	; 0x8002dd <__data_end+0x1>
     266:	89 2f       	mov	r24, r25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	98 2f       	mov	r25, r24
     26c:	88 27       	eor	r24, r24
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <__data_end+0x1>
     276:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     27a:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <__data_end>
     27e:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <__data_end+0x1>
     282:	81 5e       	subi	r24, 0xE1	; 225
     284:	91 09       	sbc	r25, r1
     286:	90 93 dd 02 	sts	0x02DD, r25	; 0x8002dd <__data_end+0x1>
     28a:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28e:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <__data_end>
     292:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <__data_end+0x1>
     296:	99 23       	and	r25, r25
     298:	1c f4       	brge	.+6      	; 0x2a0 <ADC_init+0x11e>
     29a:	91 95       	neg	r25
     29c:	81 95       	neg	r24
     29e:	91 09       	sbc	r25, r1
     2a0:	05 97       	sbiw	r24, 0x05	; 5
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a4:	80 91 cc 04 	lds	r24, 0x04CC	; 0x8004cc <gas_sensor_initialization_errors>
     2a8:	82 60       	ori	r24, 0x02	; 2
     2aa:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ae:	ea e7       	ldi	r30, 0x7A	; 122
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8f 77       	andi	r24, 0x7F	; 127
     2b6:	80 83       	st	Z, r24
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <BME_read_correction_coefficients>:
********************************************************************************/

/********************************************************************************
						Functions
********************************************************************************/
void BME_read_correction_coefficients(void) {
     2be:	ff 92       	push	r15
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     2c8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     2cc:	88 23       	and	r24, r24
     2ce:	59 f1       	breq	.+86     	; 0x326 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2d0:	c5 e1       	ldi	r28, 0x15	; 21
     2d2:	d4 e0       	ldi	r29, 0x04	; 4
     2d4:	0f 2e       	mov	r0, r31
     2d6:	fc ee       	ldi	r31, 0xEC	; 236
     2d8:	ff 2e       	mov	r15, r31
     2da:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2dc:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2de:	1d ee       	ldi	r17, 0xED	; 237
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2e0:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2e2:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     2e4:	62 e0       	ldi	r22, 0x02	; 2
     2e6:	ce 01       	movw	r24, r28
     2e8:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2ec:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     2f0:	81 11       	cpse	r24, r1
     2f2:	fc cf       	rjmp	.-8      	; 0x2ec <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2f4:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     2f6:	6a e1       	ldi	r22, 0x1A	; 26
     2f8:	ce 01       	movw	r24, r28
     2fa:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2fe:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     302:	81 11       	cpse	r24, r1
     304:	fc cf       	rjmp	.-8      	; 0x2fe <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     306:	6a e1       	ldi	r22, 0x1A	; 26
     308:	ce 01       	movw	r24, r28
     30a:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     30e:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     312:	89 81       	ldd	r24, Y+1	; 0x01
     314:	83 fb       	bst	r24, 3
     316:	88 27       	eor	r24, r24
     318:	80 f9       	bld	r24, 0
     31a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     31e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     322:	81 11       	cpse	r24, r1
     324:	dd cf       	rjmp	.-70     	; 0x2e0 <BME_read_correction_coefficients+0x22>
	// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     326:	e5 e1       	ldi	r30, 0x15	; 21
     328:	f4 e0       	ldi	r31, 0x04	; 4
     32a:	8c ee       	ldi	r24, 0xEC	; 236
     32c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
     32e:	88 e8       	ldi	r24, 0x88	; 136
     330:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     332:	62 e0       	ldi	r22, 0x02	; 2
     334:	cf 01       	movw	r24, r30
     336:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     33a:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     33e:	81 11       	cpse	r24, r1
     340:	fc cf       	rjmp	.-8      	; 0x33a <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     342:	8d ee       	ldi	r24, 0xED	; 237
     344:	80 93 15 04 	sts	0x0415, r24	; 0x800415 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     348:	6b e1       	ldi	r22, 0x1B	; 27
     34a:	85 e1       	ldi	r24, 0x15	; 21
     34c:	94 e0       	ldi	r25, 0x04	; 4
     34e:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     352:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     356:	81 11       	cpse	r24, r1
     358:	fc cf       	rjmp	.-8      	; 0x352 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     35a:	6b e1       	ldi	r22, 0x1B	; 27
     35c:	85 e1       	ldi	r24, 0x15	; 21
     35e:	94 e0       	ldi	r25, 0x04	; 4
     360:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     364:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
     368:	c6 e1       	ldi	r28, 0x16	; 22
     36a:	d4 e0       	ldi	r29, 0x04	; 4
     36c:	01 e4       	ldi	r16, 0x41	; 65
     36e:	14 e0       	ldi	r17, 0x04	; 4
     370:	21 e3       	ldi	r18, 0x31	; 49
     372:	34 e0       	ldi	r19, 0x04	; 4
     374:	d8 01       	movw	r26, r16
     376:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     378:	81 91       	ld	r24, Z+
     37a:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     37c:	e2 17       	cp	r30, r18
     37e:	f3 07       	cpc	r31, r19
     380:	d9 f7       	brne	.-10     	; 0x378 <BME_read_correction_coefficients+0xba>
     382:	8b e1       	ldi	r24, 0x1B	; 27
     384:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <i.2323>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     388:	e1 e4       	ldi	r30, 0x41	; 65
     38a:	f4 e0       	ldi	r31, 0x04	; 4
     38c:	81 81       	ldd	r24, Z+1	; 0x01
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	98 2f       	mov	r25, r24
     392:	88 27       	eor	r24, r24
     394:	20 81       	ld	r18, Z
     396:	82 2b       	or	r24, r18
     398:	90 93 14 04 	sts	0x0414, r25	; 0x800414 <dig_T1+0x1>
     39c:	80 93 13 04 	sts	0x0413, r24	; 0x800413 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     3a0:	83 81       	ldd	r24, Z+3	; 0x03
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	98 2f       	mov	r25, r24
     3a6:	88 27       	eor	r24, r24
     3a8:	22 81       	ldd	r18, Z+2	; 0x02
     3aa:	82 2b       	or	r24, r18
     3ac:	90 93 40 04 	sts	0x0440, r25	; 0x800440 <dig_T2+0x1>
     3b0:	80 93 3f 04 	sts	0x043F, r24	; 0x80043f <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     3b4:	85 81       	ldd	r24, Z+5	; 0x05
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	98 2f       	mov	r25, r24
     3ba:	88 27       	eor	r24, r24
     3bc:	24 81       	ldd	r18, Z+4	; 0x04
     3be:	82 2b       	or	r24, r18
     3c0:	90 93 e0 04 	sts	0x04E0, r25	; 0x8004e0 <dig_T3+0x1>
     3c4:	80 93 df 04 	sts	0x04DF, r24	; 0x8004df <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     3c8:	87 81       	ldd	r24, Z+7	; 0x07
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	98 2f       	mov	r25, r24
     3ce:	88 27       	eor	r24, r24
     3d0:	26 81       	ldd	r18, Z+6	; 0x06
     3d2:	82 2b       	or	r24, r18
     3d4:	90 93 ce 04 	sts	0x04CE, r25	; 0x8004ce <dig_P1+0x1>
     3d8:	80 93 cd 04 	sts	0x04CD, r24	; 0x8004cd <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     3dc:	81 85       	ldd	r24, Z+9	; 0x09
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	98 2f       	mov	r25, r24
     3e2:	88 27       	eor	r24, r24
     3e4:	20 85       	ldd	r18, Z+8	; 0x08
     3e6:	82 2b       	or	r24, r18
     3e8:	90 93 87 04 	sts	0x0487, r25	; 0x800487 <dig_P2+0x1>
     3ec:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     3f0:	83 85       	ldd	r24, Z+11	; 0x0b
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	98 2f       	mov	r25, r24
     3f6:	88 27       	eor	r24, r24
     3f8:	22 85       	ldd	r18, Z+10	; 0x0a
     3fa:	82 2b       	or	r24, r18
     3fc:	90 93 d0 04 	sts	0x04D0, r25	; 0x8004d0 <dig_P3+0x1>
     400:	80 93 cf 04 	sts	0x04CF, r24	; 0x8004cf <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     404:	85 85       	ldd	r24, Z+13	; 0x0d
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	98 2f       	mov	r25, r24
     40a:	88 27       	eor	r24, r24
     40c:	24 85       	ldd	r18, Z+12	; 0x0c
     40e:	82 2b       	or	r24, r18
     410:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <dig_P4+0x1>
     414:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     418:	87 85       	ldd	r24, Z+15	; 0x0f
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	98 2f       	mov	r25, r24
     41e:	88 27       	eor	r24, r24
     420:	26 85       	ldd	r18, Z+14	; 0x0e
     422:	82 2b       	or	r24, r18
     424:	90 93 a9 04 	sts	0x04A9, r25	; 0x8004a9 <dig_P5+0x1>
     428:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     42c:	81 89       	ldd	r24, Z+17	; 0x11
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	98 2f       	mov	r25, r24
     432:	88 27       	eor	r24, r24
     434:	20 89       	ldd	r18, Z+16	; 0x10
     436:	82 2b       	or	r24, r18
     438:	90 93 e2 04 	sts	0x04E2, r25	; 0x8004e2 <dig_P6+0x1>
     43c:	80 93 e1 04 	sts	0x04E1, r24	; 0x8004e1 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     440:	83 89       	ldd	r24, Z+19	; 0x13
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	98 2f       	mov	r25, r24
     446:	88 27       	eor	r24, r24
     448:	22 89       	ldd	r18, Z+18	; 0x12
     44a:	82 2b       	or	r24, r18
     44c:	90 93 12 04 	sts	0x0412, r25	; 0x800412 <dig_P7+0x1>
     450:	80 93 11 04 	sts	0x0411, r24	; 0x800411 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     454:	85 89       	ldd	r24, Z+21	; 0x15
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	98 2f       	mov	r25, r24
     45a:	88 27       	eor	r24, r24
     45c:	24 89       	ldd	r18, Z+20	; 0x14
     45e:	82 2b       	or	r24, r18
     460:	90 93 d2 04 	sts	0x04D2, r25	; 0x8004d2 <dig_P8+0x1>
     464:	80 93 d1 04 	sts	0x04D1, r24	; 0x8004d1 <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     468:	87 89       	ldd	r24, Z+23	; 0x17
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	98 2f       	mov	r25, r24
     46e:	88 27       	eor	r24, r24
     470:	26 89       	ldd	r18, Z+22	; 0x16
     472:	82 2b       	or	r24, r18
     474:	90 93 de 04 	sts	0x04DE, r25	; 0x8004de <dig_P9+0x1>
     478:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <dig_P9>
	dig_H1 = RawBMEdata[25];
     47c:	81 8d       	ldd	r24, Z+25	; 0x19
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	90 93 70 04 	sts	0x0470, r25	; 0x800470 <dig_H1+0x1>
     484:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     488:	e5 e1       	ldi	r30, 0x15	; 21
     48a:	f4 e0       	ldi	r31, 0x04	; 4
     48c:	8c ee       	ldi	r24, 0xEC	; 236
     48e:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     490:	81 ee       	ldi	r24, 0xE1	; 225
     492:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     494:	62 e0       	ldi	r22, 0x02	; 2
     496:	cf 01       	movw	r24, r30
     498:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     49c:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     4a0:	81 11       	cpse	r24, r1
     4a2:	fc cf       	rjmp	.-8      	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     4a4:	8d ee       	ldi	r24, 0xED	; 237
     4a6:	80 93 15 04 	sts	0x0415, r24	; 0x800415 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     4aa:	68 e0       	ldi	r22, 0x08	; 8
     4ac:	85 e1       	ldi	r24, 0x15	; 21
     4ae:	94 e0       	ldi	r25, 0x04	; 4
     4b0:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     4b4:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     4b8:	81 11       	cpse	r24, r1
     4ba:	fc cf       	rjmp	.-8      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     4bc:	68 e0       	ldi	r22, 0x08	; 8
     4be:	85 e1       	ldi	r24, 0x15	; 21
     4c0:	94 e0       	ldi	r25, 0x04	; 4
     4c2:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     4c6:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
     4ca:	2d e1       	ldi	r18, 0x1D	; 29
     4cc:	34 e0       	ldi	r19, 0x04	; 4
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     4ce:	89 91       	ld	r24, Y+
     4d0:	f8 01       	movw	r30, r16
     4d2:	81 93       	st	Z+, r24
     4d4:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     4d6:	c2 17       	cp	r28, r18
     4d8:	d3 07       	cpc	r29, r19
     4da:	c9 f7       	brne	.-14     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
     4dc:	87 e0       	ldi	r24, 0x07	; 7
     4de:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <i.2323>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8);
     4e2:	e1 e4       	ldi	r30, 0x41	; 65
     4e4:	f4 e0       	ldi	r31, 0x04	; 4
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	98 2f       	mov	r25, r24
     4ec:	88 27       	eor	r24, r24
     4ee:	21 81       	ldd	r18, Z+1	; 0x01
     4f0:	82 2b       	or	r24, r18
     4f2:	90 93 e4 04 	sts	0x04E4, r25	; 0x8004e4 <dig_H2+0x1>
     4f6:	80 93 e3 04 	sts	0x04E3, r24	; 0x8004e3 <dig_H2>
	dig_H3 = RawBMEdata[3];
     4fa:	83 81       	ldd	r24, Z+3	; 0x03
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	90 93 d8 04 	sts	0x04D8, r25	; 0x8004d8 <dig_H3+0x1>
     502:	80 93 d7 04 	sts	0x04D7, r24	; 0x8004d7 <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     506:	85 81       	ldd	r24, Z+5	; 0x05
     508:	82 95       	swap	r24
     50a:	86 95       	lsr	r24
     50c:	87 70       	andi	r24, 0x07	; 7
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	24 81       	ldd	r18, Z+4	; 0x04
     512:	40 e1       	ldi	r20, 0x10	; 16
     514:	24 9f       	mul	r18, r20
     516:	90 01       	movw	r18, r0
     518:	11 24       	eor	r1, r1
     51a:	28 2b       	or	r18, r24
     51c:	39 2b       	or	r19, r25
     51e:	30 93 3e 04 	sts	0x043E, r19	; 0x80043e <dig_H4+0x1>
     522:	20 93 3d 04 	sts	0x043D, r18	; 0x80043d <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     526:	26 81       	ldd	r18, Z+6	; 0x06
     528:	40 e1       	ldi	r20, 0x10	; 16
     52a:	24 9f       	mul	r18, r20
     52c:	90 01       	movw	r18, r0
     52e:	11 24       	eor	r1, r1
     530:	82 2b       	or	r24, r18
     532:	93 2b       	or	r25, r19
     534:	90 93 d5 04 	sts	0x04D5, r25	; 0x8004d5 <dig_H5+0x1>
     538:	80 93 d4 04 	sts	0x04D4, r24	; 0x8004d4 <dig_H5>
	dig_H6 = RawBMEdata[7];
     53c:	87 81       	ldd	r24, Z+7	; 0x07
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <dig_H6+0x1>
     544:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <dig_H6>
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	1f 91       	pop	r17
     54e:	0f 91       	pop	r16
     550:	ff 90       	pop	r15
     552:	08 95       	ret

00000554 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     554:	e5 e1       	ldi	r30, 0x15	; 21
     556:	f4 e0       	ldi	r31, 0x04	; 4
     558:	8c ee       	ldi	r24, 0xEC	; 236
     55a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     55c:	80 ee       	ldi	r24, 0xE0	; 224
     55e:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     560:	86 eb       	ldi	r24, 0xB6	; 182
     562:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     564:	63 e0       	ldi	r22, 0x03	; 3
     566:	cf 01       	movw	r24, r30
     568:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     56c:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     570:	81 11       	cpse	r24, r1
     572:	fc cf       	rjmp	.-8      	; 0x56c <bme280basic_init+0x18>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     574:	e5 e1       	ldi	r30, 0x15	; 21
     576:	f4 e0       	ldi	r31, 0x04	; 4
     578:	8c ee       	ldi	r24, 0xEC	; 236
     57a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     57c:	80 ed       	ldi	r24, 0xD0	; 208
     57e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     580:	62 e0       	ldi	r22, 0x02	; 2
     582:	cf 01       	movw	r24, r30
     584:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     588:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     58c:	81 11       	cpse	r24, r1
     58e:	fc cf       	rjmp	.-8      	; 0x588 <bme280basic_init+0x34>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     590:	8d ee       	ldi	r24, 0xED	; 237
     592:	80 93 15 04 	sts	0x0415, r24	; 0x800415 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     596:	62 e0       	ldi	r22, 0x02	; 2
     598:	85 e1       	ldi	r24, 0x15	; 21
     59a:	94 e0       	ldi	r25, 0x04	; 4
     59c:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5a0:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     5a4:	81 11       	cpse	r24, r1
     5a6:	fc cf       	rjmp	.-8      	; 0x5a0 <bme280basic_init+0x4c>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     5a8:	62 e0       	ldi	r22, 0x02	; 2
     5aa:	85 e1       	ldi	r24, 0x15	; 21
     5ac:	94 e0       	ldi	r25, 0x04	; 4
     5ae:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     5b2:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) {
     5b6:	80 91 16 04 	lds	r24, 0x0416	; 0x800416 <BMEmessageBuf+0x1>
     5ba:	80 36       	cpi	r24, 0x60	; 96
     5bc:	99 f5       	brne	.+102    	; 0x624 <bme280basic_init+0xd0>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5be:	e5 e1       	ldi	r30, 0x15	; 21
     5c0:	f4 e0       	ldi	r31, 0x04	; 4
     5c2:	8c ee       	ldi	r24, 0xEC	; 236
     5c4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     5c6:	82 ef       	ldi	r24, 0xF2	; 242
     5c8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ce:	63 e0       	ldi	r22, 0x03	; 3
     5d0:	cf 01       	movw	r24, r30
     5d2:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5d6:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     5da:	81 11       	cpse	r24, r1
     5dc:	fc cf       	rjmp	.-8      	; 0x5d6 <bme280basic_init+0x82>
		//
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5de:	e5 e1       	ldi	r30, 0x15	; 21
     5e0:	f4 e0       	ldi	r31, 0x04	; 4
     5e2:	8c ee       	ldi	r24, 0xEC	; 236
     5e4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     5e6:	85 ef       	ldi	r24, 0xF5	; 245
     5e8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     5ea:	80 e1       	ldi	r24, 0x10	; 16
     5ec:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ee:	63 e0       	ldi	r22, 0x03	; 3
     5f0:	cf 01       	movw	r24, r30
     5f2:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5f6:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     5fa:	81 11       	cpse	r24, r1
     5fc:	fc cf       	rjmp	.-8      	; 0x5f6 <bme280basic_init+0xa2>
		//
		BME_read_correction_coefficients();
     5fe:	5f de       	rcall	.-834    	; 0x2be <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     600:	81 e3       	ldi	r24, 0x31	; 49
     602:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     606:	e5 e1       	ldi	r30, 0x15	; 21
     608:	f4 e0       	ldi	r31, 0x04	; 4
     60a:	9c ee       	ldi	r25, 0xEC	; 236
     60c:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     60e:	94 ef       	ldi	r25, 0xF4	; 244
     610:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     612:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     614:	63 e0       	ldi	r22, 0x03	; 3
     616:	cf 01       	movw	r24, r30
     618:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     61c:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     620:	81 11       	cpse	r24, r1
     622:	fc cf       	rjmp	.-8      	; 0x61c <bme280basic_init+0xc8>
     624:	08 95       	ret

00000626 <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     626:	ff 92       	push	r15
     628:	0f 93       	push	r16
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     630:	81 e0       	ldi	r24, 0x01	; 1
     632:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <BMEbusy.2377>
	while (BMEbusy) {
     636:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <BMEbusy.2377>
     63a:	88 23       	and	r24, r24
     63c:	59 f1       	breq	.+86     	; 0x694 <bme280basic_bulk_data_read+0x6e>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     63e:	c5 e1       	ldi	r28, 0x15	; 21
     640:	d4 e0       	ldi	r29, 0x04	; 4
     642:	0f 2e       	mov	r0, r31
     644:	fc ee       	ldi	r31, 0xEC	; 236
     646:	ff 2e       	mov	r15, r31
     648:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     64a:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     64c:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     64e:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     650:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     652:	62 e0       	ldi	r22, 0x02	; 2
     654:	ce 01       	movw	r24, r28
     656:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     65a:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     65e:	81 11       	cpse	r24, r1
     660:	fc cf       	rjmp	.-8      	; 0x65a <bme280basic_bulk_data_read+0x34>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     662:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     664:	62 e0       	ldi	r22, 0x02	; 2
     666:	ce 01       	movw	r24, r28
     668:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     66c:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     670:	81 11       	cpse	r24, r1
     672:	fc cf       	rjmp	.-8      	; 0x66c <bme280basic_bulk_data_read+0x46>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     674:	62 e0       	ldi	r22, 0x02	; 2
     676:	ce 01       	movw	r24, r28
     678:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     67c:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     680:	89 81       	ldd	r24, Y+1	; 0x01
     682:	83 fb       	bst	r24, 3
     684:	88 27       	eor	r24, r24
     686:	80 f9       	bld	r24, 0
     688:	80 93 de 02 	sts	0x02DE, r24	; 0x8002de <BMEbusy.2377>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     68c:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <BMEbusy.2377>
     690:	81 11       	cpse	r24, r1
     692:	dd cf       	rjmp	.-70     	; 0x64e <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     694:	e5 e1       	ldi	r30, 0x15	; 21
     696:	f4 e0       	ldi	r31, 0x04	; 4
     698:	8c ee       	ldi	r24, 0xEC	; 236
     69a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from
     69c:	87 ef       	ldi	r24, 0xF7	; 247
     69e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6a0:	62 e0       	ldi	r22, 0x02	; 2
     6a2:	cf 01       	movw	r24, r30
     6a4:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6a8:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     6ac:	81 11       	cpse	r24, r1
     6ae:	fc cf       	rjmp	.-8      	; 0x6a8 <bme280basic_bulk_data_read+0x82>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6b0:	8d ee       	ldi	r24, 0xED	; 237
     6b2:	80 93 15 04 	sts	0x0415, r24	; 0x800415 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     6b6:	69 e0       	ldi	r22, 0x09	; 9
     6b8:	85 e1       	ldi	r24, 0x15	; 21
     6ba:	94 e0       	ldi	r25, 0x04	; 4
     6bc:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6c0:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     6c4:	81 11       	cpse	r24, r1
     6c6:	fc cf       	rjmp	.-8      	; 0x6c0 <bme280basic_bulk_data_read+0x9a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     6c8:	69 e0       	ldi	r22, 0x09	; 9
     6ca:	85 e1       	ldi	r24, 0x15	; 21
     6cc:	94 e0       	ldi	r25, 0x04	; 4
     6ce:	0e 94 c2 0c 	call	0x1984	; 0x1984 <TWI_Get_Data_From_Transceiver>
     6d2:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <TWI_XFER_STATUS>
     6d6:	e6 e1       	ldi	r30, 0x16	; 22
     6d8:	f4 e0       	ldi	r31, 0x04	; 4
     6da:	a1 e4       	ldi	r26, 0x41	; 65
     6dc:	b4 e0       	ldi	r27, 0x04	; 4
     6de:	2e e1       	ldi	r18, 0x1E	; 30
     6e0:	34 e0       	ldi	r19, 0x04	; 4
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     6e2:	81 91       	ld	r24, Z+
     6e4:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     6e6:	e2 17       	cp	r30, r18
     6e8:	f3 07       	cpc	r31, r19
     6ea:	d9 f7       	brne	.-10     	; 0x6e2 <bme280basic_bulk_data_read+0xbc>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     6ec:	e1 e4       	ldi	r30, 0x41	; 65
     6ee:	f4 e0       	ldi	r31, 0x04	; 4
     6f0:	81 81       	ldd	r24, Z+1	; 0x01
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	a0 e0       	ldi	r26, 0x00	; 0
     6f6:	b0 e0       	ldi	r27, 0x00	; 0
     6f8:	88 0f       	add	r24, r24
     6fa:	99 1f       	adc	r25, r25
     6fc:	aa 1f       	adc	r26, r26
     6fe:	bb 1f       	adc	r27, r27
     700:	88 0f       	add	r24, r24
     702:	99 1f       	adc	r25, r25
     704:	aa 1f       	adc	r26, r26
     706:	bb 1f       	adc	r27, r27
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	aa 1f       	adc	r26, r26
     70e:	bb 1f       	adc	r27, r27
     710:	88 0f       	add	r24, r24
     712:	99 1f       	adc	r25, r25
     714:	aa 1f       	adc	r26, r26
     716:	bb 1f       	adc	r27, r27
     718:	40 81       	ld	r20, Z
     71a:	50 e0       	ldi	r21, 0x00	; 0
     71c:	60 e0       	ldi	r22, 0x00	; 0
     71e:	70 e0       	ldi	r23, 0x00	; 0
     720:	03 2e       	mov	r0, r19
     722:	3c e0       	ldi	r19, 0x0C	; 12
     724:	44 0f       	add	r20, r20
     726:	55 1f       	adc	r21, r21
     728:	66 1f       	adc	r22, r22
     72a:	77 1f       	adc	r23, r23
     72c:	3a 95       	dec	r19
     72e:	d1 f7       	brne	.-12     	; 0x724 <bme280basic_bulk_data_read+0xfe>
     730:	30 2d       	mov	r19, r0
     732:	84 2b       	or	r24, r20
     734:	95 2b       	or	r25, r21
     736:	a6 2b       	or	r26, r22
     738:	b7 2b       	or	r27, r23
     73a:	22 81       	ldd	r18, Z+2	; 0x02
     73c:	22 95       	swap	r18
     73e:	2f 70       	andi	r18, 0x0F	; 15
     740:	82 2b       	or	r24, r18
     742:	80 93 aa 04 	sts	0x04AA, r24	; 0x8004aa <rawPress>
     746:	90 93 ab 04 	sts	0x04AB, r25	; 0x8004ab <rawPress+0x1>
     74a:	a0 93 ac 04 	sts	0x04AC, r26	; 0x8004ac <rawPress+0x2>
     74e:	b0 93 ad 04 	sts	0x04AD, r27	; 0x8004ad <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     752:	84 81       	ldd	r24, Z+4	; 0x04
     754:	90 e0       	ldi	r25, 0x00	; 0
     756:	a0 e0       	ldi	r26, 0x00	; 0
     758:	b0 e0       	ldi	r27, 0x00	; 0
     75a:	88 0f       	add	r24, r24
     75c:	99 1f       	adc	r25, r25
     75e:	aa 1f       	adc	r26, r26
     760:	bb 1f       	adc	r27, r27
     762:	88 0f       	add	r24, r24
     764:	99 1f       	adc	r25, r25
     766:	aa 1f       	adc	r26, r26
     768:	bb 1f       	adc	r27, r27
     76a:	88 0f       	add	r24, r24
     76c:	99 1f       	adc	r25, r25
     76e:	aa 1f       	adc	r26, r26
     770:	bb 1f       	adc	r27, r27
     772:	88 0f       	add	r24, r24
     774:	99 1f       	adc	r25, r25
     776:	aa 1f       	adc	r26, r26
     778:	bb 1f       	adc	r27, r27
     77a:	43 81       	ldd	r20, Z+3	; 0x03
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	60 e0       	ldi	r22, 0x00	; 0
     780:	70 e0       	ldi	r23, 0x00	; 0
     782:	03 2e       	mov	r0, r19
     784:	3c e0       	ldi	r19, 0x0C	; 12
     786:	44 0f       	add	r20, r20
     788:	55 1f       	adc	r21, r21
     78a:	66 1f       	adc	r22, r22
     78c:	77 1f       	adc	r23, r23
     78e:	3a 95       	dec	r19
     790:	d1 f7       	brne	.-12     	; 0x786 <bme280basic_bulk_data_read+0x160>
     792:	30 2d       	mov	r19, r0
     794:	84 2b       	or	r24, r20
     796:	95 2b       	or	r25, r21
     798:	a6 2b       	or	r26, r22
     79a:	b7 2b       	or	r27, r23
     79c:	25 81       	ldd	r18, Z+5	; 0x05
     79e:	22 95       	swap	r18
     7a0:	2f 70       	andi	r18, 0x0F	; 15
     7a2:	82 2b       	or	r24, r18
     7a4:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <rawTemp>
     7a8:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <rawTemp+0x1>
     7ac:	a0 93 74 04 	sts	0x0474, r26	; 0x800474 <rawTemp+0x2>
     7b0:	b0 93 75 04 	sts	0x0475, r27	; 0x800475 <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     7b4:	86 81       	ldd	r24, Z+6	; 0x06
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	a0 e0       	ldi	r26, 0x00	; 0
     7ba:	b0 e0       	ldi	r27, 0x00	; 0
     7bc:	ba 2f       	mov	r27, r26
     7be:	a9 2f       	mov	r26, r25
     7c0:	98 2f       	mov	r25, r24
     7c2:	88 27       	eor	r24, r24
     7c4:	27 81       	ldd	r18, Z+7	; 0x07
     7c6:	82 2b       	or	r24, r18
     7c8:	80 93 ae 04 	sts	0x04AE, r24	; 0x8004ae <rawHum>
     7cc:	90 93 af 04 	sts	0x04AF, r25	; 0x8004af <rawHum+0x1>
     7d0:	a0 93 b0 04 	sts	0x04B0, r26	; 0x8004b0 <rawHum+0x2>
     7d4:	b0 93 b1 04 	sts	0x04B1, r27	; 0x8004b1 <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     7d8:	e5 e1       	ldi	r30, 0x15	; 21
     7da:	f4 e0       	ldi	r31, 0x04	; 4
     7dc:	8c ee       	ldi	r24, 0xEC	; 236
     7de:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     7e0:	84 ef       	ldi	r24, 0xF4	; 244
     7e2:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     7e4:	81 e3       	ldi	r24, 0x31	; 49
     7e6:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     7e8:	63 e0       	ldi	r22, 0x03	; 3
     7ea:	cf 01       	movw	r24, r30
     7ec:	0e 94 96 0c 	call	0x192c	; 0x192c <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     7f0:	0e 94 92 0c 	call	0x1924	; 0x1924 <TWI_Transceiver_Busy>
     7f4:	81 11       	cpse	r24, r1
     7f6:	fc cf       	rjmp	.-8      	; 0x7f0 <bme280basic_bulk_data_read+0x1ca>
	//  All done - and the next measurement cycle has  been kicked off!
}
     7f8:	df 91       	pop	r29
     7fa:	cf 91       	pop	r28
     7fc:	1f 91       	pop	r17
     7fe:	0f 91       	pop	r16
     800:	ff 90       	pop	r15
     802:	08 95       	ret

00000804 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     804:	8f 92       	push	r8
     806:	9f 92       	push	r9
     808:	af 92       	push	r10
     80a:	bf 92       	push	r11
     80c:	cf 92       	push	r12
     80e:	df 92       	push	r13
     810:	ef 92       	push	r14
     812:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     814:	20 91 13 04 	lds	r18, 0x0413	; 0x800413 <dig_T1>
     818:	30 91 14 04 	lds	r19, 0x0414	; 0x800414 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     81c:	6b 01       	movw	r12, r22
     81e:	7c 01       	movw	r14, r24
     820:	68 94       	set
     822:	13 f8       	bld	r1, 3
     824:	f5 94       	asr	r15
     826:	e7 94       	ror	r14
     828:	d7 94       	ror	r13
     82a:	c7 94       	ror	r12
     82c:	16 94       	lsr	r1
     82e:	d1 f7       	brne	.-12     	; 0x824 <BME280_compensate_T_int32+0x20>
     830:	c2 1a       	sub	r12, r18
     832:	d3 0a       	sbc	r13, r19
     834:	e1 08       	sbc	r14, r1
     836:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     838:	dc 01       	movw	r26, r24
     83a:	cb 01       	movw	r24, r22
     83c:	68 94       	set
     83e:	12 f8       	bld	r1, 2
     840:	b5 95       	asr	r27
     842:	a7 95       	ror	r26
     844:	97 95       	ror	r25
     846:	87 95       	ror	r24
     848:	16 94       	lsr	r1
     84a:	d1 f7       	brne	.-12     	; 0x840 <BME280_compensate_T_int32+0x3c>
     84c:	22 0f       	add	r18, r18
     84e:	33 1f       	adc	r19, r19
     850:	4c 01       	movw	r8, r24
     852:	5d 01       	movw	r10, r26
     854:	82 1a       	sub	r8, r18
     856:	93 0a       	sbc	r9, r19
     858:	a1 08       	sbc	r10, r1
     85a:	b1 08       	sbc	r11, r1
     85c:	a5 01       	movw	r20, r10
     85e:	94 01       	movw	r18, r8
     860:	a0 91 3f 04 	lds	r26, 0x043F	; 0x80043f <dig_T2>
     864:	b0 91 40 04 	lds	r27, 0x0440	; 0x800440 <dig_T2+0x1>
     868:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <__mulshisi3>
     86c:	4b 01       	movw	r8, r22
     86e:	5c 01       	movw	r10, r24
     870:	07 2e       	mov	r0, r23
     872:	7b e0       	ldi	r23, 0x0B	; 11
     874:	b5 94       	asr	r11
     876:	a7 94       	ror	r10
     878:	97 94       	ror	r9
     87a:	87 94       	ror	r8
     87c:	7a 95       	dec	r23
     87e:	d1 f7       	brne	.-12     	; 0x874 <BME280_compensate_T_int32+0x70>
     880:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     882:	a7 01       	movw	r20, r14
     884:	96 01       	movw	r18, r12
     886:	c7 01       	movw	r24, r14
     888:	b6 01       	movw	r22, r12
     88a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <__mulsi3>
     88e:	9b 01       	movw	r18, r22
     890:	ac 01       	movw	r20, r24
     892:	01 2e       	mov	r0, r17
     894:	1c e0       	ldi	r17, 0x0C	; 12
     896:	55 95       	asr	r21
     898:	47 95       	ror	r20
     89a:	37 95       	ror	r19
     89c:	27 95       	ror	r18
     89e:	1a 95       	dec	r17
     8a0:	d1 f7       	brne	.-12     	; 0x896 <BME280_compensate_T_int32+0x92>
     8a2:	10 2d       	mov	r17, r0
     8a4:	a0 91 df 04 	lds	r26, 0x04DF	; 0x8004df <dig_T3>
     8a8:	b0 91 e0 04 	lds	r27, 0x04E0	; 0x8004e0 <dig_T3+0x1>
     8ac:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <__mulshisi3>
     8b0:	dc 01       	movw	r26, r24
     8b2:	cb 01       	movw	r24, r22
     8b4:	07 2e       	mov	r0, r23
     8b6:	7e e0       	ldi	r23, 0x0E	; 14
     8b8:	b5 95       	asr	r27
     8ba:	a7 95       	ror	r26
     8bc:	97 95       	ror	r25
     8be:	87 95       	ror	r24
     8c0:	7a 95       	dec	r23
     8c2:	d1 f7       	brne	.-12     	; 0x8b8 <BME280_compensate_T_int32+0xb4>
     8c4:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     8c6:	88 0d       	add	r24, r8
     8c8:	99 1d       	adc	r25, r9
     8ca:	aa 1d       	adc	r26, r10
     8cc:	bb 1d       	adc	r27, r11
     8ce:	80 93 e5 04 	sts	0x04E5, r24	; 0x8004e5 <t_fine>
     8d2:	90 93 e6 04 	sts	0x04E6, r25	; 0x8004e6 <t_fine+0x1>
     8d6:	a0 93 e7 04 	sts	0x04E7, r26	; 0x8004e7 <t_fine+0x2>
     8da:	b0 93 e8 04 	sts	0x04E8, r27	; 0x8004e8 <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     8de:	6c 01       	movw	r12, r24
     8e0:	7d 01       	movw	r14, r26
     8e2:	cc 0c       	add	r12, r12
     8e4:	dd 1c       	adc	r13, r13
     8e6:	ee 1c       	adc	r14, r14
     8e8:	ff 1c       	adc	r15, r15
     8ea:	cc 0c       	add	r12, r12
     8ec:	dd 1c       	adc	r13, r13
     8ee:	ee 1c       	adc	r14, r14
     8f0:	ff 1c       	adc	r15, r15
     8f2:	8c 0d       	add	r24, r12
     8f4:	9d 1d       	adc	r25, r13
     8f6:	ae 1d       	adc	r26, r14
     8f8:	bf 1d       	adc	r27, r15
     8fa:	80 58       	subi	r24, 0x80	; 128
     8fc:	9f 4f       	sbci	r25, 0xFF	; 255
     8fe:	af 4f       	sbci	r26, 0xFF	; 255
     900:	bf 4f       	sbci	r27, 0xFF	; 255
     902:	69 2f       	mov	r22, r25
     904:	7a 2f       	mov	r23, r26
     906:	8b 2f       	mov	r24, r27
     908:	99 27       	eor	r25, r25
     90a:	87 fd       	sbrc	r24, 7
     90c:	9a 95       	dec	r25
	return T;
}
     90e:	ff 90       	pop	r15
     910:	ef 90       	pop	r14
     912:	df 90       	pop	r13
     914:	cf 90       	pop	r12
     916:	bf 90       	pop	r11
     918:	af 90       	pop	r10
     91a:	9f 90       	pop	r9
     91c:	8f 90       	pop	r8
     91e:	08 95       	ret

00000920 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     920:	2f 92       	push	r2
     922:	3f 92       	push	r3
     924:	4f 92       	push	r4
     926:	5f 92       	push	r5
     928:	6f 92       	push	r6
     92a:	7f 92       	push	r7
     92c:	8f 92       	push	r8
     92e:	9f 92       	push	r9
     930:	af 92       	push	r10
     932:	bf 92       	push	r11
     934:	cf 92       	push	r12
     936:	df 92       	push	r13
     938:	ef 92       	push	r14
     93a:	ff 92       	push	r15
     93c:	0f 93       	push	r16
     93e:	1f 93       	push	r17
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
     944:	cd b7       	in	r28, 0x3d	; 61
     946:	de b7       	in	r29, 0x3e	; 62
     948:	6e 97       	sbiw	r28, 0x1e	; 30
     94a:	0f b6       	in	r0, 0x3f	; 63
     94c:	f8 94       	cli
     94e:	de bf       	out	0x3e, r29	; 62
     950:	0f be       	out	0x3f, r0	; 63
     952:	cd bf       	out	0x3d, r28	; 61
     954:	6e 8b       	std	Y+22, r22	; 0x16
     956:	7f 8b       	std	Y+23, r23	; 0x17
     958:	88 8f       	std	Y+24, r24	; 0x18
     95a:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     95c:	80 91 e5 04 	lds	r24, 0x04E5	; 0x8004e5 <t_fine>
     960:	90 91 e6 04 	lds	r25, 0x04E6	; 0x8004e6 <t_fine+0x1>
     964:	a0 91 e7 04 	lds	r26, 0x04E7	; 0x8004e7 <t_fine+0x2>
     968:	b0 91 e8 04 	lds	r27, 0x04E8	; 0x8004e8 <t_fine+0x3>
     96c:	8c 01       	movw	r16, r24
     96e:	9d 01       	movw	r18, r26
     970:	14 5f       	subi	r17, 0xF4	; 244
     972:	21 40       	sbci	r18, 0x01	; 1
     974:	31 09       	sbc	r19, r1
     976:	09 83       	std	Y+1, r16	; 0x01
     978:	1a 83       	std	Y+2, r17	; 0x02
     97a:	2b 83       	std	Y+3, r18	; 0x03
     97c:	3c 83       	std	Y+4, r19	; 0x04
     97e:	33 0f       	add	r19, r19
     980:	00 0b       	sbc	r16, r16
     982:	10 2f       	mov	r17, r16
     984:	98 01       	movw	r18, r16
     986:	0d 83       	std	Y+5, r16	; 0x05
     988:	1e 83       	std	Y+6, r17	; 0x06
     98a:	2f 83       	std	Y+7, r18	; 0x07
     98c:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     98e:	a9 80       	ldd	r10, Y+1	; 0x01
     990:	ba 80       	ldd	r11, Y+2	; 0x02
     992:	cb 80       	ldd	r12, Y+3	; 0x03
     994:	dc 80       	ldd	r13, Y+4	; 0x04
     996:	ed 80       	ldd	r14, Y+5	; 0x05
     998:	fe 2c       	mov	r15, r14
     99a:	0e 2d       	mov	r16, r14
     99c:	1e 2d       	mov	r17, r14
     99e:	2a 2d       	mov	r18, r10
     9a0:	3b 2d       	mov	r19, r11
     9a2:	4c 2d       	mov	r20, r12
     9a4:	5d 2d       	mov	r21, r13
     9a6:	60 2f       	mov	r22, r16
     9a8:	70 2f       	mov	r23, r16
     9aa:	80 2f       	mov	r24, r16
     9ac:	9e 2d       	mov	r25, r14
     9ae:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     9b2:	2d 87       	std	Y+13, r18	; 0x0d
     9b4:	3e 87       	std	Y+14, r19	; 0x0e
     9b6:	4f 87       	std	Y+15, r20	; 0x0f
     9b8:	58 8b       	std	Y+16, r21	; 0x10
     9ba:	69 8b       	std	Y+17, r22	; 0x11
     9bc:	7a 8b       	std	Y+18, r23	; 0x12
     9be:	8b 8b       	std	Y+19, r24	; 0x13
     9c0:	9c 8b       	std	Y+20, r25	; 0x14
     9c2:	10 91 e1 04 	lds	r17, 0x04E1	; 0x8004e1 <dig_P6>
     9c6:	1a 8f       	std	Y+26, r17	; 0x1a
     9c8:	20 91 e2 04 	lds	r18, 0x04E2	; 0x8004e2 <dig_P6+0x1>
     9cc:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     9ce:	30 91 a8 04 	lds	r19, 0x04A8	; 0x8004a8 <dig_P5>
     9d2:	3b 8f       	std	Y+27, r19	; 0x1b
     9d4:	40 91 a9 04 	lds	r20, 0x04A9	; 0x8004a9 <dig_P5+0x1>
     9d8:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     9da:	50 91 88 04 	lds	r21, 0x0488	; 0x800488 <dig_P4>
     9de:	5c 8f       	std	Y+28, r21	; 0x1c
     9e0:	80 91 89 04 	lds	r24, 0x0489	; 0x800489 <dig_P4+0x1>
     9e4:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     9e6:	30 91 87 04 	lds	r19, 0x0487	; 0x800487 <dig_P2+0x1>
     9ea:	20 91 86 04 	lds	r18, 0x0486	; 0x800486 <dig_P2>
     9ee:	93 2f       	mov	r25, r19
     9f0:	99 0f       	add	r25, r25
     9f2:	99 0b       	sbc	r25, r25
     9f4:	fe 2c       	mov	r15, r14
     9f6:	0e 2d       	mov	r16, r14
     9f8:	1e 2d       	mov	r17, r14
     9fa:	49 2f       	mov	r20, r25
     9fc:	59 2f       	mov	r21, r25
     9fe:	69 2f       	mov	r22, r25
     a00:	79 2f       	mov	r23, r25
     a02:	89 2f       	mov	r24, r25
     a04:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     a08:	0c e0       	ldi	r16, 0x0C	; 12
     a0a:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     a0e:	42 2e       	mov	r4, r18
     a10:	53 2e       	mov	r5, r19
     a12:	64 2e       	mov	r6, r20
     a14:	75 2e       	mov	r7, r21
     a16:	86 2e       	mov	r8, r22
     a18:	97 2e       	mov	r9, r23
     a1a:	28 2e       	mov	r2, r24
     a1c:	39 2e       	mov	r3, r25
     a1e:	b0 90 d0 04 	lds	r11, 0x04D0	; 0x8004d0 <dig_P3+0x1>
     a22:	a0 90 cf 04 	lds	r10, 0x04CF	; 0x8004cf <dig_P3>
     a26:	1b 2d       	mov	r17, r11
     a28:	11 0f       	add	r17, r17
     a2a:	11 0b       	sbc	r17, r17
     a2c:	c1 2e       	mov	r12, r17
     a2e:	d1 2e       	mov	r13, r17
     a30:	e1 2e       	mov	r14, r17
     a32:	f1 2e       	mov	r15, r17
     a34:	01 2f       	mov	r16, r17
     a36:	2d 85       	ldd	r18, Y+13	; 0x0d
     a38:	3e 85       	ldd	r19, Y+14	; 0x0e
     a3a:	4f 85       	ldd	r20, Y+15	; 0x0f
     a3c:	58 89       	ldd	r21, Y+16	; 0x10
     a3e:	69 89       	ldd	r22, Y+17	; 0x11
     a40:	7a 89       	ldd	r23, Y+18	; 0x12
     a42:	8b 89       	ldd	r24, Y+19	; 0x13
     a44:	9c 89       	ldd	r25, Y+20	; 0x14
     a46:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     a4a:	08 e0       	ldi	r16, 0x08	; 8
     a4c:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     a50:	a4 2c       	mov	r10, r4
     a52:	b5 2c       	mov	r11, r5
     a54:	c6 2c       	mov	r12, r6
     a56:	d7 2c       	mov	r13, r7
     a58:	e8 2c       	mov	r14, r8
     a5a:	f9 2c       	mov	r15, r9
     a5c:	02 2d       	mov	r16, r2
     a5e:	13 2d       	mov	r17, r3
     a60:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     a64:	70 58       	subi	r23, 0x80	; 128
     a66:	8f 4f       	sbci	r24, 0xFF	; 255
     a68:	9f 4f       	sbci	r25, 0xFF	; 255
     a6a:	20 90 cd 04 	lds	r2, 0x04CD	; 0x8004cd <dig_P1>
     a6e:	30 90 ce 04 	lds	r3, 0x04CE	; 0x8004ce <dig_P1+0x1>
     a72:	a2 2c       	mov	r10, r2
     a74:	b3 2c       	mov	r11, r3
     a76:	c1 2c       	mov	r12, r1
     a78:	d1 2c       	mov	r13, r1
     a7a:	e1 2c       	mov	r14, r1
     a7c:	f1 2c       	mov	r15, r1
     a7e:	00 e0       	ldi	r16, 0x00	; 0
     a80:	10 e0       	ldi	r17, 0x00	; 0
     a82:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     a86:	01 e2       	ldi	r16, 0x21	; 33
     a88:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     a8c:	29 87       	std	Y+9, r18	; 0x09
     a8e:	3a 87       	std	Y+10, r19	; 0x0a
     a90:	4b 87       	std	Y+11, r20	; 0x0b
     a92:	45 2e       	mov	r4, r21
     a94:	56 2e       	mov	r5, r22
     a96:	7c 87       	std	Y+12, r23	; 0x0c
     a98:	38 2e       	mov	r3, r24
     a9a:	29 2e       	mov	r2, r25
	if (var1 == 0)
     a9c:	65 2d       	mov	r22, r5
     a9e:	83 2d       	mov	r24, r3
     aa0:	92 2d       	mov	r25, r2
     aa2:	a0 e0       	ldi	r26, 0x00	; 0
     aa4:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <__cmpdi2_s8>
     aa8:	09 f4       	brne	.+2      	; 0xaac <BME280_compensate_P_int64+0x18c>
     aaa:	88 c1       	rjmp	.+784    	; 0xdbc <BME280_compensate_P_int64+0x49c>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     aac:	aa 8c       	ldd	r10, Y+26	; 0x1a
     aae:	1e 8d       	ldd	r17, Y+30	; 0x1e
     ab0:	11 0f       	add	r17, r17
     ab2:	11 0b       	sbc	r17, r17
     ab4:	be 8c       	ldd	r11, Y+30	; 0x1e
     ab6:	c1 2e       	mov	r12, r17
     ab8:	d1 2e       	mov	r13, r17
     aba:	e1 2e       	mov	r14, r17
     abc:	f1 2e       	mov	r15, r17
     abe:	01 2f       	mov	r16, r17
     ac0:	2d 85       	ldd	r18, Y+13	; 0x0d
     ac2:	3e 85       	ldd	r19, Y+14	; 0x0e
     ac4:	4f 85       	ldd	r20, Y+15	; 0x0f
     ac6:	58 89       	ldd	r21, Y+16	; 0x10
     ac8:	69 89       	ldd	r22, Y+17	; 0x11
     aca:	7a 89       	ldd	r23, Y+18	; 0x12
     acc:	8b 89       	ldd	r24, Y+19	; 0x13
     ace:	9c 89       	ldd	r25, Y+20	; 0x14
     ad0:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     ad4:	2d 87       	std	Y+13, r18	; 0x0d
     ad6:	3e 87       	std	Y+14, r19	; 0x0e
     ad8:	64 2e       	mov	r6, r20
     ada:	75 2e       	mov	r7, r21
     adc:	86 2e       	mov	r8, r22
     ade:	97 2e       	mov	r9, r23
     ae0:	88 8b       	std	Y+16, r24	; 0x10
     ae2:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     ae4:	2b 8d       	ldd	r18, Y+27	; 0x1b
     ae6:	9d 8d       	ldd	r25, Y+29	; 0x1d
     ae8:	99 0f       	add	r25, r25
     aea:	99 0b       	sbc	r25, r25
     aec:	a9 80       	ldd	r10, Y+1	; 0x01
     aee:	ba 80       	ldd	r11, Y+2	; 0x02
     af0:	cb 80       	ldd	r12, Y+3	; 0x03
     af2:	dc 80       	ldd	r13, Y+4	; 0x04
     af4:	ed 80       	ldd	r14, Y+5	; 0x05
     af6:	fe 2c       	mov	r15, r14
     af8:	0e 2d       	mov	r16, r14
     afa:	1e 2d       	mov	r17, r14
     afc:	3d 8d       	ldd	r19, Y+29	; 0x1d
     afe:	49 2f       	mov	r20, r25
     b00:	59 2f       	mov	r21, r25
     b02:	69 2f       	mov	r22, r25
     b04:	79 2f       	mov	r23, r25
     b06:	89 2f       	mov	r24, r25
     b08:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     b0c:	01 e1       	ldi	r16, 0x11	; 17
     b0e:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     b12:	ad 84       	ldd	r10, Y+13	; 0x0d
     b14:	be 84       	ldd	r11, Y+14	; 0x0e
     b16:	c6 2c       	mov	r12, r6
     b18:	d7 2c       	mov	r13, r7
     b1a:	e8 2c       	mov	r14, r8
     b1c:	f9 2c       	mov	r15, r9
     b1e:	08 89       	ldd	r16, Y+16	; 0x10
     b20:	1f 85       	ldd	r17, Y+15	; 0x0f
     b22:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
     b26:	a2 2e       	mov	r10, r18
     b28:	b3 2e       	mov	r11, r19
     b2a:	c4 2e       	mov	r12, r20
     b2c:	d5 2e       	mov	r13, r21
     b2e:	e6 2e       	mov	r14, r22
     b30:	f7 2e       	mov	r15, r23
     b32:	e8 2f       	mov	r30, r24
     b34:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e1       	ldi	r26, 0x10	; 16
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	2e 89       	ldd	r18, Y+22	; 0x16
     b40:	3f 89       	ldd	r19, Y+23	; 0x17
     b42:	48 8d       	ldd	r20, Y+24	; 0x18
     b44:	59 8d       	ldd	r21, Y+25	; 0x19
     b46:	82 1b       	sub	r24, r18
     b48:	93 0b       	sbc	r25, r19
     b4a:	a4 0b       	sbc	r26, r20
     b4c:	b5 0b       	sbc	r27, r21
     b4e:	3c 01       	movw	r6, r24
     b50:	4d 01       	movw	r8, r26
     b52:	99 0c       	add	r9, r9
     b54:	66 08       	sbc	r6, r6
     b56:	76 2c       	mov	r7, r6
     b58:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     b5a:	28 2f       	mov	r18, r24
     b5c:	39 2f       	mov	r19, r25
     b5e:	4a 2f       	mov	r20, r26
     b60:	5b 2f       	mov	r21, r27
     b62:	66 2d       	mov	r22, r6
     b64:	76 2d       	mov	r23, r6
     b66:	86 2d       	mov	r24, r6
     b68:	96 2d       	mov	r25, r6
     b6a:	0f e1       	ldi	r16, 0x1F	; 31
     b6c:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     b70:	82 2e       	mov	r8, r18
     b72:	93 2e       	mov	r9, r19
     b74:	f4 2f       	mov	r31, r20
     b76:	75 2e       	mov	r7, r21
     b78:	b6 2f       	mov	r27, r22
     b7a:	a7 2f       	mov	r26, r23
     b7c:	68 2e       	mov	r6, r24
     b7e:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     b80:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b82:	9d 89       	ldd	r25, Y+21	; 0x15
     b84:	99 0f       	add	r25, r25
     b86:	99 0b       	sbc	r25, r25
     b88:	3d 89       	ldd	r19, Y+21	; 0x15
     b8a:	49 2f       	mov	r20, r25
     b8c:	59 2f       	mov	r21, r25
     b8e:	69 2f       	mov	r22, r25
     b90:	79 2f       	mov	r23, r25
     b92:	89 2f       	mov	r24, r25
     b94:	03 e2       	ldi	r16, 0x23	; 35
     b96:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     b9a:	0e 2f       	mov	r16, r30
     b9c:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
     ba0:	a2 2e       	mov	r10, r18
     ba2:	b3 2e       	mov	r11, r19
     ba4:	c4 2e       	mov	r12, r20
     ba6:	d5 2e       	mov	r13, r21
     ba8:	e6 2e       	mov	r14, r22
     baa:	f7 2e       	mov	r15, r23
     bac:	08 2f       	mov	r16, r24
     bae:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     bb0:	28 2d       	mov	r18, r8
     bb2:	39 2d       	mov	r19, r9
     bb4:	4f 2f       	mov	r20, r31
     bb6:	57 2d       	mov	r21, r7
     bb8:	6b 2f       	mov	r22, r27
     bba:	7a 2f       	mov	r23, r26
     bbc:	86 2d       	mov	r24, r6
     bbe:	9d 81       	ldd	r25, Y+5	; 0x05
     bc0:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     bc4:	82 2e       	mov	r8, r18
     bc6:	93 2e       	mov	r9, r19
     bc8:	49 83       	std	Y+1, r20	; 0x01
     bca:	65 2e       	mov	r6, r21
     bcc:	b6 2f       	mov	r27, r22
     bce:	a7 2f       	mov	r26, r23
     bd0:	f8 2f       	mov	r31, r24
     bd2:	e9 2f       	mov	r30, r25
     bd4:	03 e0       	ldi	r16, 0x03	; 3
     bd6:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     bda:	a8 2c       	mov	r10, r8
     bdc:	b9 2c       	mov	r11, r9
     bde:	c9 80       	ldd	r12, Y+1	; 0x01
     be0:	d6 2c       	mov	r13, r6
     be2:	eb 2e       	mov	r14, r27
     be4:	fa 2e       	mov	r15, r26
     be6:	0f 2f       	mov	r16, r31
     be8:	1e 2f       	mov	r17, r30
     bea:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     bee:	a2 2e       	mov	r10, r18
     bf0:	b3 2e       	mov	r11, r19
     bf2:	c4 2e       	mov	r12, r20
     bf4:	d5 2e       	mov	r13, r21
     bf6:	e6 2e       	mov	r14, r22
     bf8:	f7 2e       	mov	r15, r23
     bfa:	78 2e       	mov	r7, r24
     bfc:	19 2f       	mov	r17, r25
     bfe:	03 e0       	ldi	r16, 0x03	; 3
     c00:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     c04:	07 2d       	mov	r16, r7
     c06:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     c0a:	03 e0       	ldi	r16, 0x03	; 3
     c0c:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     c10:	a8 2c       	mov	r10, r8
     c12:	b9 2c       	mov	r11, r9
     c14:	c9 80       	ldd	r12, Y+1	; 0x01
     c16:	d6 2c       	mov	r13, r6
     c18:	eb 2e       	mov	r14, r27
     c1a:	fa 2e       	mov	r15, r26
     c1c:	0f 2f       	mov	r16, r31
     c1e:	1e 2f       	mov	r17, r30
     c20:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     c24:	02 e0       	ldi	r16, 0x02	; 2
     c26:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     c2a:	0f 2f       	mov	r16, r31
     c2c:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     c30:	01 e0       	ldi	r16, 0x01	; 1
     c32:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     c36:	0f 2f       	mov	r16, r31
     c38:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     c3c:	a9 84       	ldd	r10, Y+9	; 0x09
     c3e:	ba 84       	ldd	r11, Y+10	; 0x0a
     c40:	cb 84       	ldd	r12, Y+11	; 0x0b
     c42:	d4 2c       	mov	r13, r4
     c44:	e5 2c       	mov	r14, r5
     c46:	fc 84       	ldd	r15, Y+12	; 0x0c
     c48:	03 2d       	mov	r16, r3
     c4a:	12 2d       	mov	r17, r2
     c4c:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <__divdi3>
     c50:	2e 87       	std	Y+14, r18	; 0x0e
     c52:	3d 87       	std	Y+13, r19	; 0x0d
     c54:	49 83       	std	Y+1, r20	; 0x01
     c56:	5d 83       	std	Y+5, r21	; 0x05
     c58:	69 87       	std	Y+9, r22	; 0x09
     c5a:	7a 87       	std	Y+10, r23	; 0x0a
     c5c:	8b 87       	std	Y+11, r24	; 0x0b
     c5e:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     c60:	0d e0       	ldi	r16, 0x0D	; 13
     c62:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     c66:	82 2e       	mov	r8, r18
     c68:	93 2e       	mov	r9, r19
     c6a:	74 2e       	mov	r7, r20
     c6c:	65 2e       	mov	r6, r21
     c6e:	56 2e       	mov	r5, r22
     c70:	47 2e       	mov	r4, r23
     c72:	38 2e       	mov	r3, r24
     c74:	29 2e       	mov	r2, r25
     c76:	30 91 de 04 	lds	r19, 0x04DE	; 0x8004de <dig_P9+0x1>
     c7a:	20 91 dd 04 	lds	r18, 0x04DD	; 0x8004dd <dig_P9>
     c7e:	93 2f       	mov	r25, r19
     c80:	99 0f       	add	r25, r25
     c82:	99 0b       	sbc	r25, r25
     c84:	a8 2c       	mov	r10, r8
     c86:	b9 2c       	mov	r11, r9
     c88:	c7 2c       	mov	r12, r7
     c8a:	d6 2c       	mov	r13, r6
     c8c:	e5 2c       	mov	r14, r5
     c8e:	f4 2c       	mov	r15, r4
     c90:	03 2d       	mov	r16, r3
     c92:	12 2d       	mov	r17, r2
     c94:	49 2f       	mov	r20, r25
     c96:	59 2f       	mov	r21, r25
     c98:	69 2f       	mov	r22, r25
     c9a:	79 2f       	mov	r23, r25
     c9c:	89 2f       	mov	r24, r25
     c9e:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     ca2:	a2 2e       	mov	r10, r18
     ca4:	b3 2e       	mov	r11, r19
     ca6:	c4 2e       	mov	r12, r20
     ca8:	d5 2e       	mov	r13, r21
     caa:	e6 2e       	mov	r14, r22
     cac:	f7 2e       	mov	r15, r23
     cae:	08 2f       	mov	r16, r24
     cb0:	19 2f       	mov	r17, r25
     cb2:	28 2d       	mov	r18, r8
     cb4:	39 2d       	mov	r19, r9
     cb6:	47 2d       	mov	r20, r7
     cb8:	56 2d       	mov	r21, r6
     cba:	65 2d       	mov	r22, r5
     cbc:	74 2d       	mov	r23, r4
     cbe:	83 2d       	mov	r24, r3
     cc0:	92 2d       	mov	r25, r2
     cc2:	0e 94 66 0e 	call	0x1ccc	; 0x1ccc <__muldi3>
     cc6:	09 e1       	ldi	r16, 0x19	; 25
     cc8:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     ccc:	a2 2e       	mov	r10, r18
     cce:	b3 2e       	mov	r11, r19
     cd0:	c4 2e       	mov	r12, r20
     cd2:	d5 2e       	mov	r13, r21
     cd4:	e6 2e       	mov	r14, r22
     cd6:	f7 2e       	mov	r15, r23
     cd8:	08 2f       	mov	r16, r24
     cda:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     cdc:	2e 85       	ldd	r18, Y+14	; 0x0e
     cde:	3d 85       	ldd	r19, Y+13	; 0x0d
     ce0:	49 81       	ldd	r20, Y+1	; 0x01
     ce2:	5d 81       	ldd	r21, Y+5	; 0x05
     ce4:	69 85       	ldd	r22, Y+9	; 0x09
     ce6:	7a 85       	ldd	r23, Y+10	; 0x0a
     ce8:	8b 85       	ldd	r24, Y+11	; 0x0b
     cea:	9c 85       	ldd	r25, Y+12	; 0x0c
     cec:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
     cf0:	22 2e       	mov	r2, r18
     cf2:	33 2e       	mov	r3, r19
     cf4:	44 2e       	mov	r4, r20
     cf6:	55 2e       	mov	r5, r21
     cf8:	66 2e       	mov	r6, r22
     cfa:	77 2e       	mov	r7, r23
     cfc:	88 2e       	mov	r8, r24
     cfe:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
     d00:	30 91 d2 04 	lds	r19, 0x04D2	; 0x8004d2 <dig_P8+0x1>
     d04:	20 91 d1 04 	lds	r18, 0x04D1	; 0x8004d1 <dig_P8>
     d08:	93 2f       	mov	r25, r19
     d0a:	99 0f       	add	r25, r25
     d0c:	99 0b       	sbc	r25, r25
     d0e:	ae 84       	ldd	r10, Y+14	; 0x0e
     d10:	bd 84       	ldd	r11, Y+13	; 0x0d
     d12:	c9 80       	ldd	r12, Y+1	; 0x01
     d14:	dd 80       	ldd	r13, Y+5	; 0x05
     d16:	e9 84       	ldd	r14, Y+9	; 0x09
     d18:	fa 84       	ldd	r15, Y+10	; 0x0a
     d1a:	0b 85       	ldd	r16, Y+11	; 0x0b
     d1c:	1c 85       	ldd	r17, Y+12	; 0x0c
     d1e:	49 2f       	mov	r20, r25
     d20:	59 2f       	mov	r21, r25
     d22:	69 2f       	mov	r22, r25
     d24:	79 2f       	mov	r23, r25
     d26:	89 2f       	mov	r24, r25
     d28:	d1 d7       	rcall	.+4002   	; 0x1ccc <__muldi3>
     d2a:	03 e1       	ldi	r16, 0x13	; 19
     d2c:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     d30:	a2 2e       	mov	r10, r18
     d32:	b3 2e       	mov	r11, r19
     d34:	c4 2e       	mov	r12, r20
     d36:	d5 2e       	mov	r13, r21
     d38:	e6 2e       	mov	r14, r22
     d3a:	f7 2e       	mov	r15, r23
     d3c:	08 2f       	mov	r16, r24
     d3e:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     d40:	22 2d       	mov	r18, r2
     d42:	33 2d       	mov	r19, r3
     d44:	44 2d       	mov	r20, r4
     d46:	55 2d       	mov	r21, r5
     d48:	66 2d       	mov	r22, r6
     d4a:	77 2d       	mov	r23, r7
     d4c:	88 2d       	mov	r24, r8
     d4e:	99 2d       	mov	r25, r9
     d50:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
     d54:	08 e0       	ldi	r16, 0x08	; 8
     d56:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__ashrdi3>
     d5a:	40 90 11 04 	lds	r4, 0x0411	; 0x800411 <dig_P7>
     d5e:	50 90 12 04 	lds	r5, 0x0412	; 0x800412 <dig_P7+0x1>
     d62:	05 2c       	mov	r0, r5
     d64:	00 0c       	add	r0, r0
     d66:	66 08       	sbc	r6, r6
     d68:	77 08       	sbc	r7, r7
     d6a:	44 0c       	add	r4, r4
     d6c:	55 1c       	adc	r5, r5
     d6e:	66 1c       	adc	r6, r6
     d70:	77 1c       	adc	r7, r7
     d72:	44 0c       	add	r4, r4
     d74:	55 1c       	adc	r5, r5
     d76:	66 1c       	adc	r6, r6
     d78:	77 1c       	adc	r7, r7
     d7a:	44 0c       	add	r4, r4
     d7c:	55 1c       	adc	r5, r5
     d7e:	66 1c       	adc	r6, r6
     d80:	77 1c       	adc	r7, r7
     d82:	44 0c       	add	r4, r4
     d84:	55 1c       	adc	r5, r5
     d86:	66 1c       	adc	r6, r6
     d88:	77 1c       	adc	r7, r7
     d8a:	83 01       	movw	r16, r6
     d8c:	72 01       	movw	r14, r4
     d8e:	11 0f       	add	r17, r17
     d90:	ee 08       	sbc	r14, r14
     d92:	fe 2c       	mov	r15, r14
     d94:	87 01       	movw	r16, r14
     d96:	e9 82       	std	Y+1, r14	; 0x01
     d98:	fa 82       	std	Y+2, r15	; 0x02
     d9a:	0b 83       	std	Y+3, r16	; 0x03
     d9c:	1c 83       	std	Y+4, r17	; 0x04
     d9e:	a4 2c       	mov	r10, r4
     da0:	b5 2c       	mov	r11, r5
     da2:	c6 2c       	mov	r12, r6
     da4:	d7 2c       	mov	r13, r7
     da6:	e9 80       	ldd	r14, Y+1	; 0x01
     da8:	fe 2c       	mov	r15, r14
     daa:	0e 2d       	mov	r16, r14
     dac:	1e 2d       	mov	r17, r14
     dae:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <__adddi3>
	return(long)p;
     db2:	62 2f       	mov	r22, r18
     db4:	73 2f       	mov	r23, r19
     db6:	84 2f       	mov	r24, r20
     db8:	95 2f       	mov	r25, r21
     dba:	04 c0       	rjmp	.+8      	; 0xdc4 <BME280_compensate_P_int64+0x4a4>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
     dbc:	60 e0       	ldi	r22, 0x00	; 0
     dbe:	70 e0       	ldi	r23, 0x00	; 0
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
     dc4:	6e 96       	adiw	r28, 0x1e	; 30
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	de bf       	out	0x3e, r29	; 62
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	cd bf       	out	0x3d, r28	; 61
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	1f 91       	pop	r17
     dd6:	0f 91       	pop	r16
     dd8:	ff 90       	pop	r15
     dda:	ef 90       	pop	r14
     ddc:	df 90       	pop	r13
     dde:	cf 90       	pop	r12
     de0:	bf 90       	pop	r11
     de2:	af 90       	pop	r10
     de4:	9f 90       	pop	r9
     de6:	8f 90       	pop	r8
     de8:	7f 90       	pop	r7
     dea:	6f 90       	pop	r6
     dec:	5f 90       	pop	r5
     dee:	4f 90       	pop	r4
     df0:	3f 90       	pop	r3
     df2:	2f 90       	pop	r2
     df4:	08 95       	ret

00000df6 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
     df6:	2f 92       	push	r2
     df8:	3f 92       	push	r3
     dfa:	4f 92       	push	r4
     dfc:	5f 92       	push	r5
     dfe:	6f 92       	push	r6
     e00:	7f 92       	push	r7
     e02:	8f 92       	push	r8
     e04:	9f 92       	push	r9
     e06:	af 92       	push	r10
     e08:	bf 92       	push	r11
     e0a:	cf 92       	push	r12
     e0c:	df 92       	push	r13
     e0e:	ef 92       	push	r14
     e10:	ff 92       	push	r15
     e12:	0f 93       	push	r16
     e14:	1f 93       	push	r17
     e16:	cf 93       	push	r28
     e18:	df 93       	push	r29
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
     e1e:	67 97       	sbiw	r28, 0x17	; 23
     e20:	0f b6       	in	r0, 0x3f	; 63
     e22:	f8 94       	cli
     e24:	de bf       	out	0x3e, r29	; 62
     e26:	0f be       	out	0x3f, r0	; 63
     e28:	cd bf       	out	0x3d, r28	; 61
     e2a:	2b 01       	movw	r4, r22
     e2c:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
     e2e:	80 91 e5 04 	lds	r24, 0x04E5	; 0x8004e5 <t_fine>
     e32:	90 91 e6 04 	lds	r25, 0x04E6	; 0x8004e6 <t_fine+0x1>
     e36:	a0 91 e7 04 	lds	r26, 0x04E7	; 0x8004e7 <t_fine+0x2>
     e3a:	b0 91 e8 04 	lds	r27, 0x04E8	; 0x8004e8 <t_fine+0x3>
     e3e:	6c 01       	movw	r12, r24
     e40:	7d 01       	movw	r14, r26
     e42:	ff 0c       	add	r15, r15
     e44:	cc 08       	sbc	r12, r12
     e46:	dc 2c       	mov	r13, r12
     e48:	76 01       	movw	r14, r12
     e4a:	28 2f       	mov	r18, r24
     e4c:	39 2f       	mov	r19, r25
     e4e:	4a 2f       	mov	r20, r26
     e50:	5b 2f       	mov	r21, r27
     e52:	6c 2d       	mov	r22, r12
     e54:	7c 2d       	mov	r23, r12
     e56:	8c 2d       	mov	r24, r12
     e58:	9c 2d       	mov	r25, r12
     e5a:	3c 52       	subi	r19, 0x2C	; 44
     e5c:	41 40       	sbci	r20, 0x01	; 1
     e5e:	51 09       	sbc	r21, r1
     e60:	61 09       	sbc	r22, r1
     e62:	71 09       	sbc	r23, r1
     e64:	81 09       	sbc	r24, r1
     e66:	91 09       	sbc	r25, r1
     e68:	2f 8b       	std	Y+23, r18	; 0x17
     e6a:	3e 8b       	std	Y+22, r19	; 0x16
     e6c:	49 83       	std	Y+1, r20	; 0x01
     e6e:	59 87       	std	Y+9, r21	; 0x09
     e70:	6a 87       	std	Y+10, r22	; 0x0a
     e72:	7b 87       	std	Y+11, r23	; 0x0b
     e74:	8c 87       	std	Y+12, r24	; 0x0c
     e76:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
     e78:	03 2e       	mov	r0, r19
     e7a:	3e e0       	ldi	r19, 0x0E	; 14
     e7c:	44 0c       	add	r4, r4
     e7e:	55 1c       	adc	r5, r5
     e80:	66 1c       	adc	r6, r6
     e82:	77 1c       	adc	r7, r7
     e84:	3a 95       	dec	r19
     e86:	d1 f7       	brne	.-12     	; 0xe7c <bme280_compensate_H_int32+0x86>
     e88:	30 2d       	mov	r19, r0
     e8a:	53 01       	movw	r10, r6
     e8c:	42 01       	movw	r8, r4
     e8e:	bb 0c       	add	r11, r11
     e90:	88 08       	sbc	r8, r8
     e92:	98 2c       	mov	r9, r8
     e94:	54 01       	movw	r10, r8
     e96:	30 91 3e 04 	lds	r19, 0x043E	; 0x80043e <dig_H4+0x1>
     e9a:	20 91 3d 04 	lds	r18, 0x043D	; 0x80043d <dig_H4>
     e9e:	93 2f       	mov	r25, r19
     ea0:	99 0f       	add	r25, r25
     ea2:	99 0b       	sbc	r25, r25
     ea4:	49 2f       	mov	r20, r25
     ea6:	59 2f       	mov	r21, r25
     ea8:	69 2f       	mov	r22, r25
     eaa:	79 2f       	mov	r23, r25
     eac:	89 2f       	mov	r24, r25
     eae:	04 e1       	ldi	r16, 0x14	; 20
     eb0:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <__ashldi3>
     eb4:	f2 2f       	mov	r31, r18
     eb6:	e3 2f       	mov	r30, r19
     eb8:	c4 2e       	mov	r12, r20
     eba:	d5 2e       	mov	r13, r21
     ebc:	e6 2e       	mov	r14, r22
     ebe:	f7 2e       	mov	r15, r23
     ec0:	08 2f       	mov	r16, r24
     ec2:	19 2f       	mov	r17, r25
     ec4:	24 2d       	mov	r18, r4
     ec6:	35 2d       	mov	r19, r5
     ec8:	46 2d       	mov	r20, r6
     eca:	57 2d       	mov	r21, r7
     ecc:	68 2d       	mov	r22, r8
     ece:	78 2d       	mov	r23, r8
     ed0:	88 2d       	mov	r24, r8
     ed2:	98 2d       	mov	r25, r8
     ed4:	af 2e       	mov	r10, r31
     ed6:	be 2e       	mov	r11, r30
     ed8:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     edc:	22 2e       	mov	r2, r18
     ede:	33 2e       	mov	r3, r19
     ee0:	44 2e       	mov	r4, r20
     ee2:	55 2e       	mov	r5, r21
     ee4:	66 2e       	mov	r6, r22
     ee6:	77 2e       	mov	r7, r23
     ee8:	88 2e       	mov	r8, r24
     eea:	99 2e       	mov	r9, r25
     eec:	30 91 d5 04 	lds	r19, 0x04D5	; 0x8004d5 <dig_H5+0x1>
     ef0:	20 91 d4 04 	lds	r18, 0x04D4	; 0x8004d4 <dig_H5>
     ef4:	93 2f       	mov	r25, r19
     ef6:	99 0f       	add	r25, r25
     ef8:	99 0b       	sbc	r25, r25
     efa:	af 88       	ldd	r10, Y+23	; 0x17
     efc:	be 88       	ldd	r11, Y+22	; 0x16
     efe:	c9 80       	ldd	r12, Y+1	; 0x01
     f00:	d9 84       	ldd	r13, Y+9	; 0x09
     f02:	ea 84       	ldd	r14, Y+10	; 0x0a
     f04:	fb 84       	ldd	r15, Y+11	; 0x0b
     f06:	0c 85       	ldd	r16, Y+12	; 0x0c
     f08:	1d 85       	ldd	r17, Y+13	; 0x0d
     f0a:	49 2f       	mov	r20, r25
     f0c:	59 2f       	mov	r21, r25
     f0e:	69 2f       	mov	r22, r25
     f10:	79 2f       	mov	r23, r25
     f12:	89 2f       	mov	r24, r25
     f14:	db d6       	rcall	.+3510   	; 0x1ccc <__muldi3>
     f16:	a2 2e       	mov	r10, r18
     f18:	b3 2e       	mov	r11, r19
     f1a:	c4 2e       	mov	r12, r20
     f1c:	d5 2e       	mov	r13, r21
     f1e:	e6 2e       	mov	r14, r22
     f20:	f7 2e       	mov	r15, r23
     f22:	08 2f       	mov	r16, r24
     f24:	19 2f       	mov	r17, r25
     f26:	22 2d       	mov	r18, r2
     f28:	33 2d       	mov	r19, r3
     f2a:	44 2d       	mov	r20, r4
     f2c:	55 2d       	mov	r21, r5
     f2e:	66 2d       	mov	r22, r6
     f30:	77 2d       	mov	r23, r7
     f32:	88 2d       	mov	r24, r8
     f34:	99 2d       	mov	r25, r9
     f36:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <__subdi3>
     f3a:	30 5c       	subi	r19, 0xC0	; 192
     f3c:	4f 4f       	sbci	r20, 0xFF	; 255
     f3e:	5f 4f       	sbci	r21, 0xFF	; 255
     f40:	6f 4f       	sbci	r22, 0xFF	; 255
     f42:	7f 4f       	sbci	r23, 0xFF	; 255
     f44:	8f 4f       	sbci	r24, 0xFF	; 255
     f46:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     f48:	0f e0       	ldi	r16, 0x0F	; 15
     f4a:	fa d7       	rcall	.+4084   	; 0x1f40 <__ashrdi3>
     f4c:	2e 87       	std	Y+14, r18	; 0x0e
     f4e:	3f 87       	std	Y+15, r19	; 0x0f
     f50:	48 8b       	std	Y+16, r20	; 0x10
     f52:	59 8b       	std	Y+17, r21	; 0x11
     f54:	6a 8b       	std	Y+18, r22	; 0x12
     f56:	7b 8b       	std	Y+19, r23	; 0x13
     f58:	8c 8b       	std	Y+20, r24	; 0x14
     f5a:	9d 8b       	std	Y+21, r25	; 0x15
     f5c:	30 91 96 04 	lds	r19, 0x0496	; 0x800496 <dig_H6+0x1>
     f60:	20 91 95 04 	lds	r18, 0x0495	; 0x800495 <dig_H6>
     f64:	93 2f       	mov	r25, r19
     f66:	99 0f       	add	r25, r25
     f68:	99 0b       	sbc	r25, r25
     f6a:	af 88       	ldd	r10, Y+23	; 0x17
     f6c:	be 88       	ldd	r11, Y+22	; 0x16
     f6e:	c9 80       	ldd	r12, Y+1	; 0x01
     f70:	d9 84       	ldd	r13, Y+9	; 0x09
     f72:	ea 84       	ldd	r14, Y+10	; 0x0a
     f74:	fb 84       	ldd	r15, Y+11	; 0x0b
     f76:	0c 85       	ldd	r16, Y+12	; 0x0c
     f78:	1d 85       	ldd	r17, Y+13	; 0x0d
     f7a:	49 2f       	mov	r20, r25
     f7c:	59 2f       	mov	r21, r25
     f7e:	69 2f       	mov	r22, r25
     f80:	79 2f       	mov	r23, r25
     f82:	89 2f       	mov	r24, r25
     f84:	a3 d6       	rcall	.+3398   	; 0x1ccc <__muldi3>
     f86:	0a e0       	ldi	r16, 0x0A	; 10
     f88:	db d7       	rcall	.+4022   	; 0x1f40 <__ashrdi3>
     f8a:	82 2e       	mov	r8, r18
     f8c:	93 2e       	mov	r9, r19
     f8e:	74 2e       	mov	r7, r20
     f90:	65 2e       	mov	r6, r21
     f92:	56 2e       	mov	r5, r22
     f94:	47 2e       	mov	r4, r23
     f96:	38 2e       	mov	r3, r24
     f98:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     f9a:	40 91 d7 04 	lds	r20, 0x04D7	; 0x8004d7 <dig_H3>
     f9e:	50 91 d8 04 	lds	r21, 0x04D8	; 0x8004d8 <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     fa2:	0c 85       	ldd	r16, Y+12	; 0x0c
     fa4:	24 2f       	mov	r18, r20
     fa6:	35 2f       	mov	r19, r21
     fa8:	40 e0       	ldi	r20, 0x00	; 0
     faa:	50 e0       	ldi	r21, 0x00	; 0
     fac:	60 e0       	ldi	r22, 0x00	; 0
     fae:	70 e0       	ldi	r23, 0x00	; 0
     fb0:	80 e0       	ldi	r24, 0x00	; 0
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	8b d6       	rcall	.+3350   	; 0x1ccc <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     fb6:	0b e0       	ldi	r16, 0x0B	; 11
     fb8:	c3 d7       	rcall	.+3974   	; 0x1f40 <__ashrdi3>
     fba:	30 58       	subi	r19, 0x80	; 128
     fbc:	4f 4f       	sbci	r20, 0xFF	; 255
     fbe:	5f 4f       	sbci	r21, 0xFF	; 255
     fc0:	6f 4f       	sbci	r22, 0xFF	; 255
     fc2:	7f 4f       	sbci	r23, 0xFF	; 255
     fc4:	8f 4f       	sbci	r24, 0xFF	; 255
     fc6:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     fc8:	a2 2e       	mov	r10, r18
     fca:	b3 2e       	mov	r11, r19
     fcc:	c4 2e       	mov	r12, r20
     fce:	d5 2e       	mov	r13, r21
     fd0:	e6 2e       	mov	r14, r22
     fd2:	f7 2e       	mov	r15, r23
     fd4:	08 2f       	mov	r16, r24
     fd6:	19 2f       	mov	r17, r25
     fd8:	28 2d       	mov	r18, r8
     fda:	39 2d       	mov	r19, r9
     fdc:	47 2d       	mov	r20, r7
     fde:	56 2d       	mov	r21, r6
     fe0:	65 2d       	mov	r22, r5
     fe2:	74 2d       	mov	r23, r4
     fe4:	83 2d       	mov	r24, r3
     fe6:	92 2d       	mov	r25, r2
     fe8:	71 d6       	rcall	.+3298   	; 0x1ccc <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
     fea:	0a e0       	ldi	r16, 0x0A	; 10
     fec:	a9 d7       	rcall	.+3922   	; 0x1f40 <__ashrdi3>
     fee:	40 5e       	subi	r20, 0xE0	; 224
     ff0:	5f 4f       	sbci	r21, 0xFF	; 255
     ff2:	6f 4f       	sbci	r22, 0xFF	; 255
     ff4:	7f 4f       	sbci	r23, 0xFF	; 255
     ff6:	8f 4f       	sbci	r24, 0xFF	; 255
     ff8:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
     ffa:	b0 90 e4 04 	lds	r11, 0x04E4	; 0x8004e4 <dig_H2+0x1>
     ffe:	a0 90 e3 04 	lds	r10, 0x04E3	; 0x8004e3 <dig_H2>
    1002:	1b 2d       	mov	r17, r11
    1004:	11 0f       	add	r17, r17
    1006:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1008:	c1 2e       	mov	r12, r17
    100a:	d1 2e       	mov	r13, r17
    100c:	e1 2e       	mov	r14, r17
    100e:	f1 2e       	mov	r15, r17
    1010:	01 2f       	mov	r16, r17
    1012:	5c d6       	rcall	.+3256   	; 0x1ccc <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    1014:	30 5e       	subi	r19, 0xE0	; 224
    1016:	4f 4f       	sbci	r20, 0xFF	; 255
    1018:	5f 4f       	sbci	r21, 0xFF	; 255
    101a:	6f 4f       	sbci	r22, 0xFF	; 255
    101c:	7f 4f       	sbci	r23, 0xFF	; 255
    101e:	8f 4f       	sbci	r24, 0xFF	; 255
    1020:	9f 4f       	sbci	r25, 0xFF	; 255
    1022:	0e e0       	ldi	r16, 0x0E	; 14
    1024:	8d d7       	rcall	.+3866   	; 0x1f40 <__ashrdi3>
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1026:	a2 2e       	mov	r10, r18
    1028:	b3 2e       	mov	r11, r19
    102a:	c4 2e       	mov	r12, r20
    102c:	d5 2e       	mov	r13, r21
    102e:	e6 2e       	mov	r14, r22
    1030:	f7 2e       	mov	r15, r23
    1032:	08 2f       	mov	r16, r24
    1034:	19 2f       	mov	r17, r25
    1036:	2e 85       	ldd	r18, Y+14	; 0x0e
    1038:	3f 85       	ldd	r19, Y+15	; 0x0f
    103a:	48 89       	ldd	r20, Y+16	; 0x10
    103c:	59 89       	ldd	r21, Y+17	; 0x11
    103e:	6a 89       	ldd	r22, Y+18	; 0x12
    1040:	7b 89       	ldd	r23, Y+19	; 0x13
    1042:	8c 89       	ldd	r24, Y+20	; 0x14
    1044:	9d 89       	ldd	r25, Y+21	; 0x15
    1046:	42 d6       	rcall	.+3204   	; 0x1ccc <__muldi3>
    1048:	42 2e       	mov	r4, r18
    104a:	53 2e       	mov	r5, r19
    104c:	64 2e       	mov	r6, r20
    104e:	75 2e       	mov	r7, r21
    1050:	86 2e       	mov	r8, r22
    1052:	97 2e       	mov	r9, r23
    1054:	28 2e       	mov	r2, r24
    1056:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1058:	0f e0       	ldi	r16, 0x0F	; 15
    105a:	72 d7       	rcall	.+3812   	; 0x1f40 <__ashrdi3>
    105c:	a2 2e       	mov	r10, r18
    105e:	b3 2e       	mov	r11, r19
    1060:	c4 2e       	mov	r12, r20
    1062:	d5 2e       	mov	r13, r21
    1064:	e6 2e       	mov	r14, r22
    1066:	f7 2e       	mov	r15, r23
    1068:	08 2f       	mov	r16, r24
    106a:	19 2f       	mov	r17, r25
    106c:	2f d6       	rcall	.+3166   	; 0x1ccc <__muldi3>
    106e:	07 e0       	ldi	r16, 0x07	; 7
    1070:	67 d7       	rcall	.+3790   	; 0x1f40 <__ashrdi3>
    1072:	e0 91 6f 04 	lds	r30, 0x046F	; 0x80046f <dig_H1>
    1076:	f0 91 70 04 	lds	r31, 0x0470	; 0x800470 <dig_H1+0x1>
    107a:	5f 01       	movw	r10, r30
    107c:	c1 2c       	mov	r12, r1
    107e:	d1 2c       	mov	r13, r1
    1080:	e1 2c       	mov	r14, r1
    1082:	f1 2c       	mov	r15, r1
    1084:	87 01       	movw	r16, r14
    1086:	e9 83       	std	Y+1, r30	; 0x01
    1088:	ba 82       	std	Y+2, r11	; 0x02
    108a:	cb 82       	std	Y+3, r12	; 0x03
    108c:	dc 82       	std	Y+4, r13	; 0x04
    108e:	ed 82       	std	Y+5, r14	; 0x05
    1090:	fe 82       	std	Y+6, r15	; 0x06
    1092:	0f 83       	std	Y+7, r16	; 0x07
    1094:	18 87       	std	Y+8, r17	; 0x08
    1096:	c1 2c       	mov	r12, r1
    1098:	d1 2c       	mov	r13, r1
    109a:	e1 2c       	mov	r14, r1
    109c:	f1 2c       	mov	r15, r1
    109e:	00 e0       	ldi	r16, 0x00	; 0
    10a0:	10 e0       	ldi	r17, 0x00	; 0
    10a2:	14 d6       	rcall	.+3112   	; 0x1ccc <__muldi3>
    10a4:	04 e0       	ldi	r16, 0x04	; 4
    10a6:	4c d7       	rcall	.+3736   	; 0x1f40 <__ashrdi3>
    10a8:	a2 2e       	mov	r10, r18
    10aa:	b3 2e       	mov	r11, r19
    10ac:	c4 2e       	mov	r12, r20
    10ae:	d5 2e       	mov	r13, r21
    10b0:	e6 2e       	mov	r14, r22
    10b2:	f7 2e       	mov	r15, r23
    10b4:	08 2f       	mov	r16, r24
    10b6:	19 2f       	mov	r17, r25
    10b8:	24 2d       	mov	r18, r4
    10ba:	35 2d       	mov	r19, r5
    10bc:	46 2d       	mov	r20, r6
    10be:	57 2d       	mov	r21, r7
    10c0:	68 2d       	mov	r22, r8
    10c2:	79 2d       	mov	r23, r9
    10c4:	82 2d       	mov	r24, r2
    10c6:	93 2d       	mov	r25, r3
    10c8:	62 d7       	rcall	.+3780   	; 0x1f8e <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    10ca:	f2 2e       	mov	r15, r18
    10cc:	03 2f       	mov	r16, r19
    10ce:	14 2f       	mov	r17, r20
    10d0:	65 2e       	mov	r6, r21
    10d2:	76 2e       	mov	r7, r22
    10d4:	b7 2f       	mov	r27, r23
    10d6:	f8 2f       	mov	r31, r24
    10d8:	e9 2f       	mov	r30, r25
    10da:	a0 e0       	ldi	r26, 0x00	; 0
    10dc:	61 d7       	rcall	.+3778   	; 0x1fa0 <__cmpdi2_s8>
    10de:	44 f4       	brge	.+16     	; 0x10f0 <bme280_compensate_H_int32+0x2fa>
    10e0:	f1 2c       	mov	r15, r1
    10e2:	00 e0       	ldi	r16, 0x00	; 0
    10e4:	10 e0       	ldi	r17, 0x00	; 0
    10e6:	61 2c       	mov	r6, r1
    10e8:	71 2c       	mov	r7, r1
    10ea:	b0 e0       	ldi	r27, 0x00	; 0
    10ec:	f0 e0       	ldi	r31, 0x00	; 0
    10ee:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    10f0:	8f 2c       	mov	r8, r15
    10f2:	90 2e       	mov	r9, r16
    10f4:	a1 2e       	mov	r10, r17
    10f6:	b6 2c       	mov	r11, r6
    10f8:	c7 2c       	mov	r12, r7
    10fa:	db 2e       	mov	r13, r27
    10fc:	ef 2e       	mov	r14, r31
    10fe:	ae 2f       	mov	r26, r30
    1100:	2f 2d       	mov	r18, r15
    1102:	30 2f       	mov	r19, r16
    1104:	41 2f       	mov	r20, r17
    1106:	56 2d       	mov	r21, r6
    1108:	67 2d       	mov	r22, r7
    110a:	7b 2f       	mov	r23, r27
    110c:	8f 2f       	mov	r24, r31
    110e:	9e 2f       	mov	r25, r30
    1110:	21 15       	cp	r18, r1
    1112:	31 05       	cpc	r19, r1
    1114:	41 05       	cpc	r20, r1
    1116:	59 41       	sbci	r21, 0x19	; 25
    1118:	61 05       	cpc	r22, r1
    111a:	71 05       	cpc	r23, r1
    111c:	81 05       	cpc	r24, r1
    111e:	91 05       	cpc	r25, r1
    1120:	61 f0       	breq	.+24     	; 0x113a <bme280_compensate_H_int32+0x344>
    1122:	5c f0       	brlt	.+22     	; 0x113a <bme280_compensate_H_int32+0x344>
    1124:	81 2c       	mov	r8, r1
    1126:	91 2c       	mov	r9, r1
    1128:	a1 2c       	mov	r10, r1
    112a:	0f 2e       	mov	r0, r31
    112c:	f9 e1       	ldi	r31, 0x19	; 25
    112e:	bf 2e       	mov	r11, r31
    1130:	f0 2d       	mov	r31, r0
    1132:	c1 2c       	mov	r12, r1
    1134:	d1 2c       	mov	r13, r1
    1136:	e1 2c       	mov	r14, r1
    1138:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    113a:	28 2d       	mov	r18, r8
    113c:	39 2d       	mov	r19, r9
    113e:	4a 2d       	mov	r20, r10
    1140:	5b 2d       	mov	r21, r11
    1142:	6c 2d       	mov	r22, r12
    1144:	7d 2d       	mov	r23, r13
    1146:	8e 2d       	mov	r24, r14
    1148:	9a 2f       	mov	r25, r26
    114a:	0c e0       	ldi	r16, 0x0C	; 12
    114c:	f9 d6       	rcall	.+3570   	; 0x1f40 <__ashrdi3>
    114e:	62 2f       	mov	r22, r18
    1150:	73 2f       	mov	r23, r19
    1152:	84 2f       	mov	r24, r20
    1154:	95 2f       	mov	r25, r21
}
    1156:	67 96       	adiw	r28, 0x17	; 23
    1158:	0f b6       	in	r0, 0x3f	; 63
    115a:	f8 94       	cli
    115c:	de bf       	out	0x3e, r29	; 62
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	cd bf       	out	0x3d, r28	; 61
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	ff 90       	pop	r15
    116c:	ef 90       	pop	r14
    116e:	df 90       	pop	r13
    1170:	cf 90       	pop	r12
    1172:	bf 90       	pop	r11
    1174:	af 90       	pop	r10
    1176:	9f 90       	pop	r9
    1178:	8f 90       	pop	r8
    117a:	7f 90       	pop	r7
    117c:	6f 90       	pop	r6
    117e:	5f 90       	pop	r5
    1180:	4f 90       	pop	r4
    1182:	3f 90       	pop	r3
    1184:	2f 90       	pop	r2
    1186:	08 95       	ret

00001188 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
    1188:	87 e0       	ldi	r24, 0x07	; 7
    118a:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
    118c:	85 b1       	in	r24, 0x05	; 5
    118e:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
    1190:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
    1192:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
    1194:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
    1196:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
    1198:	41 9a       	sbi	0x08, 1	; 8
    119a:	08 95       	ret

0000119c <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
    11a0:	2f ef       	ldi	r18, 0xFF	; 255
    11a2:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
    11a4:	fc 01       	movw	r30, r24
    11a6:	ee 0f       	add	r30, r30
    11a8:	ff 1f       	adc	r31, r31
    11aa:	ee 0f       	add	r30, r30
    11ac:	ff 1f       	adc	r31, r31
    11ae:	ea 5d       	subi	r30, 0xDA	; 218
    11b0:	fb 4f       	sbci	r31, 0xFB	; 251
    11b2:	11 82       	std	Z+1, r1	; 0x01
    11b4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
    11b6:	33 83       	std	Z+3, r19	; 0x03
    11b8:	22 83       	std	Z+2, r18	; 0x02
    11ba:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
    11bc:	85 30       	cpi	r24, 0x05	; 5
    11be:	91 05       	cpc	r25, r1
    11c0:	89 f7       	brne	.-30     	; 0x11a4 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
    11c2:	08 95       	ret

000011c4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
    11c4:	ef 92       	push	r14
    11c6:	ff 92       	push	r15
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
    11d0:	0f 2e       	mov	r0, r31
    11d2:	fc ef       	ldi	r31, 0xFC	; 252
    11d4:	ef 2e       	mov	r14, r31
    11d6:	f3 e0       	ldi	r31, 0x03	; 3
    11d8:	ff 2e       	mov	r15, r31
    11da:	f0 2d       	mov	r31, r0
    11dc:	00 e0       	ldi	r16, 0x00	; 0
    11de:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
    11e0:	c7 01       	movw	r24, r14
    11e2:	0e 94 98 12 	call	0x2530	; 0x2530 <eeprom_read_word>
    11e6:	e8 01       	movw	r28, r16
    11e8:	cc 0f       	add	r28, r28
    11ea:	dd 1f       	adc	r29, r29
    11ec:	cc 0f       	add	r28, r28
    11ee:	dd 1f       	adc	r29, r29
    11f0:	ca 5d       	subi	r28, 0xDA	; 218
    11f2:	db 4f       	sbci	r29, 0xFB	; 251
    11f4:	99 83       	std	Y+1, r25	; 0x01
    11f6:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
    11f8:	c7 01       	movw	r24, r14
    11fa:	02 96       	adiw	r24, 0x02	; 2
    11fc:	0e 94 98 12 	call	0x2530	; 0x2530 <eeprom_read_word>
    1200:	9b 83       	std	Y+3, r25	; 0x03
    1202:	8a 83       	std	Y+2, r24	; 0x02
    1204:	0f 5f       	subi	r16, 0xFF	; 255
    1206:	1f 4f       	sbci	r17, 0xFF	; 255
    1208:	84 e0       	ldi	r24, 0x04	; 4
    120a:	e8 0e       	add	r14, r24
    120c:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
    120e:	05 30       	cpi	r16, 0x05	; 5
    1210:	11 05       	cpc	r17, r1
    1212:	31 f7       	brne	.-52     	; 0x11e0 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
    1214:	df 91       	pop	r29
    1216:	cf 91       	pop	r28
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	ff 90       	pop	r15
    121e:	ef 90       	pop	r14
    1220:	08 95       	ret

00001222 <gas_sensors_init>:

void gas_sensors_init(void)
{
    1222:	af 92       	push	r10
    1224:	bf 92       	push	r11
    1226:	cf 92       	push	r12
    1228:	df 92       	push	r13
    122a:	ef 92       	push	r14
    122c:	ff 92       	push	r15
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	cf 93       	push	r28
    1234:	df 93       	push	r29
    1236:	1f 92       	push	r1
    1238:	cd b7       	in	r28, 0x3d	; 61
    123a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
    123c:	10 92 cc 04 	sts	0x04CC, r1	; 0x8004cc <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
    1240:	10 92 9b 04 	sts	0x049B, r1	; 0x80049b <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
    1244:	bf df       	rcall	.-130    	; 0x11c4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
    1246:	aa df       	rcall	.-172    	; 0x119c <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    1248:	ea e7       	ldi	r30, 0x7A	; 122
    124a:	f0 e0       	ldi	r31, 0x00	; 0
    124c:	80 81       	ld	r24, Z
    124e:	80 68       	ori	r24, 0x80	; 128
    1250:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1252:	19 82       	std	Y+1, r1	; 0x01
    1254:	89 81       	ldd	r24, Y+1	; 0x01
    1256:	85 30       	cpi	r24, 0x05	; 5
    1258:	08 f0       	brcs	.+2      	; 0x125c <gas_sensors_init+0x3a>
    125a:	52 c0       	rjmp	.+164    	; 0x1300 <gas_sensors_init+0xde>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
    125c:	0a e7       	ldi	r16, 0x7A	; 122
    125e:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    1260:	0f 2e       	mov	r0, r31
    1262:	f8 e7       	ldi	r31, 0x78	; 120
    1264:	ef 2e       	mov	r14, r31
    1266:	f1 2c       	mov	r15, r1
    1268:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    126a:	bb 24       	eor	r11, r11
    126c:	b3 94       	inc	r11
    126e:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    1270:	cc 24       	eor	r12, r12
    1272:	c3 94       	inc	r12
    1274:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    1276:	89 81       	ldd	r24, Y+1	; 0x01
    1278:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
    127c:	f8 01       	movw	r30, r16
    127e:	80 81       	ld	r24, Z
    1280:	80 64       	ori	r24, 0x40	; 64
    1282:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
    1284:	f8 01       	movw	r30, r16
    1286:	80 81       	ld	r24, Z
    1288:	84 ff       	sbrs	r24, 4
    128a:	fc cf       	rjmp	.-8      	; 0x1284 <gas_sensors_init+0x62>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    128c:	f7 01       	movw	r30, r14
    128e:	80 81       	ld	r24, Z
    1290:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    1292:	e9 81       	ldd	r30, Y+1	; 0x01
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	ee 0f       	add	r30, r30
    1298:	ff 1f       	adc	r31, r31
    129a:	ee 0f       	add	r30, r30
    129c:	ff 1f       	adc	r31, r31
    129e:	ea 5d       	subi	r30, 0xDA	; 218
    12a0:	fb 4f       	sbci	r31, 0xFB	; 251
    12a2:	20 81       	ld	r18, Z
    12a4:	31 81       	ldd	r19, Z+1	; 0x01
    12a6:	e9 81       	ldd	r30, Y+1	; 0x01
    12a8:	f0 e0       	ldi	r31, 0x00	; 0
    12aa:	ee 0f       	add	r30, r30
    12ac:	ff 1f       	adc	r31, r31
    12ae:	ee 0f       	add	r30, r30
    12b0:	ff 1f       	adc	r31, r31
    12b2:	ea 5d       	subi	r30, 0xDA	; 218
    12b4:	fb 4f       	sbci	r31, 0xFB	; 251
    12b6:	62 81       	ldd	r22, Z+2	; 0x02
    12b8:	73 81       	ldd	r23, Z+3	; 0x03
    12ba:	4b 2d       	mov	r20, r11
    12bc:	68 17       	cp	r22, r24
    12be:	79 07       	cpc	r23, r25
    12c0:	08 f0       	brcs	.+2      	; 0x12c4 <gas_sensors_init+0xa2>
    12c2:	4a 2d       	mov	r20, r10
    12c4:	41 11       	cpse	r20, r1
    12c6:	07 c0       	rjmp	.+14     	; 0x12d6 <gas_sensors_init+0xb4>
    12c8:	4b 2d       	mov	r20, r11
    12ca:	82 17       	cp	r24, r18
    12cc:	93 07       	cpc	r25, r19
    12ce:	08 f0       	brcs	.+2      	; 0x12d2 <gas_sensors_init+0xb0>
    12d0:	4a 2d       	mov	r20, r10
    12d2:	44 23       	and	r20, r20
    12d4:	71 f0       	breq	.+28     	; 0x12f2 <gas_sensors_init+0xd0>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    12d6:	99 81       	ldd	r25, Y+1	; 0x01
    12d8:	20 91 cc 04 	lds	r18, 0x04CC	; 0x8004cc <gas_sensor_initialization_errors>
    12dc:	9d 5f       	subi	r25, 0xFD	; 253
    12de:	a6 01       	movw	r20, r12
    12e0:	02 c0       	rjmp	.+4      	; 0x12e6 <gas_sensors_init+0xc4>
    12e2:	44 0f       	add	r20, r20
    12e4:	55 1f       	adc	r21, r21
    12e6:	9a 95       	dec	r25
    12e8:	e2 f7       	brpl	.-8      	; 0x12e2 <gas_sensors_init+0xc0>
    12ea:	ca 01       	movw	r24, r20
    12ec:	82 2b       	or	r24, r18
    12ee:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    12f2:	89 81       	ldd	r24, Y+1	; 0x01
    12f4:	8f 5f       	subi	r24, 0xFF	; 255
    12f6:	89 83       	std	Y+1, r24	; 0x01
    12f8:	89 81       	ldd	r24, Y+1	; 0x01
    12fa:	85 30       	cpi	r24, 0x05	; 5
    12fc:	08 f4       	brcc	.+2      	; 0x1300 <gas_sensors_init+0xde>
    12fe:	bb cf       	rjmp	.-138    	; 0x1276 <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
    1300:	ea e7       	ldi	r30, 0x7A	; 122
    1302:	f0 e0       	ldi	r31, 0x00	; 0
    1304:	80 81       	ld	r24, Z
    1306:	8f 77       	andi	r24, 0x7F	; 127
    1308:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
    130a:	0f 90       	pop	r0
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10
    1320:	08 95       	ret

00001322 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
    1322:	8f 92       	push	r8
    1324:	9f 92       	push	r9
    1326:	af 92       	push	r10
    1328:	bf 92       	push	r11
    132a:	cf 92       	push	r12
    132c:	df 92       	push	r13
    132e:	ef 92       	push	r14
    1330:	ff 92       	push	r15
    1332:	0f 93       	push	r16
    1334:	1f 93       	push	r17
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	00 d0       	rcall	.+0      	; 0x133c <start_gas_sensor_read+0x1a>
    133c:	1f 92       	push	r1
    133e:	cd b7       	in	r28, 0x3d	; 61
    1340:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    1342:	ea e7       	ldi	r30, 0x7A	; 122
    1344:	f0 e0       	ldi	r31, 0x00	; 0
    1346:	80 81       	ld	r24, Z
    1348:	80 68       	ori	r24, 0x80	; 128
    134a:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    134c:	19 82       	std	Y+1, r1	; 0x01
    134e:	89 81       	ldd	r24, Y+1	; 0x01
    1350:	85 30       	cpi	r24, 0x05	; 5
    1352:	08 f0       	brcs	.+2      	; 0x1356 <start_gas_sensor_read+0x34>
    1354:	77 c0       	rjmp	.+238    	; 0x1444 <start_gas_sensor_read+0x122>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
    1356:	68 94       	set
    1358:	88 24       	eor	r8, r8
    135a:	82 f8       	bld	r8, 2
    135c:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    135e:	0a e7       	ldi	r16, 0x7A	; 122
    1360:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    1362:	0f 2e       	mov	r0, r31
    1364:	f8 e7       	ldi	r31, 0x78	; 120
    1366:	ef 2e       	mov	r14, r31
    1368:	f1 2c       	mov	r15, r1
    136a:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    136c:	cc 24       	eor	r12, r12
    136e:	c3 94       	inc	r12
    1370:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    1372:	bb 24       	eor	r11, r11
    1374:	b3 94       	inc	r11
    1376:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    1378:	89 81       	ldd	r24, Y+1	; 0x01
    137a:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
		total = 0;	// re-zero the average
    137e:	1b 82       	std	Y+3, r1	; 0x03
    1380:	1a 82       	std	Y+2, r1	; 0x02
    1382:	28 2d       	mov	r18, r8
    1384:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    1386:	f8 01       	movw	r30, r16
    1388:	80 81       	ld	r24, Z
    138a:	80 64       	ori	r24, 0x40	; 64
    138c:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
    138e:	f8 01       	movw	r30, r16
    1390:	80 81       	ld	r24, Z
    1392:	84 ff       	sbrs	r24, 4
    1394:	fc cf       	rjmp	.-8      	; 0x138e <start_gas_sensor_read+0x6c>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    1396:	f7 01       	movw	r30, r14
    1398:	80 81       	ld	r24, Z
    139a:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    139c:	e9 81       	ldd	r30, Y+1	; 0x01
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	ee 0f       	add	r30, r30
    13a2:	ff 1f       	adc	r31, r31
    13a4:	ee 0f       	add	r30, r30
    13a6:	ff 1f       	adc	r31, r31
    13a8:	ea 5d       	subi	r30, 0xDA	; 218
    13aa:	fb 4f       	sbci	r31, 0xFB	; 251
    13ac:	40 81       	ld	r20, Z
    13ae:	51 81       	ldd	r21, Z+1	; 0x01
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
    13b4:	ee 0f       	add	r30, r30
    13b6:	ff 1f       	adc	r31, r31
    13b8:	ee 0f       	add	r30, r30
    13ba:	ff 1f       	adc	r31, r31
    13bc:	ea 5d       	subi	r30, 0xDA	; 218
    13be:	fb 4f       	sbci	r31, 0xFB	; 251
    13c0:	62 81       	ldd	r22, Z+2	; 0x02
    13c2:	73 81       	ldd	r23, Z+3	; 0x03
    13c4:	eb 2d       	mov	r30, r11
    13c6:	68 17       	cp	r22, r24
    13c8:	79 07       	cpc	r23, r25
    13ca:	08 f0       	brcs	.+2      	; 0x13ce <start_gas_sensor_read+0xac>
    13cc:	ea 2d       	mov	r30, r10
    13ce:	e1 11       	cpse	r30, r1
    13d0:	07 c0       	rjmp	.+14     	; 0x13e0 <start_gas_sensor_read+0xbe>
    13d2:	6b 2d       	mov	r22, r11
    13d4:	84 17       	cp	r24, r20
    13d6:	95 07       	cpc	r25, r21
    13d8:	08 f0       	brcs	.+2      	; 0x13dc <start_gas_sensor_read+0xba>
    13da:	6a 2d       	mov	r22, r10
    13dc:	66 23       	and	r22, r22
    13de:	71 f0       	breq	.+28     	; 0x13fc <start_gas_sensor_read+0xda>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    13e0:	59 81       	ldd	r21, Y+1	; 0x01
    13e2:	60 91 cc 04 	lds	r22, 0x04CC	; 0x8004cc <gas_sensor_initialization_errors>
    13e6:	5d 5f       	subi	r21, 0xFD	; 253
    13e8:	f6 01       	movw	r30, r12
    13ea:	02 c0       	rjmp	.+4      	; 0x13f0 <start_gas_sensor_read+0xce>
    13ec:	ee 0f       	add	r30, r30
    13ee:	ff 1f       	adc	r31, r31
    13f0:	5a 95       	dec	r21
    13f2:	e2 f7       	brpl	.-8      	; 0x13ec <start_gas_sensor_read+0xca>
    13f4:	af 01       	movw	r20, r30
    13f6:	46 2b       	or	r20, r22
    13f8:	40 93 cc 04 	sts	0x04CC, r20	; 0x8004cc <gas_sensor_initialization_errors>
			}
			total += ADC_result;
    13fc:	4a 81       	ldd	r20, Y+2	; 0x02
    13fe:	5b 81       	ldd	r21, Y+3	; 0x03
    1400:	84 0f       	add	r24, r20
    1402:	95 1f       	adc	r25, r21
    1404:	9b 83       	std	Y+3, r25	; 0x03
    1406:	8a 83       	std	Y+2, r24	; 0x02
    1408:	21 50       	subi	r18, 0x01	; 1
    140a:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
    140c:	09 f0       	breq	.+2      	; 0x1410 <start_gas_sensor_read+0xee>
    140e:	bb cf       	rjmp	.-138    	; 0x1386 <start_gas_sensor_read+0x64>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
    1410:	8a 81       	ldd	r24, Y+2	; 0x02
    1412:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
    1414:	e9 81       	ldd	r30, Y+1	; 0x01
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	ee 0f       	add	r30, r30
    141a:	ff 1f       	adc	r31, r31
    141c:	e4 56       	subi	r30, 0x64	; 100
    141e:	fb 4f       	sbci	r31, 0xFB	; 251
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
    1420:	9c 01       	movw	r18, r24
    1422:	99 23       	and	r25, r25
    1424:	14 f4       	brge	.+4      	; 0x142a <start_gas_sensor_read+0x108>
    1426:	2d 5f       	subi	r18, 0xFD	; 253
    1428:	3f 4f       	sbci	r19, 0xFF	; 255
    142a:	35 95       	asr	r19
    142c:	27 95       	ror	r18
    142e:	35 95       	asr	r19
    1430:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
    1432:	31 83       	std	Z+1, r19	; 0x01
    1434:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1436:	89 81       	ldd	r24, Y+1	; 0x01
    1438:	8f 5f       	subi	r24, 0xFF	; 255
    143a:	89 83       	std	Y+1, r24	; 0x01
    143c:	89 81       	ldd	r24, Y+1	; 0x01
    143e:	85 30       	cpi	r24, 0x05	; 5
    1440:	08 f4       	brcc	.+2      	; 0x1444 <start_gas_sensor_read+0x122>
    1442:	9a cf       	rjmp	.-204    	; 0x1378 <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
    1444:	0f 90       	pop	r0
    1446:	0f 90       	pop	r0
    1448:	0f 90       	pop	r0
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	ff 90       	pop	r15
    1454:	ef 90       	pop	r14
    1456:	df 90       	pop	r13
    1458:	cf 90       	pop	r12
    145a:	bf 90       	pop	r11
    145c:	af 90       	pop	r10
    145e:	9f 90       	pop	r9
    1460:	8f 90       	pop	r8
    1462:	08 95       	ret

00001464 <binary_search>:

void binary_search(int array[], int top, int bottom, int number) //return value directly above & below number
{
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
	if ((number > array[top]) | (number < array[bottom]))
    1468:	fb 01       	movw	r30, r22
    146a:	ee 0f       	add	r30, r30
    146c:	ff 1f       	adc	r31, r31
    146e:	e8 0f       	add	r30, r24
    1470:	f9 1f       	adc	r31, r25
    1472:	a1 e0       	ldi	r26, 0x01	; 1
    1474:	01 90       	ld	r0, Z+
    1476:	f0 81       	ld	r31, Z
    1478:	e0 2d       	mov	r30, r0
    147a:	e2 17       	cp	r30, r18
    147c:	f3 07       	cpc	r31, r19
    147e:	0c f0       	brlt	.+2      	; 0x1482 <binary_search+0x1e>
    1480:	a0 e0       	ldi	r26, 0x00	; 0
    1482:	a1 11       	cpse	r26, r1
    1484:	0f c0       	rjmp	.+30     	; 0x14a4 <binary_search+0x40>
    1486:	fa 01       	movw	r30, r20
    1488:	ee 0f       	add	r30, r30
    148a:	ff 1f       	adc	r31, r31
    148c:	e8 0f       	add	r30, r24
    148e:	f9 1f       	adc	r31, r25
    1490:	a1 e0       	ldi	r26, 0x01	; 1
    1492:	01 90       	ld	r0, Z+
    1494:	f0 81       	ld	r31, Z
    1496:	e0 2d       	mov	r30, r0
    1498:	2e 17       	cp	r18, r30
    149a:	3f 07       	cpc	r19, r31
    149c:	0c f0       	brlt	.+2      	; 0x14a0 <binary_search+0x3c>
    149e:	a0 e0       	ldi	r26, 0x00	; 0
    14a0:	aa 23       	and	r26, r26
    14a2:	71 f1       	breq	.+92     	; 0x1500 <binary_search+0x9c>
	{
		int mid = bottom + (top - bottom)/2;
    14a4:	db 01       	movw	r26, r22
    14a6:	a4 1b       	sub	r26, r20
    14a8:	b5 0b       	sbc	r27, r21
    14aa:	fd 01       	movw	r30, r26
    14ac:	0a f4       	brpl	.+2      	; 0x14b0 <binary_search+0x4c>
    14ae:	31 96       	adiw	r30, 0x01	; 1
    14b0:	f5 95       	asr	r31
    14b2:	e7 95       	ror	r30
    14b4:	e4 0f       	add	r30, r20
    14b6:	f5 1f       	adc	r31, r21
		
		// If the element is closest to the middle
		if (number >= array[mid] && number <= array [mid + 1])
    14b8:	df 01       	movw	r26, r30
    14ba:	aa 0f       	add	r26, r26
    14bc:	bb 1f       	adc	r27, r27
    14be:	ec 01       	movw	r28, r24
    14c0:	ca 0f       	add	r28, r26
    14c2:	db 1f       	adc	r29, r27
    14c4:	09 90       	ld	r0, Y+
    14c6:	d8 81       	ld	r29, Y
    14c8:	c0 2d       	mov	r28, r0
    14ca:	2c 17       	cp	r18, r28
    14cc:	3d 07       	cpc	r19, r29
    14ce:	8c f0       	brlt	.+34     	; 0x14f2 <binary_search+0x8e>
    14d0:	a8 0f       	add	r26, r24
    14d2:	b9 1f       	adc	r27, r25
    14d4:	12 96       	adiw	r26, 0x02	; 2
    14d6:	4d 91       	ld	r20, X+
    14d8:	5c 91       	ld	r21, X
    14da:	13 97       	sbiw	r26, 0x03	; 3
    14dc:	42 17       	cp	r20, r18
    14de:	53 07       	cpc	r21, r19
    14e0:	5c f0       	brlt	.+22     	; 0x14f8 <binary_search+0x94>
		{
			valueOfIndex = mid + 1;
    14e2:	af 01       	movw	r20, r30
    14e4:	4f 5f       	subi	r20, 0xFF	; 255
    14e6:	5f 4f       	sbci	r21, 0xFF	; 255
    14e8:	50 93 fa 04 	sts	0x04FA, r21	; 0x8004fa <valueOfIndex+0x1>
    14ec:	40 93 f9 04 	sts	0x04F9, r20	; 0x8004f9 <valueOfIndex>
    14f0:	03 c0       	rjmp	.+6      	; 0x14f8 <binary_search+0x94>
		}
		
		// If element is smaller than mid, then
		// it can only be present in left subarray
		else if (number < array[mid])
		return binary_search(array, mid, bottom, number);
    14f2:	bf 01       	movw	r22, r30
    14f4:	b7 df       	rcall	.-146    	; 0x1464 <binary_search>
    14f6:	04 c0       	rjmp	.+8      	; 0x1500 <binary_search+0x9c>
		
		// Else the element can only be present
		// in right subarray
		return binary_search(array, top, mid+1, number);
    14f8:	af 01       	movw	r20, r30
    14fa:	4f 5f       	subi	r20, 0xFF	; 255
    14fc:	5f 4f       	sbci	r21, 0xFF	; 255
    14fe:	b2 df       	rcall	.-156    	; 0x1464 <binary_search>
	}
	
	// We reach here when element is not
	// present in array
	//printf('value not in array');
}
    1500:	df 91       	pop	r29
    1502:	cf 91       	pop	r28
    1504:	08 95       	ret

00001506 <convert_to_ppm>:

uint16_t convert_to_ppm(uint8_t sensor_id)
{
    1506:	cf 93       	push	r28
    1508:	df 93       	push	r29
    150a:	cd b7       	in	r28, 0x3d	; 61
    150c:	de b7       	in	r29, 0x3e	; 62
    150e:	da 95       	dec	r29
    1510:	0f b6       	in	r0, 0x3f	; 63
    1512:	f8 94       	cli
    1514:	de bf       	out	0x3e, r29	; 62
    1516:	0f be       	out	0x3f, r0	; 63
    1518:	cd bf       	out	0x3d, r28	; 61
	int R0_VALS_GAS_SENSORS[6] = {381, 508, 308, 405, 38, 0}; //all R0 values. We may have a 6th sensor but it is currently not in existence
	int R0_RATIOS_CO[2][64] = {{101, 99, 98, 96, 95, 93, 92, 90, 89, 87, 86, 84, 83, 81, 80, 78, 77, 75, 74, 72, 71, 69, 67, 66, 64, 63, 61, 60,
    151a:	80 e0       	ldi	r24, 0x00	; 0
    151c:	ea e3       	ldi	r30, 0x3A	; 58
    151e:	f1 e0       	ldi	r31, 0x01	; 1
    1520:	de 01       	movw	r26, r28
    1522:	11 96       	adiw	r26, 0x01	; 1
    1524:	01 90       	ld	r0, Z+
    1526:	0d 92       	st	X+, r0
    1528:	8a 95       	dec	r24
    152a:	e1 f7       	brne	.-8      	; 0x1524 <convert_to_ppm+0x1e>
	58, 57, 55, 54, 52, 51, 49, 48, 46, 45, 43, 42, 40, 39, 37, 35, 34, 32, 31, 29, 28, 26, 25, 23, 22, 20, 19, 17, 16, 14, 13, 11, 10, 8, 7, 5}, //R0 ratio corresponding to certain ppm val
	{44, 52, 53, 54, 55, 57, 57, 59, 60, 62, 64, 66, 67, 70, 71, 74, 75, 78, 80, 83, 85, 88, 92, 94, 99, 102, 107, 110, 116, 119, 125, 128,
	135, 139, 146, 150, 159, 163, 174, 180, 192, 200, 216, 233, 243, 264, 278, 306, 323, 359, 381, 432, 466, 542, 586, 699, 779, 980, 1101, 1434, 1684, 2409, 2955, 4563}};//PPM values
	baseIndexToTable = 0;
    152c:	10 92 92 04 	sts	0x0492, r1	; 0x800492 <baseIndexToTable+0x1>
    1530:	10 92 91 04 	sts	0x0491, r1	; 0x800491 <baseIndexToTable>
	interpolationNum = 0;
    1534:	10 92 6e 04 	sts	0x046E, r1	; 0x80046e <interpolationNum+0x1>
    1538:	10 92 6d 04 	sts	0x046D, r1	; 0x80046d <interpolationNum>
	numTimes256 = 0;
    153c:	10 92 8c 04 	sts	0x048C, r1	; 0x80048c <numTimes256+0x1>
    1540:	10 92 8b 04 	sts	0x048B, r1	; 0x80048b <numTimes256>
	valueOfIndex = 0;
    1544:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <valueOfIndex+0x1>
    1548:	10 92 f9 04 	sts	0x04F9, r1	; 0x8004f9 <valueOfIndex>
	
	//Per sensor - make look-up table w/ values corresponding to out put. 
	//Get approx ppm
	//write equation
	//First sensor is CO
	numTimes256 = (raw_gas_vector[0]<<8)/(R0_VALS_GAS_SENSORS[0]<<8); //temporary routine while there is only 1 sensor, will be put into a loop later
    154c:	80 e0       	ldi	r24, 0x00	; 0
    154e:	90 91 9c 04 	lds	r25, 0x049C	; 0x80049c <raw_gas_vector>
    1552:	60 e0       	ldi	r22, 0x00	; 0
    1554:	7d e7       	ldi	r23, 0x7D	; 125
    1556:	8d d3       	rcall	.+1818   	; 0x1c72 <__udivmodhi4>
    1558:	70 93 8c 04 	sts	0x048C, r23	; 0x80048c <numTimes256+0x1>
    155c:	60 93 8b 04 	sts	0x048B, r22	; 0x80048b <numTimes256>
	interpolationNum = 0x03 | numTimes256;
    1560:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <numTimes256>
    1564:	90 91 8c 04 	lds	r25, 0x048C	; 0x80048c <numTimes256+0x1>
    1568:	83 60       	ori	r24, 0x03	; 3
    156a:	90 93 6e 04 	sts	0x046E, r25	; 0x80046e <interpolationNum+0x1>
    156e:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <interpolationNum>
	baseIndexToTable = numTimes256 >> 2;
    1572:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <numTimes256>
    1576:	90 91 8c 04 	lds	r25, 0x048C	; 0x80048c <numTimes256+0x1>
    157a:	95 95       	asr	r25
    157c:	87 95       	ror	r24
    157e:	95 95       	asr	r25
    1580:	87 95       	ror	r24
    1582:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <baseIndexToTable+0x1>
    1586:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <baseIndexToTable>
	binary_search(R0_RATIOS_CO[0], 0, 63, baseIndexToTable);
    158a:	20 91 91 04 	lds	r18, 0x0491	; 0x800491 <baseIndexToTable>
    158e:	30 91 92 04 	lds	r19, 0x0492	; 0x800492 <baseIndexToTable+0x1>
    1592:	4f e3       	ldi	r20, 0x3F	; 63
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	70 e0       	ldi	r23, 0x00	; 0
    159a:	ce 01       	movw	r24, r28
    159c:	01 96       	adiw	r24, 0x01	; 1
    159e:	62 df       	rcall	.-316    	; 0x1464 <binary_search>
	ppmValue[0] = (((R0_RATIOS_CO[1][valueOfIndex] - R0_RATIOS_CO[1][valueOfIndex-1])*interpolationNum)>>2) + R0_RATIOS_CO[1][valueOfIndex-1];
    15a0:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <valueOfIndex>
    15a4:	90 91 fa 04 	lds	r25, 0x04FA	; 0x8004fa <valueOfIndex+0x1>
    15a8:	a0 91 f9 04 	lds	r26, 0x04F9	; 0x8004f9 <valueOfIndex>
    15ac:	b0 91 fa 04 	lds	r27, 0x04FA	; 0x8004fa <valueOfIndex+0x1>
    15b0:	20 91 6d 04 	lds	r18, 0x046D	; 0x80046d <interpolationNum>
    15b4:	30 91 6e 04 	lds	r19, 0x046E	; 0x80046e <interpolationNum+0x1>
    15b8:	60 91 f9 04 	lds	r22, 0x04F9	; 0x8004f9 <valueOfIndex>
    15bc:	70 91 fa 04 	lds	r23, 0x04FA	; 0x8004fa <valueOfIndex+0x1>
    15c0:	80 5c       	subi	r24, 0xC0	; 192
    15c2:	9f 4f       	sbci	r25, 0xFF	; 255
    15c4:	88 0f       	add	r24, r24
    15c6:	99 1f       	adc	r25, r25
    15c8:	41 e0       	ldi	r20, 0x01	; 1
    15ca:	50 e0       	ldi	r21, 0x00	; 0
    15cc:	4c 0f       	add	r20, r28
    15ce:	5d 1f       	adc	r21, r29
    15d0:	84 0f       	add	r24, r20
    15d2:	95 1f       	adc	r25, r21
    15d4:	df 96       	adiw	r26, 0x3f	; 63
    15d6:	aa 0f       	add	r26, r26
    15d8:	bb 1f       	adc	r27, r27
    15da:	a4 0f       	add	r26, r20
    15dc:	b5 1f       	adc	r27, r21
    15de:	fc 01       	movw	r30, r24
    15e0:	40 81       	ld	r20, Z
    15e2:	51 81       	ldd	r21, Z+1	; 0x01
    15e4:	8d 91       	ld	r24, X+
    15e6:	9c 91       	ld	r25, X
    15e8:	48 1b       	sub	r20, r24
    15ea:	59 0b       	sbc	r21, r25
    15ec:	42 9f       	mul	r20, r18
    15ee:	c0 01       	movw	r24, r0
    15f0:	43 9f       	mul	r20, r19
    15f2:	90 0d       	add	r25, r0
    15f4:	52 9f       	mul	r21, r18
    15f6:	90 0d       	add	r25, r0
    15f8:	11 24       	eor	r1, r1
    15fa:	95 95       	asr	r25
    15fc:	87 95       	ror	r24
    15fe:	95 95       	asr	r25
    1600:	87 95       	ror	r24
    1602:	fb 01       	movw	r30, r22
    1604:	ff 96       	adiw	r30, 0x3f	; 63
    1606:	ee 0f       	add	r30, r30
    1608:	ff 1f       	adc	r31, r31
    160a:	21 e0       	ldi	r18, 0x01	; 1
    160c:	30 e0       	ldi	r19, 0x00	; 0
    160e:	2c 0f       	add	r18, r28
    1610:	3d 1f       	adc	r19, r29
    1612:	e2 0f       	add	r30, r18
    1614:	f3 1f       	adc	r31, r19
    1616:	20 81       	ld	r18, Z
    1618:	31 81       	ldd	r19, Z+1	; 0x01
    161a:	82 0f       	add	r24, r18
    161c:	93 1f       	adc	r25, r19
    161e:	90 93 7b 04 	sts	0x047B, r25	; 0x80047b <ppmValue+0x1>
    1622:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <ppmValue>

}
    1626:	d3 95       	inc	r29
    1628:	0f b6       	in	r0, 0x3f	; 63
    162a:	f8 94       	cli
    162c:	de bf       	out	0x3e, r29	; 62
    162e:	0f be       	out	0x3f, r0	; 63
    1630:	cd bf       	out	0x3d, r28	; 61
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	08 95       	ret

00001638 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    1638:	a7 dd       	rcall	.-1202   	; 0x1188 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    163a:	10 92 00 05 	sts	0x0500, r1	; 0x800500 <seconds+0x1>
    163e:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <seconds>
	ItsTime=0;
    1642:	10 92 25 04 	sts	0x0425, r1	; 0x800425 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
    1646:	8b e2       	ldi	r24, 0x2B	; 43
    1648:	91 e0       	ldi	r25, 0x01	; 1
    164a:	90 93 04 07 	sts	0x0704, r25	; 0x800704 <__iob+0x3>
    164e:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
    1652:	3e d1       	rcall	.+636    	; 0x18d0 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    1654:	81 e8       	ldi	r24, 0x81	; 129
    1656:	90 e0       	ldi	r25, 0x00	; 0
    1658:	38 d2       	rcall	.+1136   	; 0x1aca <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
    165a:	81 e8       	ldi	r24, 0x81	; 129
    165c:	90 e0       	ldi	r25, 0x00	; 0
    165e:	90 d2       	rcall	.+1312   	; 0x1b80 <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    1660:	57 d1       	rcall	.+686    	; 0x1910 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    1662:	0e 94 c1 00 	call	0x182	; 0x182 <ADC_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
    1666:	dd dd       	rcall	.-1094   	; 0x1222 <gas_sensors_init>
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
    1668:	2a 9a       	sbi	0x05, 2	; 5
	ClearBit(PORTB, PORTB2);
    166a:	2a 98       	cbi	0x05, 2	; 5
	// 
	// Start all interrupts
	sei();
    166c:	78 94       	sei
	//
	// Initialize and check the BME interface...
	bme280basic_init();
    166e:	0e 94 aa 02 	call	0x554	; 0x554 <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	printf("\n%s",String);
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	91 e0       	ldi	r25, 0x01	; 1
    1676:	9f 93       	push	r25
    1678:	8f 93       	push	r24
    167a:	8a e3       	ldi	r24, 0x3A	; 58
    167c:	92 e0       	ldi	r25, 0x02	; 2
    167e:	9f 93       	push	r25
    1680:	8f 93       	push	r24
    1682:	a9 d4       	rcall	.+2386   	; 0x1fd6 <printf>
	//wait until button is pushed before proceeding to loop
	ToggleBit(PORTB, PORTB0); //will keep yellow LED until button is pressed.
    1684:	95 b1       	in	r25, 0x05	; 5
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	98 27       	eor	r25, r24
    168a:	95 b9       	out	0x05, r25	; 5
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
	ToggleBit(PORTB, PORTB0);
    168c:	95 b1       	in	r25, 0x05	; 5
    168e:	89 27       	eor	r24, r25
    1690:	85 b9       	out	0x05, r24	; 5
    1692:	0f 90       	pop	r0
    1694:	0f 90       	pop	r0
    1696:	0f 90       	pop	r0
    1698:	0f 90       	pop	r0
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
			ItsTime = 0; 
 			seconds++;
 			printf("\nSeconds = %u", seconds);
    169a:	0f 2e       	mov	r0, r31
    169c:	fe e3       	ldi	r31, 0x3E	; 62
    169e:	af 2e       	mov	r10, r31
    16a0:	f2 e0       	ldi	r31, 0x02	; 2
    16a2:	bf 2e       	mov	r11, r31
    16a4:	f0 2d       	mov	r31, r0
			// - Send the data over the serial port
			// - Wait for the transmission to complete, then
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    16a6:	0f 2e       	mov	r0, r31
    16a8:	f1 e0       	ldi	r31, 0x01	; 1
    16aa:	cf 2e       	mov	r12, r31
    16ac:	f6 e0       	ldi	r31, 0x06	; 6
    16ae:	df 2e       	mov	r13, r31
    16b0:	f0 2d       	mov	r31, r0
    16b2:	0f 2e       	mov	r0, r31
    16b4:	fa e3       	ldi	r31, 0x3A	; 58
    16b6:	ef 2e       	mov	r14, r31
    16b8:	f2 e0       	ldi	r31, 0x02	; 2
    16ba:	ff 2e       	mov	r15, r31
    16bc:	f0 2d       	mov	r31, r0
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
// 			distance = LIDAR_distance();
 			printf("\nLIDAR distance = %u", distance);
    16be:	0c e4       	ldi	r16, 0x4C	; 76
    16c0:	12 e0       	ldi	r17, 0x02	; 2
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    16c2:	cc e9       	ldi	r28, 0x9C	; 156
    16c4:	d4 e0       	ldi	r29, 0x04	; 4
    16c6:	0f 2e       	mov	r0, r31
    16c8:	f1 e6       	ldi	r31, 0x61	; 97
    16ca:	8f 2e       	mov	r8, r31
    16cc:	f2 e0       	ldi	r31, 0x02	; 2
    16ce:	9f 2e       	mov	r9, r31
    16d0:	f0 2d       	mov	r31, r0
			while(UART0TransmitInProgress) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    16d2:	0f 2e       	mov	r0, r31
    16d4:	fa e6       	ldi	r31, 0x6A	; 106
    16d6:	2f 2e       	mov	r2, r31
    16d8:	f2 e0       	ldi	r31, 0x02	; 2
    16da:	3f 2e       	mov	r3, r31
    16dc:	f0 2d       	mov	r31, r0
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
    16de:	80 91 25 04 	lds	r24, 0x0425	; 0x800425 <ItsTime>
    16e2:	81 30       	cpi	r24, 0x01	; 1
    16e4:	e1 f7       	brne	.-8      	; 0x16de <main+0xa6>
			ItsTime = 0; 
    16e6:	10 92 25 04 	sts	0x0425, r1	; 0x800425 <ItsTime>
 			seconds++;
    16ea:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <seconds>
    16ee:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <seconds+0x1>
    16f2:	01 96       	adiw	r24, 0x01	; 1
    16f4:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <seconds+0x1>
    16f8:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <seconds>
 			printf("\nSeconds = %u", seconds);
    16fc:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <seconds>
    1700:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <seconds+0x1>
    1704:	9f 93       	push	r25
    1706:	8f 93       	push	r24
    1708:	bf 92       	push	r11
    170a:	af 92       	push	r10
    170c:	64 d4       	rcall	.+2248   	; 0x1fd6 <printf>
			// - Send the data over the serial port
			// - Wait for the transmission to complete, then
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    170e:	df 92       	push	r13
    1710:	cf 92       	push	r12
    1712:	ff 92       	push	r15
    1714:	ef 92       	push	r14
    1716:	5f d4       	rcall	.+2238   	; 0x1fd6 <printf>
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
// 			distance = LIDAR_distance();
 			printf("\nLIDAR distance = %u", distance);
    1718:	80 91 79 04 	lds	r24, 0x0479	; 0x800479 <distance+0x1>
    171c:	8f 93       	push	r24
    171e:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <distance>
    1722:	8f 93       	push	r24
    1724:	1f 93       	push	r17
    1726:	0f 93       	push	r16
    1728:	56 d4       	rcall	.+2220   	; 0x1fd6 <printf>
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    172a:	fb dd       	rcall	.-1034   	; 0x1322 <start_gas_sensor_read>
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	8f 93       	push	r24
    1730:	88 81       	ld	r24, Y
    1732:	8f 93       	push	r24
    1734:	9f 92       	push	r9
    1736:	8f 92       	push	r8
    1738:	4e d4       	rcall	.+2204   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    173a:	8b 81       	ldd	r24, Y+3	; 0x03
    173c:	8f 93       	push	r24
    173e:	8a 81       	ldd	r24, Y+2	; 0x02
    1740:	8f 93       	push	r24
    1742:	3f 92       	push	r3
    1744:	2f 92       	push	r2
    1746:	47 d4       	rcall	.+2190   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
 			printf("\nNA = %u", raw_gas_vector[2]);
    1748:	8d 81       	ldd	r24, Y+5	; 0x05
    174a:	8f 93       	push	r24
    174c:	8c 81       	ldd	r24, Y+4	; 0x04
    174e:	8f 93       	push	r24
    1750:	a2 e7       	ldi	r26, 0x72	; 114
    1752:	b2 e0       	ldi	r27, 0x02	; 2
    1754:	bf 93       	push	r27
    1756:	af 93       	push	r26
    1758:	3e d4       	rcall	.+2172   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {} 
 			printf("\nCH4 = %u", raw_gas_vector[3]);
    175a:	8f 81       	ldd	r24, Y+7	; 0x07
    175c:	8f 93       	push	r24
    175e:	8e 81       	ldd	r24, Y+6	; 0x06
    1760:	8f 93       	push	r24
    1762:	ab e7       	ldi	r26, 0x7B	; 123
    1764:	b2 e0       	ldi	r27, 0x02	; 2
    1766:	bf 93       	push	r27
    1768:	af 93       	push	r26
    176a:	35 d4       	rcall	.+2154   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
 			printf("\nO3 = %u", raw_gas_vector[4]);
    176c:	89 85       	ldd	r24, Y+9	; 0x09
    176e:	8f 93       	push	r24
    1770:	88 85       	ldd	r24, Y+8	; 0x08
    1772:	8f 93       	push	r24
    1774:	a5 e8       	ldi	r26, 0x85	; 133
    1776:	b2 e0       	ldi	r27, 0x02	; 2
    1778:	bf 93       	push	r27
    177a:	af 93       	push	r26
    177c:	2c d4       	rcall	.+2136   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
			//
			//============================
			// Now read the BME interface...
 			bme280basic_bulk_data_read();
    177e:	ad b7       	in	r26, 0x3d	; 61
    1780:	be b7       	in	r27, 0x3e	; 62
    1782:	90 96       	adiw	r26, 0x20	; 32
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	be bf       	out	0x3e, r27	; 62
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	ad bf       	out	0x3d, r26	; 61
    178e:	0e 94 13 03 	call	0x626	; 0x626 <bme280basic_bulk_data_read>
 			// Calculate the temperature and print it
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    1792:	60 91 72 04 	lds	r22, 0x0472	; 0x800472 <rawTemp>
    1796:	70 91 73 04 	lds	r23, 0x0473	; 0x800473 <rawTemp+0x1>
    179a:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <rawTemp+0x2>
    179e:	90 91 75 04 	lds	r25, 0x0475	; 0x800475 <rawTemp+0x3>
    17a2:	30 d8       	rcall	.-4000   	; 0x804 <BME280_compensate_T_int32>
    17a4:	60 93 69 04 	sts	0x0469, r22	; 0x800469 <tempCelsius>
    17a8:	70 93 6a 04 	sts	0x046A, r23	; 0x80046a <tempCelsius+0x1>
    17ac:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <tempCelsius+0x2>
    17b0:	90 93 6c 04 	sts	0x046C, r25	; 0x80046c <tempCelsius+0x3>
// 			sprintf(temperatureBuf, "%lu", tempCelsius);
  			printf("\nCelsius = %lu", tempCelsius);
    17b4:	9f 93       	push	r25
    17b6:	8f 93       	push	r24
    17b8:	7f 93       	push	r23
    17ba:	6f 93       	push	r22
    17bc:	ae e8       	ldi	r26, 0x8E	; 142
    17be:	b2 e0       	ldi	r27, 0x02	; 2
    17c0:	bf 93       	push	r27
    17c2:	af 93       	push	r26
    17c4:	08 d4       	rcall	.+2064   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
 			// Calculate the pressure and print it
			pressure = BME280_compensate_P_int64(rawPress);
    17c6:	60 91 aa 04 	lds	r22, 0x04AA	; 0x8004aa <rawPress>
    17ca:	70 91 ab 04 	lds	r23, 0x04AB	; 0x8004ab <rawPress+0x1>
    17ce:	80 91 ac 04 	lds	r24, 0x04AC	; 0x8004ac <rawPress+0x2>
    17d2:	90 91 ad 04 	lds	r25, 0x04AD	; 0x8004ad <rawPress+0x3>
    17d6:	a4 d8       	rcall	.-3768   	; 0x920 <BME280_compensate_P_int64>
    17d8:	60 93 8d 04 	sts	0x048D, r22	; 0x80048d <pressure>
    17dc:	70 93 8e 04 	sts	0x048E, r23	; 0x80048e <pressure+0x1>
    17e0:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <pressure+0x2>
    17e4:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <pressure+0x3>
 			printf("\nPressure in Pa = %lu", pressure>>8);
    17e8:	bb 27       	eor	r27, r27
    17ea:	97 fd       	sbrc	r25, 7
    17ec:	ba 95       	dec	r27
    17ee:	a9 2f       	mov	r26, r25
    17f0:	98 2f       	mov	r25, r24
    17f2:	87 2f       	mov	r24, r23
    17f4:	bf 93       	push	r27
    17f6:	af 93       	push	r26
    17f8:	9f 93       	push	r25
    17fa:	8f 93       	push	r24
    17fc:	ad e9       	ldi	r26, 0x9D	; 157
    17fe:	b2 e0       	ldi	r27, 0x02	; 2
    1800:	bf 93       	push	r27
    1802:	af 93       	push	r26
    1804:	e8 d3       	rcall	.+2000   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
 			// Calculate the humidity and print it
			 humidity = bme280_compensate_H_int32(rawHum);
    1806:	60 91 ae 04 	lds	r22, 0x04AE	; 0x8004ae <rawHum>
    180a:	70 91 af 04 	lds	r23, 0x04AF	; 0x8004af <rawHum+0x1>
    180e:	80 91 b0 04 	lds	r24, 0x04B0	; 0x8004b0 <rawHum+0x2>
    1812:	90 91 b1 04 	lds	r25, 0x04B1	; 0x8004b1 <rawHum+0x3>
    1816:	ef da       	rcall	.-2594   	; 0xdf6 <bme280_compensate_H_int32>
    1818:	2b 01       	movw	r4, r22
    181a:	3c 01       	movw	r6, r24
    181c:	60 93 97 04 	sts	0x0497, r22	; 0x800497 <humidity>
    1820:	70 93 98 04 	sts	0x0498, r23	; 0x800498 <humidity+0x1>
    1824:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <humidity+0x2>
    1828:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <humidity+0x3>
 			printf("\nHumidity%% = %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    182c:	a8 ee       	ldi	r26, 0xE8	; 232
    182e:	b3 e0       	ldi	r27, 0x03	; 3
    1830:	9b 01       	movw	r18, r22
    1832:	ac 01       	movw	r20, r24
    1834:	3b d2       	rcall	.+1142   	; 0x1cac <__muluhisi3>
    1836:	dc 01       	movw	r26, r24
    1838:	cb 01       	movw	r24, r22
    183a:	07 2e       	mov	r0, r23
    183c:	7a e0       	ldi	r23, 0x0A	; 10
    183e:	b5 95       	asr	r27
    1840:	a7 95       	ror	r26
    1842:	97 95       	ror	r25
    1844:	87 95       	ror	r24
    1846:	7a 95       	dec	r23
    1848:	d1 f7       	brne	.-12     	; 0x183e <main+0x206>
    184a:	70 2d       	mov	r23, r0
    184c:	bf 93       	push	r27
    184e:	af 93       	push	r26
    1850:	9f 93       	push	r25
    1852:	8f 93       	push	r24
    1854:	d3 01       	movw	r26, r6
    1856:	c2 01       	movw	r24, r4
    1858:	07 2e       	mov	r0, r23
    185a:	7a e0       	ldi	r23, 0x0A	; 10
    185c:	b5 95       	asr	r27
    185e:	a7 95       	ror	r26
    1860:	97 95       	ror	r25
    1862:	87 95       	ror	r24
    1864:	7a 95       	dec	r23
    1866:	d1 f7       	brne	.-12     	; 0x185c <main+0x224>
    1868:	70 2d       	mov	r23, r0
    186a:	bf 93       	push	r27
    186c:	af 93       	push	r26
    186e:	9f 93       	push	r25
    1870:	8f 93       	push	r24
    1872:	a3 eb       	ldi	r26, 0xB3	; 179
    1874:	b2 e0       	ldi	r27, 0x02	; 2
    1876:	bf 93       	push	r27
    1878:	af 93       	push	r26
    187a:	ad d3       	rcall	.+1882   	; 0x1fd6 <printf>
			while(UART0TransmitInProgress) {}
    187c:	ad b7       	in	r26, 0x3d	; 61
    187e:	be b7       	in	r27, 0x3e	; 62
    1880:	56 96       	adiw	r26, 0x16	; 22
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	be bf       	out	0x3e, r27	; 62
    1888:	0f be       	out	0x3f, r0	; 63
    188a:	ad bf       	out	0x3d, r26	; 61
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			convert_to_ppm(0); //only works for co right now
    188c:	80 e0       	ldi	r24, 0x00	; 0
    188e:	3b de       	rcall	.-906    	; 0x1506 <convert_to_ppm>
			printf("ppm value CO: %d", ppmValue[0]);
    1890:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <ppmValue>
    1894:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <ppmValue+0x1>
    1898:	9f 93       	push	r25
    189a:	8f 93       	push	r24
    189c:	8a ec       	ldi	r24, 0xCA	; 202
    189e:	92 e0       	ldi	r25, 0x02	; 2
    18a0:	9f 93       	push	r25
    18a2:	8f 93       	push	r24
    18a4:	98 d3       	rcall	.+1840   	; 0x1fd6 <printf>
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
    18a6:	e9 ec       	ldi	r30, 0xC9	; 201
    18a8:	f0 e0       	ldi	r31, 0x00	; 0
    18aa:	80 81       	ld	r24, Z
    18ac:	80 69       	ori	r24, 0x90	; 144
    18ae:	80 83       	st	Z, r24
    18b0:	0f 90       	pop	r0
    18b2:	0f 90       	pop	r0
    18b4:	0f 90       	pop	r0
    18b6:	0f 90       	pop	r0
    18b8:	12 cf       	rjmp	.-476    	; 0x16de <main+0xa6>

000018ba <__vector_default>:
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
    18ba:	1f 92       	push	r1
    18bc:	0f 92       	push	r0
    18be:	0f b6       	in	r0, 0x3f	; 63
    18c0:	0f 92       	push	r0
    18c2:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
    18c4:	2a 9a       	sbi	0x05, 2	; 5
    18c6:	0f 90       	pop	r0
    18c8:	0f be       	out	0x3f, r0	; 63
    18ca:	0f 90       	pop	r0
    18cc:	1f 90       	pop	r1
    18ce:	18 95       	reti

000018d0 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    18d0:	8d e0       	ldi	r24, 0x0D	; 13
    18d2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    18d6:	8a e4       	ldi	r24, 0x4A	; 74
    18d8:	9c e4       	ldi	r25, 0x4C	; 76
    18da:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    18de:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    18e2:	08 95       	ret

000018e4 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    18e4:	18 95       	reti

000018e6 <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
    18e6:	1f 92       	push	r1
    18e8:	0f 92       	push	r0
    18ea:	0f b6       	in	r0, 0x3f	; 63
    18ec:	0f 92       	push	r0
    18ee:	11 24       	eor	r1, r1
    18f0:	8f 93       	push	r24
    18f2:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    18f4:	95 b1       	in	r25, 0x05	; 5
    18f6:	82 e0       	ldi	r24, 0x02	; 2
    18f8:	89 27       	eor	r24, r25
    18fa:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    18fc:	81 e0       	ldi	r24, 0x01	; 1
    18fe:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <ItsTime>
}
    1902:	9f 91       	pop	r25
    1904:	8f 91       	pop	r24
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63
    190a:	0f 90       	pop	r0
    190c:	1f 90       	pop	r1
    190e:	18 95       	reti

00001910 <TWI_Master_Initialise>:
    1910:	81 e1       	ldi	r24, 0x11	; 17
    1912:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    1916:	8f ef       	ldi	r24, 0xFF	; 255
    1918:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    191c:	84 e0       	ldi	r24, 0x04	; 4
    191e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1922:	08 95       	ret

00001924 <TWI_Transceiver_Busy>:
    1924:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1928:	81 78       	andi	r24, 0x81	; 129
    192a:	08 95       	ret

0000192c <TWI_Start_Transceiver_With_Data>:
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	ec 01       	movw	r28, r24
    1932:	ec eb       	ldi	r30, 0xBC	; 188
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	90 81       	ld	r25, Z
    1938:	91 78       	andi	r25, 0x81	; 129
    193a:	e9 f7       	brne	.-6      	; 0x1936 <TWI_Start_Transceiver_With_Data+0xa>
    193c:	60 93 e2 02 	sts	0x02E2, r22	; 0x8002e2 <TWI_msgSize>
    1940:	88 81       	ld	r24, Y
    1942:	80 93 e3 02 	sts	0x02E3, r24	; 0x8002e3 <TWI_buf>
    1946:	80 fd       	sbrc	r24, 0
    1948:	12 c0       	rjmp	.+36     	; 0x196e <TWI_Start_Transceiver_With_Data+0x42>
    194a:	62 30       	cpi	r22, 0x02	; 2
    194c:	80 f0       	brcs	.+32     	; 0x196e <TWI_Start_Transceiver_With_Data+0x42>
    194e:	fe 01       	movw	r30, r28
    1950:	31 96       	adiw	r30, 0x01	; 1
    1952:	a4 ee       	ldi	r26, 0xE4	; 228
    1954:	b2 e0       	ldi	r27, 0x02	; 2
    1956:	62 50       	subi	r22, 0x02	; 2
    1958:	26 2f       	mov	r18, r22
    195a:	30 e0       	ldi	r19, 0x00	; 0
    195c:	2e 5f       	subi	r18, 0xFE	; 254
    195e:	3f 4f       	sbci	r19, 0xFF	; 255
    1960:	2c 0f       	add	r18, r28
    1962:	3d 1f       	adc	r19, r29
    1964:	91 91       	ld	r25, Z+
    1966:	9d 93       	st	X+, r25
    1968:	e2 17       	cp	r30, r18
    196a:	f3 07       	cpc	r31, r19
    196c:	d9 f7       	brne	.-10     	; 0x1964 <TWI_Start_Transceiver_With_Data+0x38>
    196e:	10 92 e1 02 	sts	0x02E1, r1	; 0x8002e1 <TWI_statusReg>
    1972:	88 ef       	ldi	r24, 0xF8	; 248
    1974:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    1978:	85 ea       	ldi	r24, 0xA5	; 165
    197a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    197e:	df 91       	pop	r29
    1980:	cf 91       	pop	r28
    1982:	08 95       	ret

00001984 <TWI_Get_Data_From_Transceiver>:
    1984:	ac 01       	movw	r20, r24
    1986:	ec eb       	ldi	r30, 0xBC	; 188
    1988:	f0 e0       	ldi	r31, 0x00	; 0
    198a:	90 81       	ld	r25, Z
    198c:	91 78       	andi	r25, 0x81	; 129
    198e:	e9 f7       	brne	.-6      	; 0x198a <TWI_Get_Data_From_Transceiver+0x6>
    1990:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <TWI_statusReg>
    1994:	80 ff       	sbrs	r24, 0
    1996:	11 c0       	rjmp	.+34     	; 0x19ba <TWI_Get_Data_From_Transceiver+0x36>
    1998:	66 23       	and	r22, r22
    199a:	79 f0       	breq	.+30     	; 0x19ba <TWI_Get_Data_From_Transceiver+0x36>
    199c:	a3 ee       	ldi	r26, 0xE3	; 227
    199e:	b2 e0       	ldi	r27, 0x02	; 2
    19a0:	fa 01       	movw	r30, r20
    19a2:	61 50       	subi	r22, 0x01	; 1
    19a4:	26 2f       	mov	r18, r22
    19a6:	30 e0       	ldi	r19, 0x00	; 0
    19a8:	2f 5f       	subi	r18, 0xFF	; 255
    19aa:	3f 4f       	sbci	r19, 0xFF	; 255
    19ac:	24 0f       	add	r18, r20
    19ae:	35 1f       	adc	r19, r21
    19b0:	9d 91       	ld	r25, X+
    19b2:	91 93       	st	Z+, r25
    19b4:	e2 17       	cp	r30, r18
    19b6:	f3 07       	cpc	r31, r19
    19b8:	d9 f7       	brne	.-10     	; 0x19b0 <TWI_Get_Data_From_Transceiver+0x2c>
    19ba:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <TWI_statusReg>
    19be:	81 70       	andi	r24, 0x01	; 1
    19c0:	08 95       	ret

000019c2 <__vector_26>:
    19c2:	1f 92       	push	r1
    19c4:	0f 92       	push	r0
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	0f 92       	push	r0
    19ca:	11 24       	eor	r1, r1
    19cc:	0b b6       	in	r0, 0x3b	; 59
    19ce:	0f 92       	push	r0
    19d0:	2f 93       	push	r18
    19d2:	3f 93       	push	r19
    19d4:	8f 93       	push	r24
    19d6:	9f 93       	push	r25
    19d8:	af 93       	push	r26
    19da:	bf 93       	push	r27
    19dc:	ef 93       	push	r30
    19de:	ff 93       	push	r31
    19e0:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    19e4:	8e 2f       	mov	r24, r30
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	fc 01       	movw	r30, r24
    19ea:	38 97       	sbiw	r30, 0x08	; 8
    19ec:	e1 35       	cpi	r30, 0x51	; 81
    19ee:	f1 05       	cpc	r31, r1
    19f0:	08 f0       	brcs	.+2      	; 0x19f4 <__vector_26+0x32>
    19f2:	55 c0       	rjmp	.+170    	; 0x1a9e <__vector_26+0xdc>
    19f4:	ea 5b       	subi	r30, 0xBA	; 186
    19f6:	ff 4f       	sbci	r31, 0xFF	; 255
    19f8:	50 c1       	rjmp	.+672    	; 0x1c9a <__tablejump2__>
    19fa:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <TWI_bufPtr.1555>
    19fe:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <TWI_bufPtr.1555>
    1a02:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <TWI_msgSize>
    1a06:	e8 17       	cp	r30, r24
    1a08:	70 f4       	brcc	.+28     	; 0x1a26 <__vector_26+0x64>
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	8e 0f       	add	r24, r30
    1a0e:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <TWI_bufPtr.1555>
    1a12:	f0 e0       	ldi	r31, 0x00	; 0
    1a14:	ed 51       	subi	r30, 0x1D	; 29
    1a16:	fd 4f       	sbci	r31, 0xFD	; 253
    1a18:	80 81       	ld	r24, Z
    1a1a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1a1e:	85 e8       	ldi	r24, 0x85	; 133
    1a20:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a24:	43 c0       	rjmp	.+134    	; 0x1aac <__vector_26+0xea>
    1a26:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <TWI_statusReg>
    1a2a:	81 60       	ori	r24, 0x01	; 1
    1a2c:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <TWI_statusReg>
    1a30:	84 e9       	ldi	r24, 0x94	; 148
    1a32:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a36:	3a c0       	rjmp	.+116    	; 0x1aac <__vector_26+0xea>
    1a38:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <TWI_bufPtr.1555>
    1a3c:	81 e0       	ldi	r24, 0x01	; 1
    1a3e:	8e 0f       	add	r24, r30
    1a40:	80 93 e0 02 	sts	0x02E0, r24	; 0x8002e0 <TWI_bufPtr.1555>
    1a44:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1a48:	f0 e0       	ldi	r31, 0x00	; 0
    1a4a:	ed 51       	subi	r30, 0x1D	; 29
    1a4c:	fd 4f       	sbci	r31, 0xFD	; 253
    1a4e:	80 83       	st	Z, r24
    1a50:	20 91 e0 02 	lds	r18, 0x02E0	; 0x8002e0 <TWI_bufPtr.1555>
    1a54:	30 e0       	ldi	r19, 0x00	; 0
    1a56:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <TWI_msgSize>
    1a5a:	90 e0       	ldi	r25, 0x00	; 0
    1a5c:	01 97       	sbiw	r24, 0x01	; 1
    1a5e:	28 17       	cp	r18, r24
    1a60:	39 07       	cpc	r19, r25
    1a62:	24 f4       	brge	.+8      	; 0x1a6c <__vector_26+0xaa>
    1a64:	85 ec       	ldi	r24, 0xC5	; 197
    1a66:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a6a:	20 c0       	rjmp	.+64     	; 0x1aac <__vector_26+0xea>
    1a6c:	85 e8       	ldi	r24, 0x85	; 133
    1a6e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a72:	1c c0       	rjmp	.+56     	; 0x1aac <__vector_26+0xea>
    1a74:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1a78:	e0 91 e0 02 	lds	r30, 0x02E0	; 0x8002e0 <TWI_bufPtr.1555>
    1a7c:	f0 e0       	ldi	r31, 0x00	; 0
    1a7e:	ed 51       	subi	r30, 0x1D	; 29
    1a80:	fd 4f       	sbci	r31, 0xFD	; 253
    1a82:	80 83       	st	Z, r24
    1a84:	80 91 e1 02 	lds	r24, 0x02E1	; 0x8002e1 <TWI_statusReg>
    1a88:	81 60       	ori	r24, 0x01	; 1
    1a8a:	80 93 e1 02 	sts	0x02E1, r24	; 0x8002e1 <TWI_statusReg>
    1a8e:	84 e9       	ldi	r24, 0x94	; 148
    1a90:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a94:	0b c0       	rjmp	.+22     	; 0x1aac <__vector_26+0xea>
    1a96:	85 ea       	ldi	r24, 0xA5	; 165
    1a98:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1a9c:	07 c0       	rjmp	.+14     	; 0x1aac <__vector_26+0xea>
    1a9e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1aa2:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    1aa6:	84 e0       	ldi	r24, 0x04	; 4
    1aa8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1aac:	ff 91       	pop	r31
    1aae:	ef 91       	pop	r30
    1ab0:	bf 91       	pop	r27
    1ab2:	af 91       	pop	r26
    1ab4:	9f 91       	pop	r25
    1ab6:	8f 91       	pop	r24
    1ab8:	3f 91       	pop	r19
    1aba:	2f 91       	pop	r18
    1abc:	0f 90       	pop	r0
    1abe:	0b be       	out	0x3b, r0	; 59
    1ac0:	0f 90       	pop	r0
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	0f 90       	pop	r0
    1ac6:	1f 90       	pop	r1
    1ac8:	18 95       	reti

00001aca <USART0_init>:
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1aca:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    1ace:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    1ad2:	88 e0       	ldi	r24, 0x08	; 8
    1ad4:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1ad8:	86 e0       	ldi	r24, 0x06	; 6
    1ada:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1ade:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <UART0_RxTail>
    1ae2:	10 92 f6 03 	sts	0x03F6, r1	; 0x8003f6 <UART0_RxHead>
    1ae6:	10 92 f3 02 	sts	0x02F3, r1	; 0x8002f3 <UART0_TxTail>
    1aea:	10 92 f4 02 	sts	0x02F4, r1	; 0x8002f4 <UART0_TxHead>
    1aee:	08 95       	ret

00001af0 <USART0_Transmit_IO>:
    1af0:	91 e0       	ldi	r25, 0x01	; 1
    1af2:	90 93 f7 03 	sts	0x03F7, r25	; 0x8003f7 <UART0TransmitInProgress>
    1af6:	20 91 f4 02 	lds	r18, 0x02F4	; 0x8002f4 <UART0_TxHead>
    1afa:	2f 5f       	subi	r18, 0xFF	; 255
    1afc:	90 91 f3 02 	lds	r25, 0x02F3	; 0x8002f3 <UART0_TxTail>
    1b00:	29 17       	cp	r18, r25
    1b02:	e1 f3       	breq	.-8      	; 0x1afc <USART0_Transmit_IO+0xc>
    1b04:	e2 2f       	mov	r30, r18
    1b06:	f0 e0       	ldi	r31, 0x00	; 0
    1b08:	eb 50       	subi	r30, 0x0B	; 11
    1b0a:	fd 4f       	sbci	r31, 0xFD	; 253
    1b0c:	80 83       	st	Z, r24
    1b0e:	20 93 f4 02 	sts	0x02F4, r18	; 0x8002f4 <UART0_TxHead>
    1b12:	e1 ec       	ldi	r30, 0xC1	; 193
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	80 81       	ld	r24, Z
    1b18:	80 62       	ori	r24, 0x20	; 32
    1b1a:	80 83       	st	Z, r24
    1b1c:	80 e0       	ldi	r24, 0x00	; 0
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	08 95       	ret

00001b22 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1b22:	1f 92       	push	r1
    1b24:	0f 92       	push	r0
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	0f 92       	push	r0
    1b2a:	11 24       	eor	r1, r1
    1b2c:	0b b6       	in	r0, 0x3b	; 59
    1b2e:	0f 92       	push	r0
    1b30:	8f 93       	push	r24
    1b32:	9f 93       	push	r25
    1b34:	ef 93       	push	r30
    1b36:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1b38:	90 91 f4 02 	lds	r25, 0x02F4	; 0x8002f4 <UART0_TxHead>
    1b3c:	80 91 f3 02 	lds	r24, 0x02F3	; 0x8002f3 <UART0_TxTail>
    1b40:	98 17       	cp	r25, r24
    1b42:	61 f0       	breq	.+24     	; 0x1b5c <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1b44:	e0 91 f3 02 	lds	r30, 0x02F3	; 0x8002f3 <UART0_TxTail>
    1b48:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1b4a:	e0 93 f3 02 	sts	0x02F3, r30	; 0x8002f3 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	eb 50       	subi	r30, 0x0B	; 11
    1b52:	fd 4f       	sbci	r31, 0xFD	; 253
    1b54:	80 81       	ld	r24, Z
    1b56:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1b5a:	07 c0       	rjmp	.+14     	; 0x1b6a <__vector_21+0x48>
		} 
		else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1b5c:	e1 ec       	ldi	r30, 0xC1	; 193
    1b5e:	f0 e0       	ldi	r31, 0x00	; 0
    1b60:	80 81       	ld	r24, Z
    1b62:	8f 7d       	andi	r24, 0xDF	; 223
    1b64:	80 83       	st	Z, r24
		// Indicate transmission is complete
		UART0TransmitInProgress = 0;
    1b66:	10 92 f7 03 	sts	0x03F7, r1	; 0x8003f7 <UART0TransmitInProgress>
	}
    1b6a:	ff 91       	pop	r31
    1b6c:	ef 91       	pop	r30
    1b6e:	9f 91       	pop	r25
    1b70:	8f 91       	pop	r24
    1b72:	0f 90       	pop	r0
    1b74:	0b be       	out	0x3b, r0	; 59
    1b76:	0f 90       	pop	r0
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	0f 90       	pop	r0
    1b7c:	1f 90       	pop	r1
    1b7e:	18 95       	reti

00001b80 <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1b80:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1b84:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1b88:	80 e9       	ldi	r24, 0x90	; 144
    1b8a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1b8e:	86 e0       	ldi	r24, 0x06	; 6
    1b90:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1b94:	10 92 fa 03 	sts	0x03FA, r1	; 0x8003fa <UART1_RxTail>
    1b98:	10 92 fb 03 	sts	0x03FB, r1	; 0x8003fb <UART1_RxHead>
    1b9c:	10 92 f8 03 	sts	0x03F8, r1	; 0x8003f8 <UART1_TxTail>
    1ba0:	10 92 f9 03 	sts	0x03F9, r1	; 0x8003f9 <UART1_TxHead>
    1ba4:	08 95       	ret

00001ba6 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1ba6:	1f 92       	push	r1
    1ba8:	0f 92       	push	r0
    1baa:	0f b6       	in	r0, 0x3f	; 63
    1bac:	0f 92       	push	r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	0b b6       	in	r0, 0x3b	; 59
    1bb2:	0f 92       	push	r0
    1bb4:	2f 93       	push	r18
    1bb6:	3f 93       	push	r19
    1bb8:	8f 93       	push	r24
    1bba:	9f 93       	push	r25
    1bbc:	af 93       	push	r26
    1bbe:	bf 93       	push	r27
    1bc0:	cf 93       	push	r28
    1bc2:	df 93       	push	r29
    1bc4:	ef 93       	push	r30
    1bc6:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1bc8:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1bcc:	80 91 fb 03 	lds	r24, 0x03FB	; 0x8003fb <UART1_RxHead>
    1bd0:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1bd2:	80 93 fb 03 	sts	0x03FB, r24	; 0x8003fb <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1bd6:	20 91 fa 03 	lds	r18, 0x03FA	; 0x8003fa <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1bda:	e8 2f       	mov	r30, r24
    1bdc:	f0 e0       	ldi	r31, 0x00	; 0
    1bde:	ef 5f       	subi	r30, 0xFF	; 255
    1be0:	fa 4f       	sbci	r31, 0xFA	; 250
    1be2:	90 83       	st	Z, r25
	
	if (data == 10)
    1be4:	9a 30       	cpi	r25, 0x0A	; 10
    1be6:	29 f5       	brne	.+74     	; 0x1c32 <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1be8:	90 91 06 05 	lds	r25, 0x0506	; 0x800506 <UART1_RxBuf+0x5>
    1bec:	97 34       	cpi	r25, 0x47	; 71
    1bee:	e9 f4       	brne	.+58     	; 0x1c2a <__vector_28+0x84>
    1bf0:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
    1bf2:	2e 2f       	mov	r18, r30
    1bf4:	30 e0       	ldi	r19, 0x00	; 0
    1bf6:	d9 01       	movw	r26, r18
    1bf8:	af 5f       	subi	r26, 0xFF	; 255
    1bfa:	b9 4f       	sbci	r27, 0xF9	; 249
    1bfc:	e9 01       	movw	r28, r18
    1bfe:	cf 5f       	subi	r28, 0xFF	; 255
    1c00:	da 4f       	sbci	r29, 0xFA	; 250
    1c02:	99 81       	ldd	r25, Y+1	; 0x01
    1c04:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1c06:	ef 5f       	subi	r30, 0xFF	; 255
    1c08:	8e 17       	cp	r24, r30
    1c0a:	98 f7       	brcc	.-26     	; 0x1bf2 <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i-3]=0x00; //This sets the end of the string after the checksum, removing the CR/LF codes from the string.
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	e2 50       	subi	r30, 0x02	; 2
    1c10:	fa 4f       	sbci	r31, 0xFA	; 250
    1c12:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1c14:	e9 ec       	ldi	r30, 0xC9	; 201
    1c16:	f0 e0       	ldi	r31, 0x00	; 0
    1c18:	80 81       	ld	r24, Z
    1c1a:	10 82       	st	Z, r1
 			ItsTime = 1;
    1c1c:	81 e0       	ldi	r24, 0x01	; 1
    1c1e:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <ItsTime>
 			ToggleBit(PORTB, PORTB1);
    1c22:	95 b1       	in	r25, 0x05	; 5
    1c24:	82 e0       	ldi	r24, 0x02	; 2
    1c26:	89 27       	eor	r24, r25
    1c28:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1c2a:	10 92 fa 03 	sts	0x03FA, r1	; 0x8003fa <UART1_RxTail>
		UART1_RxHead = 0;
    1c2e:	10 92 fb 03 	sts	0x03FB, r1	; 0x8003fb <UART1_RxHead>
	}
}
    1c32:	ff 91       	pop	r31
    1c34:	ef 91       	pop	r30
    1c36:	df 91       	pop	r29
    1c38:	cf 91       	pop	r28
    1c3a:	bf 91       	pop	r27
    1c3c:	af 91       	pop	r26
    1c3e:	9f 91       	pop	r25
    1c40:	8f 91       	pop	r24
    1c42:	3f 91       	pop	r19
    1c44:	2f 91       	pop	r18
    1c46:	0f 90       	pop	r0
    1c48:	0b be       	out	0x3b, r0	; 59
    1c4a:	0f 90       	pop	r0
    1c4c:	0f be       	out	0x3f, r0	; 63
    1c4e:	0f 90       	pop	r0
    1c50:	1f 90       	pop	r1
    1c52:	18 95       	reti

00001c54 <__mulsi3>:
    1c54:	db 01       	movw	r26, r22
    1c56:	8f 93       	push	r24
    1c58:	9f 93       	push	r25
    1c5a:	28 d0       	rcall	.+80     	; 0x1cac <__muluhisi3>
    1c5c:	bf 91       	pop	r27
    1c5e:	af 91       	pop	r26
    1c60:	a2 9f       	mul	r26, r18
    1c62:	80 0d       	add	r24, r0
    1c64:	91 1d       	adc	r25, r1
    1c66:	a3 9f       	mul	r26, r19
    1c68:	90 0d       	add	r25, r0
    1c6a:	b2 9f       	mul	r27, r18
    1c6c:	90 0d       	add	r25, r0
    1c6e:	11 24       	eor	r1, r1
    1c70:	08 95       	ret

00001c72 <__udivmodhi4>:
    1c72:	aa 1b       	sub	r26, r26
    1c74:	bb 1b       	sub	r27, r27
    1c76:	51 e1       	ldi	r21, 0x11	; 17
    1c78:	07 c0       	rjmp	.+14     	; 0x1c88 <__udivmodhi4_ep>

00001c7a <__udivmodhi4_loop>:
    1c7a:	aa 1f       	adc	r26, r26
    1c7c:	bb 1f       	adc	r27, r27
    1c7e:	a6 17       	cp	r26, r22
    1c80:	b7 07       	cpc	r27, r23
    1c82:	10 f0       	brcs	.+4      	; 0x1c88 <__udivmodhi4_ep>
    1c84:	a6 1b       	sub	r26, r22
    1c86:	b7 0b       	sbc	r27, r23

00001c88 <__udivmodhi4_ep>:
    1c88:	88 1f       	adc	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	5a 95       	dec	r21
    1c8e:	a9 f7       	brne	.-22     	; 0x1c7a <__udivmodhi4_loop>
    1c90:	80 95       	com	r24
    1c92:	90 95       	com	r25
    1c94:	bc 01       	movw	r22, r24
    1c96:	cd 01       	movw	r24, r26
    1c98:	08 95       	ret

00001c9a <__tablejump2__>:
    1c9a:	ee 0f       	add	r30, r30
    1c9c:	ff 1f       	adc	r31, r31
    1c9e:	00 24       	eor	r0, r0
    1ca0:	00 1c       	adc	r0, r0
    1ca2:	0b be       	out	0x3b, r0	; 59
    1ca4:	07 90       	elpm	r0, Z+
    1ca6:	f6 91       	elpm	r31, Z
    1ca8:	e0 2d       	mov	r30, r0
    1caa:	09 94       	ijmp

00001cac <__muluhisi3>:
    1cac:	85 d1       	rcall	.+778    	; 0x1fb8 <__umulhisi3>
    1cae:	a5 9f       	mul	r26, r21
    1cb0:	90 0d       	add	r25, r0
    1cb2:	b4 9f       	mul	r27, r20
    1cb4:	90 0d       	add	r25, r0
    1cb6:	a4 9f       	mul	r26, r20
    1cb8:	80 0d       	add	r24, r0
    1cba:	91 1d       	adc	r25, r1
    1cbc:	11 24       	eor	r1, r1
    1cbe:	08 95       	ret

00001cc0 <__mulshisi3>:
    1cc0:	b7 ff       	sbrs	r27, 7
    1cc2:	f4 cf       	rjmp	.-24     	; 0x1cac <__muluhisi3>

00001cc4 <__mulohisi3>:
    1cc4:	f3 df       	rcall	.-26     	; 0x1cac <__muluhisi3>
    1cc6:	82 1b       	sub	r24, r18
    1cc8:	93 0b       	sbc	r25, r19
    1cca:	08 95       	ret

00001ccc <__muldi3>:
    1ccc:	df 93       	push	r29
    1cce:	cf 93       	push	r28
    1cd0:	1f 93       	push	r17
    1cd2:	0f 93       	push	r16
    1cd4:	9a 9d       	mul	r25, r10
    1cd6:	f0 2d       	mov	r31, r0
    1cd8:	21 9f       	mul	r18, r17
    1cda:	f0 0d       	add	r31, r0
    1cdc:	8b 9d       	mul	r24, r11
    1cde:	f0 0d       	add	r31, r0
    1ce0:	8a 9d       	mul	r24, r10
    1ce2:	e0 2d       	mov	r30, r0
    1ce4:	f1 0d       	add	r31, r1
    1ce6:	03 9f       	mul	r16, r19
    1ce8:	f0 0d       	add	r31, r0
    1cea:	02 9f       	mul	r16, r18
    1cec:	e0 0d       	add	r30, r0
    1cee:	f1 1d       	adc	r31, r1
    1cf0:	4e 9d       	mul	r20, r14
    1cf2:	e0 0d       	add	r30, r0
    1cf4:	f1 1d       	adc	r31, r1
    1cf6:	5e 9d       	mul	r21, r14
    1cf8:	f0 0d       	add	r31, r0
    1cfa:	4f 9d       	mul	r20, r15
    1cfc:	f0 0d       	add	r31, r0
    1cfe:	7f 93       	push	r23
    1d00:	6f 93       	push	r22
    1d02:	bf 92       	push	r11
    1d04:	af 92       	push	r10
    1d06:	5f 93       	push	r21
    1d08:	4f 93       	push	r20
    1d0a:	d5 01       	movw	r26, r10
    1d0c:	55 d1       	rcall	.+682    	; 0x1fb8 <__umulhisi3>
    1d0e:	8b 01       	movw	r16, r22
    1d10:	ac 01       	movw	r20, r24
    1d12:	d7 01       	movw	r26, r14
    1d14:	51 d1       	rcall	.+674    	; 0x1fb8 <__umulhisi3>
    1d16:	eb 01       	movw	r28, r22
    1d18:	e8 0f       	add	r30, r24
    1d1a:	f9 1f       	adc	r31, r25
    1d1c:	d6 01       	movw	r26, r12
    1d1e:	1f d0       	rcall	.+62     	; 0x1d5e <__muldi3_6>
    1d20:	2f 91       	pop	r18
    1d22:	3f 91       	pop	r19
    1d24:	d6 01       	movw	r26, r12
    1d26:	48 d1       	rcall	.+656    	; 0x1fb8 <__umulhisi3>
    1d28:	c6 0f       	add	r28, r22
    1d2a:	d7 1f       	adc	r29, r23
    1d2c:	e8 1f       	adc	r30, r24
    1d2e:	f9 1f       	adc	r31, r25
    1d30:	af 91       	pop	r26
    1d32:	bf 91       	pop	r27
    1d34:	14 d0       	rcall	.+40     	; 0x1d5e <__muldi3_6>
    1d36:	2f 91       	pop	r18
    1d38:	3f 91       	pop	r19
    1d3a:	3e d1       	rcall	.+636    	; 0x1fb8 <__umulhisi3>
    1d3c:	c6 0f       	add	r28, r22
    1d3e:	d7 1f       	adc	r29, r23
    1d40:	e8 1f       	adc	r30, r24
    1d42:	f9 1f       	adc	r31, r25
    1d44:	d6 01       	movw	r26, r12
    1d46:	38 d1       	rcall	.+624    	; 0x1fb8 <__umulhisi3>
    1d48:	e6 0f       	add	r30, r22
    1d4a:	f7 1f       	adc	r31, r23
    1d4c:	98 01       	movw	r18, r16
    1d4e:	be 01       	movw	r22, r28
    1d50:	cf 01       	movw	r24, r30
    1d52:	11 24       	eor	r1, r1
    1d54:	0f 91       	pop	r16
    1d56:	1f 91       	pop	r17
    1d58:	cf 91       	pop	r28
    1d5a:	df 91       	pop	r29
    1d5c:	08 95       	ret

00001d5e <__muldi3_6>:
    1d5e:	2c d1       	rcall	.+600    	; 0x1fb8 <__umulhisi3>
    1d60:	46 0f       	add	r20, r22
    1d62:	57 1f       	adc	r21, r23
    1d64:	c8 1f       	adc	r28, r24
    1d66:	d9 1f       	adc	r29, r25
    1d68:	08 f4       	brcc	.+2      	; 0x1d6c <__muldi3_6+0xe>
    1d6a:	31 96       	adiw	r30, 0x01	; 1
    1d6c:	08 95       	ret

00001d6e <__moddi3>:
    1d6e:	68 94       	set
    1d70:	01 c0       	rjmp	.+2      	; 0x1d74 <__divdi3_moddi3>

00001d72 <__divdi3>:
    1d72:	e8 94       	clt

00001d74 <__divdi3_moddi3>:
    1d74:	f9 2f       	mov	r31, r25
    1d76:	f1 2b       	or	r31, r17
    1d78:	0a f0       	brmi	.+2      	; 0x1d7c <__divdi3_moddi3+0x8>
    1d7a:	27 c0       	rjmp	.+78     	; 0x1dca <__udivdi3_umoddi3>
    1d7c:	a0 e0       	ldi	r26, 0x00	; 0
    1d7e:	b0 e0       	ldi	r27, 0x00	; 0
    1d80:	e3 ec       	ldi	r30, 0xC3	; 195
    1d82:	fe e0       	ldi	r31, 0x0E	; 14
    1d84:	93 c0       	rjmp	.+294    	; 0x1eac <__prologue_saves__+0xc>
    1d86:	09 2e       	mov	r0, r25
    1d88:	05 94       	asr	r0
    1d8a:	1a f4       	brpl	.+6      	; 0x1d92 <__divdi3_moddi3+0x1e>
    1d8c:	79 d0       	rcall	.+242    	; 0x1e80 <__negdi2>
    1d8e:	11 23       	and	r17, r17
    1d90:	92 f4       	brpl	.+36     	; 0x1db6 <__divdi3_moddi3+0x42>
    1d92:	f0 e8       	ldi	r31, 0x80	; 128
    1d94:	0f 26       	eor	r0, r31
    1d96:	ff ef       	ldi	r31, 0xFF	; 255
    1d98:	e0 94       	com	r14
    1d9a:	f0 94       	com	r15
    1d9c:	00 95       	com	r16
    1d9e:	10 95       	com	r17
    1da0:	b0 94       	com	r11
    1da2:	c0 94       	com	r12
    1da4:	d0 94       	com	r13
    1da6:	a1 94       	neg	r10
    1da8:	bf 0a       	sbc	r11, r31
    1daa:	cf 0a       	sbc	r12, r31
    1dac:	df 0a       	sbc	r13, r31
    1dae:	ef 0a       	sbc	r14, r31
    1db0:	ff 0a       	sbc	r15, r31
    1db2:	0f 0b       	sbc	r16, r31
    1db4:	1f 0b       	sbc	r17, r31
    1db6:	13 d0       	rcall	.+38     	; 0x1dde <__udivmod64>
    1db8:	07 fc       	sbrc	r0, 7
    1dba:	62 d0       	rcall	.+196    	; 0x1e80 <__negdi2>
    1dbc:	cd b7       	in	r28, 0x3d	; 61
    1dbe:	de b7       	in	r29, 0x3e	; 62
    1dc0:	ec e0       	ldi	r30, 0x0C	; 12
    1dc2:	90 c0       	rjmp	.+288    	; 0x1ee4 <__epilogue_restores__+0xc>

00001dc4 <__umoddi3>:
    1dc4:	68 94       	set
    1dc6:	01 c0       	rjmp	.+2      	; 0x1dca <__udivdi3_umoddi3>

00001dc8 <__udivdi3>:
    1dc8:	e8 94       	clt

00001dca <__udivdi3_umoddi3>:
    1dca:	8f 92       	push	r8
    1dcc:	9f 92       	push	r9
    1dce:	cf 93       	push	r28
    1dd0:	df 93       	push	r29
    1dd2:	05 d0       	rcall	.+10     	; 0x1dde <__udivmod64>
    1dd4:	df 91       	pop	r29
    1dd6:	cf 91       	pop	r28
    1dd8:	9f 90       	pop	r9
    1dda:	8f 90       	pop	r8
    1ddc:	08 95       	ret

00001dde <__udivmod64>:
    1dde:	88 24       	eor	r8, r8
    1de0:	99 24       	eor	r9, r9
    1de2:	f4 01       	movw	r30, r8
    1de4:	e4 01       	movw	r28, r8
    1de6:	b0 e4       	ldi	r27, 0x40	; 64
    1de8:	9f 93       	push	r25
    1dea:	aa 27       	eor	r26, r26
    1dec:	9a 15       	cp	r25, r10
    1dee:	8b 04       	cpc	r8, r11
    1df0:	9c 04       	cpc	r9, r12
    1df2:	ed 05       	cpc	r30, r13
    1df4:	fe 05       	cpc	r31, r14
    1df6:	cf 05       	cpc	r28, r15
    1df8:	d0 07       	cpc	r29, r16
    1dfa:	a1 07       	cpc	r26, r17
    1dfc:	98 f4       	brcc	.+38     	; 0x1e24 <__udivmod64+0x46>
    1dfe:	ad 2f       	mov	r26, r29
    1e00:	dc 2f       	mov	r29, r28
    1e02:	cf 2f       	mov	r28, r31
    1e04:	fe 2f       	mov	r31, r30
    1e06:	e9 2d       	mov	r30, r9
    1e08:	98 2c       	mov	r9, r8
    1e0a:	89 2e       	mov	r8, r25
    1e0c:	98 2f       	mov	r25, r24
    1e0e:	87 2f       	mov	r24, r23
    1e10:	76 2f       	mov	r23, r22
    1e12:	65 2f       	mov	r22, r21
    1e14:	54 2f       	mov	r21, r20
    1e16:	43 2f       	mov	r20, r19
    1e18:	32 2f       	mov	r19, r18
    1e1a:	22 27       	eor	r18, r18
    1e1c:	b8 50       	subi	r27, 0x08	; 8
    1e1e:	31 f7       	brne	.-52     	; 0x1dec <__udivmod64+0xe>
    1e20:	bf 91       	pop	r27
    1e22:	27 c0       	rjmp	.+78     	; 0x1e72 <__udivmod64+0x94>
    1e24:	1b 2e       	mov	r1, r27
    1e26:	bf 91       	pop	r27
    1e28:	bb 27       	eor	r27, r27
    1e2a:	22 0f       	add	r18, r18
    1e2c:	33 1f       	adc	r19, r19
    1e2e:	44 1f       	adc	r20, r20
    1e30:	55 1f       	adc	r21, r21
    1e32:	66 1f       	adc	r22, r22
    1e34:	77 1f       	adc	r23, r23
    1e36:	88 1f       	adc	r24, r24
    1e38:	99 1f       	adc	r25, r25
    1e3a:	88 1c       	adc	r8, r8
    1e3c:	99 1c       	adc	r9, r9
    1e3e:	ee 1f       	adc	r30, r30
    1e40:	ff 1f       	adc	r31, r31
    1e42:	cc 1f       	adc	r28, r28
    1e44:	dd 1f       	adc	r29, r29
    1e46:	aa 1f       	adc	r26, r26
    1e48:	bb 1f       	adc	r27, r27
    1e4a:	8a 14       	cp	r8, r10
    1e4c:	9b 04       	cpc	r9, r11
    1e4e:	ec 05       	cpc	r30, r12
    1e50:	fd 05       	cpc	r31, r13
    1e52:	ce 05       	cpc	r28, r14
    1e54:	df 05       	cpc	r29, r15
    1e56:	a0 07       	cpc	r26, r16
    1e58:	b1 07       	cpc	r27, r17
    1e5a:	48 f0       	brcs	.+18     	; 0x1e6e <__udivmod64+0x90>
    1e5c:	8a 18       	sub	r8, r10
    1e5e:	9b 08       	sbc	r9, r11
    1e60:	ec 09       	sbc	r30, r12
    1e62:	fd 09       	sbc	r31, r13
    1e64:	ce 09       	sbc	r28, r14
    1e66:	df 09       	sbc	r29, r15
    1e68:	a0 0b       	sbc	r26, r16
    1e6a:	b1 0b       	sbc	r27, r17
    1e6c:	21 60       	ori	r18, 0x01	; 1
    1e6e:	1a 94       	dec	r1
    1e70:	e1 f6       	brne	.-72     	; 0x1e2a <__udivmod64+0x4c>
    1e72:	2e f4       	brtc	.+10     	; 0x1e7e <__udivmod64+0xa0>
    1e74:	94 01       	movw	r18, r8
    1e76:	af 01       	movw	r20, r30
    1e78:	be 01       	movw	r22, r28
    1e7a:	cd 01       	movw	r24, r26
    1e7c:	00 0c       	add	r0, r0
    1e7e:	08 95       	ret

00001e80 <__negdi2>:
    1e80:	60 95       	com	r22
    1e82:	70 95       	com	r23
    1e84:	80 95       	com	r24
    1e86:	90 95       	com	r25
    1e88:	30 95       	com	r19
    1e8a:	40 95       	com	r20
    1e8c:	50 95       	com	r21
    1e8e:	21 95       	neg	r18
    1e90:	3f 4f       	sbci	r19, 0xFF	; 255
    1e92:	4f 4f       	sbci	r20, 0xFF	; 255
    1e94:	5f 4f       	sbci	r21, 0xFF	; 255
    1e96:	6f 4f       	sbci	r22, 0xFF	; 255
    1e98:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9a:	8f 4f       	sbci	r24, 0xFF	; 255
    1e9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e9e:	08 95       	ret

00001ea0 <__prologue_saves__>:
    1ea0:	2f 92       	push	r2
    1ea2:	3f 92       	push	r3
    1ea4:	4f 92       	push	r4
    1ea6:	5f 92       	push	r5
    1ea8:	6f 92       	push	r6
    1eaa:	7f 92       	push	r7
    1eac:	8f 92       	push	r8
    1eae:	9f 92       	push	r9
    1eb0:	af 92       	push	r10
    1eb2:	bf 92       	push	r11
    1eb4:	cf 92       	push	r12
    1eb6:	df 92       	push	r13
    1eb8:	ef 92       	push	r14
    1eba:	ff 92       	push	r15
    1ebc:	0f 93       	push	r16
    1ebe:	1f 93       	push	r17
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	cd b7       	in	r28, 0x3d	; 61
    1ec6:	de b7       	in	r29, 0x3e	; 62
    1ec8:	ca 1b       	sub	r28, r26
    1eca:	db 0b       	sbc	r29, r27
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	de bf       	out	0x3e, r29	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	cd bf       	out	0x3d, r28	; 61
    1ed6:	09 94       	ijmp

00001ed8 <__epilogue_restores__>:
    1ed8:	2a 88       	ldd	r2, Y+18	; 0x12
    1eda:	39 88       	ldd	r3, Y+17	; 0x11
    1edc:	48 88       	ldd	r4, Y+16	; 0x10
    1ede:	5f 84       	ldd	r5, Y+15	; 0x0f
    1ee0:	6e 84       	ldd	r6, Y+14	; 0x0e
    1ee2:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ee4:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ee6:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ee8:	aa 84       	ldd	r10, Y+10	; 0x0a
    1eea:	b9 84       	ldd	r11, Y+9	; 0x09
    1eec:	c8 84       	ldd	r12, Y+8	; 0x08
    1eee:	df 80       	ldd	r13, Y+7	; 0x07
    1ef0:	ee 80       	ldd	r14, Y+6	; 0x06
    1ef2:	fd 80       	ldd	r15, Y+5	; 0x05
    1ef4:	0c 81       	ldd	r16, Y+4	; 0x04
    1ef6:	1b 81       	ldd	r17, Y+3	; 0x03
    1ef8:	aa 81       	ldd	r26, Y+2	; 0x02
    1efa:	b9 81       	ldd	r27, Y+1	; 0x01
    1efc:	ce 0f       	add	r28, r30
    1efe:	d1 1d       	adc	r29, r1
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	de bf       	out	0x3e, r29	; 62
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	cd bf       	out	0x3d, r28	; 61
    1f0a:	ed 01       	movw	r28, r26
    1f0c:	08 95       	ret

00001f0e <__ashldi3>:
    1f0e:	0f 93       	push	r16
    1f10:	08 30       	cpi	r16, 0x08	; 8
    1f12:	90 f0       	brcs	.+36     	; 0x1f38 <__ashldi3+0x2a>
    1f14:	98 2f       	mov	r25, r24
    1f16:	87 2f       	mov	r24, r23
    1f18:	76 2f       	mov	r23, r22
    1f1a:	65 2f       	mov	r22, r21
    1f1c:	54 2f       	mov	r21, r20
    1f1e:	43 2f       	mov	r20, r19
    1f20:	32 2f       	mov	r19, r18
    1f22:	22 27       	eor	r18, r18
    1f24:	08 50       	subi	r16, 0x08	; 8
    1f26:	f4 cf       	rjmp	.-24     	; 0x1f10 <__ashldi3+0x2>
    1f28:	22 0f       	add	r18, r18
    1f2a:	33 1f       	adc	r19, r19
    1f2c:	44 1f       	adc	r20, r20
    1f2e:	55 1f       	adc	r21, r21
    1f30:	66 1f       	adc	r22, r22
    1f32:	77 1f       	adc	r23, r23
    1f34:	88 1f       	adc	r24, r24
    1f36:	99 1f       	adc	r25, r25
    1f38:	0a 95       	dec	r16
    1f3a:	b2 f7       	brpl	.-20     	; 0x1f28 <__ashldi3+0x1a>
    1f3c:	0f 91       	pop	r16
    1f3e:	08 95       	ret

00001f40 <__ashrdi3>:
    1f40:	97 fb       	bst	r25, 7
    1f42:	10 f8       	bld	r1, 0

00001f44 <__lshrdi3>:
    1f44:	16 94       	lsr	r1
    1f46:	00 08       	sbc	r0, r0
    1f48:	0f 93       	push	r16
    1f4a:	08 30       	cpi	r16, 0x08	; 8
    1f4c:	98 f0       	brcs	.+38     	; 0x1f74 <__lshrdi3+0x30>
    1f4e:	08 50       	subi	r16, 0x08	; 8
    1f50:	23 2f       	mov	r18, r19
    1f52:	34 2f       	mov	r19, r20
    1f54:	45 2f       	mov	r20, r21
    1f56:	56 2f       	mov	r21, r22
    1f58:	67 2f       	mov	r22, r23
    1f5a:	78 2f       	mov	r23, r24
    1f5c:	89 2f       	mov	r24, r25
    1f5e:	90 2d       	mov	r25, r0
    1f60:	f4 cf       	rjmp	.-24     	; 0x1f4a <__lshrdi3+0x6>
    1f62:	05 94       	asr	r0
    1f64:	97 95       	ror	r25
    1f66:	87 95       	ror	r24
    1f68:	77 95       	ror	r23
    1f6a:	67 95       	ror	r22
    1f6c:	57 95       	ror	r21
    1f6e:	47 95       	ror	r20
    1f70:	37 95       	ror	r19
    1f72:	27 95       	ror	r18
    1f74:	0a 95       	dec	r16
    1f76:	aa f7       	brpl	.-22     	; 0x1f62 <__lshrdi3+0x1e>
    1f78:	0f 91       	pop	r16
    1f7a:	08 95       	ret

00001f7c <__adddi3>:
    1f7c:	2a 0d       	add	r18, r10
    1f7e:	3b 1d       	adc	r19, r11
    1f80:	4c 1d       	adc	r20, r12
    1f82:	5d 1d       	adc	r21, r13
    1f84:	6e 1d       	adc	r22, r14
    1f86:	7f 1d       	adc	r23, r15
    1f88:	80 1f       	adc	r24, r16
    1f8a:	91 1f       	adc	r25, r17
    1f8c:	08 95       	ret

00001f8e <__subdi3>:
    1f8e:	2a 19       	sub	r18, r10
    1f90:	3b 09       	sbc	r19, r11
    1f92:	4c 09       	sbc	r20, r12
    1f94:	5d 09       	sbc	r21, r13
    1f96:	6e 09       	sbc	r22, r14
    1f98:	7f 09       	sbc	r23, r15
    1f9a:	80 0b       	sbc	r24, r16
    1f9c:	91 0b       	sbc	r25, r17
    1f9e:	08 95       	ret

00001fa0 <__cmpdi2_s8>:
    1fa0:	00 24       	eor	r0, r0
    1fa2:	a7 fd       	sbrc	r26, 7
    1fa4:	00 94       	com	r0
    1fa6:	2a 17       	cp	r18, r26
    1fa8:	30 05       	cpc	r19, r0
    1faa:	40 05       	cpc	r20, r0
    1fac:	50 05       	cpc	r21, r0
    1fae:	60 05       	cpc	r22, r0
    1fb0:	70 05       	cpc	r23, r0
    1fb2:	80 05       	cpc	r24, r0
    1fb4:	90 05       	cpc	r25, r0
    1fb6:	08 95       	ret

00001fb8 <__umulhisi3>:
    1fb8:	a2 9f       	mul	r26, r18
    1fba:	b0 01       	movw	r22, r0
    1fbc:	b3 9f       	mul	r27, r19
    1fbe:	c0 01       	movw	r24, r0
    1fc0:	a3 9f       	mul	r26, r19
    1fc2:	70 0d       	add	r23, r0
    1fc4:	81 1d       	adc	r24, r1
    1fc6:	11 24       	eor	r1, r1
    1fc8:	91 1d       	adc	r25, r1
    1fca:	b2 9f       	mul	r27, r18
    1fcc:	70 0d       	add	r23, r0
    1fce:	81 1d       	adc	r24, r1
    1fd0:	11 24       	eor	r1, r1
    1fd2:	91 1d       	adc	r25, r1
    1fd4:	08 95       	ret

00001fd6 <printf>:
    1fd6:	cf 93       	push	r28
    1fd8:	df 93       	push	r29
    1fda:	cd b7       	in	r28, 0x3d	; 61
    1fdc:	de b7       	in	r29, 0x3e	; 62
    1fde:	ae 01       	movw	r20, r28
    1fe0:	4b 5f       	subi	r20, 0xFB	; 251
    1fe2:	5f 4f       	sbci	r21, 0xFF	; 255
    1fe4:	fa 01       	movw	r30, r20
    1fe6:	61 91       	ld	r22, Z+
    1fe8:	71 91       	ld	r23, Z+
    1fea:	af 01       	movw	r20, r30
    1fec:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <__iob+0x2>
    1ff0:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <__iob+0x3>
    1ff4:	03 d0       	rcall	.+6      	; 0x1ffc <vfprintf>
    1ff6:	df 91       	pop	r29
    1ff8:	cf 91       	pop	r28
    1ffa:	08 95       	ret

00001ffc <vfprintf>:
    1ffc:	2f 92       	push	r2
    1ffe:	3f 92       	push	r3
    2000:	4f 92       	push	r4
    2002:	5f 92       	push	r5
    2004:	6f 92       	push	r6
    2006:	7f 92       	push	r7
    2008:	8f 92       	push	r8
    200a:	9f 92       	push	r9
    200c:	af 92       	push	r10
    200e:	bf 92       	push	r11
    2010:	cf 92       	push	r12
    2012:	df 92       	push	r13
    2014:	ef 92       	push	r14
    2016:	ff 92       	push	r15
    2018:	0f 93       	push	r16
    201a:	1f 93       	push	r17
    201c:	cf 93       	push	r28
    201e:	df 93       	push	r29
    2020:	cd b7       	in	r28, 0x3d	; 61
    2022:	de b7       	in	r29, 0x3e	; 62
    2024:	2c 97       	sbiw	r28, 0x0c	; 12
    2026:	0f b6       	in	r0, 0x3f	; 63
    2028:	f8 94       	cli
    202a:	de bf       	out	0x3e, r29	; 62
    202c:	0f be       	out	0x3f, r0	; 63
    202e:	cd bf       	out	0x3d, r28	; 61
    2030:	7c 01       	movw	r14, r24
    2032:	6b 01       	movw	r12, r22
    2034:	8a 01       	movw	r16, r20
    2036:	fc 01       	movw	r30, r24
    2038:	17 82       	std	Z+7, r1	; 0x07
    203a:	16 82       	std	Z+6, r1	; 0x06
    203c:	83 81       	ldd	r24, Z+3	; 0x03
    203e:	81 ff       	sbrs	r24, 1
    2040:	b0 c1       	rjmp	.+864    	; 0x23a2 <vfprintf+0x3a6>
    2042:	ce 01       	movw	r24, r28
    2044:	01 96       	adiw	r24, 0x01	; 1
    2046:	4c 01       	movw	r8, r24
    2048:	f7 01       	movw	r30, r14
    204a:	93 81       	ldd	r25, Z+3	; 0x03
    204c:	f6 01       	movw	r30, r12
    204e:	93 fd       	sbrc	r25, 3
    2050:	85 91       	lpm	r24, Z+
    2052:	93 ff       	sbrs	r25, 3
    2054:	81 91       	ld	r24, Z+
    2056:	6f 01       	movw	r12, r30
    2058:	88 23       	and	r24, r24
    205a:	09 f4       	brne	.+2      	; 0x205e <vfprintf+0x62>
    205c:	9e c1       	rjmp	.+828    	; 0x239a <vfprintf+0x39e>
    205e:	85 32       	cpi	r24, 0x25	; 37
    2060:	39 f4       	brne	.+14     	; 0x2070 <vfprintf+0x74>
    2062:	93 fd       	sbrc	r25, 3
    2064:	85 91       	lpm	r24, Z+
    2066:	93 ff       	sbrs	r25, 3
    2068:	81 91       	ld	r24, Z+
    206a:	6f 01       	movw	r12, r30
    206c:	85 32       	cpi	r24, 0x25	; 37
    206e:	21 f4       	brne	.+8      	; 0x2078 <vfprintf+0x7c>
    2070:	b7 01       	movw	r22, r14
    2072:	90 e0       	ldi	r25, 0x00	; 0
    2074:	c7 d1       	rcall	.+910    	; 0x2404 <fputc>
    2076:	e8 cf       	rjmp	.-48     	; 0x2048 <vfprintf+0x4c>
    2078:	51 2c       	mov	r5, r1
    207a:	31 2c       	mov	r3, r1
    207c:	20 e0       	ldi	r18, 0x00	; 0
    207e:	20 32       	cpi	r18, 0x20	; 32
    2080:	a0 f4       	brcc	.+40     	; 0x20aa <vfprintf+0xae>
    2082:	8b 32       	cpi	r24, 0x2B	; 43
    2084:	69 f0       	breq	.+26     	; 0x20a0 <vfprintf+0xa4>
    2086:	30 f4       	brcc	.+12     	; 0x2094 <vfprintf+0x98>
    2088:	80 32       	cpi	r24, 0x20	; 32
    208a:	59 f0       	breq	.+22     	; 0x20a2 <vfprintf+0xa6>
    208c:	83 32       	cpi	r24, 0x23	; 35
    208e:	69 f4       	brne	.+26     	; 0x20aa <vfprintf+0xae>
    2090:	20 61       	ori	r18, 0x10	; 16
    2092:	2c c0       	rjmp	.+88     	; 0x20ec <vfprintf+0xf0>
    2094:	8d 32       	cpi	r24, 0x2D	; 45
    2096:	39 f0       	breq	.+14     	; 0x20a6 <vfprintf+0xaa>
    2098:	80 33       	cpi	r24, 0x30	; 48
    209a:	39 f4       	brne	.+14     	; 0x20aa <vfprintf+0xae>
    209c:	21 60       	ori	r18, 0x01	; 1
    209e:	26 c0       	rjmp	.+76     	; 0x20ec <vfprintf+0xf0>
    20a0:	22 60       	ori	r18, 0x02	; 2
    20a2:	24 60       	ori	r18, 0x04	; 4
    20a4:	23 c0       	rjmp	.+70     	; 0x20ec <vfprintf+0xf0>
    20a6:	28 60       	ori	r18, 0x08	; 8
    20a8:	21 c0       	rjmp	.+66     	; 0x20ec <vfprintf+0xf0>
    20aa:	27 fd       	sbrc	r18, 7
    20ac:	27 c0       	rjmp	.+78     	; 0x20fc <vfprintf+0x100>
    20ae:	30 ed       	ldi	r19, 0xD0	; 208
    20b0:	38 0f       	add	r19, r24
    20b2:	3a 30       	cpi	r19, 0x0A	; 10
    20b4:	78 f4       	brcc	.+30     	; 0x20d4 <vfprintf+0xd8>
    20b6:	26 ff       	sbrs	r18, 6
    20b8:	06 c0       	rjmp	.+12     	; 0x20c6 <vfprintf+0xca>
    20ba:	fa e0       	ldi	r31, 0x0A	; 10
    20bc:	5f 9e       	mul	r5, r31
    20be:	30 0d       	add	r19, r0
    20c0:	11 24       	eor	r1, r1
    20c2:	53 2e       	mov	r5, r19
    20c4:	13 c0       	rjmp	.+38     	; 0x20ec <vfprintf+0xf0>
    20c6:	8a e0       	ldi	r24, 0x0A	; 10
    20c8:	38 9e       	mul	r3, r24
    20ca:	30 0d       	add	r19, r0
    20cc:	11 24       	eor	r1, r1
    20ce:	33 2e       	mov	r3, r19
    20d0:	20 62       	ori	r18, 0x20	; 32
    20d2:	0c c0       	rjmp	.+24     	; 0x20ec <vfprintf+0xf0>
    20d4:	8e 32       	cpi	r24, 0x2E	; 46
    20d6:	21 f4       	brne	.+8      	; 0x20e0 <vfprintf+0xe4>
    20d8:	26 fd       	sbrc	r18, 6
    20da:	5f c1       	rjmp	.+702    	; 0x239a <vfprintf+0x39e>
    20dc:	20 64       	ori	r18, 0x40	; 64
    20de:	06 c0       	rjmp	.+12     	; 0x20ec <vfprintf+0xf0>
    20e0:	8c 36       	cpi	r24, 0x6C	; 108
    20e2:	11 f4       	brne	.+4      	; 0x20e8 <vfprintf+0xec>
    20e4:	20 68       	ori	r18, 0x80	; 128
    20e6:	02 c0       	rjmp	.+4      	; 0x20ec <vfprintf+0xf0>
    20e8:	88 36       	cpi	r24, 0x68	; 104
    20ea:	41 f4       	brne	.+16     	; 0x20fc <vfprintf+0x100>
    20ec:	f6 01       	movw	r30, r12
    20ee:	93 fd       	sbrc	r25, 3
    20f0:	85 91       	lpm	r24, Z+
    20f2:	93 ff       	sbrs	r25, 3
    20f4:	81 91       	ld	r24, Z+
    20f6:	6f 01       	movw	r12, r30
    20f8:	81 11       	cpse	r24, r1
    20fa:	c1 cf       	rjmp	.-126    	; 0x207e <vfprintf+0x82>
    20fc:	98 2f       	mov	r25, r24
    20fe:	9f 7d       	andi	r25, 0xDF	; 223
    2100:	95 54       	subi	r25, 0x45	; 69
    2102:	93 30       	cpi	r25, 0x03	; 3
    2104:	28 f4       	brcc	.+10     	; 0x2110 <vfprintf+0x114>
    2106:	0c 5f       	subi	r16, 0xFC	; 252
    2108:	1f 4f       	sbci	r17, 0xFF	; 255
    210a:	ff e3       	ldi	r31, 0x3F	; 63
    210c:	f9 83       	std	Y+1, r31	; 0x01
    210e:	0d c0       	rjmp	.+26     	; 0x212a <vfprintf+0x12e>
    2110:	83 36       	cpi	r24, 0x63	; 99
    2112:	31 f0       	breq	.+12     	; 0x2120 <vfprintf+0x124>
    2114:	83 37       	cpi	r24, 0x73	; 115
    2116:	71 f0       	breq	.+28     	; 0x2134 <vfprintf+0x138>
    2118:	83 35       	cpi	r24, 0x53	; 83
    211a:	09 f0       	breq	.+2      	; 0x211e <vfprintf+0x122>
    211c:	57 c0       	rjmp	.+174    	; 0x21cc <vfprintf+0x1d0>
    211e:	21 c0       	rjmp	.+66     	; 0x2162 <vfprintf+0x166>
    2120:	f8 01       	movw	r30, r16
    2122:	80 81       	ld	r24, Z
    2124:	89 83       	std	Y+1, r24	; 0x01
    2126:	0e 5f       	subi	r16, 0xFE	; 254
    2128:	1f 4f       	sbci	r17, 0xFF	; 255
    212a:	44 24       	eor	r4, r4
    212c:	43 94       	inc	r4
    212e:	51 2c       	mov	r5, r1
    2130:	54 01       	movw	r10, r8
    2132:	14 c0       	rjmp	.+40     	; 0x215c <vfprintf+0x160>
    2134:	38 01       	movw	r6, r16
    2136:	f2 e0       	ldi	r31, 0x02	; 2
    2138:	6f 0e       	add	r6, r31
    213a:	71 1c       	adc	r7, r1
    213c:	f8 01       	movw	r30, r16
    213e:	a0 80       	ld	r10, Z
    2140:	b1 80       	ldd	r11, Z+1	; 0x01
    2142:	26 ff       	sbrs	r18, 6
    2144:	03 c0       	rjmp	.+6      	; 0x214c <vfprintf+0x150>
    2146:	65 2d       	mov	r22, r5
    2148:	70 e0       	ldi	r23, 0x00	; 0
    214a:	02 c0       	rjmp	.+4      	; 0x2150 <vfprintf+0x154>
    214c:	6f ef       	ldi	r22, 0xFF	; 255
    214e:	7f ef       	ldi	r23, 0xFF	; 255
    2150:	c5 01       	movw	r24, r10
    2152:	2c 87       	std	Y+12, r18	; 0x0c
    2154:	4c d1       	rcall	.+664    	; 0x23ee <strnlen>
    2156:	2c 01       	movw	r4, r24
    2158:	83 01       	movw	r16, r6
    215a:	2c 85       	ldd	r18, Y+12	; 0x0c
    215c:	2f 77       	andi	r18, 0x7F	; 127
    215e:	22 2e       	mov	r2, r18
    2160:	16 c0       	rjmp	.+44     	; 0x218e <vfprintf+0x192>
    2162:	38 01       	movw	r6, r16
    2164:	f2 e0       	ldi	r31, 0x02	; 2
    2166:	6f 0e       	add	r6, r31
    2168:	71 1c       	adc	r7, r1
    216a:	f8 01       	movw	r30, r16
    216c:	a0 80       	ld	r10, Z
    216e:	b1 80       	ldd	r11, Z+1	; 0x01
    2170:	26 ff       	sbrs	r18, 6
    2172:	03 c0       	rjmp	.+6      	; 0x217a <vfprintf+0x17e>
    2174:	65 2d       	mov	r22, r5
    2176:	70 e0       	ldi	r23, 0x00	; 0
    2178:	02 c0       	rjmp	.+4      	; 0x217e <vfprintf+0x182>
    217a:	6f ef       	ldi	r22, 0xFF	; 255
    217c:	7f ef       	ldi	r23, 0xFF	; 255
    217e:	c5 01       	movw	r24, r10
    2180:	2c 87       	std	Y+12, r18	; 0x0c
    2182:	2a d1       	rcall	.+596    	; 0x23d8 <strnlen_P>
    2184:	2c 01       	movw	r4, r24
    2186:	2c 85       	ldd	r18, Y+12	; 0x0c
    2188:	20 68       	ori	r18, 0x80	; 128
    218a:	22 2e       	mov	r2, r18
    218c:	83 01       	movw	r16, r6
    218e:	23 fc       	sbrc	r2, 3
    2190:	19 c0       	rjmp	.+50     	; 0x21c4 <vfprintf+0x1c8>
    2192:	83 2d       	mov	r24, r3
    2194:	90 e0       	ldi	r25, 0x00	; 0
    2196:	48 16       	cp	r4, r24
    2198:	59 06       	cpc	r5, r25
    219a:	a0 f4       	brcc	.+40     	; 0x21c4 <vfprintf+0x1c8>
    219c:	b7 01       	movw	r22, r14
    219e:	80 e2       	ldi	r24, 0x20	; 32
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	30 d1       	rcall	.+608    	; 0x2404 <fputc>
    21a4:	3a 94       	dec	r3
    21a6:	f5 cf       	rjmp	.-22     	; 0x2192 <vfprintf+0x196>
    21a8:	f5 01       	movw	r30, r10
    21aa:	27 fc       	sbrc	r2, 7
    21ac:	85 91       	lpm	r24, Z+
    21ae:	27 fe       	sbrs	r2, 7
    21b0:	81 91       	ld	r24, Z+
    21b2:	5f 01       	movw	r10, r30
    21b4:	b7 01       	movw	r22, r14
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	25 d1       	rcall	.+586    	; 0x2404 <fputc>
    21ba:	31 10       	cpse	r3, r1
    21bc:	3a 94       	dec	r3
    21be:	f1 e0       	ldi	r31, 0x01	; 1
    21c0:	4f 1a       	sub	r4, r31
    21c2:	51 08       	sbc	r5, r1
    21c4:	41 14       	cp	r4, r1
    21c6:	51 04       	cpc	r5, r1
    21c8:	79 f7       	brne	.-34     	; 0x21a8 <vfprintf+0x1ac>
    21ca:	de c0       	rjmp	.+444    	; 0x2388 <vfprintf+0x38c>
    21cc:	84 36       	cpi	r24, 0x64	; 100
    21ce:	11 f0       	breq	.+4      	; 0x21d4 <vfprintf+0x1d8>
    21d0:	89 36       	cpi	r24, 0x69	; 105
    21d2:	31 f5       	brne	.+76     	; 0x2220 <vfprintf+0x224>
    21d4:	f8 01       	movw	r30, r16
    21d6:	27 ff       	sbrs	r18, 7
    21d8:	07 c0       	rjmp	.+14     	; 0x21e8 <vfprintf+0x1ec>
    21da:	60 81       	ld	r22, Z
    21dc:	71 81       	ldd	r23, Z+1	; 0x01
    21de:	82 81       	ldd	r24, Z+2	; 0x02
    21e0:	93 81       	ldd	r25, Z+3	; 0x03
    21e2:	0c 5f       	subi	r16, 0xFC	; 252
    21e4:	1f 4f       	sbci	r17, 0xFF	; 255
    21e6:	08 c0       	rjmp	.+16     	; 0x21f8 <vfprintf+0x1fc>
    21e8:	60 81       	ld	r22, Z
    21ea:	71 81       	ldd	r23, Z+1	; 0x01
    21ec:	07 2e       	mov	r0, r23
    21ee:	00 0c       	add	r0, r0
    21f0:	88 0b       	sbc	r24, r24
    21f2:	99 0b       	sbc	r25, r25
    21f4:	0e 5f       	subi	r16, 0xFE	; 254
    21f6:	1f 4f       	sbci	r17, 0xFF	; 255
    21f8:	2f 76       	andi	r18, 0x6F	; 111
    21fa:	72 2e       	mov	r7, r18
    21fc:	97 ff       	sbrs	r25, 7
    21fe:	09 c0       	rjmp	.+18     	; 0x2212 <vfprintf+0x216>
    2200:	90 95       	com	r25
    2202:	80 95       	com	r24
    2204:	70 95       	com	r23
    2206:	61 95       	neg	r22
    2208:	7f 4f       	sbci	r23, 0xFF	; 255
    220a:	8f 4f       	sbci	r24, 0xFF	; 255
    220c:	9f 4f       	sbci	r25, 0xFF	; 255
    220e:	20 68       	ori	r18, 0x80	; 128
    2210:	72 2e       	mov	r7, r18
    2212:	2a e0       	ldi	r18, 0x0A	; 10
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	a4 01       	movw	r20, r8
    2218:	2d d1       	rcall	.+602    	; 0x2474 <__ultoa_invert>
    221a:	a8 2e       	mov	r10, r24
    221c:	a8 18       	sub	r10, r8
    221e:	43 c0       	rjmp	.+134    	; 0x22a6 <vfprintf+0x2aa>
    2220:	85 37       	cpi	r24, 0x75	; 117
    2222:	29 f4       	brne	.+10     	; 0x222e <vfprintf+0x232>
    2224:	2f 7e       	andi	r18, 0xEF	; 239
    2226:	b2 2e       	mov	r11, r18
    2228:	2a e0       	ldi	r18, 0x0A	; 10
    222a:	30 e0       	ldi	r19, 0x00	; 0
    222c:	25 c0       	rjmp	.+74     	; 0x2278 <vfprintf+0x27c>
    222e:	f2 2f       	mov	r31, r18
    2230:	f9 7f       	andi	r31, 0xF9	; 249
    2232:	bf 2e       	mov	r11, r31
    2234:	8f 36       	cpi	r24, 0x6F	; 111
    2236:	c1 f0       	breq	.+48     	; 0x2268 <vfprintf+0x26c>
    2238:	18 f4       	brcc	.+6      	; 0x2240 <vfprintf+0x244>
    223a:	88 35       	cpi	r24, 0x58	; 88
    223c:	79 f0       	breq	.+30     	; 0x225c <vfprintf+0x260>
    223e:	ad c0       	rjmp	.+346    	; 0x239a <vfprintf+0x39e>
    2240:	80 37       	cpi	r24, 0x70	; 112
    2242:	19 f0       	breq	.+6      	; 0x224a <vfprintf+0x24e>
    2244:	88 37       	cpi	r24, 0x78	; 120
    2246:	21 f0       	breq	.+8      	; 0x2250 <vfprintf+0x254>
    2248:	a8 c0       	rjmp	.+336    	; 0x239a <vfprintf+0x39e>
    224a:	2f 2f       	mov	r18, r31
    224c:	20 61       	ori	r18, 0x10	; 16
    224e:	b2 2e       	mov	r11, r18
    2250:	b4 fe       	sbrs	r11, 4
    2252:	0d c0       	rjmp	.+26     	; 0x226e <vfprintf+0x272>
    2254:	8b 2d       	mov	r24, r11
    2256:	84 60       	ori	r24, 0x04	; 4
    2258:	b8 2e       	mov	r11, r24
    225a:	09 c0       	rjmp	.+18     	; 0x226e <vfprintf+0x272>
    225c:	24 ff       	sbrs	r18, 4
    225e:	0a c0       	rjmp	.+20     	; 0x2274 <vfprintf+0x278>
    2260:	9f 2f       	mov	r25, r31
    2262:	96 60       	ori	r25, 0x06	; 6
    2264:	b9 2e       	mov	r11, r25
    2266:	06 c0       	rjmp	.+12     	; 0x2274 <vfprintf+0x278>
    2268:	28 e0       	ldi	r18, 0x08	; 8
    226a:	30 e0       	ldi	r19, 0x00	; 0
    226c:	05 c0       	rjmp	.+10     	; 0x2278 <vfprintf+0x27c>
    226e:	20 e1       	ldi	r18, 0x10	; 16
    2270:	30 e0       	ldi	r19, 0x00	; 0
    2272:	02 c0       	rjmp	.+4      	; 0x2278 <vfprintf+0x27c>
    2274:	20 e1       	ldi	r18, 0x10	; 16
    2276:	32 e0       	ldi	r19, 0x02	; 2
    2278:	f8 01       	movw	r30, r16
    227a:	b7 fe       	sbrs	r11, 7
    227c:	07 c0       	rjmp	.+14     	; 0x228c <vfprintf+0x290>
    227e:	60 81       	ld	r22, Z
    2280:	71 81       	ldd	r23, Z+1	; 0x01
    2282:	82 81       	ldd	r24, Z+2	; 0x02
    2284:	93 81       	ldd	r25, Z+3	; 0x03
    2286:	0c 5f       	subi	r16, 0xFC	; 252
    2288:	1f 4f       	sbci	r17, 0xFF	; 255
    228a:	06 c0       	rjmp	.+12     	; 0x2298 <vfprintf+0x29c>
    228c:	60 81       	ld	r22, Z
    228e:	71 81       	ldd	r23, Z+1	; 0x01
    2290:	80 e0       	ldi	r24, 0x00	; 0
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	0e 5f       	subi	r16, 0xFE	; 254
    2296:	1f 4f       	sbci	r17, 0xFF	; 255
    2298:	a4 01       	movw	r20, r8
    229a:	ec d0       	rcall	.+472    	; 0x2474 <__ultoa_invert>
    229c:	a8 2e       	mov	r10, r24
    229e:	a8 18       	sub	r10, r8
    22a0:	fb 2d       	mov	r31, r11
    22a2:	ff 77       	andi	r31, 0x7F	; 127
    22a4:	7f 2e       	mov	r7, r31
    22a6:	76 fe       	sbrs	r7, 6
    22a8:	0b c0       	rjmp	.+22     	; 0x22c0 <vfprintf+0x2c4>
    22aa:	37 2d       	mov	r19, r7
    22ac:	3e 7f       	andi	r19, 0xFE	; 254
    22ae:	a5 14       	cp	r10, r5
    22b0:	50 f4       	brcc	.+20     	; 0x22c6 <vfprintf+0x2ca>
    22b2:	74 fe       	sbrs	r7, 4
    22b4:	0a c0       	rjmp	.+20     	; 0x22ca <vfprintf+0x2ce>
    22b6:	72 fc       	sbrc	r7, 2
    22b8:	08 c0       	rjmp	.+16     	; 0x22ca <vfprintf+0x2ce>
    22ba:	37 2d       	mov	r19, r7
    22bc:	3e 7e       	andi	r19, 0xEE	; 238
    22be:	05 c0       	rjmp	.+10     	; 0x22ca <vfprintf+0x2ce>
    22c0:	ba 2c       	mov	r11, r10
    22c2:	37 2d       	mov	r19, r7
    22c4:	03 c0       	rjmp	.+6      	; 0x22cc <vfprintf+0x2d0>
    22c6:	ba 2c       	mov	r11, r10
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <vfprintf+0x2d0>
    22ca:	b5 2c       	mov	r11, r5
    22cc:	34 ff       	sbrs	r19, 4
    22ce:	0d c0       	rjmp	.+26     	; 0x22ea <vfprintf+0x2ee>
    22d0:	fe 01       	movw	r30, r28
    22d2:	ea 0d       	add	r30, r10
    22d4:	f1 1d       	adc	r31, r1
    22d6:	80 81       	ld	r24, Z
    22d8:	80 33       	cpi	r24, 0x30	; 48
    22da:	11 f4       	brne	.+4      	; 0x22e0 <vfprintf+0x2e4>
    22dc:	39 7e       	andi	r19, 0xE9	; 233
    22de:	09 c0       	rjmp	.+18     	; 0x22f2 <vfprintf+0x2f6>
    22e0:	32 ff       	sbrs	r19, 2
    22e2:	06 c0       	rjmp	.+12     	; 0x22f0 <vfprintf+0x2f4>
    22e4:	b3 94       	inc	r11
    22e6:	b3 94       	inc	r11
    22e8:	04 c0       	rjmp	.+8      	; 0x22f2 <vfprintf+0x2f6>
    22ea:	83 2f       	mov	r24, r19
    22ec:	86 78       	andi	r24, 0x86	; 134
    22ee:	09 f0       	breq	.+2      	; 0x22f2 <vfprintf+0x2f6>
    22f0:	b3 94       	inc	r11
    22f2:	33 fd       	sbrc	r19, 3
    22f4:	12 c0       	rjmp	.+36     	; 0x231a <vfprintf+0x31e>
    22f6:	30 ff       	sbrs	r19, 0
    22f8:	06 c0       	rjmp	.+12     	; 0x2306 <vfprintf+0x30a>
    22fa:	5a 2c       	mov	r5, r10
    22fc:	b3 14       	cp	r11, r3
    22fe:	18 f4       	brcc	.+6      	; 0x2306 <vfprintf+0x30a>
    2300:	53 0c       	add	r5, r3
    2302:	5b 18       	sub	r5, r11
    2304:	b3 2c       	mov	r11, r3
    2306:	b3 14       	cp	r11, r3
    2308:	60 f4       	brcc	.+24     	; 0x2322 <vfprintf+0x326>
    230a:	b7 01       	movw	r22, r14
    230c:	80 e2       	ldi	r24, 0x20	; 32
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	3c 87       	std	Y+12, r19	; 0x0c
    2312:	78 d0       	rcall	.+240    	; 0x2404 <fputc>
    2314:	b3 94       	inc	r11
    2316:	3c 85       	ldd	r19, Y+12	; 0x0c
    2318:	f6 cf       	rjmp	.-20     	; 0x2306 <vfprintf+0x30a>
    231a:	b3 14       	cp	r11, r3
    231c:	10 f4       	brcc	.+4      	; 0x2322 <vfprintf+0x326>
    231e:	3b 18       	sub	r3, r11
    2320:	01 c0       	rjmp	.+2      	; 0x2324 <vfprintf+0x328>
    2322:	31 2c       	mov	r3, r1
    2324:	34 ff       	sbrs	r19, 4
    2326:	11 c0       	rjmp	.+34     	; 0x234a <vfprintf+0x34e>
    2328:	b7 01       	movw	r22, r14
    232a:	80 e3       	ldi	r24, 0x30	; 48
    232c:	90 e0       	ldi	r25, 0x00	; 0
    232e:	3c 87       	std	Y+12, r19	; 0x0c
    2330:	69 d0       	rcall	.+210    	; 0x2404 <fputc>
    2332:	3c 85       	ldd	r19, Y+12	; 0x0c
    2334:	32 ff       	sbrs	r19, 2
    2336:	16 c0       	rjmp	.+44     	; 0x2364 <vfprintf+0x368>
    2338:	31 fd       	sbrc	r19, 1
    233a:	03 c0       	rjmp	.+6      	; 0x2342 <vfprintf+0x346>
    233c:	88 e7       	ldi	r24, 0x78	; 120
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	02 c0       	rjmp	.+4      	; 0x2346 <vfprintf+0x34a>
    2342:	88 e5       	ldi	r24, 0x58	; 88
    2344:	90 e0       	ldi	r25, 0x00	; 0
    2346:	b7 01       	movw	r22, r14
    2348:	0c c0       	rjmp	.+24     	; 0x2362 <vfprintf+0x366>
    234a:	83 2f       	mov	r24, r19
    234c:	86 78       	andi	r24, 0x86	; 134
    234e:	51 f0       	breq	.+20     	; 0x2364 <vfprintf+0x368>
    2350:	31 ff       	sbrs	r19, 1
    2352:	02 c0       	rjmp	.+4      	; 0x2358 <vfprintf+0x35c>
    2354:	8b e2       	ldi	r24, 0x2B	; 43
    2356:	01 c0       	rjmp	.+2      	; 0x235a <vfprintf+0x35e>
    2358:	80 e2       	ldi	r24, 0x20	; 32
    235a:	37 fd       	sbrc	r19, 7
    235c:	8d e2       	ldi	r24, 0x2D	; 45
    235e:	b7 01       	movw	r22, r14
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	50 d0       	rcall	.+160    	; 0x2404 <fputc>
    2364:	a5 14       	cp	r10, r5
    2366:	30 f4       	brcc	.+12     	; 0x2374 <vfprintf+0x378>
    2368:	b7 01       	movw	r22, r14
    236a:	80 e3       	ldi	r24, 0x30	; 48
    236c:	90 e0       	ldi	r25, 0x00	; 0
    236e:	4a d0       	rcall	.+148    	; 0x2404 <fputc>
    2370:	5a 94       	dec	r5
    2372:	f8 cf       	rjmp	.-16     	; 0x2364 <vfprintf+0x368>
    2374:	aa 94       	dec	r10
    2376:	f4 01       	movw	r30, r8
    2378:	ea 0d       	add	r30, r10
    237a:	f1 1d       	adc	r31, r1
    237c:	80 81       	ld	r24, Z
    237e:	b7 01       	movw	r22, r14
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	40 d0       	rcall	.+128    	; 0x2404 <fputc>
    2384:	a1 10       	cpse	r10, r1
    2386:	f6 cf       	rjmp	.-20     	; 0x2374 <vfprintf+0x378>
    2388:	33 20       	and	r3, r3
    238a:	09 f4       	brne	.+2      	; 0x238e <vfprintf+0x392>
    238c:	5d ce       	rjmp	.-838    	; 0x2048 <vfprintf+0x4c>
    238e:	b7 01       	movw	r22, r14
    2390:	80 e2       	ldi	r24, 0x20	; 32
    2392:	90 e0       	ldi	r25, 0x00	; 0
    2394:	37 d0       	rcall	.+110    	; 0x2404 <fputc>
    2396:	3a 94       	dec	r3
    2398:	f7 cf       	rjmp	.-18     	; 0x2388 <vfprintf+0x38c>
    239a:	f7 01       	movw	r30, r14
    239c:	86 81       	ldd	r24, Z+6	; 0x06
    239e:	97 81       	ldd	r25, Z+7	; 0x07
    23a0:	02 c0       	rjmp	.+4      	; 0x23a6 <vfprintf+0x3aa>
    23a2:	8f ef       	ldi	r24, 0xFF	; 255
    23a4:	9f ef       	ldi	r25, 0xFF	; 255
    23a6:	2c 96       	adiw	r28, 0x0c	; 12
    23a8:	0f b6       	in	r0, 0x3f	; 63
    23aa:	f8 94       	cli
    23ac:	de bf       	out	0x3e, r29	; 62
    23ae:	0f be       	out	0x3f, r0	; 63
    23b0:	cd bf       	out	0x3d, r28	; 61
    23b2:	df 91       	pop	r29
    23b4:	cf 91       	pop	r28
    23b6:	1f 91       	pop	r17
    23b8:	0f 91       	pop	r16
    23ba:	ff 90       	pop	r15
    23bc:	ef 90       	pop	r14
    23be:	df 90       	pop	r13
    23c0:	cf 90       	pop	r12
    23c2:	bf 90       	pop	r11
    23c4:	af 90       	pop	r10
    23c6:	9f 90       	pop	r9
    23c8:	8f 90       	pop	r8
    23ca:	7f 90       	pop	r7
    23cc:	6f 90       	pop	r6
    23ce:	5f 90       	pop	r5
    23d0:	4f 90       	pop	r4
    23d2:	3f 90       	pop	r3
    23d4:	2f 90       	pop	r2
    23d6:	08 95       	ret

000023d8 <strnlen_P>:
    23d8:	fc 01       	movw	r30, r24
    23da:	05 90       	lpm	r0, Z+
    23dc:	61 50       	subi	r22, 0x01	; 1
    23de:	70 40       	sbci	r23, 0x00	; 0
    23e0:	01 10       	cpse	r0, r1
    23e2:	d8 f7       	brcc	.-10     	; 0x23da <strnlen_P+0x2>
    23e4:	80 95       	com	r24
    23e6:	90 95       	com	r25
    23e8:	8e 0f       	add	r24, r30
    23ea:	9f 1f       	adc	r25, r31
    23ec:	08 95       	ret

000023ee <strnlen>:
    23ee:	fc 01       	movw	r30, r24
    23f0:	61 50       	subi	r22, 0x01	; 1
    23f2:	70 40       	sbci	r23, 0x00	; 0
    23f4:	01 90       	ld	r0, Z+
    23f6:	01 10       	cpse	r0, r1
    23f8:	d8 f7       	brcc	.-10     	; 0x23f0 <strnlen+0x2>
    23fa:	80 95       	com	r24
    23fc:	90 95       	com	r25
    23fe:	8e 0f       	add	r24, r30
    2400:	9f 1f       	adc	r25, r31
    2402:	08 95       	ret

00002404 <fputc>:
    2404:	0f 93       	push	r16
    2406:	1f 93       	push	r17
    2408:	cf 93       	push	r28
    240a:	df 93       	push	r29
    240c:	fb 01       	movw	r30, r22
    240e:	23 81       	ldd	r18, Z+3	; 0x03
    2410:	21 fd       	sbrc	r18, 1
    2412:	03 c0       	rjmp	.+6      	; 0x241a <fputc+0x16>
    2414:	8f ef       	ldi	r24, 0xFF	; 255
    2416:	9f ef       	ldi	r25, 0xFF	; 255
    2418:	28 c0       	rjmp	.+80     	; 0x246a <fputc+0x66>
    241a:	22 ff       	sbrs	r18, 2
    241c:	16 c0       	rjmp	.+44     	; 0x244a <fputc+0x46>
    241e:	46 81       	ldd	r20, Z+6	; 0x06
    2420:	57 81       	ldd	r21, Z+7	; 0x07
    2422:	24 81       	ldd	r18, Z+4	; 0x04
    2424:	35 81       	ldd	r19, Z+5	; 0x05
    2426:	42 17       	cp	r20, r18
    2428:	53 07       	cpc	r21, r19
    242a:	44 f4       	brge	.+16     	; 0x243c <fputc+0x38>
    242c:	a0 81       	ld	r26, Z
    242e:	b1 81       	ldd	r27, Z+1	; 0x01
    2430:	9d 01       	movw	r18, r26
    2432:	2f 5f       	subi	r18, 0xFF	; 255
    2434:	3f 4f       	sbci	r19, 0xFF	; 255
    2436:	31 83       	std	Z+1, r19	; 0x01
    2438:	20 83       	st	Z, r18
    243a:	8c 93       	st	X, r24
    243c:	26 81       	ldd	r18, Z+6	; 0x06
    243e:	37 81       	ldd	r19, Z+7	; 0x07
    2440:	2f 5f       	subi	r18, 0xFF	; 255
    2442:	3f 4f       	sbci	r19, 0xFF	; 255
    2444:	37 83       	std	Z+7, r19	; 0x07
    2446:	26 83       	std	Z+6, r18	; 0x06
    2448:	10 c0       	rjmp	.+32     	; 0x246a <fputc+0x66>
    244a:	eb 01       	movw	r28, r22
    244c:	09 2f       	mov	r16, r25
    244e:	18 2f       	mov	r17, r24
    2450:	00 84       	ldd	r0, Z+8	; 0x08
    2452:	f1 85       	ldd	r31, Z+9	; 0x09
    2454:	e0 2d       	mov	r30, r0
    2456:	09 95       	icall
    2458:	89 2b       	or	r24, r25
    245a:	e1 f6       	brne	.-72     	; 0x2414 <fputc+0x10>
    245c:	8e 81       	ldd	r24, Y+6	; 0x06
    245e:	9f 81       	ldd	r25, Y+7	; 0x07
    2460:	01 96       	adiw	r24, 0x01	; 1
    2462:	9f 83       	std	Y+7, r25	; 0x07
    2464:	8e 83       	std	Y+6, r24	; 0x06
    2466:	81 2f       	mov	r24, r17
    2468:	90 2f       	mov	r25, r16
    246a:	df 91       	pop	r29
    246c:	cf 91       	pop	r28
    246e:	1f 91       	pop	r17
    2470:	0f 91       	pop	r16
    2472:	08 95       	ret

00002474 <__ultoa_invert>:
    2474:	fa 01       	movw	r30, r20
    2476:	aa 27       	eor	r26, r26
    2478:	28 30       	cpi	r18, 0x08	; 8
    247a:	51 f1       	breq	.+84     	; 0x24d0 <__ultoa_invert+0x5c>
    247c:	20 31       	cpi	r18, 0x10	; 16
    247e:	81 f1       	breq	.+96     	; 0x24e0 <__ultoa_invert+0x6c>
    2480:	e8 94       	clt
    2482:	6f 93       	push	r22
    2484:	6e 7f       	andi	r22, 0xFE	; 254
    2486:	6e 5f       	subi	r22, 0xFE	; 254
    2488:	7f 4f       	sbci	r23, 0xFF	; 255
    248a:	8f 4f       	sbci	r24, 0xFF	; 255
    248c:	9f 4f       	sbci	r25, 0xFF	; 255
    248e:	af 4f       	sbci	r26, 0xFF	; 255
    2490:	b1 e0       	ldi	r27, 0x01	; 1
    2492:	3e d0       	rcall	.+124    	; 0x2510 <__ultoa_invert+0x9c>
    2494:	b4 e0       	ldi	r27, 0x04	; 4
    2496:	3c d0       	rcall	.+120    	; 0x2510 <__ultoa_invert+0x9c>
    2498:	67 0f       	add	r22, r23
    249a:	78 1f       	adc	r23, r24
    249c:	89 1f       	adc	r24, r25
    249e:	9a 1f       	adc	r25, r26
    24a0:	a1 1d       	adc	r26, r1
    24a2:	68 0f       	add	r22, r24
    24a4:	79 1f       	adc	r23, r25
    24a6:	8a 1f       	adc	r24, r26
    24a8:	91 1d       	adc	r25, r1
    24aa:	a1 1d       	adc	r26, r1
    24ac:	6a 0f       	add	r22, r26
    24ae:	71 1d       	adc	r23, r1
    24b0:	81 1d       	adc	r24, r1
    24b2:	91 1d       	adc	r25, r1
    24b4:	a1 1d       	adc	r26, r1
    24b6:	20 d0       	rcall	.+64     	; 0x24f8 <__ultoa_invert+0x84>
    24b8:	09 f4       	brne	.+2      	; 0x24bc <__ultoa_invert+0x48>
    24ba:	68 94       	set
    24bc:	3f 91       	pop	r19
    24be:	2a e0       	ldi	r18, 0x0A	; 10
    24c0:	26 9f       	mul	r18, r22
    24c2:	11 24       	eor	r1, r1
    24c4:	30 19       	sub	r19, r0
    24c6:	30 5d       	subi	r19, 0xD0	; 208
    24c8:	31 93       	st	Z+, r19
    24ca:	de f6       	brtc	.-74     	; 0x2482 <__ultoa_invert+0xe>
    24cc:	cf 01       	movw	r24, r30
    24ce:	08 95       	ret
    24d0:	46 2f       	mov	r20, r22
    24d2:	47 70       	andi	r20, 0x07	; 7
    24d4:	40 5d       	subi	r20, 0xD0	; 208
    24d6:	41 93       	st	Z+, r20
    24d8:	b3 e0       	ldi	r27, 0x03	; 3
    24da:	0f d0       	rcall	.+30     	; 0x24fa <__ultoa_invert+0x86>
    24dc:	c9 f7       	brne	.-14     	; 0x24d0 <__ultoa_invert+0x5c>
    24de:	f6 cf       	rjmp	.-20     	; 0x24cc <__ultoa_invert+0x58>
    24e0:	46 2f       	mov	r20, r22
    24e2:	4f 70       	andi	r20, 0x0F	; 15
    24e4:	40 5d       	subi	r20, 0xD0	; 208
    24e6:	4a 33       	cpi	r20, 0x3A	; 58
    24e8:	18 f0       	brcs	.+6      	; 0x24f0 <__ultoa_invert+0x7c>
    24ea:	49 5d       	subi	r20, 0xD9	; 217
    24ec:	31 fd       	sbrc	r19, 1
    24ee:	40 52       	subi	r20, 0x20	; 32
    24f0:	41 93       	st	Z+, r20
    24f2:	02 d0       	rcall	.+4      	; 0x24f8 <__ultoa_invert+0x84>
    24f4:	a9 f7       	brne	.-22     	; 0x24e0 <__ultoa_invert+0x6c>
    24f6:	ea cf       	rjmp	.-44     	; 0x24cc <__ultoa_invert+0x58>
    24f8:	b4 e0       	ldi	r27, 0x04	; 4
    24fa:	a6 95       	lsr	r26
    24fc:	97 95       	ror	r25
    24fe:	87 95       	ror	r24
    2500:	77 95       	ror	r23
    2502:	67 95       	ror	r22
    2504:	ba 95       	dec	r27
    2506:	c9 f7       	brne	.-14     	; 0x24fa <__ultoa_invert+0x86>
    2508:	00 97       	sbiw	r24, 0x00	; 0
    250a:	61 05       	cpc	r22, r1
    250c:	71 05       	cpc	r23, r1
    250e:	08 95       	ret
    2510:	9b 01       	movw	r18, r22
    2512:	ac 01       	movw	r20, r24
    2514:	0a 2e       	mov	r0, r26
    2516:	06 94       	lsr	r0
    2518:	57 95       	ror	r21
    251a:	47 95       	ror	r20
    251c:	37 95       	ror	r19
    251e:	27 95       	ror	r18
    2520:	ba 95       	dec	r27
    2522:	c9 f7       	brne	.-14     	; 0x2516 <__ultoa_invert+0xa2>
    2524:	62 0f       	add	r22, r18
    2526:	73 1f       	adc	r23, r19
    2528:	84 1f       	adc	r24, r20
    252a:	95 1f       	adc	r25, r21
    252c:	a0 1d       	adc	r26, r0
    252e:	08 95       	ret

00002530 <eeprom_read_word>:
    2530:	a8 e1       	ldi	r26, 0x18	; 24
    2532:	b0 e0       	ldi	r27, 0x00	; 0
    2534:	42 e0       	ldi	r20, 0x02	; 2
    2536:	50 e0       	ldi	r21, 0x00	; 0
    2538:	02 c0       	rjmp	.+4      	; 0x253e <eeprom_read_blraw>

0000253a <eeprom_read_block>:
    253a:	dc 01       	movw	r26, r24
    253c:	cb 01       	movw	r24, r22

0000253e <eeprom_read_blraw>:
    253e:	fc 01       	movw	r30, r24
    2540:	f9 99       	sbic	0x1f, 1	; 31
    2542:	fe cf       	rjmp	.-4      	; 0x2540 <eeprom_read_blraw+0x2>
    2544:	06 c0       	rjmp	.+12     	; 0x2552 <eeprom_read_blraw+0x14>
    2546:	f2 bd       	out	0x22, r31	; 34
    2548:	e1 bd       	out	0x21, r30	; 33
    254a:	f8 9a       	sbi	0x1f, 0	; 31
    254c:	31 96       	adiw	r30, 0x01	; 1
    254e:	00 b4       	in	r0, 0x20	; 32
    2550:	0d 92       	st	X+, r0
    2552:	41 50       	subi	r20, 0x01	; 1
    2554:	50 40       	sbci	r21, 0x00	; 0
    2556:	b8 f7       	brcc	.-18     	; 0x2546 <eeprom_read_blraw+0x8>
    2558:	08 95       	ret

0000255a <_exit>:
    255a:	f8 94       	cli

0000255c <__stop_program>:
    255c:	ff cf       	rjmp	.-2      	; 0x255c <__stop_program>
