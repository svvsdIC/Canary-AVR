
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ca  00800100  0000226a  000022fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000226a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000416  008001ca  008001ca  000023c8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000023c8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002424  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000258  00000000  00000000  00002468  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000045a4  00000000  00000000  000026c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015f7  00000000  00000000  00006c64  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000019a9  00000000  00000000  0000825b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000067c  00000000  00000000  00009c04  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000bc6  00000000  00000000  0000a280  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001828  00000000  00000000  0000ae46  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a0  00000000  00000000  0000c66e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 ff 0a 	jmp	0x15fe	; 0x15fe <__vector_13>
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 6d 0b 	jmp	0x16da	; 0x16da <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 5a 0c 	jmp	0x18b4	; 0x18b4 <__vector_28>
      74:	7b c0       	rjmp	.+246    	; 0x16c <__bad_interrupt>
      76:	00 00       	nop
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	89 0b       	sbc	r24, r25
      8e:	db 0b       	sbc	r29, r27
      90:	db 0b       	sbc	r29, r27
      92:	db 0b       	sbc	r29, r27
      94:	db 0b       	sbc	r29, r27
      96:	db 0b       	sbc	r29, r27
      98:	db 0b       	sbc	r29, r27
      9a:	db 0b       	sbc	r29, r27
      9c:	89 0b       	sbc	r24, r25
      9e:	db 0b       	sbc	r29, r27
      a0:	db 0b       	sbc	r29, r27
      a2:	db 0b       	sbc	r29, r27
      a4:	db 0b       	sbc	r29, r27
      a6:	db 0b       	sbc	r29, r27
      a8:	db 0b       	sbc	r29, r27
      aa:	db 0b       	sbc	r29, r27
      ac:	8b 0b       	sbc	r24, r27
      ae:	db 0b       	sbc	r29, r27
      b0:	db 0b       	sbc	r29, r27
      b2:	db 0b       	sbc	r29, r27
      b4:	db 0b       	sbc	r29, r27
      b6:	db 0b       	sbc	r29, r27
      b8:	db 0b       	sbc	r29, r27
      ba:	db 0b       	sbc	r29, r27
      bc:	db 0b       	sbc	r29, r27
      be:	db 0b       	sbc	r29, r27
      c0:	db 0b       	sbc	r29, r27
      c2:	db 0b       	sbc	r29, r27
      c4:	db 0b       	sbc	r29, r27
      c6:	db 0b       	sbc	r29, r27
      c8:	db 0b       	sbc	r29, r27
      ca:	db 0b       	sbc	r29, r27
      cc:	8b 0b       	sbc	r24, r27
      ce:	db 0b       	sbc	r29, r27
      d0:	db 0b       	sbc	r29, r27
      d2:	db 0b       	sbc	r29, r27
      d4:	db 0b       	sbc	r29, r27
      d6:	db 0b       	sbc	r29, r27
      d8:	db 0b       	sbc	r29, r27
      da:	db 0b       	sbc	r29, r27
      dc:	db 0b       	sbc	r29, r27
      de:	db 0b       	sbc	r29, r27
      e0:	db 0b       	sbc	r29, r27
      e2:	db 0b       	sbc	r29, r27
      e4:	db 0b       	sbc	r29, r27
      e6:	db 0b       	sbc	r29, r27
      e8:	db 0b       	sbc	r29, r27
      ea:	db 0b       	sbc	r29, r27
      ec:	d7 0b       	sbc	r29, r23
      ee:	db 0b       	sbc	r29, r27
      f0:	db 0b       	sbc	r29, r27
      f2:	db 0b       	sbc	r29, r27
      f4:	db 0b       	sbc	r29, r27
      f6:	db 0b       	sbc	r29, r27
      f8:	db 0b       	sbc	r29, r27
      fa:	db 0b       	sbc	r29, r27
      fc:	b4 0b       	sbc	r27, r20
      fe:	db 0b       	sbc	r29, r27
     100:	db 0b       	sbc	r29, r27
     102:	db 0b       	sbc	r29, r27
     104:	db 0b       	sbc	r29, r27
     106:	db 0b       	sbc	r29, r27
     108:	db 0b       	sbc	r29, r27
     10a:	db 0b       	sbc	r29, r27
     10c:	db 0b       	sbc	r29, r27
     10e:	db 0b       	sbc	r29, r27
     110:	db 0b       	sbc	r29, r27
     112:	db 0b       	sbc	r29, r27
     114:	db 0b       	sbc	r29, r27
     116:	db 0b       	sbc	r29, r27
     118:	db 0b       	sbc	r29, r27
     11a:	db 0b       	sbc	r29, r27
     11c:	a8 0b       	sbc	r26, r24
     11e:	db 0b       	sbc	r29, r27
     120:	db 0b       	sbc	r29, r27
     122:	db 0b       	sbc	r29, r27
     124:	db 0b       	sbc	r29, r27
     126:	db 0b       	sbc	r29, r27
     128:	db 0b       	sbc	r29, r27
     12a:	db 0b       	sbc	r29, r27
     12c:	c6 0b       	sbc	r28, r22

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ea e6       	ldi	r30, 0x6A	; 106
     142:	f2 e2       	ldi	r31, 0x22	; 34
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	aa 3c       	cpi	r26, 0xCA	; 202
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	25 e0       	ldi	r18, 0x05	; 5
     156:	aa ec       	ldi	r26, 0xCA	; 202
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a0 3e       	cpi	r26, 0xE0	; 224
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 c2 09 	call	0x1384	; 0x1384 <main>
     168:	0c 94 33 11 	jmp	0x2266	; 0x2266 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 e9 0a 	jmp	0x15d2	; 0x15d2 <__vector_default>

00000170 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	90 81       	ld	r25, Z
     176:	90 7e       	andi	r25, 0xE0	; 224
     178:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     17a:	90 81       	ld	r25, Z
     17c:	89 2b       	or	r24, r25
     17e:	80 83       	st	Z, r24
     180:	08 95       	ret

00000182 <ADC_init>:
}

void ADC_init(void)
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     186:	ec e7       	ldi	r30, 0x7C	; 124
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	80 64       	ori	r24, 0x40	; 64
     18e:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     190:	ca e7       	ldi	r28, 0x7A	; 122
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	88 81       	ld	r24, Y
     196:	81 60       	ori	r24, 0x01	; 1
     198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     19a:	88 81       	ld	r24, Y
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     1a0:	88 81       	ld	r24, Y
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a6:	a4 e6       	ldi	r26, 0x64	; 100
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	8c 91       	ld	r24, X
     1ac:	8e 7f       	andi	r24, 0xFE	; 254
     1ae:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 7d       	andi	r24, 0xDF	; 223
     1b4:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b6:	8f e3       	ldi	r24, 0x3F	; 63
     1b8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1bc:	88 81       	ld	r24, Y
     1be:	80 68       	ori	r24, 0x80	; 128
     1c0:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c2:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c6:	8f e1       	ldi	r24, 0x1F	; 31
     1c8:	d3 df       	rcall	.-90     	; 0x170 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1ca:	88 81       	ld	r24, Y
     1cc:	80 64       	ori	r24, 0x40	; 64
     1ce:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1d0:	ea e7       	ldi	r30, 0x7A	; 122
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	84 ff       	sbrs	r24, 4
     1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1da:	ea e7       	ldi	r30, 0x7A	; 122
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	80 64       	ori	r24, 0x40	; 64
     1e2:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e4:	80 81       	ld	r24, Z
     1e6:	84 ff       	sbrs	r24, 4
     1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1ea:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     1f4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fc:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     200:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     204:	89 2f       	mov	r24, r25
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	98 2f       	mov	r25, r24
     20a:	88 27       	eor	r24, r24
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     214:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     218:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     21c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     220:	99 23       	and	r25, r25
     222:	1c f4       	brge	.+6      	; 0x22a <ADC_init+0xa8>
     224:	91 95       	neg	r25
     226:	81 95       	neg	r24
     228:	91 09       	sbc	r25, r1
     22a:	05 97       	sbiw	r24, 0x05	; 5
     22c:	2c f0       	brlt	.+10     	; 0x238 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22e:	80 91 a7 03 	lds	r24, 0x03A7	; 0x8003a7 <gas_sensor_initialization_errors>
     232:	81 60       	ori	r24, 0x01	; 1
     234:	80 93 a7 03 	sts	0x03A7, r24	; 0x8003a7 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     238:	8e e1       	ldi	r24, 0x1E	; 30
     23a:	9a df       	rcall	.-204    	; 0x170 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23c:	ea e7       	ldi	r30, 0x7A	; 122
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	80 64       	ori	r24, 0x40	; 64
     244:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     246:	80 81       	ld	r24, Z
     248:	84 ff       	sbrs	r24, 4
     24a:	fd cf       	rjmp	.-6      	; 0x246 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     256:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     25a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25e:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     262:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     266:	89 2f       	mov	r24, r25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	98 2f       	mov	r25, r24
     26c:	88 27       	eor	r24, r24
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     276:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     27a:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     27e:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     282:	81 5e       	subi	r24, 0xE1	; 225
     284:	91 09       	sbc	r25, r1
     286:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     28a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     292:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     296:	99 23       	and	r25, r25
     298:	1c f4       	brge	.+6      	; 0x2a0 <ADC_init+0x11e>
     29a:	91 95       	neg	r25
     29c:	81 95       	neg	r24
     29e:	91 09       	sbc	r25, r1
     2a0:	05 97       	sbiw	r24, 0x05	; 5
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a4:	80 91 a7 03 	lds	r24, 0x03A7	; 0x8003a7 <gas_sensor_initialization_errors>
     2a8:	82 60       	ori	r24, 0x02	; 2
     2aa:	80 93 a7 03 	sts	0x03A7, r24	; 0x8003a7 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ae:	ea e7       	ldi	r30, 0x7A	; 122
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8f 77       	andi	r24, 0x7F	; 127
     2b6:	80 83       	st	Z, r24
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <BME_read_correction_coefficients>:
********************************************************************************/

/********************************************************************************
						Functions
********************************************************************************/
void BME_read_correction_coefficients(void) {
     2be:	ff 92       	push	r15
     2c0:	0f 93       	push	r16
     2c2:	1f 93       	push	r17
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     2c8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     2cc:	88 23       	and	r24, r24
     2ce:	59 f1       	breq	.+86     	; 0x326 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2d0:	c2 e0       	ldi	r28, 0x02	; 2
     2d2:	d3 e0       	ldi	r29, 0x03	; 3
     2d4:	0f 2e       	mov	r0, r31
     2d6:	fc ee       	ldi	r31, 0xEC	; 236
     2d8:	ff 2e       	mov	r15, r31
     2da:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2dc:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2de:	1d ee       	ldi	r17, 0xED	; 237
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     2e0:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     2e2:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     2e4:	62 e0       	ldi	r22, 0x02	; 2
     2e6:	ce 01       	movw	r24, r28
     2e8:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2ec:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     2f0:	81 11       	cpse	r24, r1
     2f2:	fc cf       	rjmp	.-8      	; 0x2ec <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     2f4:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     2f6:	6a e1       	ldi	r22, 0x1A	; 26
     2f8:	ce 01       	movw	r24, r28
     2fa:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     2fe:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     302:	81 11       	cpse	r24, r1
     304:	fc cf       	rjmp	.-8      	; 0x2fe <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     306:	6a e1       	ldi	r22, 0x1A	; 26
     308:	ce 01       	movw	r24, r28
     30a:	0e 94 4e 0b 	call	0x169c	; 0x169c <TWI_Get_Data_From_Transceiver>
     30e:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     312:	89 81       	ldd	r24, Y+1	; 0x01
     314:	83 fb       	bst	r24, 3
     316:	88 27       	eor	r24, r24
     318:	80 f9       	bld	r24, 0
     31a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
	// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
	/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
	/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     31e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     322:	81 11       	cpse	r24, r1
     324:	dd cf       	rjmp	.-70     	; 0x2e0 <BME_read_correction_coefficients+0x22>
	// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     326:	e2 e0       	ldi	r30, 0x02	; 2
     328:	f3 e0       	ldi	r31, 0x03	; 3
     32a:	8c ee       	ldi	r24, 0xEC	; 236
     32c:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
     32e:	88 e8       	ldi	r24, 0x88	; 136
     330:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     332:	62 e0       	ldi	r22, 0x02	; 2
     334:	cf 01       	movw	r24, r30
     336:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     33a:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     33e:	81 11       	cpse	r24, r1
     340:	fc cf       	rjmp	.-8      	; 0x33a <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     342:	8d ee       	ldi	r24, 0xED	; 237
     344:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     348:	6b e1       	ldi	r22, 0x1B	; 27
     34a:	82 e0       	ldi	r24, 0x02	; 2
     34c:	93 e0       	ldi	r25, 0x03	; 3
     34e:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     352:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     356:	81 11       	cpse	r24, r1
     358:	fc cf       	rjmp	.-8      	; 0x352 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     35a:	6b e1       	ldi	r22, 0x1B	; 27
     35c:	82 e0       	ldi	r24, 0x02	; 2
     35e:	93 e0       	ldi	r25, 0x03	; 3
     360:	0e 94 4e 0b 	call	0x169c	; 0x169c <TWI_Get_Data_From_Transceiver>
     364:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
     368:	c3 e0       	ldi	r28, 0x03	; 3
     36a:	d3 e0       	ldi	r29, 0x03	; 3
     36c:	0e e2       	ldi	r16, 0x2E	; 46
     36e:	13 e0       	ldi	r17, 0x03	; 3
     370:	2e e1       	ldi	r18, 0x1E	; 30
     372:	33 e0       	ldi	r19, 0x03	; 3
     374:	d8 01       	movw	r26, r16
     376:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     378:	81 91       	ld	r24, Z+
     37a:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     37c:	e2 17       	cp	r30, r18
     37e:	f3 07       	cpc	r31, r19
     380:	d9 f7       	brne	.-10     	; 0x378 <BME_read_correction_coefficients+0xba>
     382:	8b e1       	ldi	r24, 0x1B	; 27
     384:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2432>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     388:	ee e2       	ldi	r30, 0x2E	; 46
     38a:	f3 e0       	ldi	r31, 0x03	; 3
     38c:	81 81       	ldd	r24, Z+1	; 0x01
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	98 2f       	mov	r25, r24
     392:	88 27       	eor	r24, r24
     394:	20 81       	ld	r18, Z
     396:	82 2b       	or	r24, r18
     398:	90 93 01 03 	sts	0x0301, r25	; 0x800301 <dig_T1+0x1>
     39c:	80 93 00 03 	sts	0x0300, r24	; 0x800300 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     3a0:	83 81       	ldd	r24, Z+3	; 0x03
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	98 2f       	mov	r25, r24
     3a6:	88 27       	eor	r24, r24
     3a8:	22 81       	ldd	r18, Z+2	; 0x02
     3aa:	82 2b       	or	r24, r18
     3ac:	90 93 2d 03 	sts	0x032D, r25	; 0x80032d <dig_T2+0x1>
     3b0:	80 93 2c 03 	sts	0x032C, r24	; 0x80032c <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     3b4:	85 81       	ldd	r24, Z+5	; 0x05
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	98 2f       	mov	r25, r24
     3ba:	88 27       	eor	r24, r24
     3bc:	24 81       	ldd	r18, Z+4	; 0x04
     3be:	82 2b       	or	r24, r18
     3c0:	90 93 bb 03 	sts	0x03BB, r25	; 0x8003bb <dig_T3+0x1>
     3c4:	80 93 ba 03 	sts	0x03BA, r24	; 0x8003ba <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     3c8:	87 81       	ldd	r24, Z+7	; 0x07
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	98 2f       	mov	r25, r24
     3ce:	88 27       	eor	r24, r24
     3d0:	26 81       	ldd	r18, Z+6	; 0x06
     3d2:	82 2b       	or	r24, r18
     3d4:	90 93 a9 03 	sts	0x03A9, r25	; 0x8003a9 <dig_P1+0x1>
     3d8:	80 93 a8 03 	sts	0x03A8, r24	; 0x8003a8 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     3dc:	81 85       	ldd	r24, Z+9	; 0x09
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	98 2f       	mov	r25, r24
     3e2:	88 27       	eor	r24, r24
     3e4:	20 85       	ldd	r18, Z+8	; 0x08
     3e6:	82 2b       	or	r24, r18
     3e8:	90 93 66 03 	sts	0x0366, r25	; 0x800366 <dig_P2+0x1>
     3ec:	80 93 65 03 	sts	0x0365, r24	; 0x800365 <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     3f0:	83 85       	ldd	r24, Z+11	; 0x0b
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	98 2f       	mov	r25, r24
     3f6:	88 27       	eor	r24, r24
     3f8:	22 85       	ldd	r18, Z+10	; 0x0a
     3fa:	82 2b       	or	r24, r18
     3fc:	90 93 ab 03 	sts	0x03AB, r25	; 0x8003ab <dig_P3+0x1>
     400:	80 93 aa 03 	sts	0x03AA, r24	; 0x8003aa <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     404:	85 85       	ldd	r24, Z+13	; 0x0d
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	98 2f       	mov	r25, r24
     40a:	88 27       	eor	r24, r24
     40c:	24 85       	ldd	r18, Z+12	; 0x0c
     40e:	82 2b       	or	r24, r18
     410:	90 93 68 03 	sts	0x0368, r25	; 0x800368 <dig_P4+0x1>
     414:	80 93 67 03 	sts	0x0367, r24	; 0x800367 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     418:	87 85       	ldd	r24, Z+15	; 0x0f
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	98 2f       	mov	r25, r24
     41e:	88 27       	eor	r24, r24
     420:	26 85       	ldd	r18, Z+14	; 0x0e
     422:	82 2b       	or	r24, r18
     424:	90 93 84 03 	sts	0x0384, r25	; 0x800384 <dig_P5+0x1>
     428:	80 93 83 03 	sts	0x0383, r24	; 0x800383 <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     42c:	81 89       	ldd	r24, Z+17	; 0x11
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	98 2f       	mov	r25, r24
     432:	88 27       	eor	r24, r24
     434:	20 89       	ldd	r18, Z+16	; 0x10
     436:	82 2b       	or	r24, r18
     438:	90 93 bd 03 	sts	0x03BD, r25	; 0x8003bd <dig_P6+0x1>
     43c:	80 93 bc 03 	sts	0x03BC, r24	; 0x8003bc <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     440:	83 89       	ldd	r24, Z+19	; 0x13
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	98 2f       	mov	r25, r24
     446:	88 27       	eor	r24, r24
     448:	22 89       	ldd	r18, Z+18	; 0x12
     44a:	82 2b       	or	r24, r18
     44c:	90 93 ff 02 	sts	0x02FF, r25	; 0x8002ff <dig_P7+0x1>
     450:	80 93 fe 02 	sts	0x02FE, r24	; 0x8002fe <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     454:	85 89       	ldd	r24, Z+21	; 0x15
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	98 2f       	mov	r25, r24
     45a:	88 27       	eor	r24, r24
     45c:	24 89       	ldd	r18, Z+20	; 0x14
     45e:	82 2b       	or	r24, r18
     460:	90 93 ad 03 	sts	0x03AD, r25	; 0x8003ad <dig_P8+0x1>
     464:	80 93 ac 03 	sts	0x03AC, r24	; 0x8003ac <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     468:	87 89       	ldd	r24, Z+23	; 0x17
     46a:	90 e0       	ldi	r25, 0x00	; 0
     46c:	98 2f       	mov	r25, r24
     46e:	88 27       	eor	r24, r24
     470:	26 89       	ldd	r18, Z+22	; 0x16
     472:	82 2b       	or	r24, r18
     474:	90 93 b9 03 	sts	0x03B9, r25	; 0x8003b9 <dig_P9+0x1>
     478:	80 93 b8 03 	sts	0x03B8, r24	; 0x8003b8 <dig_P9>
	dig_H1 = RawBMEdata[25];
     47c:	81 8d       	ldd	r24, Z+25	; 0x19
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	90 93 5b 03 	sts	0x035B, r25	; 0x80035b <dig_H1+0x1>
     484:	80 93 5a 03 	sts	0x035A, r24	; 0x80035a <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     488:	e2 e0       	ldi	r30, 0x02	; 2
     48a:	f3 e0       	ldi	r31, 0x03	; 3
     48c:	8c ee       	ldi	r24, 0xEC	; 236
     48e:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     490:	81 ee       	ldi	r24, 0xE1	; 225
     492:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     494:	62 e0       	ldi	r22, 0x02	; 2
     496:	cf 01       	movw	r24, r30
     498:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     49c:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     4a0:	81 11       	cpse	r24, r1
     4a2:	fc cf       	rjmp	.-8      	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     4a4:	8d ee       	ldi	r24, 0xED	; 237
     4a6:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     4aa:	68 e0       	ldi	r22, 0x08	; 8
     4ac:	82 e0       	ldi	r24, 0x02	; 2
     4ae:	93 e0       	ldi	r25, 0x03	; 3
     4b0:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     4b4:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     4b8:	81 11       	cpse	r24, r1
     4ba:	fc cf       	rjmp	.-8      	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     4bc:	68 e0       	ldi	r22, 0x08	; 8
     4be:	82 e0       	ldi	r24, 0x02	; 2
     4c0:	93 e0       	ldi	r25, 0x03	; 3
     4c2:	0e 94 4e 0b 	call	0x169c	; 0x169c <TWI_Get_Data_From_Transceiver>
     4c6:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
     4ca:	2a e0       	ldi	r18, 0x0A	; 10
     4cc:	33 e0       	ldi	r19, 0x03	; 3
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     4ce:	89 91       	ld	r24, Y+
     4d0:	f8 01       	movw	r30, r16
     4d2:	81 93       	st	Z+, r24
     4d4:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     4d6:	c2 17       	cp	r28, r18
     4d8:	d3 07       	cpc	r29, r19
     4da:	c9 f7       	brne	.-14     	; 0x4ce <__LOCK_REGION_LENGTH__+0xce>
     4dc:	87 e0       	ldi	r24, 0x07	; 7
     4de:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2432>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8);
     4e2:	ee e2       	ldi	r30, 0x2E	; 46
     4e4:	f3 e0       	ldi	r31, 0x03	; 3
     4e6:	82 81       	ldd	r24, Z+2	; 0x02
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	98 2f       	mov	r25, r24
     4ec:	88 27       	eor	r24, r24
     4ee:	21 81       	ldd	r18, Z+1	; 0x01
     4f0:	82 2b       	or	r24, r18
     4f2:	90 93 bf 03 	sts	0x03BF, r25	; 0x8003bf <dig_H2+0x1>
     4f6:	80 93 be 03 	sts	0x03BE, r24	; 0x8003be <dig_H2>
	dig_H3 = RawBMEdata[3];
     4fa:	83 81       	ldd	r24, Z+3	; 0x03
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	90 93 b3 03 	sts	0x03B3, r25	; 0x8003b3 <dig_H3+0x1>
     502:	80 93 b2 03 	sts	0x03B2, r24	; 0x8003b2 <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     506:	85 81       	ldd	r24, Z+5	; 0x05
     508:	82 95       	swap	r24
     50a:	86 95       	lsr	r24
     50c:	87 70       	andi	r24, 0x07	; 7
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	24 81       	ldd	r18, Z+4	; 0x04
     512:	40 e1       	ldi	r20, 0x10	; 16
     514:	24 9f       	mul	r18, r20
     516:	90 01       	movw	r18, r0
     518:	11 24       	eor	r1, r1
     51a:	28 2b       	or	r18, r24
     51c:	39 2b       	or	r19, r25
     51e:	30 93 2b 03 	sts	0x032B, r19	; 0x80032b <dig_H4+0x1>
     522:	20 93 2a 03 	sts	0x032A, r18	; 0x80032a <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     526:	26 81       	ldd	r18, Z+6	; 0x06
     528:	40 e1       	ldi	r20, 0x10	; 16
     52a:	24 9f       	mul	r18, r20
     52c:	90 01       	movw	r18, r0
     52e:	11 24       	eor	r1, r1
     530:	82 2b       	or	r24, r18
     532:	93 2b       	or	r25, r19
     534:	90 93 b0 03 	sts	0x03B0, r25	; 0x8003b0 <dig_H5+0x1>
     538:	80 93 af 03 	sts	0x03AF, r24	; 0x8003af <dig_H5>
	dig_H6 = RawBMEdata[7];
     53c:	87 81       	ldd	r24, Z+7	; 0x07
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	90 93 71 03 	sts	0x0371, r25	; 0x800371 <dig_H6+0x1>
     544:	80 93 70 03 	sts	0x0370, r24	; 0x800370 <dig_H6>
}
     548:	df 91       	pop	r29
     54a:	cf 91       	pop	r28
     54c:	1f 91       	pop	r17
     54e:	0f 91       	pop	r16
     550:	ff 90       	pop	r15
     552:	08 95       	ret

00000554 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     554:	e2 e0       	ldi	r30, 0x02	; 2
     556:	f3 e0       	ldi	r31, 0x03	; 3
     558:	8c ee       	ldi	r24, 0xEC	; 236
     55a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     55c:	80 ee       	ldi	r24, 0xE0	; 224
     55e:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     560:	86 eb       	ldi	r24, 0xB6	; 182
     562:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     564:	63 e0       	ldi	r22, 0x03	; 3
     566:	cf 01       	movw	r24, r30
     568:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     56c:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     570:	81 11       	cpse	r24, r1
     572:	fc cf       	rjmp	.-8      	; 0x56c <bme280basic_init+0x18>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     574:	e2 e0       	ldi	r30, 0x02	; 2
     576:	f3 e0       	ldi	r31, 0x03	; 3
     578:	8c ee       	ldi	r24, 0xEC	; 236
     57a:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     57c:	80 ed       	ldi	r24, 0xD0	; 208
     57e:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     580:	62 e0       	ldi	r22, 0x02	; 2
     582:	cf 01       	movw	r24, r30
     584:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     588:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     58c:	81 11       	cpse	r24, r1
     58e:	fc cf       	rjmp	.-8      	; 0x588 <bme280basic_init+0x34>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     590:	8d ee       	ldi	r24, 0xED	; 237
     592:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     596:	62 e0       	ldi	r22, 0x02	; 2
     598:	82 e0       	ldi	r24, 0x02	; 2
     59a:	93 e0       	ldi	r25, 0x03	; 3
     59c:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5a0:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     5a4:	81 11       	cpse	r24, r1
     5a6:	fc cf       	rjmp	.-8      	; 0x5a0 <bme280basic_init+0x4c>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     5a8:	62 e0       	ldi	r22, 0x02	; 2
     5aa:	82 e0       	ldi	r24, 0x02	; 2
     5ac:	93 e0       	ldi	r25, 0x03	; 3
     5ae:	0e 94 4e 0b 	call	0x169c	; 0x169c <TWI_Get_Data_From_Transceiver>
     5b2:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) {
     5b6:	80 91 03 03 	lds	r24, 0x0303	; 0x800303 <BMEmessageBuf+0x1>
     5ba:	80 36       	cpi	r24, 0x60	; 96
     5bc:	99 f5       	brne	.+102    	; 0x624 <bme280basic_init+0xd0>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5be:	e2 e0       	ldi	r30, 0x02	; 2
     5c0:	f3 e0       	ldi	r31, 0x03	; 3
     5c2:	8c ee       	ldi	r24, 0xEC	; 236
     5c4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     5c6:	82 ef       	ldi	r24, 0xF2	; 242
     5c8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     5ca:	81 e0       	ldi	r24, 0x01	; 1
     5cc:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ce:	63 e0       	ldi	r22, 0x03	; 3
     5d0:	cf 01       	movw	r24, r30
     5d2:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5d6:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     5da:	81 11       	cpse	r24, r1
     5dc:	fc cf       	rjmp	.-8      	; 0x5d6 <bme280basic_init+0x82>
		//
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     5de:	e2 e0       	ldi	r30, 0x02	; 2
     5e0:	f3 e0       	ldi	r31, 0x03	; 3
     5e2:	8c ee       	ldi	r24, 0xEC	; 236
     5e4:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     5e6:	85 ef       	ldi	r24, 0xF5	; 245
     5e8:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     5ea:	80 e1       	ldi	r24, 0x10	; 16
     5ec:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     5ee:	63 e0       	ldi	r22, 0x03	; 3
     5f0:	cf 01       	movw	r24, r30
     5f2:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     5f6:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     5fa:	81 11       	cpse	r24, r1
     5fc:	fc cf       	rjmp	.-8      	; 0x5f6 <bme280basic_init+0xa2>
		//
		BME_read_correction_coefficients();
     5fe:	5f de       	rcall	.-834    	; 0x2be <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     600:	81 e3       	ldi	r24, 0x31	; 49
     602:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     606:	e2 e0       	ldi	r30, 0x02	; 2
     608:	f3 e0       	ldi	r31, 0x03	; 3
     60a:	9c ee       	ldi	r25, 0xEC	; 236
     60c:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     60e:	94 ef       	ldi	r25, 0xF4	; 244
     610:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     612:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     614:	63 e0       	ldi	r22, 0x03	; 3
     616:	cf 01       	movw	r24, r30
     618:	0e 94 22 0b 	call	0x1644	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     61c:	0e 94 1e 0b 	call	0x163c	; 0x163c <TWI_Transceiver_Busy>
     620:	81 11       	cpse	r24, r1
     622:	fc cf       	rjmp	.-8      	; 0x61c <bme280basic_init+0xc8>
     624:	08 95       	ret

00000626 <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     626:	ff 92       	push	r15
     628:	0f 93       	push	r16
     62a:	1f 93       	push	r17
     62c:	cf 93       	push	r28
     62e:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     630:	81 e0       	ldi	r24, 0x01	; 1
     632:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2486>
	while (BMEbusy) {
     636:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2486>
     63a:	88 23       	and	r24, r24
     63c:	39 f1       	breq	.+78     	; 0x68c <bme280basic_bulk_data_read+0x66>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     63e:	c2 e0       	ldi	r28, 0x02	; 2
     640:	d3 e0       	ldi	r29, 0x03	; 3
     642:	0f 2e       	mov	r0, r31
     644:	fc ee       	ldi	r31, 0xEC	; 236
     646:	ff 2e       	mov	r15, r31
     648:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     64a:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     64c:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     64e:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     650:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     652:	62 e0       	ldi	r22, 0x02	; 2
     654:	ce 01       	movw	r24, r28
     656:	f6 d7       	rcall	.+4076   	; 0x1644 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     658:	f1 d7       	rcall	.+4066   	; 0x163c <TWI_Transceiver_Busy>
     65a:	81 11       	cpse	r24, r1
     65c:	fd cf       	rjmp	.-6      	; 0x658 <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1).
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     65e:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     660:	62 e0       	ldi	r22, 0x02	; 2
     662:	ce 01       	movw	r24, r28
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     664:	ef d7       	rcall	.+4062   	; 0x1644 <TWI_Start_Transceiver_With_Data>
     666:	ea d7       	rcall	.+4052   	; 0x163c <TWI_Transceiver_Busy>
     668:	81 11       	cpse	r24, r1
     66a:	fd cf       	rjmp	.-6      	; 0x666 <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     66c:	62 e0       	ldi	r22, 0x02	; 2
     66e:	ce 01       	movw	r24, r28
     670:	0e 94 4e 0b 	call	0x169c	; 0x169c <TWI_Get_Data_From_Transceiver>
     674:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     678:	89 81       	ldd	r24, Y+1	; 0x01
     67a:	83 fb       	bst	r24, 3
     67c:	88 27       	eor	r24, r24
     67e:	80 f9       	bld	r24, 0
     680:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2486>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     684:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2486>
     688:	81 11       	cpse	r24, r1
     68a:	e1 cf       	rjmp	.-62     	; 0x64e <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     68c:	e2 e0       	ldi	r30, 0x02	; 2
     68e:	f3 e0       	ldi	r31, 0x03	; 3
     690:	8c ee       	ldi	r24, 0xEC	; 236
     692:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from
     694:	87 ef       	ldi	r24, 0xF7	; 247
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     696:	81 83       	std	Z+1, r24	; 0x01
     698:	62 e0       	ldi	r22, 0x02	; 2
     69a:	cf 01       	movw	r24, r30
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     69c:	d3 d7       	rcall	.+4006   	; 0x1644 <TWI_Start_Transceiver_With_Data>
     69e:	ce d7       	rcall	.+3996   	; 0x163c <TWI_Transceiver_Busy>
     6a0:	81 11       	cpse	r24, r1
     6a2:	fd cf       	rjmp	.-6      	; 0x69e <bme280basic_bulk_data_read+0x78>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6a4:	8d ee       	ldi	r24, 0xED	; 237
     6a6:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     6aa:	69 e0       	ldi	r22, 0x09	; 9
     6ac:	82 e0       	ldi	r24, 0x02	; 2
     6ae:	93 e0       	ldi	r25, 0x03	; 3
     6b0:	c9 d7       	rcall	.+3986   	; 0x1644 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6b2:	c4 d7       	rcall	.+3976   	; 0x163c <TWI_Transceiver_Busy>
     6b4:	81 11       	cpse	r24, r1
     6b6:	fd cf       	rjmp	.-6      	; 0x6b2 <bme280basic_bulk_data_read+0x8c>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     6b8:	69 e0       	ldi	r22, 0x09	; 9
     6ba:	82 e0       	ldi	r24, 0x02	; 2
     6bc:	93 e0       	ldi	r25, 0x03	; 3
     6be:	ee d7       	rcall	.+4060   	; 0x169c <TWI_Get_Data_From_Transceiver>
     6c0:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <TWI_XFER_STATUS>
     6c4:	e3 e0       	ldi	r30, 0x03	; 3
     6c6:	f3 e0       	ldi	r31, 0x03	; 3
     6c8:	ae e2       	ldi	r26, 0x2E	; 46
     6ca:	b3 e0       	ldi	r27, 0x03	; 3
     6cc:	2b e0       	ldi	r18, 0x0B	; 11
     6ce:	33 e0       	ldi	r19, 0x03	; 3
     6d0:	81 91       	ld	r24, Z+
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     6d2:	8d 93       	st	X+, r24
     6d4:	e2 17       	cp	r30, r18
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     6d6:	f3 07       	cpc	r31, r19
     6d8:	d9 f7       	brne	.-10     	; 0x6d0 <bme280basic_bulk_data_read+0xaa>
     6da:	ee e2       	ldi	r30, 0x2E	; 46
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     6dc:	f3 e0       	ldi	r31, 0x03	; 3
     6de:	80 81       	ld	r24, Z
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	a0 e0       	ldi	r26, 0x00	; 0
     6e4:	b0 e0       	ldi	r27, 0x00	; 0
     6e6:	ac 01       	movw	r20, r24
     6e8:	bd 01       	movw	r22, r26
     6ea:	03 2e       	mov	r0, r19
     6ec:	3c e0       	ldi	r19, 0x0C	; 12
     6ee:	44 0f       	add	r20, r20
     6f0:	55 1f       	adc	r21, r21
     6f2:	66 1f       	adc	r22, r22
     6f4:	77 1f       	adc	r23, r23
     6f6:	3a 95       	dec	r19
     6f8:	d1 f7       	brne	.-12     	; 0x6ee <bme280basic_bulk_data_read+0xc8>
     6fa:	30 2d       	mov	r19, r0
     6fc:	91 81       	ldd	r25, Z+1	; 0x01
     6fe:	89 2f       	mov	r24, r25
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	a0 e0       	ldi	r26, 0x00	; 0
     704:	b0 e0       	ldi	r27, 0x00	; 0
     706:	88 0f       	add	r24, r24
     708:	99 1f       	adc	r25, r25
     70a:	aa 1f       	adc	r26, r26
     70c:	bb 1f       	adc	r27, r27
     70e:	88 0f       	add	r24, r24
     710:	99 1f       	adc	r25, r25
     712:	aa 1f       	adc	r26, r26
     714:	bb 1f       	adc	r27, r27
     716:	88 0f       	add	r24, r24
     718:	99 1f       	adc	r25, r25
     71a:	aa 1f       	adc	r26, r26
     71c:	bb 1f       	adc	r27, r27
     71e:	88 0f       	add	r24, r24
     720:	99 1f       	adc	r25, r25
     722:	aa 1f       	adc	r26, r26
     724:	bb 1f       	adc	r27, r27
     726:	84 2b       	or	r24, r20
     728:	95 2b       	or	r25, r21
     72a:	a6 2b       	or	r26, r22
     72c:	b7 2b       	or	r27, r23
     72e:	22 81       	ldd	r18, Z+2	; 0x02
     730:	22 95       	swap	r18
     732:	2f 70       	andi	r18, 0x0F	; 15
     734:	82 2b       	or	r24, r18
     736:	80 93 85 03 	sts	0x0385, r24	; 0x800385 <rawPress>
     73a:	90 93 86 03 	sts	0x0386, r25	; 0x800386 <rawPress+0x1>
     73e:	a0 93 87 03 	sts	0x0387, r26	; 0x800387 <rawPress+0x2>
     742:	b0 93 88 03 	sts	0x0388, r27	; 0x800388 <rawPress+0x3>
     746:	83 81       	ldd	r24, Z+3	; 0x03
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	a0 e0       	ldi	r26, 0x00	; 0
     74c:	b0 e0       	ldi	r27, 0x00	; 0
     74e:	ac 01       	movw	r20, r24
     750:	bd 01       	movw	r22, r26
     752:	03 2e       	mov	r0, r19
     754:	3c e0       	ldi	r19, 0x0C	; 12
     756:	44 0f       	add	r20, r20
     758:	55 1f       	adc	r21, r21
     75a:	66 1f       	adc	r22, r22
     75c:	77 1f       	adc	r23, r23
     75e:	3a 95       	dec	r19
     760:	d1 f7       	brne	.-12     	; 0x756 <bme280basic_bulk_data_read+0x130>
     762:	30 2d       	mov	r19, r0
     764:	94 81       	ldd	r25, Z+4	; 0x04
     766:	89 2f       	mov	r24, r25
     768:	90 e0       	ldi	r25, 0x00	; 0
     76a:	a0 e0       	ldi	r26, 0x00	; 0
     76c:	b0 e0       	ldi	r27, 0x00	; 0
     76e:	88 0f       	add	r24, r24
     770:	99 1f       	adc	r25, r25
     772:	aa 1f       	adc	r26, r26
     774:	bb 1f       	adc	r27, r27
     776:	88 0f       	add	r24, r24
     778:	99 1f       	adc	r25, r25
     77a:	aa 1f       	adc	r26, r26
     77c:	bb 1f       	adc	r27, r27
     77e:	88 0f       	add	r24, r24
     780:	99 1f       	adc	r25, r25
     782:	aa 1f       	adc	r26, r26
     784:	bb 1f       	adc	r27, r27
     786:	88 0f       	add	r24, r24
     788:	99 1f       	adc	r25, r25
     78a:	aa 1f       	adc	r26, r26
     78c:	bb 1f       	adc	r27, r27
     78e:	84 2b       	or	r24, r20
     790:	95 2b       	or	r25, r21
     792:	a6 2b       	or	r26, r22
     794:	b7 2b       	or	r27, r23
     796:	25 81       	ldd	r18, Z+5	; 0x05
     798:	22 95       	swap	r18
     79a:	2f 70       	andi	r18, 0x0F	; 15
     79c:	82 2b       	or	r24, r18
     79e:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <rawTemp>
     7a2:	90 93 5e 03 	sts	0x035E, r25	; 0x80035e <rawTemp+0x1>
     7a6:	a0 93 5f 03 	sts	0x035F, r26	; 0x80035f <rawTemp+0x2>
     7aa:	b0 93 60 03 	sts	0x0360, r27	; 0x800360 <rawTemp+0x3>
     7ae:	86 81       	ldd	r24, Z+6	; 0x06
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	a0 e0       	ldi	r26, 0x00	; 0
     7b4:	b0 e0       	ldi	r27, 0x00	; 0
     7b6:	ba 2f       	mov	r27, r26
     7b8:	a9 2f       	mov	r26, r25
     7ba:	98 2f       	mov	r25, r24
     7bc:	88 27       	eor	r24, r24
     7be:	27 81       	ldd	r18, Z+7	; 0x07
     7c0:	82 2b       	or	r24, r18
     7c2:	80 93 89 03 	sts	0x0389, r24	; 0x800389 <rawHum>
     7c6:	90 93 8a 03 	sts	0x038A, r25	; 0x80038a <rawHum+0x1>
     7ca:	a0 93 8b 03 	sts	0x038B, r26	; 0x80038b <rawHum+0x2>
     7ce:	b0 93 8c 03 	sts	0x038C, r27	; 0x80038c <rawHum+0x3>
     7d2:	e2 e0       	ldi	r30, 0x02	; 2
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     7d4:	f3 e0       	ldi	r31, 0x03	; 3
     7d6:	8c ee       	ldi	r24, 0xEC	; 236
     7d8:	80 83       	st	Z, r24
     7da:	84 ef       	ldi	r24, 0xF4	; 244
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     7dc:	81 83       	std	Z+1, r24	; 0x01
     7de:	81 e3       	ldi	r24, 0x31	; 49
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     7e0:	82 83       	std	Z+2, r24	; 0x02
     7e2:	63 e0       	ldi	r22, 0x03	; 3
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     7e4:	cf 01       	movw	r24, r30
     7e6:	2e d7       	rcall	.+3676   	; 0x1644 <TWI_Start_Transceiver_With_Data>
     7e8:	29 d7       	rcall	.+3666   	; 0x163c <TWI_Transceiver_Busy>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     7ea:	81 11       	cpse	r24, r1
     7ec:	fd cf       	rjmp	.-6      	; 0x7e8 <bme280basic_bulk_data_read+0x1c2>
     7ee:	df 91       	pop	r29
     7f0:	cf 91       	pop	r28
	//  All done - and the next measurement cycle has  been kicked off!
}
     7f2:	1f 91       	pop	r17
     7f4:	0f 91       	pop	r16
     7f6:	ff 90       	pop	r15
     7f8:	08 95       	ret

000007fa <BME280_compensate_T_int32>:
     7fa:	8f 92       	push	r8
     7fc:	9f 92       	push	r9

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     7fe:	af 92       	push	r10
     800:	bf 92       	push	r11
     802:	cf 92       	push	r12
     804:	df 92       	push	r13
     806:	ef 92       	push	r14
     808:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     80a:	20 91 00 03 	lds	r18, 0x0300	; 0x800300 <dig_T1>
     80e:	30 91 01 03 	lds	r19, 0x0301	; 0x800301 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     812:	6b 01       	movw	r12, r22
     814:	7c 01       	movw	r14, r24
     816:	68 94       	set
     818:	13 f8       	bld	r1, 3
     81a:	f5 94       	asr	r15
     81c:	e7 94       	ror	r14
     81e:	d7 94       	ror	r13
     820:	c7 94       	ror	r12
     822:	16 94       	lsr	r1
     824:	d1 f7       	brne	.-12     	; 0x81a <BME280_compensate_T_int32+0x20>
     826:	c2 1a       	sub	r12, r18
     828:	d3 0a       	sbc	r13, r19
     82a:	e1 08       	sbc	r14, r1
     82c:	f1 08       	sbc	r15, r1
	t_fine = var1 + var2;
     82e:	dc 01       	movw	r26, r24
     830:	cb 01       	movw	r24, r22
     832:	68 94       	set
     834:	12 f8       	bld	r1, 2
     836:	b5 95       	asr	r27
     838:	a7 95       	ror	r26
     83a:	97 95       	ror	r25
     83c:	87 95       	ror	r24
     83e:	16 94       	lsr	r1
     840:	d1 f7       	brne	.-12     	; 0x836 <BME280_compensate_T_int32+0x3c>
     842:	22 0f       	add	r18, r18
     844:	33 1f       	adc	r19, r19
     846:	4c 01       	movw	r8, r24
     848:	5d 01       	movw	r10, r26
     84a:	82 1a       	sub	r8, r18
     84c:	93 0a       	sbc	r9, r19
     84e:	a1 08       	sbc	r10, r1
     850:	b1 08       	sbc	r11, r1
     852:	a5 01       	movw	r20, r10
     854:	94 01       	movw	r18, r8
     856:	a0 91 2c 03 	lds	r26, 0x032C	; 0x80032c <dig_T2>
     85a:	b0 91 2d 03 	lds	r27, 0x032D	; 0x80032d <dig_T2+0x1>
     85e:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <__mulshisi3>
     862:	4b 01       	movw	r8, r22
     864:	5c 01       	movw	r10, r24
     866:	07 2e       	mov	r0, r23
     868:	7b e0       	ldi	r23, 0x0B	; 11
     86a:	b5 94       	asr	r11
     86c:	a7 94       	ror	r10
     86e:	97 94       	ror	r9
     870:	87 94       	ror	r8
     872:	7a 95       	dec	r23
     874:	d1 f7       	brne	.-12     	; 0x86a <BME280_compensate_T_int32+0x70>
     876:	70 2d       	mov	r23, r0
     878:	a7 01       	movw	r20, r14
     87a:	96 01       	movw	r18, r12
     87c:	c7 01       	movw	r24, r14
     87e:	b6 01       	movw	r22, r12
     880:	0e 94 b1 0c 	call	0x1962	; 0x1962 <__mulsi3>
     884:	9b 01       	movw	r18, r22
     886:	ac 01       	movw	r20, r24
     888:	01 2e       	mov	r0, r17
     88a:	1c e0       	ldi	r17, 0x0C	; 12
     88c:	55 95       	asr	r21
     88e:	47 95       	ror	r20
     890:	37 95       	ror	r19
     892:	27 95       	ror	r18
     894:	1a 95       	dec	r17
     896:	d1 f7       	brne	.-12     	; 0x88c <BME280_compensate_T_int32+0x92>
     898:	10 2d       	mov	r17, r0
     89a:	a0 91 ba 03 	lds	r26, 0x03BA	; 0x8003ba <dig_T3>
     89e:	b0 91 bb 03 	lds	r27, 0x03BB	; 0x8003bb <dig_T3+0x1>
     8a2:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <__mulshisi3>
     8a6:	dc 01       	movw	r26, r24
     8a8:	cb 01       	movw	r24, r22
     8aa:	07 2e       	mov	r0, r23
     8ac:	7e e0       	ldi	r23, 0x0E	; 14
     8ae:	b5 95       	asr	r27
     8b0:	a7 95       	ror	r26
     8b2:	97 95       	ror	r25
     8b4:	87 95       	ror	r24
     8b6:	7a 95       	dec	r23
     8b8:	d1 f7       	brne	.-12     	; 0x8ae <BME280_compensate_T_int32+0xb4>
     8ba:	70 2d       	mov	r23, r0
     8bc:	88 0d       	add	r24, r8
     8be:	99 1d       	adc	r25, r9
     8c0:	aa 1d       	adc	r26, r10
     8c2:	bb 1d       	adc	r27, r11
     8c4:	80 93 c0 03 	sts	0x03C0, r24	; 0x8003c0 <t_fine>
     8c8:	90 93 c1 03 	sts	0x03C1, r25	; 0x8003c1 <t_fine+0x1>
     8cc:	a0 93 c2 03 	sts	0x03C2, r26	; 0x8003c2 <t_fine+0x2>
     8d0:	b0 93 c3 03 	sts	0x03C3, r27	; 0x8003c3 <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
	return T;
     8d4:	6c 01       	movw	r12, r24
     8d6:	7d 01       	movw	r14, r26
     8d8:	cc 0c       	add	r12, r12
     8da:	dd 1c       	adc	r13, r13
     8dc:	ee 1c       	adc	r14, r14
     8de:	ff 1c       	adc	r15, r15
     8e0:	cc 0c       	add	r12, r12
     8e2:	dd 1c       	adc	r13, r13
     8e4:	ee 1c       	adc	r14, r14
     8e6:	ff 1c       	adc	r15, r15
     8e8:	8c 0d       	add	r24, r12
     8ea:	9d 1d       	adc	r25, r13
     8ec:	ae 1d       	adc	r26, r14
     8ee:	bf 1d       	adc	r27, r15
     8f0:	80 58       	subi	r24, 0x80	; 128
     8f2:	9f 4f       	sbci	r25, 0xFF	; 255
     8f4:	af 4f       	sbci	r26, 0xFF	; 255
     8f6:	bf 4f       	sbci	r27, 0xFF	; 255
     8f8:	69 2f       	mov	r22, r25
     8fa:	7a 2f       	mov	r23, r26
     8fc:	8b 2f       	mov	r24, r27
     8fe:	99 27       	eor	r25, r25
     900:	87 fd       	sbrc	r24, 7
     902:	9a 95       	dec	r25
}
     904:	ff 90       	pop	r15
     906:	ef 90       	pop	r14
     908:	df 90       	pop	r13
     90a:	cf 90       	pop	r12
     90c:	bf 90       	pop	r11
     90e:	af 90       	pop	r10
     910:	9f 90       	pop	r9
     912:	8f 90       	pop	r8
     914:	08 95       	ret

00000916 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     916:	2f 92       	push	r2
     918:	3f 92       	push	r3
     91a:	4f 92       	push	r4
     91c:	5f 92       	push	r5
     91e:	6f 92       	push	r6
     920:	7f 92       	push	r7
     922:	8f 92       	push	r8
     924:	9f 92       	push	r9
     926:	af 92       	push	r10
     928:	bf 92       	push	r11
     92a:	cf 92       	push	r12
     92c:	df 92       	push	r13
     92e:	ef 92       	push	r14
     930:	ff 92       	push	r15
     932:	0f 93       	push	r16
     934:	1f 93       	push	r17
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	cd b7       	in	r28, 0x3d	; 61
     93c:	de b7       	in	r29, 0x3e	; 62
     93e:	66 97       	sbiw	r28, 0x16	; 22
     940:	0f b6       	in	r0, 0x3f	; 63
     942:	f8 94       	cli
     944:	de bf       	out	0x3e, r29	; 62
     946:	0f be       	out	0x3f, r0	; 63
     948:	cd bf       	out	0x3d, r28	; 61
     94a:	69 8b       	std	Y+17, r22	; 0x11
     94c:	7a 8b       	std	Y+18, r23	; 0x12
     94e:	8b 8b       	std	Y+19, r24	; 0x13
     950:	9c 8b       	std	Y+20, r25	; 0x14
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     952:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <t_fine>
     956:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <t_fine+0x1>
     95a:	a0 91 c2 03 	lds	r26, 0x03C2	; 0x8003c2 <t_fine+0x2>
     95e:	b0 91 c3 03 	lds	r27, 0x03C3	; 0x8003c3 <t_fine+0x3>
     962:	9c 01       	movw	r18, r24
     964:	ad 01       	movw	r20, r26
     966:	34 5f       	subi	r19, 0xF4	; 244
     968:	41 40       	sbci	r20, 0x01	; 1
     96a:	51 09       	sbc	r21, r1
     96c:	29 83       	std	Y+1, r18	; 0x01
     96e:	3a 83       	std	Y+2, r19	; 0x02
     970:	4b 83       	std	Y+3, r20	; 0x03
     972:	5c 83       	std	Y+4, r21	; 0x04
     974:	55 0f       	add	r21, r21
     976:	22 0b       	sbc	r18, r18
     978:	32 2f       	mov	r19, r18
     97a:	a9 01       	movw	r20, r18
     97c:	2d 83       	std	Y+5, r18	; 0x05
     97e:	3e 83       	std	Y+6, r19	; 0x06
     980:	4f 83       	std	Y+7, r20	; 0x07
     982:	58 87       	std	Y+8, r21	; 0x08
	var2 = var1*var1*(long)dig_P6;
     984:	a9 80       	ldd	r10, Y+1	; 0x01
     986:	ba 80       	ldd	r11, Y+2	; 0x02
     988:	cb 80       	ldd	r12, Y+3	; 0x03
     98a:	dc 80       	ldd	r13, Y+4	; 0x04
     98c:	ed 80       	ldd	r14, Y+5	; 0x05
     98e:	fe 2c       	mov	r15, r14
     990:	0e 2d       	mov	r16, r14
     992:	1e 2d       	mov	r17, r14
     994:	2a 2d       	mov	r18, r10
     996:	3b 2d       	mov	r19, r11
     998:	4c 2d       	mov	r20, r12
     99a:	5d 2d       	mov	r21, r13
     99c:	60 2f       	mov	r22, r16
     99e:	70 2f       	mov	r23, r16
     9a0:	80 2f       	mov	r24, r16
     9a2:	9e 2d       	mov	r25, r14
     9a4:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <__muldi3>
     9a8:	29 87       	std	Y+9, r18	; 0x09
     9aa:	3a 87       	std	Y+10, r19	; 0x0a
     9ac:	4b 87       	std	Y+11, r20	; 0x0b
     9ae:	5c 87       	std	Y+12, r21	; 0x0c
     9b0:	6d 87       	std	Y+13, r22	; 0x0d
     9b2:	7e 87       	std	Y+14, r23	; 0x0e
     9b4:	8f 87       	std	Y+15, r24	; 0x0f
     9b6:	98 8b       	std	Y+16, r25	; 0x10
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     9b8:	30 91 66 03 	lds	r19, 0x0366	; 0x800366 <dig_P2+0x1>
     9bc:	20 91 65 03 	lds	r18, 0x0365	; 0x800365 <dig_P2>
     9c0:	93 2f       	mov	r25, r19
     9c2:	99 0f       	add	r25, r25
     9c4:	99 0b       	sbc	r25, r25
     9c6:	e0 2e       	mov	r14, r16
     9c8:	0f 2d       	mov	r16, r15
     9ca:	49 2f       	mov	r20, r25
     9cc:	59 2f       	mov	r21, r25
     9ce:	69 2f       	mov	r22, r25
     9d0:	79 2f       	mov	r23, r25
     9d2:	89 2f       	mov	r24, r25
     9d4:	ee d7       	rcall	.+4060   	; 0x19b2 <__muldi3>
     9d6:	0c e0       	ldi	r16, 0x0C	; 12
     9d8:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__ashldi3>
     9dc:	62 2e       	mov	r6, r18
     9de:	73 2e       	mov	r7, r19
     9e0:	84 2e       	mov	r8, r20
     9e2:	95 2e       	mov	r9, r21
     9e4:	6e 8b       	std	Y+22, r22	; 0x16
     9e6:	7d 8b       	std	Y+21, r23	; 0x15
     9e8:	58 2e       	mov	r5, r24
     9ea:	49 2e       	mov	r4, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     9ec:	30 91 ab 03 	lds	r19, 0x03AB	; 0x8003ab <dig_P3+0x1>
     9f0:	20 91 aa 03 	lds	r18, 0x03AA	; 0x8003aa <dig_P3>
     9f4:	93 2f       	mov	r25, r19
     9f6:	99 0f       	add	r25, r25
     9f8:	99 0b       	sbc	r25, r25
     9fa:	a9 84       	ldd	r10, Y+9	; 0x09
     9fc:	ba 84       	ldd	r11, Y+10	; 0x0a
     9fe:	cb 84       	ldd	r12, Y+11	; 0x0b
     a00:	dc 84       	ldd	r13, Y+12	; 0x0c
     a02:	ed 84       	ldd	r14, Y+13	; 0x0d
     a04:	fe 84       	ldd	r15, Y+14	; 0x0e
     a06:	0f 85       	ldd	r16, Y+15	; 0x0f
     a08:	18 89       	ldd	r17, Y+16	; 0x10
     a0a:	49 2f       	mov	r20, r25
     a0c:	59 2f       	mov	r21, r25
     a0e:	69 2f       	mov	r22, r25
     a10:	79 2f       	mov	r23, r25
     a12:	89 2f       	mov	r24, r25
     a14:	ce d7       	rcall	.+3996   	; 0x19b2 <__muldi3>
     a16:	08 e0       	ldi	r16, 0x08	; 8
     a18:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__ashrdi3>
     a1c:	a6 2c       	mov	r10, r6
     a1e:	b7 2c       	mov	r11, r7
     a20:	c8 2c       	mov	r12, r8
     a22:	d9 2c       	mov	r13, r9
     a24:	ee 88       	ldd	r14, Y+22	; 0x16
     a26:	fd 88       	ldd	r15, Y+21	; 0x15
     a28:	05 2d       	mov	r16, r5
     a2a:	14 2d       	mov	r17, r4
     a2c:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <__adddi3>
     a30:	70 58       	subi	r23, 0x80	; 128
     a32:	8f 4f       	sbci	r24, 0xFF	; 255
     a34:	9f 4f       	sbci	r25, 0xFF	; 255
     a36:	20 90 a8 03 	lds	r2, 0x03A8	; 0x8003a8 <dig_P1>
     a3a:	30 90 a9 03 	lds	r3, 0x03A9	; 0x8003a9 <dig_P1+0x1>
     a3e:	a2 2c       	mov	r10, r2
     a40:	b3 2c       	mov	r11, r3
     a42:	c1 2c       	mov	r12, r1
     a44:	d1 2c       	mov	r13, r1
     a46:	e1 2c       	mov	r14, r1
     a48:	f1 2c       	mov	r15, r1
     a4a:	00 e0       	ldi	r16, 0x00	; 0
     a4c:	10 e0       	ldi	r17, 0x00	; 0
     a4e:	b1 d7       	rcall	.+3938   	; 0x19b2 <__muldi3>
     a50:	01 e2       	ldi	r16, 0x21	; 33
     a52:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__ashrdi3>
     a56:	32 2e       	mov	r3, r18
     a58:	23 2e       	mov	r2, r19
     a5a:	94 2e       	mov	r9, r20
     a5c:	5e 8b       	std	Y+22, r21	; 0x16
     a5e:	6d 8b       	std	Y+21, r22	; 0x15
     a60:	47 2e       	mov	r4, r23
     a62:	58 2e       	mov	r5, r24
     a64:	69 2e       	mov	r6, r25
	if (var1 == 0)
     a66:	a0 e0       	ldi	r26, 0x00	; 0
     a68:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <__cmpdi2_s8>
     a6c:	09 f4       	brne	.+2      	; 0xa70 <BME280_compensate_P_int64+0x15a>
     a6e:	40 c1       	rjmp	.+640    	; 0xcf0 <BME280_compensate_P_int64+0x3da>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     a70:	30 91 bd 03 	lds	r19, 0x03BD	; 0x8003bd <dig_P6+0x1>
     a74:	20 91 bc 03 	lds	r18, 0x03BC	; 0x8003bc <dig_P6>
     a78:	93 2f       	mov	r25, r19
     a7a:	99 0f       	add	r25, r25
     a7c:	99 0b       	sbc	r25, r25
     a7e:	a9 84       	ldd	r10, Y+9	; 0x09
     a80:	ba 84       	ldd	r11, Y+10	; 0x0a
     a82:	cb 84       	ldd	r12, Y+11	; 0x0b
     a84:	dc 84       	ldd	r13, Y+12	; 0x0c
     a86:	ed 84       	ldd	r14, Y+13	; 0x0d
     a88:	fe 84       	ldd	r15, Y+14	; 0x0e
     a8a:	0f 85       	ldd	r16, Y+15	; 0x0f
     a8c:	18 89       	ldd	r17, Y+16	; 0x10
     a8e:	49 2f       	mov	r20, r25
     a90:	59 2f       	mov	r21, r25
     a92:	69 2f       	mov	r22, r25
     a94:	79 2f       	mov	r23, r25
     a96:	89 2f       	mov	r24, r25
     a98:	8c d7       	rcall	.+3864   	; 0x19b2 <__muldi3>
     a9a:	29 87       	std	Y+9, r18	; 0x09
     a9c:	3a 87       	std	Y+10, r19	; 0x0a
     a9e:	4b 87       	std	Y+11, r20	; 0x0b
     aa0:	75 2e       	mov	r7, r21
     aa2:	86 2e       	mov	r8, r22
     aa4:	7c 87       	std	Y+12, r23	; 0x0c
     aa6:	8d 87       	std	Y+13, r24	; 0x0d
     aa8:	9e 87       	std	Y+14, r25	; 0x0e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     aaa:	30 91 84 03 	lds	r19, 0x0384	; 0x800384 <dig_P5+0x1>
     aae:	20 91 83 03 	lds	r18, 0x0383	; 0x800383 <dig_P5>
     ab2:	93 2f       	mov	r25, r19
     ab4:	99 0f       	add	r25, r25
     ab6:	99 0b       	sbc	r25, r25
     ab8:	a9 80       	ldd	r10, Y+1	; 0x01
     aba:	ba 80       	ldd	r11, Y+2	; 0x02
     abc:	cb 80       	ldd	r12, Y+3	; 0x03
     abe:	dc 80       	ldd	r13, Y+4	; 0x04
     ac0:	ed 80       	ldd	r14, Y+5	; 0x05
     ac2:	fe 2c       	mov	r15, r14
     ac4:	0e 2d       	mov	r16, r14
     ac6:	1e 2d       	mov	r17, r14
     ac8:	49 2f       	mov	r20, r25
     aca:	59 2f       	mov	r21, r25
     acc:	69 2f       	mov	r22, r25
     ace:	79 2f       	mov	r23, r25
     ad0:	89 2f       	mov	r24, r25
     ad2:	6f d7       	rcall	.+3806   	; 0x19b2 <__muldi3>
     ad4:	01 e1       	ldi	r16, 0x11	; 17
     ad6:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__ashldi3>
     ada:	a9 84       	ldd	r10, Y+9	; 0x09
     adc:	ba 84       	ldd	r11, Y+10	; 0x0a
     ade:	cb 84       	ldd	r12, Y+11	; 0x0b
     ae0:	d7 2c       	mov	r13, r7
     ae2:	e8 2c       	mov	r14, r8
     ae4:	fc 84       	ldd	r15, Y+12	; 0x0c
     ae6:	0d 85       	ldd	r16, Y+13	; 0x0d
     ae8:	1e 85       	ldd	r17, Y+14	; 0x0e
     aea:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <__adddi3>
     aee:	a2 2e       	mov	r10, r18
     af0:	b3 2e       	mov	r11, r19
     af2:	c4 2e       	mov	r12, r20
     af4:	d5 2e       	mov	r13, r21
     af6:	e6 2e       	mov	r14, r22
     af8:	f7 2e       	mov	r15, r23
     afa:	78 2e       	mov	r7, r24
     afc:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	29 89       	ldd	r18, Y+17	; 0x11
     b08:	3a 89       	ldd	r19, Y+18	; 0x12
     b0a:	4b 89       	ldd	r20, Y+19	; 0x13
     b0c:	5c 89       	ldd	r21, Y+20	; 0x14
     b0e:	82 1b       	sub	r24, r18
     b10:	93 0b       	sbc	r25, r19
     b12:	a4 0b       	sbc	r26, r20
     b14:	b5 0b       	sbc	r27, r21
     b16:	9c 01       	movw	r18, r24
     b18:	ad 01       	movw	r20, r26
     b1a:	55 0f       	add	r21, r21
     b1c:	22 0b       	sbc	r18, r18
     b1e:	32 2f       	mov	r19, r18
     b20:	a9 01       	movw	r20, r18
     b22:	29 83       	std	Y+1, r18	; 0x01
     b24:	3a 83       	std	Y+2, r19	; 0x02
     b26:	4b 83       	std	Y+3, r20	; 0x03
     b28:	5c 83       	std	Y+4, r21	; 0x04
     b2a:	28 2f       	mov	r18, r24
     b2c:	39 2f       	mov	r19, r25
     b2e:	4a 2f       	mov	r20, r26
     b30:	5b 2f       	mov	r21, r27
     b32:	69 81       	ldd	r22, Y+1	; 0x01
     b34:	76 2f       	mov	r23, r22
     b36:	86 2f       	mov	r24, r22
     b38:	96 2f       	mov	r25, r22
     b3a:	0f e1       	ldi	r16, 0x1F	; 31
     b3c:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__ashldi3>
     b40:	82 2e       	mov	r8, r18
     b42:	39 83       	std	Y+1, r19	; 0x01
     b44:	4d 83       	std	Y+5, r20	; 0x05
     b46:	59 87       	std	Y+9, r21	; 0x09
     b48:	b6 2f       	mov	r27, r22
     b4a:	a7 2f       	mov	r26, r23
     b4c:	f8 2f       	mov	r31, r24
     b4e:	e9 2f       	mov	r30, r25
     b50:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <dig_P4+0x1>
     b54:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <dig_P4>
     b58:	93 2f       	mov	r25, r19
     b5a:	99 0f       	add	r25, r25
     b5c:	99 0b       	sbc	r25, r25
     b5e:	49 2f       	mov	r20, r25
     b60:	59 2f       	mov	r21, r25
     b62:	69 2f       	mov	r22, r25
     b64:	79 2f       	mov	r23, r25
     b66:	89 2f       	mov	r24, r25
     b68:	03 e2       	ldi	r16, 0x23	; 35
     b6a:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <__ashldi3>
     b6e:	07 2d       	mov	r16, r7
     b70:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <__adddi3>
     b74:	a2 2e       	mov	r10, r18
     b76:	b3 2e       	mov	r11, r19
     b78:	c4 2e       	mov	r12, r20
     b7a:	d5 2e       	mov	r13, r21
     b7c:	e6 2e       	mov	r14, r22
     b7e:	f7 2e       	mov	r15, r23
     b80:	08 2f       	mov	r16, r24
     b82:	19 2f       	mov	r17, r25
     b84:	28 2d       	mov	r18, r8
     b86:	39 81       	ldd	r19, Y+1	; 0x01
     b88:	4d 81       	ldd	r20, Y+5	; 0x05
     b8a:	59 85       	ldd	r21, Y+9	; 0x09
     b8c:	6b 2f       	mov	r22, r27
     b8e:	7a 2f       	mov	r23, r26
     b90:	8f 2f       	mov	r24, r31
     b92:	9e 2f       	mov	r25, r30
     b94:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <__subdi3>
     b98:	0f 2e       	mov	r0, r31
     b9a:	f5 e3       	ldi	r31, 0x35	; 53
     b9c:	af 2e       	mov	r10, r31
     b9e:	f0 2d       	mov	r31, r0
     ba0:	0f 2e       	mov	r0, r31
     ba2:	fc e0       	ldi	r31, 0x0C	; 12
     ba4:	bf 2e       	mov	r11, r31
     ba6:	f0 2d       	mov	r31, r0
     ba8:	c1 2c       	mov	r12, r1
     baa:	d1 2c       	mov	r13, r1
     bac:	e1 2c       	mov	r14, r1
     bae:	f1 2c       	mov	r15, r1
     bb0:	00 e0       	ldi	r16, 0x00	; 0
     bb2:	10 e0       	ldi	r17, 0x00	; 0
     bb4:	fe d6       	rcall	.+3580   	; 0x19b2 <__muldi3>
     bb6:	a3 2c       	mov	r10, r3
     bb8:	b2 2c       	mov	r11, r2
     bba:	c9 2c       	mov	r12, r9
     bbc:	de 88       	ldd	r13, Y+22	; 0x16
     bbe:	ed 88       	ldd	r14, Y+21	; 0x15
     bc0:	f4 2c       	mov	r15, r4
     bc2:	05 2d       	mov	r16, r5
     bc4:	16 2d       	mov	r17, r6
     bc6:	48 d7       	rcall	.+3728   	; 0x1a58 <__divdi3>
     bc8:	2e 87       	std	Y+14, r18	; 0x0e
     bca:	3d 87       	std	Y+13, r19	; 0x0d
     bcc:	49 83       	std	Y+1, r20	; 0x01
     bce:	5d 83       	std	Y+5, r21	; 0x05
     bd0:	69 87       	std	Y+9, r22	; 0x09
     bd2:	7a 87       	std	Y+10, r23	; 0x0a
     bd4:	8b 87       	std	Y+11, r24	; 0x0b
     bd6:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     bd8:	0d e0       	ldi	r16, 0x0D	; 13
     bda:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__ashrdi3>
     bde:	92 2e       	mov	r9, r18
     be0:	83 2e       	mov	r8, r19
     be2:	74 2e       	mov	r7, r20
     be4:	65 2e       	mov	r6, r21
     be6:	56 2e       	mov	r5, r22
     be8:	47 2e       	mov	r4, r23
     bea:	38 2e       	mov	r3, r24
     bec:	29 2e       	mov	r2, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     bee:	30 91 b9 03 	lds	r19, 0x03B9	; 0x8003b9 <dig_P9+0x1>
     bf2:	20 91 b8 03 	lds	r18, 0x03B8	; 0x8003b8 <dig_P9>
     bf6:	93 2f       	mov	r25, r19
     bf8:	99 0f       	add	r25, r25
     bfa:	99 0b       	sbc	r25, r25
     bfc:	a9 2c       	mov	r10, r9
     bfe:	b8 2c       	mov	r11, r8
     c00:	c7 2c       	mov	r12, r7
     c02:	d6 2c       	mov	r13, r6
     c04:	e5 2c       	mov	r14, r5
     c06:	f4 2c       	mov	r15, r4
     c08:	03 2d       	mov	r16, r3
     c0a:	12 2d       	mov	r17, r2
     c0c:	49 2f       	mov	r20, r25
     c0e:	59 2f       	mov	r21, r25
     c10:	69 2f       	mov	r22, r25
     c12:	79 2f       	mov	r23, r25
     c14:	89 2f       	mov	r24, r25
     c16:	cd d6       	rcall	.+3482   	; 0x19b2 <__muldi3>
     c18:	cc d6       	rcall	.+3480   	; 0x19b2 <__muldi3>
     c1a:	09 e1       	ldi	r16, 0x19	; 25
     c1c:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <__ashrdi3>
     c20:	ae 84       	ldd	r10, Y+14	; 0x0e
     c22:	bd 84       	ldd	r11, Y+13	; 0x0d
     c24:	c9 80       	ldd	r12, Y+1	; 0x01
     c26:	dd 80       	ldd	r13, Y+5	; 0x05
     c28:	e9 84       	ldd	r14, Y+9	; 0x09
     c2a:	fa 84       	ldd	r15, Y+10	; 0x0a
     c2c:	0b 85       	ldd	r16, Y+11	; 0x0b
     c2e:	1c 85       	ldd	r17, Y+12	; 0x0c
     c30:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <__adddi3>
     c34:	22 2e       	mov	r2, r18
     c36:	33 2e       	mov	r3, r19
     c38:	44 2e       	mov	r4, r20
     c3a:	55 2e       	mov	r5, r21
     c3c:	66 2e       	mov	r6, r22
     c3e:	77 2e       	mov	r7, r23
     c40:	88 2e       	mov	r8, r24
     c42:	99 2e       	mov	r9, r25
     c44:	30 91 ad 03 	lds	r19, 0x03AD	; 0x8003ad <dig_P8+0x1>
     c48:	20 91 ac 03 	lds	r18, 0x03AC	; 0x8003ac <dig_P8>
     c4c:	93 2f       	mov	r25, r19
     c4e:	99 0f       	add	r25, r25
     c50:	99 0b       	sbc	r25, r25
     c52:	49 2f       	mov	r20, r25
     c54:	59 2f       	mov	r21, r25
     c56:	69 2f       	mov	r22, r25
     c58:	79 2f       	mov	r23, r25
     c5a:	89 2f       	mov	r24, r25
     c5c:	aa d6       	rcall	.+3412   	; 0x19b2 <__muldi3>
     c5e:	03 e1       	ldi	r16, 0x13	; 19
     c60:	e2 d7       	rcall	.+4036   	; 0x1c26 <__ashrdi3>
     c62:	a2 2e       	mov	r10, r18
     c64:	b3 2e       	mov	r11, r19
     c66:	c4 2e       	mov	r12, r20
     c68:	d5 2e       	mov	r13, r21
     c6a:	e6 2e       	mov	r14, r22
     c6c:	f7 2e       	mov	r15, r23
     c6e:	08 2f       	mov	r16, r24
     c70:	19 2f       	mov	r17, r25
     c72:	22 2d       	mov	r18, r2
     c74:	33 2d       	mov	r19, r3
     c76:	44 2d       	mov	r20, r4
     c78:	55 2d       	mov	r21, r5
     c7a:	66 2d       	mov	r22, r6
     c7c:	77 2d       	mov	r23, r7
     c7e:	88 2d       	mov	r24, r8
     c80:	99 2d       	mov	r25, r9
     c82:	ef d7       	rcall	.+4062   	; 0x1c62 <__adddi3>
     c84:	08 e0       	ldi	r16, 0x08	; 8
     c86:	cf d7       	rcall	.+3998   	; 0x1c26 <__ashrdi3>
     c88:	a2 2e       	mov	r10, r18
     c8a:	b3 2e       	mov	r11, r19
     c8c:	c4 2e       	mov	r12, r20
     c8e:	d5 2e       	mov	r13, r21
     c90:	e6 2e       	mov	r14, r22
     c92:	f7 2e       	mov	r15, r23
     c94:	08 2f       	mov	r16, r24
     c96:	19 2f       	mov	r17, r25
	return(long)p;
     c98:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <dig_P7>
     c9c:	90 91 ff 02 	lds	r25, 0x02FF	; 0x8002ff <dig_P7+0x1>
     ca0:	09 2e       	mov	r0, r25
     ca2:	00 0c       	add	r0, r0
     ca4:	aa 0b       	sbc	r26, r26
     ca6:	bb 0b       	sbc	r27, r27
     ca8:	88 0f       	add	r24, r24
     caa:	99 1f       	adc	r25, r25
     cac:	aa 1f       	adc	r26, r26
     cae:	bb 1f       	adc	r27, r27
     cb0:	88 0f       	add	r24, r24
     cb2:	99 1f       	adc	r25, r25
     cb4:	aa 1f       	adc	r26, r26
     cb6:	bb 1f       	adc	r27, r27
     cb8:	88 0f       	add	r24, r24
     cba:	99 1f       	adc	r25, r25
     cbc:	aa 1f       	adc	r26, r26
     cbe:	bb 1f       	adc	r27, r27
     cc0:	88 0f       	add	r24, r24
     cc2:	99 1f       	adc	r25, r25
     cc4:	aa 1f       	adc	r26, r26
     cc6:	bb 1f       	adc	r27, r27
     cc8:	2c 01       	movw	r4, r24
     cca:	3d 01       	movw	r6, r26
     ccc:	77 0c       	add	r7, r7
     cce:	44 08       	sbc	r4, r4
     cd0:	54 2c       	mov	r5, r4
     cd2:	32 01       	movw	r6, r4
     cd4:	28 2f       	mov	r18, r24
     cd6:	39 2f       	mov	r19, r25
     cd8:	4a 2f       	mov	r20, r26
     cda:	5b 2f       	mov	r21, r27
     cdc:	64 2d       	mov	r22, r4
     cde:	74 2d       	mov	r23, r4
     ce0:	84 2d       	mov	r24, r4
     ce2:	94 2d       	mov	r25, r4
     ce4:	be d7       	rcall	.+3964   	; 0x1c62 <__adddi3>
     ce6:	62 2f       	mov	r22, r18
     ce8:	73 2f       	mov	r23, r19
     cea:	84 2f       	mov	r24, r20
     cec:	95 2f       	mov	r25, r21
     cee:	04 c0       	rjmp	.+8      	; 0xcf8 <BME280_compensate_P_int64+0x3e2>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
     cf0:	60 e0       	ldi	r22, 0x00	; 0
     cf2:	70 e0       	ldi	r23, 0x00	; 0
     cf4:	80 e0       	ldi	r24, 0x00	; 0
     cf6:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
     cf8:	66 96       	adiw	r28, 0x16	; 22
     cfa:	0f b6       	in	r0, 0x3f	; 63
     cfc:	f8 94       	cli
     cfe:	de bf       	out	0x3e, r29	; 62
     d00:	0f be       	out	0x3f, r0	; 63
     d02:	cd bf       	out	0x3d, r28	; 61
     d04:	df 91       	pop	r29
     d06:	cf 91       	pop	r28
     d08:	1f 91       	pop	r17
     d0a:	0f 91       	pop	r16
     d0c:	ff 90       	pop	r15
     d0e:	ef 90       	pop	r14
     d10:	df 90       	pop	r13
     d12:	cf 90       	pop	r12
     d14:	bf 90       	pop	r11
     d16:	af 90       	pop	r10
     d18:	9f 90       	pop	r9
     d1a:	8f 90       	pop	r8
     d1c:	7f 90       	pop	r7
     d1e:	6f 90       	pop	r6
     d20:	5f 90       	pop	r5
     d22:	4f 90       	pop	r4
     d24:	3f 90       	pop	r3
     d26:	2f 90       	pop	r2
     d28:	08 95       	ret

00000d2a <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
     d2a:	2f 92       	push	r2
     d2c:	3f 92       	push	r3
     d2e:	4f 92       	push	r4
     d30:	5f 92       	push	r5
     d32:	6f 92       	push	r6
     d34:	7f 92       	push	r7
     d36:	8f 92       	push	r8
     d38:	9f 92       	push	r9
     d3a:	af 92       	push	r10
     d3c:	bf 92       	push	r11
     d3e:	cf 92       	push	r12
     d40:	df 92       	push	r13
     d42:	ef 92       	push	r14
     d44:	ff 92       	push	r15
     d46:	0f 93       	push	r16
     d48:	1f 93       	push	r17
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	cd b7       	in	r28, 0x3d	; 61
     d50:	de b7       	in	r29, 0x3e	; 62
     d52:	67 97       	sbiw	r28, 0x17	; 23
     d54:	0f b6       	in	r0, 0x3f	; 63
     d56:	f8 94       	cli
     d58:	de bf       	out	0x3e, r29	; 62
     d5a:	0f be       	out	0x3f, r0	; 63
     d5c:	cd bf       	out	0x3d, r28	; 61
     d5e:	2b 01       	movw	r4, r22
     d60:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
     d62:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <t_fine>
     d66:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <t_fine+0x1>
     d6a:	a0 91 c2 03 	lds	r26, 0x03C2	; 0x8003c2 <t_fine+0x2>
     d6e:	b0 91 c3 03 	lds	r27, 0x03C3	; 0x8003c3 <t_fine+0x3>
     d72:	6c 01       	movw	r12, r24
     d74:	7d 01       	movw	r14, r26
     d76:	ff 0c       	add	r15, r15
     d78:	cc 08       	sbc	r12, r12
     d7a:	dc 2c       	mov	r13, r12
     d7c:	76 01       	movw	r14, r12
     d7e:	28 2f       	mov	r18, r24
     d80:	39 2f       	mov	r19, r25
     d82:	4a 2f       	mov	r20, r26
     d84:	5b 2f       	mov	r21, r27
     d86:	6c 2d       	mov	r22, r12
     d88:	7c 2d       	mov	r23, r12
     d8a:	8c 2d       	mov	r24, r12
     d8c:	9c 2d       	mov	r25, r12
     d8e:	3c 52       	subi	r19, 0x2C	; 44
     d90:	41 40       	sbci	r20, 0x01	; 1
     d92:	51 09       	sbc	r21, r1
     d94:	61 09       	sbc	r22, r1
     d96:	71 09       	sbc	r23, r1
     d98:	81 09       	sbc	r24, r1
     d9a:	91 09       	sbc	r25, r1
     d9c:	2f 8b       	std	Y+23, r18	; 0x17
     d9e:	3e 8b       	std	Y+22, r19	; 0x16
     da0:	49 83       	std	Y+1, r20	; 0x01
     da2:	59 87       	std	Y+9, r21	; 0x09
     da4:	6a 87       	std	Y+10, r22	; 0x0a
     da6:	7b 87       	std	Y+11, r23	; 0x0b
     da8:	8c 87       	std	Y+12, r24	; 0x0c
     daa:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
     dac:	03 2e       	mov	r0, r19
     dae:	3e e0       	ldi	r19, 0x0E	; 14
     db0:	44 0c       	add	r4, r4
     db2:	55 1c       	adc	r5, r5
     db4:	66 1c       	adc	r6, r6
     db6:	77 1c       	adc	r7, r7
     db8:	3a 95       	dec	r19
     dba:	d1 f7       	brne	.-12     	; 0xdb0 <bme280_compensate_H_int32+0x86>
     dbc:	30 2d       	mov	r19, r0
     dbe:	53 01       	movw	r10, r6
     dc0:	42 01       	movw	r8, r4
     dc2:	bb 0c       	add	r11, r11
     dc4:	88 08       	sbc	r8, r8
     dc6:	98 2c       	mov	r9, r8
     dc8:	54 01       	movw	r10, r8
     dca:	30 91 2b 03 	lds	r19, 0x032B	; 0x80032b <dig_H4+0x1>
     dce:	20 91 2a 03 	lds	r18, 0x032A	; 0x80032a <dig_H4>
     dd2:	93 2f       	mov	r25, r19
     dd4:	99 0f       	add	r25, r25
     dd6:	99 0b       	sbc	r25, r25
     dd8:	49 2f       	mov	r20, r25
     dda:	59 2f       	mov	r21, r25
     ddc:	69 2f       	mov	r22, r25
     dde:	79 2f       	mov	r23, r25
     de0:	89 2f       	mov	r24, r25
     de2:	04 e1       	ldi	r16, 0x14	; 20
     de4:	07 d7       	rcall	.+3598   	; 0x1bf4 <__ashldi3>
     de6:	f2 2f       	mov	r31, r18
     de8:	e3 2f       	mov	r30, r19
     dea:	c4 2e       	mov	r12, r20
     dec:	d5 2e       	mov	r13, r21
     dee:	e6 2e       	mov	r14, r22
     df0:	f7 2e       	mov	r15, r23
     df2:	08 2f       	mov	r16, r24
     df4:	19 2f       	mov	r17, r25
     df6:	24 2d       	mov	r18, r4
     df8:	35 2d       	mov	r19, r5
     dfa:	46 2d       	mov	r20, r6
     dfc:	57 2d       	mov	r21, r7
     dfe:	68 2d       	mov	r22, r8
     e00:	78 2d       	mov	r23, r8
     e02:	88 2d       	mov	r24, r8
     e04:	98 2d       	mov	r25, r8
     e06:	af 2e       	mov	r10, r31
     e08:	be 2e       	mov	r11, r30
     e0a:	34 d7       	rcall	.+3688   	; 0x1c74 <__subdi3>
     e0c:	22 2e       	mov	r2, r18
     e0e:	33 2e       	mov	r3, r19
     e10:	44 2e       	mov	r4, r20
     e12:	55 2e       	mov	r5, r21
     e14:	66 2e       	mov	r6, r22
     e16:	77 2e       	mov	r7, r23
     e18:	88 2e       	mov	r8, r24
     e1a:	99 2e       	mov	r9, r25
     e1c:	30 91 b0 03 	lds	r19, 0x03B0	; 0x8003b0 <dig_H5+0x1>
     e20:	20 91 af 03 	lds	r18, 0x03AF	; 0x8003af <dig_H5>
     e24:	93 2f       	mov	r25, r19
     e26:	99 0f       	add	r25, r25
     e28:	99 0b       	sbc	r25, r25
     e2a:	af 88       	ldd	r10, Y+23	; 0x17
     e2c:	be 88       	ldd	r11, Y+22	; 0x16
     e2e:	c9 80       	ldd	r12, Y+1	; 0x01
     e30:	d9 84       	ldd	r13, Y+9	; 0x09
     e32:	ea 84       	ldd	r14, Y+10	; 0x0a
     e34:	fb 84       	ldd	r15, Y+11	; 0x0b
     e36:	0c 85       	ldd	r16, Y+12	; 0x0c
     e38:	1d 85       	ldd	r17, Y+13	; 0x0d
     e3a:	49 2f       	mov	r20, r25
     e3c:	59 2f       	mov	r21, r25
     e3e:	69 2f       	mov	r22, r25
     e40:	79 2f       	mov	r23, r25
     e42:	89 2f       	mov	r24, r25
     e44:	b6 d5       	rcall	.+2924   	; 0x19b2 <__muldi3>
     e46:	a2 2e       	mov	r10, r18
     e48:	b3 2e       	mov	r11, r19
     e4a:	c4 2e       	mov	r12, r20
     e4c:	d5 2e       	mov	r13, r21
     e4e:	e6 2e       	mov	r14, r22
     e50:	f7 2e       	mov	r15, r23
     e52:	08 2f       	mov	r16, r24
     e54:	19 2f       	mov	r17, r25
     e56:	22 2d       	mov	r18, r2
     e58:	33 2d       	mov	r19, r3
     e5a:	44 2d       	mov	r20, r4
     e5c:	55 2d       	mov	r21, r5
     e5e:	66 2d       	mov	r22, r6
     e60:	77 2d       	mov	r23, r7
     e62:	88 2d       	mov	r24, r8
     e64:	99 2d       	mov	r25, r9
     e66:	06 d7       	rcall	.+3596   	; 0x1c74 <__subdi3>
     e68:	30 5c       	subi	r19, 0xC0	; 192
     e6a:	4f 4f       	sbci	r20, 0xFF	; 255
     e6c:	5f 4f       	sbci	r21, 0xFF	; 255
     e6e:	6f 4f       	sbci	r22, 0xFF	; 255
     e70:	7f 4f       	sbci	r23, 0xFF	; 255
     e72:	8f 4f       	sbci	r24, 0xFF	; 255
     e74:	9f 4f       	sbci	r25, 0xFF	; 255
     e76:	0f e0       	ldi	r16, 0x0F	; 15
     e78:	d6 d6       	rcall	.+3500   	; 0x1c26 <__ashrdi3>
     e7a:	2e 87       	std	Y+14, r18	; 0x0e
     e7c:	3f 87       	std	Y+15, r19	; 0x0f
     e7e:	48 8b       	std	Y+16, r20	; 0x10
     e80:	59 8b       	std	Y+17, r21	; 0x11
     e82:	6a 8b       	std	Y+18, r22	; 0x12
     e84:	7b 8b       	std	Y+19, r23	; 0x13
     e86:	8c 8b       	std	Y+20, r24	; 0x14
     e88:	9d 8b       	std	Y+21, r25	; 0x15
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
     e8a:	40 91 b2 03 	lds	r20, 0x03B2	; 0x8003b2 <dig_H3>
     e8e:	50 91 b3 03 	lds	r21, 0x03B3	; 0x8003b3 <dig_H3+0x1>
     e92:	af 88       	ldd	r10, Y+23	; 0x17
     e94:	be 88       	ldd	r11, Y+22	; 0x16
     e96:	c9 80       	ldd	r12, Y+1	; 0x01
     e98:	d9 84       	ldd	r13, Y+9	; 0x09
     e9a:	ea 84       	ldd	r14, Y+10	; 0x0a
     e9c:	fb 84       	ldd	r15, Y+11	; 0x0b
     e9e:	0c 85       	ldd	r16, Y+12	; 0x0c
     ea0:	1d 85       	ldd	r17, Y+13	; 0x0d
     ea2:	24 2f       	mov	r18, r20
     ea4:	35 2f       	mov	r19, r21
     ea6:	40 e0       	ldi	r20, 0x00	; 0
     ea8:	50 e0       	ldi	r21, 0x00	; 0
     eaa:	60 e0       	ldi	r22, 0x00	; 0
     eac:	70 e0       	ldi	r23, 0x00	; 0
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	7f d5       	rcall	.+2814   	; 0x19b2 <__muldi3>
     eb4:	0b e0       	ldi	r16, 0x0B	; 11
     eb6:	b7 d6       	rcall	.+3438   	; 0x1c26 <__ashrdi3>
     eb8:	30 58       	subi	r19, 0x80	; 128
     eba:	4f 4f       	sbci	r20, 0xFF	; 255
     ebc:	5f 4f       	sbci	r21, 0xFF	; 255
     ebe:	6f 4f       	sbci	r22, 0xFF	; 255
     ec0:	7f 4f       	sbci	r23, 0xFF	; 255
     ec2:	8f 4f       	sbci	r24, 0xFF	; 255
     ec4:	9f 4f       	sbci	r25, 0xFF	; 255
     ec6:	22 2e       	mov	r2, r18
     ec8:	33 2e       	mov	r3, r19
     eca:	44 2e       	mov	r4, r20
     ecc:	55 2e       	mov	r5, r21
     ece:	66 2e       	mov	r6, r22
     ed0:	77 2e       	mov	r7, r23
     ed2:	88 2e       	mov	r8, r24
     ed4:	99 2e       	mov	r9, r25
     ed6:	30 91 71 03 	lds	r19, 0x0371	; 0x800371 <dig_H6+0x1>
     eda:	20 91 70 03 	lds	r18, 0x0370	; 0x800370 <dig_H6>
     ede:	93 2f       	mov	r25, r19
     ee0:	99 0f       	add	r25, r25
     ee2:	99 0b       	sbc	r25, r25
     ee4:	0c 85       	ldd	r16, Y+12	; 0x0c
     ee6:	49 2f       	mov	r20, r25
     ee8:	59 2f       	mov	r21, r25
     eea:	69 2f       	mov	r22, r25
     eec:	79 2f       	mov	r23, r25
     eee:	89 2f       	mov	r24, r25
     ef0:	60 d5       	rcall	.+2752   	; 0x19b2 <__muldi3>
     ef2:	0a e0       	ldi	r16, 0x0A	; 10
     ef4:	98 d6       	rcall	.+3376   	; 0x1c26 <__ashrdi3>
     ef6:	a2 2e       	mov	r10, r18
     ef8:	b3 2e       	mov	r11, r19
     efa:	c4 2e       	mov	r12, r20
     efc:	d5 2e       	mov	r13, r21
     efe:	e6 2e       	mov	r14, r22
     f00:	f7 2e       	mov	r15, r23
     f02:	08 2f       	mov	r16, r24
     f04:	19 2f       	mov	r17, r25
     f06:	22 2d       	mov	r18, r2
     f08:	33 2d       	mov	r19, r3
     f0a:	44 2d       	mov	r20, r4
     f0c:	55 2d       	mov	r21, r5
     f0e:	66 2d       	mov	r22, r6
     f10:	77 2d       	mov	r23, r7
     f12:	88 2d       	mov	r24, r8
     f14:	99 2d       	mov	r25, r9
     f16:	4d d5       	rcall	.+2714   	; 0x19b2 <__muldi3>
     f18:	0a e0       	ldi	r16, 0x0A	; 10
     f1a:	85 d6       	rcall	.+3338   	; 0x1c26 <__ashrdi3>
     f1c:	40 5e       	subi	r20, 0xE0	; 224
     f1e:	5f 4f       	sbci	r21, 0xFF	; 255
     f20:	6f 4f       	sbci	r22, 0xFF	; 255
     f22:	7f 4f       	sbci	r23, 0xFF	; 255
     f24:	8f 4f       	sbci	r24, 0xFF	; 255
     f26:	9f 4f       	sbci	r25, 0xFF	; 255
     f28:	b0 90 bf 03 	lds	r11, 0x03BF	; 0x8003bf <dig_H2+0x1>
     f2c:	a0 90 be 03 	lds	r10, 0x03BE	; 0x8003be <dig_H2>
     f30:	1b 2d       	mov	r17, r11
     f32:	11 0f       	add	r17, r17
     f34:	11 0b       	sbc	r17, r17
     f36:	c1 2e       	mov	r12, r17
     f38:	d1 2e       	mov	r13, r17
     f3a:	e1 2e       	mov	r14, r17
     f3c:	f1 2e       	mov	r15, r17
     f3e:	01 2f       	mov	r16, r17
     f40:	38 d5       	rcall	.+2672   	; 0x19b2 <__muldi3>
     f42:	30 5e       	subi	r19, 0xE0	; 224
     f44:	4f 4f       	sbci	r20, 0xFF	; 255
     f46:	5f 4f       	sbci	r21, 0xFF	; 255
     f48:	6f 4f       	sbci	r22, 0xFF	; 255
     f4a:	7f 4f       	sbci	r23, 0xFF	; 255
     f4c:	8f 4f       	sbci	r24, 0xFF	; 255
     f4e:	9f 4f       	sbci	r25, 0xFF	; 255
     f50:	0e e0       	ldi	r16, 0x0E	; 14
     f52:	69 d6       	rcall	.+3282   	; 0x1c26 <__ashrdi3>
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
     f54:	a2 2e       	mov	r10, r18
     f56:	b3 2e       	mov	r11, r19
     f58:	c4 2e       	mov	r12, r20
     f5a:	d5 2e       	mov	r13, r21
     f5c:	e6 2e       	mov	r14, r22
     f5e:	f7 2e       	mov	r15, r23
     f60:	08 2f       	mov	r16, r24
     f62:	19 2f       	mov	r17, r25
     f64:	2e 85       	ldd	r18, Y+14	; 0x0e
     f66:	3f 85       	ldd	r19, Y+15	; 0x0f
     f68:	48 89       	ldd	r20, Y+16	; 0x10
     f6a:	59 89       	ldd	r21, Y+17	; 0x11
     f6c:	6a 89       	ldd	r22, Y+18	; 0x12
     f6e:	7b 89       	ldd	r23, Y+19	; 0x13
     f70:	8c 89       	ldd	r24, Y+20	; 0x14
     f72:	9d 89       	ldd	r25, Y+21	; 0x15
     f74:	1e d5       	rcall	.+2620   	; 0x19b2 <__muldi3>
     f76:	42 2e       	mov	r4, r18
     f78:	53 2e       	mov	r5, r19
     f7a:	64 2e       	mov	r6, r20
     f7c:	75 2e       	mov	r7, r21
     f7e:	86 2e       	mov	r8, r22
     f80:	97 2e       	mov	r9, r23
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
     f82:	8a 87       	std	Y+10, r24	; 0x0a
     f84:	99 87       	std	Y+9, r25	; 0x09
     f86:	0f e0       	ldi	r16, 0x0F	; 15
     f88:	4e d6       	rcall	.+3228   	; 0x1c26 <__ashrdi3>
     f8a:	a2 2e       	mov	r10, r18
     f8c:	b3 2e       	mov	r11, r19
     f8e:	c4 2e       	mov	r12, r20
     f90:	d5 2e       	mov	r13, r21
     f92:	e6 2e       	mov	r14, r22
     f94:	f7 2e       	mov	r15, r23
     f96:	08 2f       	mov	r16, r24
     f98:	19 2f       	mov	r17, r25
     f9a:	0b d5       	rcall	.+2582   	; 0x19b2 <__muldi3>
     f9c:	07 e0       	ldi	r16, 0x07	; 7
     f9e:	43 d6       	rcall	.+3206   	; 0x1c26 <__ashrdi3>
     fa0:	e0 91 5a 03 	lds	r30, 0x035A	; 0x80035a <dig_H1>
     fa4:	f0 91 5b 03 	lds	r31, 0x035B	; 0x80035b <dig_H1+0x1>
     fa8:	5f 01       	movw	r10, r30
     faa:	c1 2c       	mov	r12, r1
     fac:	d1 2c       	mov	r13, r1
     fae:	e1 2c       	mov	r14, r1
     fb0:	f1 2c       	mov	r15, r1
     fb2:	87 01       	movw	r16, r14
     fb4:	e9 83       	std	Y+1, r30	; 0x01
     fb6:	ba 82       	std	Y+2, r11	; 0x02
     fb8:	cb 82       	std	Y+3, r12	; 0x03
     fba:	dc 82       	std	Y+4, r13	; 0x04
     fbc:	ed 82       	std	Y+5, r14	; 0x05
     fbe:	fe 82       	std	Y+6, r15	; 0x06
     fc0:	0f 83       	std	Y+7, r16	; 0x07
     fc2:	18 87       	std	Y+8, r17	; 0x08
     fc4:	c1 2c       	mov	r12, r1
     fc6:	d1 2c       	mov	r13, r1
     fc8:	e1 2c       	mov	r14, r1
     fca:	f1 2c       	mov	r15, r1
     fcc:	00 e0       	ldi	r16, 0x00	; 0
     fce:	10 e0       	ldi	r17, 0x00	; 0
     fd0:	f0 d4       	rcall	.+2528   	; 0x19b2 <__muldi3>
     fd2:	04 e0       	ldi	r16, 0x04	; 4
     fd4:	28 d6       	rcall	.+3152   	; 0x1c26 <__ashrdi3>
     fd6:	a2 2e       	mov	r10, r18
     fd8:	b3 2e       	mov	r11, r19
     fda:	c4 2e       	mov	r12, r20
     fdc:	d5 2e       	mov	r13, r21
     fde:	e6 2e       	mov	r14, r22
     fe0:	f7 2e       	mov	r15, r23
     fe2:	08 2f       	mov	r16, r24
     fe4:	19 2f       	mov	r17, r25
     fe6:	24 2d       	mov	r18, r4
     fe8:	35 2d       	mov	r19, r5
     fea:	46 2d       	mov	r20, r6
     fec:	57 2d       	mov	r21, r7
     fee:	68 2d       	mov	r22, r8
     ff0:	79 2d       	mov	r23, r9
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	99 85       	ldd	r25, Y+9	; 0x09
     ff6:	3e d6       	rcall	.+3196   	; 0x1c74 <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
     ff8:	f2 2e       	mov	r15, r18
     ffa:	03 2f       	mov	r16, r19
     ffc:	14 2f       	mov	r17, r20
     ffe:	59 87       	std	Y+9, r21	; 0x09
    1000:	69 83       	std	Y+1, r22	; 0x01
    1002:	b7 2f       	mov	r27, r23
    1004:	f8 2f       	mov	r31, r24
    1006:	e9 2f       	mov	r30, r25
    1008:	a0 e0       	ldi	r26, 0x00	; 0
    100a:	3d d6       	rcall	.+3194   	; 0x1c86 <__cmpdi2_s8>
    100c:	44 f4       	brge	.+16     	; 0x101e <bme280_compensate_H_int32+0x2f4>
    100e:	f1 2c       	mov	r15, r1
    1010:	00 e0       	ldi	r16, 0x00	; 0
    1012:	10 e0       	ldi	r17, 0x00	; 0
    1014:	19 86       	std	Y+9, r1	; 0x09
    1016:	19 82       	std	Y+1, r1	; 0x01
    1018:	b0 e0       	ldi	r27, 0x00	; 0
    101a:	f0 e0       	ldi	r31, 0x00	; 0
    101c:	e0 e0       	ldi	r30, 0x00	; 0
    101e:	8f 2c       	mov	r8, r15
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
	return (long)(v_x1_u32r>>12);
    1020:	90 2e       	mov	r9, r16
    1022:	a1 2e       	mov	r10, r17
    1024:	b9 84       	ldd	r11, Y+9	; 0x09
    1026:	c9 80       	ldd	r12, Y+1	; 0x01
    1028:	db 2e       	mov	r13, r27
    102a:	ef 2e       	mov	r14, r31
    102c:	ae 2f       	mov	r26, r30
    102e:	2f 2d       	mov	r18, r15
    1030:	30 2f       	mov	r19, r16
    1032:	41 2f       	mov	r20, r17
    1034:	5b 2d       	mov	r21, r11
    1036:	6c 2d       	mov	r22, r12
    1038:	7b 2f       	mov	r23, r27
    103a:	8f 2f       	mov	r24, r31
    103c:	9e 2f       	mov	r25, r30
    103e:	21 15       	cp	r18, r1
    1040:	31 05       	cpc	r19, r1
    1042:	41 05       	cpc	r20, r1
    1044:	59 41       	sbci	r21, 0x19	; 25
    1046:	61 05       	cpc	r22, r1
    1048:	71 05       	cpc	r23, r1
    104a:	81 05       	cpc	r24, r1
    104c:	91 05       	cpc	r25, r1
    104e:	61 f0       	breq	.+24     	; 0x1068 <bme280_compensate_H_int32+0x33e>
    1050:	5c f0       	brlt	.+22     	; 0x1068 <bme280_compensate_H_int32+0x33e>
    1052:	81 2c       	mov	r8, r1
    1054:	91 2c       	mov	r9, r1
    1056:	a1 2c       	mov	r10, r1
    1058:	0f 2e       	mov	r0, r31
    105a:	f9 e1       	ldi	r31, 0x19	; 25
    105c:	bf 2e       	mov	r11, r31
    105e:	f0 2d       	mov	r31, r0
    1060:	c1 2c       	mov	r12, r1
    1062:	d1 2c       	mov	r13, r1
    1064:	e1 2c       	mov	r14, r1
    1066:	a0 e0       	ldi	r26, 0x00	; 0
    1068:	28 2d       	mov	r18, r8
    106a:	39 2d       	mov	r19, r9
    106c:	4a 2d       	mov	r20, r10
    106e:	5b 2d       	mov	r21, r11
    1070:	6c 2d       	mov	r22, r12
    1072:	7d 2d       	mov	r23, r13
    1074:	8e 2d       	mov	r24, r14
    1076:	9a 2f       	mov	r25, r26
    1078:	0c e0       	ldi	r16, 0x0C	; 12
    107a:	d5 d5       	rcall	.+2986   	; 0x1c26 <__ashrdi3>
    107c:	62 2f       	mov	r22, r18
    107e:	73 2f       	mov	r23, r19
    1080:	84 2f       	mov	r24, r20
    1082:	95 2f       	mov	r25, r21
    1084:	67 96       	adiw	r28, 0x17	; 23
}
    1086:	0f b6       	in	r0, 0x3f	; 63
    1088:	f8 94       	cli
    108a:	de bf       	out	0x3e, r29	; 62
    108c:	0f be       	out	0x3f, r0	; 63
    108e:	cd bf       	out	0x3d, r28	; 61
    1090:	df 91       	pop	r29
    1092:	cf 91       	pop	r28
    1094:	1f 91       	pop	r17
    1096:	0f 91       	pop	r16
    1098:	ff 90       	pop	r15
    109a:	ef 90       	pop	r14
    109c:	df 90       	pop	r13
    109e:	cf 90       	pop	r12
    10a0:	bf 90       	pop	r11
    10a2:	af 90       	pop	r10
    10a4:	9f 90       	pop	r9
    10a6:	8f 90       	pop	r8
    10a8:	7f 90       	pop	r7
    10aa:	6f 90       	pop	r6
    10ac:	5f 90       	pop	r5
    10ae:	4f 90       	pop	r4
    10b0:	3f 90       	pop	r3
    10b2:	2f 90       	pop	r2
    10b4:	08 95       	ret

000010b6 <canary_io_pin_initialization>:
    10b6:	87 e0       	ldi	r24, 0x07	; 7
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
    10b8:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
    10ba:	85 b1       	in	r24, 0x05	; 5
    10bc:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
    10be:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
    10c0:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
    10c2:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
    10c4:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
    10c6:	41 9a       	sbi	0x08, 1	; 8
    10c8:	08 95       	ret

000010ca <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
    10ce:	2f ef       	ldi	r18, 0xFF	; 255
    10d0:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
    10d2:	fc 01       	movw	r30, r24
    10d4:	ee 0f       	add	r30, r30
    10d6:	ff 1f       	adc	r31, r31
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	ed 5e       	subi	r30, 0xED	; 237
    10de:	fc 4f       	sbci	r31, 0xFC	; 252
    10e0:	11 82       	std	Z+1, r1	; 0x01
    10e2:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
    10e4:	33 83       	std	Z+3, r19	; 0x03
    10e6:	22 83       	std	Z+2, r18	; 0x02
    10e8:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
    10ea:	85 30       	cpi	r24, 0x05	; 5
    10ec:	91 05       	cpc	r25, r1
    10ee:	89 f7       	brne	.-30     	; 0x10d2 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
    10f0:	08 95       	ret

000010f2 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
    10f2:	ef 92       	push	r14
    10f4:	ff 92       	push	r15
    10f6:	0f 93       	push	r16
    10f8:	1f 93       	push	r17
    10fa:	cf 93       	push	r28
    10fc:	df 93       	push	r29
    10fe:	0f 2e       	mov	r0, r31
    1100:	f9 ee       	ldi	r31, 0xE9	; 233
    1102:	ef 2e       	mov	r14, r31
    1104:	f2 e0       	ldi	r31, 0x02	; 2
    1106:	ff 2e       	mov	r15, r31
    1108:	f0 2d       	mov	r31, r0
    110a:	00 e0       	ldi	r16, 0x00	; 0
    110c:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
    110e:	c7 01       	movw	r24, r14
    1110:	0e 94 1e 11 	call	0x223c	; 0x223c <eeprom_read_word>
    1114:	e8 01       	movw	r28, r16
    1116:	cc 0f       	add	r28, r28
    1118:	dd 1f       	adc	r29, r29
    111a:	cc 0f       	add	r28, r28
    111c:	dd 1f       	adc	r29, r29
    111e:	cd 5e       	subi	r28, 0xED	; 237
    1120:	dc 4f       	sbci	r29, 0xFC	; 252
    1122:	99 83       	std	Y+1, r25	; 0x01
    1124:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
    1126:	c7 01       	movw	r24, r14
    1128:	02 96       	adiw	r24, 0x02	; 2
    112a:	0e 94 1e 11 	call	0x223c	; 0x223c <eeprom_read_word>
    112e:	9b 83       	std	Y+3, r25	; 0x03
    1130:	8a 83       	std	Y+2, r24	; 0x02
    1132:	0f 5f       	subi	r16, 0xFF	; 255
    1134:	1f 4f       	sbci	r17, 0xFF	; 255
    1136:	84 e0       	ldi	r24, 0x04	; 4
    1138:	e8 0e       	add	r14, r24
    113a:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
    113c:	05 30       	cpi	r16, 0x05	; 5
    113e:	11 05       	cpc	r17, r1
    1140:	31 f7       	brne	.-52     	; 0x110e <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
    1142:	df 91       	pop	r29
    1144:	cf 91       	pop	r28
    1146:	1f 91       	pop	r17
    1148:	0f 91       	pop	r16
    114a:	ff 90       	pop	r15
    114c:	ef 90       	pop	r14
    114e:	08 95       	ret

00001150 <gas_sensors_init>:

void gas_sensors_init(void)
{
    1150:	af 92       	push	r10
    1152:	bf 92       	push	r11
    1154:	cf 92       	push	r12
    1156:	df 92       	push	r13
    1158:	ef 92       	push	r14
    115a:	ff 92       	push	r15
    115c:	0f 93       	push	r16
    115e:	1f 93       	push	r17
    1160:	cf 93       	push	r28
    1162:	df 93       	push	r29
    1164:	1f 92       	push	r1
    1166:	cd b7       	in	r28, 0x3d	; 61
    1168:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
    116a:	10 92 a7 03 	sts	0x03A7, r1	; 0x8003a7 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
    116e:	10 92 76 03 	sts	0x0376, r1	; 0x800376 <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
    1172:	bf df       	rcall	.-130    	; 0x10f2 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
    1174:	aa df       	rcall	.-172    	; 0x10ca <get_gas_sensor_limits>
    1176:	ea e7       	ldi	r30, 0x7A	; 122
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	80 81       	ld	r24, Z
    117c:	80 68       	ori	r24, 0x80	; 128
    117e:	80 83       	st	Z, r24
    1180:	19 82       	std	Y+1, r1	; 0x01
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1182:	89 81       	ldd	r24, Y+1	; 0x01
    1184:	85 30       	cpi	r24, 0x05	; 5
    1186:	08 f0       	brcs	.+2      	; 0x118a <gas_sensors_init+0x3a>
    1188:	52 c0       	rjmp	.+164    	; 0x122e <gas_sensors_init+0xde>
    118a:	0a e7       	ldi	r16, 0x7A	; 122
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
    118c:	10 e0       	ldi	r17, 0x00	; 0
    118e:	0f 2e       	mov	r0, r31
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    1190:	f8 e7       	ldi	r31, 0x78	; 120
    1192:	ef 2e       	mov	r14, r31
    1194:	f1 2c       	mov	r15, r1
    1196:	f0 2d       	mov	r31, r0
    1198:	bb 24       	eor	r11, r11
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    119a:	b3 94       	inc	r11
    119c:	a1 2c       	mov	r10, r1
    119e:	cc 24       	eor	r12, r12
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    11a0:	c3 94       	inc	r12
    11a2:	d1 2c       	mov	r13, r1
    11a4:	89 81       	ldd	r24, Y+1	; 0x01
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    11a6:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
    11aa:	f8 01       	movw	r30, r16
		// Start conversion
		SetBit(ADCSRA, ADSC);
    11ac:	80 81       	ld	r24, Z
    11ae:	80 64       	ori	r24, 0x40	; 64
    11b0:	80 83       	st	Z, r24
    11b2:	f8 01       	movw	r30, r16
		while (BitIsClear(ADCSRA, ADIF))
    11b4:	80 81       	ld	r24, Z
    11b6:	84 ff       	sbrs	r24, 4
    11b8:	fc cf       	rjmp	.-8      	; 0x11b2 <gas_sensors_init+0x62>
    11ba:	f7 01       	movw	r30, r14
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
    11bc:	80 81       	ld	r24, Z
    11be:	91 81       	ldd	r25, Z+1	; 0x01
    11c0:	e9 81       	ldd	r30, Y+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	ee 0f       	add	r30, r30
    11c6:	ff 1f       	adc	r31, r31
    11c8:	ee 0f       	add	r30, r30
    11ca:	ff 1f       	adc	r31, r31
    11cc:	ed 5e       	subi	r30, 0xED	; 237
    11ce:	fc 4f       	sbci	r31, 0xFC	; 252
    11d0:	20 81       	ld	r18, Z
    11d2:	31 81       	ldd	r19, Z+1	; 0x01
    11d4:	e9 81       	ldd	r30, Y+1	; 0x01
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	ee 0f       	add	r30, r30
    11da:	ff 1f       	adc	r31, r31
    11dc:	ee 0f       	add	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	ed 5e       	subi	r30, 0xED	; 237
    11e2:	fc 4f       	sbci	r31, 0xFC	; 252
    11e4:	62 81       	ldd	r22, Z+2	; 0x02
    11e6:	73 81       	ldd	r23, Z+3	; 0x03
    11e8:	4b 2d       	mov	r20, r11
    11ea:	82 17       	cp	r24, r18
    11ec:	93 07       	cpc	r25, r19
    11ee:	08 f0       	brcs	.+2      	; 0x11f2 <gas_sensors_init+0xa2>
    11f0:	4a 2d       	mov	r20, r10
    11f2:	41 11       	cpse	r20, r1
    11f4:	07 c0       	rjmp	.+14     	; 0x1204 <gas_sensors_init+0xb4>
    11f6:	2b 2d       	mov	r18, r11
    11f8:	68 17       	cp	r22, r24
    11fa:	79 07       	cpc	r23, r25
    11fc:	08 f0       	brcs	.+2      	; 0x1200 <gas_sensors_init+0xb0>
    11fe:	2a 2d       	mov	r18, r10
    1200:	22 23       	and	r18, r18
    1202:	71 f0       	breq	.+28     	; 0x1220 <gas_sensors_init+0xd0>
    1204:	99 81       	ldd	r25, Y+1	; 0x01
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    1206:	20 91 a7 03 	lds	r18, 0x03A7	; 0x8003a7 <gas_sensor_initialization_errors>
    120a:	9d 5f       	subi	r25, 0xFD	; 253
    120c:	a6 01       	movw	r20, r12
    120e:	02 c0       	rjmp	.+4      	; 0x1214 <gas_sensors_init+0xc4>
    1210:	44 0f       	add	r20, r20
    1212:	55 1f       	adc	r21, r21
    1214:	9a 95       	dec	r25
    1216:	e2 f7       	brpl	.-8      	; 0x1210 <gas_sensors_init+0xc0>
    1218:	ca 01       	movw	r24, r20
    121a:	82 2b       	or	r24, r18
    121c:	80 93 a7 03 	sts	0x03A7, r24	; 0x8003a7 <gas_sensor_initialization_errors>
    1220:	89 81       	ldd	r24, Y+1	; 0x01
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1222:	8f 5f       	subi	r24, 0xFF	; 255
    1224:	89 83       	std	Y+1, r24	; 0x01
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	85 30       	cpi	r24, 0x05	; 5
    122a:	08 f4       	brcc	.+2      	; 0x122e <gas_sensors_init+0xde>
    122c:	bb cf       	rjmp	.-138    	; 0x11a4 <gas_sensors_init+0x54>
    122e:	ea e7       	ldi	r30, 0x7A	; 122
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
    1230:	f0 e0       	ldi	r31, 0x00	; 0
    1232:	80 81       	ld	r24, Z
    1234:	8f 77       	andi	r24, 0x7F	; 127
    1236:	80 83       	st	Z, r24
    1238:	0f 90       	pop	r0
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	1f 91       	pop	r17
    1240:	0f 91       	pop	r16
    1242:	ff 90       	pop	r15
    1244:	ef 90       	pop	r14
    1246:	df 90       	pop	r13
    1248:	cf 90       	pop	r12
    124a:	bf 90       	pop	r11
    124c:	af 90       	pop	r10
    124e:	08 95       	ret

00001250 <start_gas_sensor_read>:
    1250:	af 92       	push	r10

void start_gas_sensor_read(void)
{
    1252:	bf 92       	push	r11
    1254:	cf 92       	push	r12
    1256:	df 92       	push	r13
    1258:	ef 92       	push	r14
    125a:	ff 92       	push	r15
    125c:	0f 93       	push	r16
    125e:	1f 93       	push	r17
    1260:	cf 93       	push	r28
    1262:	df 93       	push	r29
    1264:	00 d0       	rcall	.+0      	; 0x1266 <start_gas_sensor_read+0x16>
    1266:	1f 92       	push	r1
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
    126c:	ea e7       	ldi	r30, 0x7A	; 122
    126e:	f0 e0       	ldi	r31, 0x00	; 0
    1270:	80 81       	ld	r24, Z
    1272:	80 68       	ori	r24, 0x80	; 128
    1274:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    1276:	19 82       	std	Y+1, r1	; 0x01
    1278:	89 81       	ldd	r24, Y+1	; 0x01
    127a:	85 30       	cpi	r24, 0x05	; 5
    127c:	08 f0       	brcs	.+2      	; 0x1280 <start_gas_sensor_read+0x30>
    127e:	74 c0       	rjmp	.+232    	; 0x1368 <start_gas_sensor_read+0x118>
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    1280:	0a e7       	ldi	r16, 0x7A	; 122
    1282:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    1284:	0f 2e       	mov	r0, r31
    1286:	f8 e7       	ldi	r31, 0x78	; 120
    1288:	ef 2e       	mov	r14, r31
    128a:	f1 2c       	mov	r15, r1
    128c:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    128e:	cc 24       	eor	r12, r12
    1290:	c3 94       	inc	r12
    1292:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    1294:	bb 24       	eor	r11, r11
    1296:	b3 94       	inc	r11
    1298:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
    129a:	89 81       	ldd	r24, Y+1	; 0x01
    129c:	0e 94 b8 00 	call	0x170	; 0x170 <ADC_SetMux>
		total = 0;	// re-zero the average
    12a0:	1b 82       	std	Y+3, r1	; 0x03
    12a2:	1a 82       	std	Y+2, r1	; 0x02
    12a4:	24 e0       	ldi	r18, 0x04	; 4
    12a6:	30 e0       	ldi	r19, 0x00	; 0
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
    12a8:	f8 01       	movw	r30, r16
    12aa:	80 81       	ld	r24, Z
    12ac:	80 64       	ori	r24, 0x40	; 64
    12ae:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
    12b0:	f8 01       	movw	r30, r16
    12b2:	80 81       	ld	r24, Z
    12b4:	84 ff       	sbrs	r24, 4
    12b6:	fc cf       	rjmp	.-8      	; 0x12b0 <start_gas_sensor_read+0x60>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
    12b8:	f7 01       	movw	r30, r14
    12ba:	80 81       	ld	r24, Z
    12bc:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
    12be:	e9 81       	ldd	r30, Y+1	; 0x01
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	ee 0f       	add	r30, r30
    12c4:	ff 1f       	adc	r31, r31
    12c6:	ee 0f       	add	r30, r30
    12c8:	ff 1f       	adc	r31, r31
    12ca:	ed 5e       	subi	r30, 0xED	; 237
    12cc:	fc 4f       	sbci	r31, 0xFC	; 252
    12ce:	40 81       	ld	r20, Z
    12d0:	51 81       	ldd	r21, Z+1	; 0x01
    12d2:	e9 81       	ldd	r30, Y+1	; 0x01
    12d4:	f0 e0       	ldi	r31, 0x00	; 0
    12d6:	ee 0f       	add	r30, r30
    12d8:	ff 1f       	adc	r31, r31
    12da:	ee 0f       	add	r30, r30
    12dc:	ff 1f       	adc	r31, r31
    12de:	ed 5e       	subi	r30, 0xED	; 237
    12e0:	fc 4f       	sbci	r31, 0xFC	; 252
    12e2:	02 80       	ldd	r0, Z+2	; 0x02
    12e4:	f3 81       	ldd	r31, Z+3	; 0x03
    12e6:	e0 2d       	mov	r30, r0
    12e8:	6b 2d       	mov	r22, r11
    12ea:	84 17       	cp	r24, r20
    12ec:	95 07       	cpc	r25, r21
    12ee:	08 f0       	brcs	.+2      	; 0x12f2 <start_gas_sensor_read+0xa2>
    12f0:	6a 2d       	mov	r22, r10
    12f2:	61 11       	cpse	r22, r1
    12f4:	07 c0       	rjmp	.+14     	; 0x1304 <start_gas_sensor_read+0xb4>
    12f6:	4b 2d       	mov	r20, r11
    12f8:	e8 17       	cp	r30, r24
    12fa:	f9 07       	cpc	r31, r25
    12fc:	08 f0       	brcs	.+2      	; 0x1300 <start_gas_sensor_read+0xb0>
    12fe:	4a 2d       	mov	r20, r10
    1300:	44 23       	and	r20, r20
    1302:	71 f0       	breq	.+28     	; 0x1320 <start_gas_sensor_read+0xd0>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
    1304:	59 81       	ldd	r21, Y+1	; 0x01
    1306:	60 91 a7 03 	lds	r22, 0x03A7	; 0x8003a7 <gas_sensor_initialization_errors>
    130a:	5d 5f       	subi	r21, 0xFD	; 253
    130c:	f6 01       	movw	r30, r12
    130e:	02 c0       	rjmp	.+4      	; 0x1314 <start_gas_sensor_read+0xc4>
    1310:	ee 0f       	add	r30, r30
    1312:	ff 1f       	adc	r31, r31
    1314:	5a 95       	dec	r21
    1316:	e2 f7       	brpl	.-8      	; 0x1310 <start_gas_sensor_read+0xc0>
    1318:	af 01       	movw	r20, r30
    131a:	46 2b       	or	r20, r22
    131c:	40 93 a7 03 	sts	0x03A7, r20	; 0x8003a7 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
    1320:	4a 81       	ldd	r20, Y+2	; 0x02
    1322:	5b 81       	ldd	r21, Y+3	; 0x03
    1324:	84 0f       	add	r24, r20
    1326:	95 1f       	adc	r25, r21
    1328:	9b 83       	std	Y+3, r25	; 0x03
    132a:	8a 83       	std	Y+2, r24	; 0x02
    132c:	21 50       	subi	r18, 0x01	; 1
    132e:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
    1330:	09 f0       	breq	.+2      	; 0x1334 <start_gas_sensor_read+0xe4>
    1332:	ba cf       	rjmp	.-140    	; 0x12a8 <start_gas_sensor_read+0x58>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
    1334:	8a 81       	ldd	r24, Y+2	; 0x02
    1336:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
    1338:	e9 81       	ldd	r30, Y+1	; 0x01
    133a:	f0 e0       	ldi	r31, 0x00	; 0
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	e9 58       	subi	r30, 0x89	; 137
    1342:	fc 4f       	sbci	r31, 0xFC	; 252
    1344:	9c 01       	movw	r18, r24
    1346:	99 23       	and	r25, r25
    1348:	14 f4       	brge	.+4      	; 0x134e <start_gas_sensor_read+0xfe>
    134a:	2d 5f       	subi	r18, 0xFD	; 253
    134c:	3f 4f       	sbci	r19, 0xFF	; 255
    134e:	35 95       	asr	r19
    1350:	27 95       	ror	r18
    1352:	35 95       	asr	r19
    1354:	27 95       	ror	r18
    1356:	31 83       	std	Z+1, r19	; 0x01
    1358:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
    135a:	89 81       	ldd	r24, Y+1	; 0x01
    135c:	8f 5f       	subi	r24, 0xFF	; 255
    135e:	89 83       	std	Y+1, r24	; 0x01
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	85 30       	cpi	r24, 0x05	; 5
    1364:	08 f4       	brcc	.+2      	; 0x1368 <start_gas_sensor_read+0x118>
    1366:	99 cf       	rjmp	.-206    	; 0x129a <start_gas_sensor_read+0x4a>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
    1368:	0f 90       	pop	r0
    136a:	0f 90       	pop	r0
    136c:	0f 90       	pop	r0
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	1f 91       	pop	r17
    1374:	0f 91       	pop	r16
    1376:	ff 90       	pop	r15
    1378:	ef 90       	pop	r14
    137a:	df 90       	pop	r13
    137c:	cf 90       	pop	r12
    137e:	bf 90       	pop	r11
    1380:	af 90       	pop	r10
    1382:	08 95       	ret

00001384 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    1384:	98 de       	rcall	.-720    	; 0x10b6 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    1386:	10 92 d9 03 	sts	0x03D9, r1	; 0x8003d9 <seconds+0x1>
    138a:	10 92 d8 03 	sts	0x03D8, r1	; 0x8003d8 <seconds>
	ItsTime=0;
    138e:	10 92 12 03 	sts	0x0312, r1	; 0x800312 <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
    1392:	8b e2       	ldi	r24, 0x2B	; 43
    1394:	91 e0       	ldi	r25, 0x01	; 1
    1396:	90 93 dd 05 	sts	0x05DD, r25	; 0x8005dd <__iob+0x3>
    139a:	80 93 dc 05 	sts	0x05DC, r24	; 0x8005dc <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
    139e:	24 d1       	rcall	.+584    	; 0x15e8 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    13a0:	81 e8       	ldi	r24, 0x81	; 129
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	1e d2       	rcall	.+1084   	; 0x17e2 <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
    13a6:	81 e8       	ldi	r24, 0x81	; 129
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	71 d2       	rcall	.+1250   	; 0x188e <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    13ac:	3d d1       	rcall	.+634    	; 0x1628 <TWI_Master_Initialise>
    13ae:	0e 94 c1 00 	call	0x182	; 0x182 <ADC_init>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
	//
	// initialize the gas sensors
	gas_sensors_init();
    13b2:	ce de       	rcall	.-612    	; 0x1150 <gas_sensors_init>
    13b4:	2a 9a       	sbi	0x05, 2	; 5
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
    13b6:	2a 98       	cbi	0x05, 2	; 5
	ClearBit(PORTB, PORTB2);
    13b8:	78 94       	sei
	// 
	// Start all interrupts
	sei();
    13ba:	cc d8       	rcall	.-3688   	; 0x554 <bme280basic_init>
	//
	// Initialize and check the BME interface...
	bme280basic_init();
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	91 e0       	ldi	r25, 0x01	; 1
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	printf("\n%s",String);
    13c0:	9f 93       	push	r25
    13c2:	8f 93       	push	r24
    13c4:	8a e3       	ldi	r24, 0x3A	; 58
    13c6:	91 e0       	ldi	r25, 0x01	; 1
    13c8:	9f 93       	push	r25
    13ca:	8f 93       	push	r24
    13cc:	77 d4       	rcall	.+2286   	; 0x1cbc <printf>
    13ce:	0f 90       	pop	r0
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	0f 2e       	mov	r0, r31
    13d8:	fe e3       	ldi	r31, 0x3E	; 62
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
			ItsTime = 0; 
 			seconds++;
 			printf("\nSeconds = %u", seconds);
    13da:	af 2e       	mov	r10, r31
    13dc:	f1 e0       	ldi	r31, 0x01	; 1
    13de:	bf 2e       	mov	r11, r31
    13e0:	f0 2d       	mov	r31, r0
    13e2:	0f 2e       	mov	r0, r31
    13e4:	fa ed       	ldi	r31, 0xDA	; 218
			// - Send the data over the serial port
			// - Wait for the transmission to complete, then
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    13e6:	cf 2e       	mov	r12, r31
    13e8:	f4 e0       	ldi	r31, 0x04	; 4
    13ea:	df 2e       	mov	r13, r31
    13ec:	f0 2d       	mov	r31, r0
    13ee:	0f 2e       	mov	r0, r31
    13f0:	fa e3       	ldi	r31, 0x3A	; 58
    13f2:	ef 2e       	mov	r14, r31
    13f4:	f1 e0       	ldi	r31, 0x01	; 1
    13f6:	ff 2e       	mov	r15, r31
    13f8:	f0 2d       	mov	r31, r0
    13fa:	0c e4       	ldi	r16, 0x4C	; 76
    13fc:	11 e0       	ldi	r17, 0x01	; 1
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
// 			distance = LIDAR_distance();
 			printf("\nLIDAR distance = %u", distance);
    13fe:	c7 e7       	ldi	r28, 0x77	; 119
    1400:	d3 e0       	ldi	r29, 0x03	; 3
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1402:	0f 2e       	mov	r0, r31
    1404:	f1 e6       	ldi	r31, 0x61	; 97
    1406:	8f 2e       	mov	r8, r31
    1408:	f1 e0       	ldi	r31, 0x01	; 1
    140a:	9f 2e       	mov	r9, r31
    140c:	f0 2d       	mov	r31, r0
    140e:	0f 2e       	mov	r0, r31
    1410:	fa e6       	ldi	r31, 0x6A	; 106
			while(UART0TransmitInProgress) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    1412:	2f 2e       	mov	r2, r31
    1414:	f1 e0       	ldi	r31, 0x01	; 1
    1416:	3f 2e       	mov	r3, r31
    1418:	f0 2d       	mov	r31, r0
    141a:	80 91 12 03 	lds	r24, 0x0312	; 0x800312 <ItsTime>
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
    141e:	81 30       	cpi	r24, 0x01	; 1
    1420:	e1 f7       	brne	.-8      	; 0x141a <main+0x96>
    1422:	10 92 12 03 	sts	0x0312, r1	; 0x800312 <ItsTime>
			ItsTime = 0; 
    1426:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <seconds>
 			seconds++;
    142a:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <seconds+0x1>
    142e:	01 96       	adiw	r24, 0x01	; 1
    1430:	90 93 d9 03 	sts	0x03D9, r25	; 0x8003d9 <seconds+0x1>
    1434:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <seconds>
    1438:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <seconds>
 			printf("\nSeconds = %u", seconds);
    143c:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <seconds+0x1>
    1440:	9f 93       	push	r25
    1442:	8f 93       	push	r24
    1444:	bf 92       	push	r11
    1446:	af 92       	push	r10
    1448:	39 d4       	rcall	.+2162   	; 0x1cbc <printf>
    144a:	df 92       	push	r13
			// - Send the data over the serial port
			// - Wait for the transmission to complete, then
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    144c:	cf 92       	push	r12
    144e:	ff 92       	push	r15
    1450:	ef 92       	push	r14
    1452:	34 d4       	rcall	.+2152   	; 0x1cbc <printf>
    1454:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <distance+0x1>
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
// 			distance = LIDAR_distance();
 			printf("\nLIDAR distance = %u", distance);
    1458:	8f 93       	push	r24
    145a:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <distance>
    145e:	8f 93       	push	r24
    1460:	1f 93       	push	r17
    1462:	0f 93       	push	r16
    1464:	2b d4       	rcall	.+2134   	; 0x1cbc <printf>
    1466:	f4 de       	rcall	.-536    	; 0x1250 <start_gas_sensor_read>
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    1468:	89 81       	ldd	r24, Y+1	; 0x01
    146a:	8f 93       	push	r24
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    146c:	88 81       	ld	r24, Y
    146e:	8f 93       	push	r24
    1470:	9f 92       	push	r9
    1472:	8f 92       	push	r8
    1474:	23 d4       	rcall	.+2118   	; 0x1cbc <printf>
    1476:	8b 81       	ldd	r24, Y+3	; 0x03
    1478:	8f 93       	push	r24
			while(UART0TransmitInProgress) {}
 			printf("\nH = %u", raw_gas_vector[1]);
    147a:	8a 81       	ldd	r24, Y+2	; 0x02
    147c:	8f 93       	push	r24
    147e:	3f 92       	push	r3
    1480:	2f 92       	push	r2
    1482:	1c d4       	rcall	.+2104   	; 0x1cbc <printf>
    1484:	8d 81       	ldd	r24, Y+5	; 0x05
    1486:	8f 93       	push	r24
			while(UART0TransmitInProgress) {}
 			printf("\nNA = %u", raw_gas_vector[2]);
    1488:	8c 81       	ldd	r24, Y+4	; 0x04
    148a:	8f 93       	push	r24
    148c:	82 e7       	ldi	r24, 0x72	; 114
    148e:	91 e0       	ldi	r25, 0x01	; 1
    1490:	9f 93       	push	r25
    1492:	8f 93       	push	r24
    1494:	13 d4       	rcall	.+2086   	; 0x1cbc <printf>
    1496:	8f 81       	ldd	r24, Y+7	; 0x07
    1498:	8f 93       	push	r24
			while(UART0TransmitInProgress) {} 
 			printf("\nCH4 = %u", raw_gas_vector[3]);
    149a:	8e 81       	ldd	r24, Y+6	; 0x06
    149c:	8f 93       	push	r24
    149e:	8b e7       	ldi	r24, 0x7B	; 123
    14a0:	91 e0       	ldi	r25, 0x01	; 1
    14a2:	9f 93       	push	r25
    14a4:	8f 93       	push	r24
    14a6:	0a d4       	rcall	.+2068   	; 0x1cbc <printf>
    14a8:	89 85       	ldd	r24, Y+9	; 0x09
    14aa:	8f 93       	push	r24
			while(UART0TransmitInProgress) {}
 			printf("\nO3 = %u", raw_gas_vector[4]);
    14ac:	88 85       	ldd	r24, Y+8	; 0x08
    14ae:	8f 93       	push	r24
    14b0:	85 e8       	ldi	r24, 0x85	; 133
    14b2:	91 e0       	ldi	r25, 0x01	; 1
    14b4:	9f 93       	push	r25
    14b6:	8f 93       	push	r24
    14b8:	01 d4       	rcall	.+2050   	; 0x1cbc <printf>
    14ba:	8d b7       	in	r24, 0x3d	; 61
    14bc:	9e b7       	in	r25, 0x3e	; 62
			while(UART0TransmitInProgress) {}
			//
			//============================
			// Now read the BME interface...
 			bme280basic_bulk_data_read();
    14be:	80 96       	adiw	r24, 0x20	; 32
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	9e bf       	out	0x3e, r25	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	8d bf       	out	0x3d, r24	; 61
    14ca:	ad d8       	rcall	.-3750   	; 0x626 <bme280basic_bulk_data_read>
    14cc:	60 91 5d 03 	lds	r22, 0x035D	; 0x80035d <rawTemp>
 			// Calculate the temperature and print it
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    14d0:	70 91 5e 03 	lds	r23, 0x035E	; 0x80035e <rawTemp+0x1>
    14d4:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <rawTemp+0x2>
    14d8:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <rawTemp+0x3>
    14dc:	8e d9       	rcall	.-3300   	; 0x7fa <BME280_compensate_T_int32>
    14de:	60 93 56 03 	sts	0x0356, r22	; 0x800356 <tempCelsius>
    14e2:	70 93 57 03 	sts	0x0357, r23	; 0x800357 <tempCelsius+0x1>
    14e6:	80 93 58 03 	sts	0x0358, r24	; 0x800358 <tempCelsius+0x2>
    14ea:	90 93 59 03 	sts	0x0359, r25	; 0x800359 <tempCelsius+0x3>
    14ee:	9f 93       	push	r25
// 			sprintf(temperatureBuf, "%lu", tempCelsius);
  			printf("\nCelsius = %lu", tempCelsius);
    14f0:	8f 93       	push	r24
    14f2:	7f 93       	push	r23
    14f4:	6f 93       	push	r22
    14f6:	8e e8       	ldi	r24, 0x8E	; 142
    14f8:	91 e0       	ldi	r25, 0x01	; 1
    14fa:	9f 93       	push	r25
    14fc:	8f 93       	push	r24
    14fe:	de d3       	rcall	.+1980   	; 0x1cbc <printf>
    1500:	60 91 85 03 	lds	r22, 0x0385	; 0x800385 <rawPress>
			while(UART0TransmitInProgress) {}
 			// Calculate the pressure and print it
			pressure = BME280_compensate_P_int64(rawPress);
    1504:	70 91 86 03 	lds	r23, 0x0386	; 0x800386 <rawPress+0x1>
    1508:	80 91 87 03 	lds	r24, 0x0387	; 0x800387 <rawPress+0x2>
    150c:	90 91 88 03 	lds	r25, 0x0388	; 0x800388 <rawPress+0x3>
    1510:	02 da       	rcall	.-3068   	; 0x916 <BME280_compensate_P_int64>
    1512:	60 93 6a 03 	sts	0x036A, r22	; 0x80036a <pressure>
    1516:	70 93 6b 03 	sts	0x036B, r23	; 0x80036b <pressure+0x1>
    151a:	80 93 6c 03 	sts	0x036C, r24	; 0x80036c <pressure+0x2>
    151e:	90 93 6d 03 	sts	0x036D, r25	; 0x80036d <pressure+0x3>
    1522:	bb 27       	eor	r27, r27
    1524:	97 fd       	sbrc	r25, 7
 			printf("\nPressure in Pa = %lu", pressure>>8);
    1526:	ba 95       	dec	r27
    1528:	a9 2f       	mov	r26, r25
    152a:	98 2f       	mov	r25, r24
    152c:	87 2f       	mov	r24, r23
    152e:	bf 93       	push	r27
    1530:	af 93       	push	r26
    1532:	9f 93       	push	r25
    1534:	8f 93       	push	r24
    1536:	8d e9       	ldi	r24, 0x9D	; 157
    1538:	91 e0       	ldi	r25, 0x01	; 1
    153a:	9f 93       	push	r25
    153c:	8f 93       	push	r24
    153e:	be d3       	rcall	.+1916   	; 0x1cbc <printf>
    1540:	60 91 89 03 	lds	r22, 0x0389	; 0x800389 <rawHum>
			while(UART0TransmitInProgress) {}
 			// Calculate the humidity and print it
			 humidity = bme280_compensate_H_int32(rawHum);
    1544:	70 91 8a 03 	lds	r23, 0x038A	; 0x80038a <rawHum+0x1>
    1548:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <rawHum+0x2>
    154c:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <rawHum+0x3>
    1550:	ec db       	rcall	.-2088   	; 0xd2a <bme280_compensate_H_int32>
    1552:	2b 01       	movw	r4, r22
    1554:	3c 01       	movw	r6, r24
    1556:	60 93 72 03 	sts	0x0372, r22	; 0x800372 <humidity>
    155a:	70 93 73 03 	sts	0x0373, r23	; 0x800373 <humidity+0x1>
    155e:	80 93 74 03 	sts	0x0374, r24	; 0x800374 <humidity+0x2>
    1562:	90 93 75 03 	sts	0x0375, r25	; 0x800375 <humidity+0x3>
    1566:	a8 ee       	ldi	r26, 0xE8	; 232
    1568:	b3 e0       	ldi	r27, 0x03	; 3
 			printf("\nHumidity%% = %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    156a:	9b 01       	movw	r18, r22
    156c:	ac 01       	movw	r20, r24
    156e:	11 d2       	rcall	.+1058   	; 0x1992 <__muluhisi3>
    1570:	dc 01       	movw	r26, r24
    1572:	cb 01       	movw	r24, r22
    1574:	07 2e       	mov	r0, r23
    1576:	7a e0       	ldi	r23, 0x0A	; 10
    1578:	b5 95       	asr	r27
    157a:	a7 95       	ror	r26
    157c:	97 95       	ror	r25
    157e:	87 95       	ror	r24
    1580:	7a 95       	dec	r23
    1582:	d1 f7       	brne	.-12     	; 0x1578 <main+0x1f4>
    1584:	70 2d       	mov	r23, r0
    1586:	bf 93       	push	r27
    1588:	af 93       	push	r26
    158a:	9f 93       	push	r25
    158c:	8f 93       	push	r24
    158e:	d3 01       	movw	r26, r6
    1590:	c2 01       	movw	r24, r4
    1592:	07 2e       	mov	r0, r23
    1594:	7a e0       	ldi	r23, 0x0A	; 10
    1596:	b5 95       	asr	r27
    1598:	a7 95       	ror	r26
    159a:	97 95       	ror	r25
    159c:	87 95       	ror	r24
    159e:	7a 95       	dec	r23
    15a0:	d1 f7       	brne	.-12     	; 0x1596 <main+0x212>
    15a2:	70 2d       	mov	r23, r0
    15a4:	bf 93       	push	r27
    15a6:	af 93       	push	r26
    15a8:	9f 93       	push	r25
    15aa:	8f 93       	push	r24
    15ac:	83 eb       	ldi	r24, 0xB3	; 179
    15ae:	91 e0       	ldi	r25, 0x01	; 1
    15b0:	9f 93       	push	r25
    15b2:	8f 93       	push	r24
    15b4:	83 d3       	rcall	.+1798   	; 0x1cbc <printf>
    15b6:	e9 ec       	ldi	r30, 0xC9	; 201
    15b8:	f0 e0       	ldi	r31, 0x00	; 0
    15ba:	80 81       	ld	r24, Z
			while(UART0TransmitInProgress) {}
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
    15bc:	80 69       	ori	r24, 0x90	; 144
    15be:	80 83       	st	Z, r24
    15c0:	8d b7       	in	r24, 0x3d	; 61
    15c2:	9e b7       	in	r25, 0x3e	; 62
    15c4:	46 96       	adiw	r24, 0x16	; 22
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	9e bf       	out	0x3e, r25	; 62
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	8d bf       	out	0x3d, r24	; 61
    15d0:	24 cf       	rjmp	.-440    	; 0x141a <main+0x96>

000015d2 <__vector_default>:
    15d2:	1f 92       	push	r1
    15d4:	0f 92       	push	r0
    15d6:	0f b6       	in	r0, 0x3f	; 63
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
    15d8:	0f 92       	push	r0
    15da:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
    15dc:	2a 9a       	sbi	0x05, 2	; 5
    15de:	0f 90       	pop	r0
    15e0:	0f be       	out	0x3f, r0	; 63
    15e2:	0f 90       	pop	r0
    15e4:	1f 90       	pop	r1
    15e6:	18 95       	reti

000015e8 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    15e8:	8d e0       	ldi	r24, 0x0D	; 13
    15ea:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    15ee:	8a e4       	ldi	r24, 0x4A	; 74
    15f0:	9c e4       	ldi	r25, 0x4C	; 76
    15f2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    15f6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    15fa:	08 95       	ret

000015fc <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    15fc:	18 95       	reti

000015fe <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
    15fe:	1f 92       	push	r1
    1600:	0f 92       	push	r0
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	0f 92       	push	r0
    1606:	11 24       	eor	r1, r1
    1608:	8f 93       	push	r24
    160a:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    160c:	95 b1       	in	r25, 0x05	; 5
    160e:	82 e0       	ldi	r24, 0x02	; 2
    1610:	89 27       	eor	r24, r25
    1612:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	80 93 12 03 	sts	0x0312, r24	; 0x800312 <ItsTime>
}
    161a:	9f 91       	pop	r25
    161c:	8f 91       	pop	r24
    161e:	0f 90       	pop	r0
    1620:	0f be       	out	0x3f, r0	; 63
    1622:	0f 90       	pop	r0
    1624:	1f 90       	pop	r1
    1626:	18 95       	reti

00001628 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1628:	81 e1       	ldi	r24, 0x11	; 17
    162a:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    162e:	8f ef       	ldi	r24, 0xFF	; 255
    1630:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1634:	84 e0       	ldi	r24, 0x04	; 4
    1636:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    163a:	08 95       	ret

0000163c <TWI_Transceiver_Busy>:
    163c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1640:	81 78       	andi	r24, 0x81	; 129
    1642:	08 95       	ret

00001644 <TWI_Start_Transceiver_With_Data>:
    1644:	cf 93       	push	r28
    1646:	df 93       	push	r29
    1648:	ec 01       	movw	r28, r24
    164a:	ec eb       	ldi	r30, 0xBC	; 188
    164c:	f0 e0       	ldi	r31, 0x00	; 0
    164e:	90 81       	ld	r25, Z
    1650:	91 78       	andi	r25, 0x81	; 129
    1652:	e9 f7       	brne	.-6      	; 0x164e <TWI_Start_Transceiver_With_Data+0xa>
    1654:	60 93 d0 01 	sts	0x01D0, r22	; 0x8001d0 <TWI_msgSize>
    1658:	88 81       	ld	r24, Y
    165a:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <TWI_buf>
    165e:	80 fd       	sbrc	r24, 0
    1660:	12 c0       	rjmp	.+36     	; 0x1686 <TWI_Start_Transceiver_With_Data+0x42>
    1662:	62 30       	cpi	r22, 0x02	; 2
    1664:	80 f0       	brcs	.+32     	; 0x1686 <TWI_Start_Transceiver_With_Data+0x42>
    1666:	fe 01       	movw	r30, r28
    1668:	31 96       	adiw	r30, 0x01	; 1
    166a:	a2 ed       	ldi	r26, 0xD2	; 210
    166c:	b1 e0       	ldi	r27, 0x01	; 1
    166e:	62 50       	subi	r22, 0x02	; 2
    1670:	26 2f       	mov	r18, r22
    1672:	30 e0       	ldi	r19, 0x00	; 0
    1674:	2e 5f       	subi	r18, 0xFE	; 254
    1676:	3f 4f       	sbci	r19, 0xFF	; 255
    1678:	2c 0f       	add	r18, r28
    167a:	3d 1f       	adc	r19, r29
    167c:	91 91       	ld	r25, Z+
    167e:	9d 93       	st	X+, r25
    1680:	e2 17       	cp	r30, r18
    1682:	f3 07       	cpc	r31, r19
    1684:	d9 f7       	brne	.-10     	; 0x167c <TWI_Start_Transceiver_With_Data+0x38>
    1686:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <TWI_statusReg>
    168a:	88 ef       	ldi	r24, 0xF8	; 248
    168c:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    1690:	85 ea       	ldi	r24, 0xA5	; 165
    1692:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	08 95       	ret

0000169c <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    169c:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    169e:	ec eb       	ldi	r30, 0xBC	; 188
    16a0:	f0 e0       	ldi	r31, 0x00	; 0
    16a2:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    16a4:	91 78       	andi	r25, 0x81	; 129
    16a6:	e9 f7       	brne	.-6      	; 0x16a2 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    16a8:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    16ac:	80 ff       	sbrs	r24, 0
    16ae:	11 c0       	rjmp	.+34     	; 0x16d2 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    16b0:	66 23       	and	r22, r22
    16b2:	79 f0       	breq	.+30     	; 0x16d2 <TWI_Get_Data_From_Transceiver+0x36>
    16b4:	a1 ed       	ldi	r26, 0xD1	; 209
    16b6:	b1 e0       	ldi	r27, 0x01	; 1
    16b8:	fa 01       	movw	r30, r20
    16ba:	61 50       	subi	r22, 0x01	; 1
    16bc:	26 2f       	mov	r18, r22
    16be:	30 e0       	ldi	r19, 0x00	; 0
    16c0:	2f 5f       	subi	r18, 0xFF	; 255
    16c2:	3f 4f       	sbci	r19, 0xFF	; 255
    16c4:	24 0f       	add	r18, r20
    16c6:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    16c8:	9d 91       	ld	r25, X+
    16ca:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    16cc:	e2 17       	cp	r30, r18
    16ce:	f3 07       	cpc	r31, r19
    16d0:	d9 f7       	brne	.-10     	; 0x16c8 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    16d2:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
}
    16d6:	81 70       	andi	r24, 0x01	; 1
    16d8:	08 95       	ret

000016da <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    16da:	1f 92       	push	r1
    16dc:	0f 92       	push	r0
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	0f 92       	push	r0
    16e2:	11 24       	eor	r1, r1
    16e4:	0b b6       	in	r0, 0x3b	; 59
    16e6:	0f 92       	push	r0
    16e8:	2f 93       	push	r18
    16ea:	3f 93       	push	r19
    16ec:	8f 93       	push	r24
    16ee:	9f 93       	push	r25
    16f0:	af 93       	push	r26
    16f2:	bf 93       	push	r27
    16f4:	ef 93       	push	r30
    16f6:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    16f8:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    16fc:	8e 2f       	mov	r24, r30
    16fe:	90 e0       	ldi	r25, 0x00	; 0
    1700:	fc 01       	movw	r30, r24
    1702:	38 97       	sbiw	r30, 0x08	; 8
    1704:	e1 35       	cpi	r30, 0x51	; 81
    1706:	f1 05       	cpc	r31, r1
    1708:	08 f0       	brcs	.+2      	; 0x170c <__vector_26+0x32>
    170a:	55 c0       	rjmp	.+170    	; 0x17b6 <__vector_26+0xdc>
    170c:	ea 5b       	subi	r30, 0xBA	; 186
    170e:	ff 4f       	sbci	r31, 0xFF	; 255
    1710:	37 c1       	rjmp	.+622    	; 0x1980 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    1712:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <TWI_bufPtr.1674>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    1716:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    171a:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    171e:	e8 17       	cp	r30, r24
    1720:	70 f4       	brcc	.+28     	; 0x173e <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    1722:	81 e0       	ldi	r24, 0x01	; 1
    1724:	8e 0f       	add	r24, r30
    1726:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1674>
    172a:	f0 e0       	ldi	r31, 0x00	; 0
    172c:	ef 52       	subi	r30, 0x2F	; 47
    172e:	fe 4f       	sbci	r31, 0xFE	; 254
    1730:	80 81       	ld	r24, Z
    1732:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1736:	85 e8       	ldi	r24, 0x85	; 133
    1738:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    173c:	43 c0       	rjmp	.+134    	; 0x17c4 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    173e:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    1742:	81 60       	ori	r24, 0x01	; 1
    1744:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1748:	84 e9       	ldi	r24, 0x94	; 148
    174a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    174e:	3a c0       	rjmp	.+116    	; 0x17c4 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    1750:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	8e 0f       	add	r24, r30
    1758:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1674>
    175c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	ef 52       	subi	r30, 0x2F	; 47
    1764:	fe 4f       	sbci	r31, 0xFE	; 254
    1766:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1768:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	01 97       	sbiw	r24, 0x01	; 1
    1776:	28 17       	cp	r18, r24
    1778:	39 07       	cpc	r19, r25
    177a:	24 f4       	brge	.+8      	; 0x1784 <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    177c:	85 ec       	ldi	r24, 0xC5	; 197
    177e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1782:	20 c0       	rjmp	.+64     	; 0x17c4 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1784:	85 e8       	ldi	r24, 0x85	; 133
    1786:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    178a:	1c c0       	rjmp	.+56     	; 0x17c4 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    178c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1790:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	ef 52       	subi	r30, 0x2F	; 47
    1798:	fe 4f       	sbci	r31, 0xFE	; 254
    179a:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    179c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    17a0:	81 60       	ori	r24, 0x01	; 1
    17a2:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    17a6:	84 e9       	ldi	r24, 0x94	; 148
    17a8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    17ac:	0b c0       	rjmp	.+22     	; 0x17c4 <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    17ae:	85 ea       	ldi	r24, 0xA5	; 165
    17b0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    17b4:	07 c0       	rjmp	.+14     	; 0x17c4 <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    17b6:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    17ba:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    17be:	84 e0       	ldi	r24, 0x04	; 4
    17c0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    17c4:	ff 91       	pop	r31
    17c6:	ef 91       	pop	r30
    17c8:	bf 91       	pop	r27
    17ca:	af 91       	pop	r26
    17cc:	9f 91       	pop	r25
    17ce:	8f 91       	pop	r24
    17d0:	3f 91       	pop	r19
    17d2:	2f 91       	pop	r18
    17d4:	0f 90       	pop	r0
    17d6:	0b be       	out	0x3b, r0	; 59
    17d8:	0f 90       	pop	r0
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	0f 90       	pop	r0
    17de:	1f 90       	pop	r1
    17e0:	18 95       	reti

000017e2 <USART0_init>:
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    17e2:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    17e6:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    17ea:	88 e0       	ldi	r24, 0x08	; 8
    17ec:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    17f0:	86 e0       	ldi	r24, 0x06	; 6
    17f2:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    17f6:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <UART0_RxTail>
    17fa:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <UART0_RxHead>
    17fe:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <UART0_TxTail>
    1802:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <UART0_TxHead>
    1806:	08 95       	ret

00001808 <USART0_Transmit_IO>:
    1808:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    180c:	2f 5f       	subi	r18, 0xFF	; 255
    180e:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1812:	29 17       	cp	r18, r25
    1814:	e1 f3       	breq	.-8      	; 0x180e <USART0_Transmit_IO+0x6>
    1816:	e2 2f       	mov	r30, r18
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	ed 51       	subi	r30, 0x1D	; 29
    181c:	fe 4f       	sbci	r31, 0xFE	; 254
    181e:	80 83       	st	Z, r24
    1820:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
    1824:	e1 ec       	ldi	r30, 0xC1	; 193
    1826:	f0 e0       	ldi	r31, 0x00	; 0
    1828:	80 81       	ld	r24, Z
    182a:	80 62       	ori	r24, 0x20	; 32
    182c:	80 83       	st	Z, r24
    182e:	80 e0       	ldi	r24, 0x00	; 0
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	08 95       	ret

00001834 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1834:	1f 92       	push	r1
    1836:	0f 92       	push	r0
    1838:	0f b6       	in	r0, 0x3f	; 63
    183a:	0f 92       	push	r0
    183c:	11 24       	eor	r1, r1
    183e:	0b b6       	in	r0, 0x3b	; 59
    1840:	0f 92       	push	r0
    1842:	8f 93       	push	r24
    1844:	9f 93       	push	r25
    1846:	ef 93       	push	r30
    1848:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    184a:	90 91 e2 01 	lds	r25, 0x01E2	; 0x8001e2 <UART0_TxHead>
    184e:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1852:	98 17       	cp	r25, r24
    1854:	61 f0       	breq	.+24     	; 0x186e <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1856:	e0 91 e1 01 	lds	r30, 0x01E1	; 0x8001e1 <UART0_TxTail>
    185a:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    185c:	e0 93 e1 01 	sts	0x01E1, r30	; 0x8001e1 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	ed 51       	subi	r30, 0x1D	; 29
    1864:	fe 4f       	sbci	r31, 0xFE	; 254
    1866:	80 81       	ld	r24, Z
    1868:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    186c:	05 c0       	rjmp	.+10     	; 0x1878 <__vector_21+0x44>
		} 
		else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    186e:	e1 ec       	ldi	r30, 0xC1	; 193
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	80 81       	ld	r24, Z
    1874:	8f 7d       	andi	r24, 0xDF	; 223
    1876:	80 83       	st	Z, r24
		// Indicate transmission is complete
		UART0TransmitInProgress = 0;
	}
    1878:	ff 91       	pop	r31
    187a:	ef 91       	pop	r30
    187c:	9f 91       	pop	r25
    187e:	8f 91       	pop	r24
    1880:	0f 90       	pop	r0
    1882:	0b be       	out	0x3b, r0	; 59
    1884:	0f 90       	pop	r0
    1886:	0f be       	out	0x3f, r0	; 63
    1888:	0f 90       	pop	r0
    188a:	1f 90       	pop	r1
    188c:	18 95       	reti

0000188e <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    188e:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1892:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1896:	80 e9       	ldi	r24, 0x90	; 144
    1898:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    189c:	86 e0       	ldi	r24, 0x06	; 6
    189e:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    18a2:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_RxTail>
    18a6:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxHead>
    18aa:	10 92 e5 02 	sts	0x02E5, r1	; 0x8002e5 <UART1_TxTail>
    18ae:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <UART1_TxHead>
    18b2:	08 95       	ret

000018b4 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    18b4:	1f 92       	push	r1
    18b6:	0f 92       	push	r0
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	0f 92       	push	r0
    18bc:	11 24       	eor	r1, r1
    18be:	0b b6       	in	r0, 0x3b	; 59
    18c0:	0f 92       	push	r0
    18c2:	2f 93       	push	r18
    18c4:	3f 93       	push	r19
    18c6:	8f 93       	push	r24
    18c8:	9f 93       	push	r25
    18ca:	af 93       	push	r26
    18cc:	bf 93       	push	r27
    18ce:	cf 93       	push	r28
    18d0:	df 93       	push	r29
    18d2:	ef 93       	push	r30
    18d4:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    18d6:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    18da:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <UART1_RxHead>
    18de:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    18e0:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    18e4:	20 91 e7 02 	lds	r18, 0x02E7	; 0x8002e7 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    18e8:	e8 2f       	mov	r30, r24
    18ea:	f0 e0       	ldi	r31, 0x00	; 0
    18ec:	e6 52       	subi	r30, 0x26	; 38
    18ee:	fc 4f       	sbci	r31, 0xFC	; 252
    18f0:	90 83       	st	Z, r25
	
	if (data == 10)
    18f2:	9a 30       	cpi	r25, 0x0A	; 10
    18f4:	29 f5       	brne	.+74     	; 0x1940 <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    18f6:	90 91 df 03 	lds	r25, 0x03DF	; 0x8003df <UART1_RxBuf+0x5>
    18fa:	97 34       	cpi	r25, 0x47	; 71
    18fc:	e9 f4       	brne	.+58     	; 0x1938 <__vector_28+0x84>
    18fe:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
    1900:	2e 2f       	mov	r18, r30
    1902:	30 e0       	ldi	r19, 0x00	; 0
    1904:	d9 01       	movw	r26, r18
    1906:	a6 52       	subi	r26, 0x26	; 38
    1908:	bb 4f       	sbci	r27, 0xFB	; 251
    190a:	e9 01       	movw	r28, r18
    190c:	c6 52       	subi	r28, 0x26	; 38
    190e:	dc 4f       	sbci	r29, 0xFC	; 252
    1910:	99 81       	ldd	r25, Y+1	; 0x01
    1912:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1914:	ef 5f       	subi	r30, 0xFF	; 255
    1916:	8e 17       	cp	r24, r30
    1918:	98 f7       	brcc	.-26     	; 0x1900 <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i-3]=0x00; //This sets the end of the string after the checksum, removing the CR/LF codes from the string.
    191a:	f0 e0       	ldi	r31, 0x00	; 0
    191c:	e9 52       	subi	r30, 0x29	; 41
    191e:	fb 4f       	sbci	r31, 0xFB	; 251
    1920:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1922:	e9 ec       	ldi	r30, 0xC9	; 201
    1924:	f0 e0       	ldi	r31, 0x00	; 0
    1926:	80 81       	ld	r24, Z
    1928:	10 82       	st	Z, r1
 			ItsTime = 1;
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	80 93 12 03 	sts	0x0312, r24	; 0x800312 <ItsTime>
 			ToggleBit(PORTB, PORTB1);
    1930:	95 b1       	in	r25, 0x05	; 5
    1932:	82 e0       	ldi	r24, 0x02	; 2
    1934:	89 27       	eor	r24, r25
    1936:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1938:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_RxTail>
		UART1_RxHead = 0;
    193c:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxHead>
	}
}
    1940:	ff 91       	pop	r31
    1942:	ef 91       	pop	r30
    1944:	df 91       	pop	r29
    1946:	cf 91       	pop	r28
    1948:	bf 91       	pop	r27
    194a:	af 91       	pop	r26
    194c:	9f 91       	pop	r25
    194e:	8f 91       	pop	r24
    1950:	3f 91       	pop	r19
    1952:	2f 91       	pop	r18
    1954:	0f 90       	pop	r0
    1956:	0b be       	out	0x3b, r0	; 59
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63
    195c:	0f 90       	pop	r0
    195e:	1f 90       	pop	r1
    1960:	18 95       	reti

00001962 <__mulsi3>:
    1962:	db 01       	movw	r26, r22
    1964:	8f 93       	push	r24
    1966:	9f 93       	push	r25
    1968:	14 d0       	rcall	.+40     	; 0x1992 <__muluhisi3>
    196a:	bf 91       	pop	r27
    196c:	af 91       	pop	r26
    196e:	a2 9f       	mul	r26, r18
    1970:	80 0d       	add	r24, r0
    1972:	91 1d       	adc	r25, r1
    1974:	a3 9f       	mul	r26, r19
    1976:	90 0d       	add	r25, r0
    1978:	b2 9f       	mul	r27, r18
    197a:	90 0d       	add	r25, r0
    197c:	11 24       	eor	r1, r1
    197e:	08 95       	ret

00001980 <__tablejump2__>:
    1980:	ee 0f       	add	r30, r30
    1982:	ff 1f       	adc	r31, r31
    1984:	00 24       	eor	r0, r0
    1986:	00 1c       	adc	r0, r0
    1988:	0b be       	out	0x3b, r0	; 59
    198a:	07 90       	elpm	r0, Z+
    198c:	f6 91       	elpm	r31, Z
    198e:	e0 2d       	mov	r30, r0
    1990:	09 94       	ijmp

00001992 <__muluhisi3>:
    1992:	85 d1       	rcall	.+778    	; 0x1c9e <__umulhisi3>
    1994:	a5 9f       	mul	r26, r21
    1996:	90 0d       	add	r25, r0
    1998:	b4 9f       	mul	r27, r20
    199a:	90 0d       	add	r25, r0
    199c:	a4 9f       	mul	r26, r20
    199e:	80 0d       	add	r24, r0
    19a0:	91 1d       	adc	r25, r1
    19a2:	11 24       	eor	r1, r1
    19a4:	08 95       	ret

000019a6 <__mulshisi3>:
    19a6:	b7 ff       	sbrs	r27, 7
    19a8:	f4 cf       	rjmp	.-24     	; 0x1992 <__muluhisi3>

000019aa <__mulohisi3>:
    19aa:	f3 df       	rcall	.-26     	; 0x1992 <__muluhisi3>
    19ac:	82 1b       	sub	r24, r18
    19ae:	93 0b       	sbc	r25, r19
    19b0:	08 95       	ret

000019b2 <__muldi3>:
    19b2:	df 93       	push	r29
    19b4:	cf 93       	push	r28
    19b6:	1f 93       	push	r17
    19b8:	0f 93       	push	r16
    19ba:	9a 9d       	mul	r25, r10
    19bc:	f0 2d       	mov	r31, r0
    19be:	21 9f       	mul	r18, r17
    19c0:	f0 0d       	add	r31, r0
    19c2:	8b 9d       	mul	r24, r11
    19c4:	f0 0d       	add	r31, r0
    19c6:	8a 9d       	mul	r24, r10
    19c8:	e0 2d       	mov	r30, r0
    19ca:	f1 0d       	add	r31, r1
    19cc:	03 9f       	mul	r16, r19
    19ce:	f0 0d       	add	r31, r0
    19d0:	02 9f       	mul	r16, r18
    19d2:	e0 0d       	add	r30, r0
    19d4:	f1 1d       	adc	r31, r1
    19d6:	4e 9d       	mul	r20, r14
    19d8:	e0 0d       	add	r30, r0
    19da:	f1 1d       	adc	r31, r1
    19dc:	5e 9d       	mul	r21, r14
    19de:	f0 0d       	add	r31, r0
    19e0:	4f 9d       	mul	r20, r15
    19e2:	f0 0d       	add	r31, r0
    19e4:	7f 93       	push	r23
    19e6:	6f 93       	push	r22
    19e8:	bf 92       	push	r11
    19ea:	af 92       	push	r10
    19ec:	5f 93       	push	r21
    19ee:	4f 93       	push	r20
    19f0:	d5 01       	movw	r26, r10
    19f2:	55 d1       	rcall	.+682    	; 0x1c9e <__umulhisi3>
    19f4:	8b 01       	movw	r16, r22
    19f6:	ac 01       	movw	r20, r24
    19f8:	d7 01       	movw	r26, r14
    19fa:	51 d1       	rcall	.+674    	; 0x1c9e <__umulhisi3>
    19fc:	eb 01       	movw	r28, r22
    19fe:	e8 0f       	add	r30, r24
    1a00:	f9 1f       	adc	r31, r25
    1a02:	d6 01       	movw	r26, r12
    1a04:	1f d0       	rcall	.+62     	; 0x1a44 <__muldi3_6>
    1a06:	2f 91       	pop	r18
    1a08:	3f 91       	pop	r19
    1a0a:	d6 01       	movw	r26, r12
    1a0c:	48 d1       	rcall	.+656    	; 0x1c9e <__umulhisi3>
    1a0e:	c6 0f       	add	r28, r22
    1a10:	d7 1f       	adc	r29, r23
    1a12:	e8 1f       	adc	r30, r24
    1a14:	f9 1f       	adc	r31, r25
    1a16:	af 91       	pop	r26
    1a18:	bf 91       	pop	r27
    1a1a:	14 d0       	rcall	.+40     	; 0x1a44 <__muldi3_6>
    1a1c:	2f 91       	pop	r18
    1a1e:	3f 91       	pop	r19
    1a20:	3e d1       	rcall	.+636    	; 0x1c9e <__umulhisi3>
    1a22:	c6 0f       	add	r28, r22
    1a24:	d7 1f       	adc	r29, r23
    1a26:	e8 1f       	adc	r30, r24
    1a28:	f9 1f       	adc	r31, r25
    1a2a:	d6 01       	movw	r26, r12
    1a2c:	38 d1       	rcall	.+624    	; 0x1c9e <__umulhisi3>
    1a2e:	e6 0f       	add	r30, r22
    1a30:	f7 1f       	adc	r31, r23
    1a32:	98 01       	movw	r18, r16
    1a34:	be 01       	movw	r22, r28
    1a36:	cf 01       	movw	r24, r30
    1a38:	11 24       	eor	r1, r1
    1a3a:	0f 91       	pop	r16
    1a3c:	1f 91       	pop	r17
    1a3e:	cf 91       	pop	r28
    1a40:	df 91       	pop	r29
    1a42:	08 95       	ret

00001a44 <__muldi3_6>:
    1a44:	2c d1       	rcall	.+600    	; 0x1c9e <__umulhisi3>
    1a46:	46 0f       	add	r20, r22
    1a48:	57 1f       	adc	r21, r23
    1a4a:	c8 1f       	adc	r28, r24
    1a4c:	d9 1f       	adc	r29, r25
    1a4e:	08 f4       	brcc	.+2      	; 0x1a52 <__muldi3_6+0xe>
    1a50:	31 96       	adiw	r30, 0x01	; 1
    1a52:	08 95       	ret

00001a54 <__moddi3>:
    1a54:	68 94       	set
    1a56:	01 c0       	rjmp	.+2      	; 0x1a5a <__divdi3_moddi3>

00001a58 <__divdi3>:
    1a58:	e8 94       	clt

00001a5a <__divdi3_moddi3>:
    1a5a:	f9 2f       	mov	r31, r25
    1a5c:	f1 2b       	or	r31, r17
    1a5e:	0a f0       	brmi	.+2      	; 0x1a62 <__divdi3_moddi3+0x8>
    1a60:	27 c0       	rjmp	.+78     	; 0x1ab0 <__udivdi3_umoddi3>
    1a62:	a0 e0       	ldi	r26, 0x00	; 0
    1a64:	b0 e0       	ldi	r27, 0x00	; 0
    1a66:	e6 e3       	ldi	r30, 0x36	; 54
    1a68:	fd e0       	ldi	r31, 0x0D	; 13
    1a6a:	93 c0       	rjmp	.+294    	; 0x1b92 <__prologue_saves__+0xc>
    1a6c:	09 2e       	mov	r0, r25
    1a6e:	05 94       	asr	r0
    1a70:	1a f4       	brpl	.+6      	; 0x1a78 <__divdi3_moddi3+0x1e>
    1a72:	79 d0       	rcall	.+242    	; 0x1b66 <__negdi2>
    1a74:	11 23       	and	r17, r17
    1a76:	92 f4       	brpl	.+36     	; 0x1a9c <__divdi3_moddi3+0x42>
    1a78:	f0 e8       	ldi	r31, 0x80	; 128
    1a7a:	0f 26       	eor	r0, r31
    1a7c:	ff ef       	ldi	r31, 0xFF	; 255
    1a7e:	e0 94       	com	r14
    1a80:	f0 94       	com	r15
    1a82:	00 95       	com	r16
    1a84:	10 95       	com	r17
    1a86:	b0 94       	com	r11
    1a88:	c0 94       	com	r12
    1a8a:	d0 94       	com	r13
    1a8c:	a1 94       	neg	r10
    1a8e:	bf 0a       	sbc	r11, r31
    1a90:	cf 0a       	sbc	r12, r31
    1a92:	df 0a       	sbc	r13, r31
    1a94:	ef 0a       	sbc	r14, r31
    1a96:	ff 0a       	sbc	r15, r31
    1a98:	0f 0b       	sbc	r16, r31
    1a9a:	1f 0b       	sbc	r17, r31
    1a9c:	13 d0       	rcall	.+38     	; 0x1ac4 <__udivmod64>
    1a9e:	07 fc       	sbrc	r0, 7
    1aa0:	62 d0       	rcall	.+196    	; 0x1b66 <__negdi2>
    1aa2:	cd b7       	in	r28, 0x3d	; 61
    1aa4:	de b7       	in	r29, 0x3e	; 62
    1aa6:	ec e0       	ldi	r30, 0x0C	; 12
    1aa8:	90 c0       	rjmp	.+288    	; 0x1bca <__epilogue_restores__+0xc>

00001aaa <__umoddi3>:
    1aaa:	68 94       	set
    1aac:	01 c0       	rjmp	.+2      	; 0x1ab0 <__udivdi3_umoddi3>

00001aae <__udivdi3>:
    1aae:	e8 94       	clt

00001ab0 <__udivdi3_umoddi3>:
    1ab0:	8f 92       	push	r8
    1ab2:	9f 92       	push	r9
    1ab4:	cf 93       	push	r28
    1ab6:	df 93       	push	r29
    1ab8:	05 d0       	rcall	.+10     	; 0x1ac4 <__udivmod64>
    1aba:	df 91       	pop	r29
    1abc:	cf 91       	pop	r28
    1abe:	9f 90       	pop	r9
    1ac0:	8f 90       	pop	r8
    1ac2:	08 95       	ret

00001ac4 <__udivmod64>:
    1ac4:	88 24       	eor	r8, r8
    1ac6:	99 24       	eor	r9, r9
    1ac8:	f4 01       	movw	r30, r8
    1aca:	e4 01       	movw	r28, r8
    1acc:	b0 e4       	ldi	r27, 0x40	; 64
    1ace:	9f 93       	push	r25
    1ad0:	aa 27       	eor	r26, r26
    1ad2:	9a 15       	cp	r25, r10
    1ad4:	8b 04       	cpc	r8, r11
    1ad6:	9c 04       	cpc	r9, r12
    1ad8:	ed 05       	cpc	r30, r13
    1ada:	fe 05       	cpc	r31, r14
    1adc:	cf 05       	cpc	r28, r15
    1ade:	d0 07       	cpc	r29, r16
    1ae0:	a1 07       	cpc	r26, r17
    1ae2:	98 f4       	brcc	.+38     	; 0x1b0a <__udivmod64+0x46>
    1ae4:	ad 2f       	mov	r26, r29
    1ae6:	dc 2f       	mov	r29, r28
    1ae8:	cf 2f       	mov	r28, r31
    1aea:	fe 2f       	mov	r31, r30
    1aec:	e9 2d       	mov	r30, r9
    1aee:	98 2c       	mov	r9, r8
    1af0:	89 2e       	mov	r8, r25
    1af2:	98 2f       	mov	r25, r24
    1af4:	87 2f       	mov	r24, r23
    1af6:	76 2f       	mov	r23, r22
    1af8:	65 2f       	mov	r22, r21
    1afa:	54 2f       	mov	r21, r20
    1afc:	43 2f       	mov	r20, r19
    1afe:	32 2f       	mov	r19, r18
    1b00:	22 27       	eor	r18, r18
    1b02:	b8 50       	subi	r27, 0x08	; 8
    1b04:	31 f7       	brne	.-52     	; 0x1ad2 <__udivmod64+0xe>
    1b06:	bf 91       	pop	r27
    1b08:	27 c0       	rjmp	.+78     	; 0x1b58 <__udivmod64+0x94>
    1b0a:	1b 2e       	mov	r1, r27
    1b0c:	bf 91       	pop	r27
    1b0e:	bb 27       	eor	r27, r27
    1b10:	22 0f       	add	r18, r18
    1b12:	33 1f       	adc	r19, r19
    1b14:	44 1f       	adc	r20, r20
    1b16:	55 1f       	adc	r21, r21
    1b18:	66 1f       	adc	r22, r22
    1b1a:	77 1f       	adc	r23, r23
    1b1c:	88 1f       	adc	r24, r24
    1b1e:	99 1f       	adc	r25, r25
    1b20:	88 1c       	adc	r8, r8
    1b22:	99 1c       	adc	r9, r9
    1b24:	ee 1f       	adc	r30, r30
    1b26:	ff 1f       	adc	r31, r31
    1b28:	cc 1f       	adc	r28, r28
    1b2a:	dd 1f       	adc	r29, r29
    1b2c:	aa 1f       	adc	r26, r26
    1b2e:	bb 1f       	adc	r27, r27
    1b30:	8a 14       	cp	r8, r10
    1b32:	9b 04       	cpc	r9, r11
    1b34:	ec 05       	cpc	r30, r12
    1b36:	fd 05       	cpc	r31, r13
    1b38:	ce 05       	cpc	r28, r14
    1b3a:	df 05       	cpc	r29, r15
    1b3c:	a0 07       	cpc	r26, r16
    1b3e:	b1 07       	cpc	r27, r17
    1b40:	48 f0       	brcs	.+18     	; 0x1b54 <__udivmod64+0x90>
    1b42:	8a 18       	sub	r8, r10
    1b44:	9b 08       	sbc	r9, r11
    1b46:	ec 09       	sbc	r30, r12
    1b48:	fd 09       	sbc	r31, r13
    1b4a:	ce 09       	sbc	r28, r14
    1b4c:	df 09       	sbc	r29, r15
    1b4e:	a0 0b       	sbc	r26, r16
    1b50:	b1 0b       	sbc	r27, r17
    1b52:	21 60       	ori	r18, 0x01	; 1
    1b54:	1a 94       	dec	r1
    1b56:	e1 f6       	brne	.-72     	; 0x1b10 <__udivmod64+0x4c>
    1b58:	2e f4       	brtc	.+10     	; 0x1b64 <__udivmod64+0xa0>
    1b5a:	94 01       	movw	r18, r8
    1b5c:	af 01       	movw	r20, r30
    1b5e:	be 01       	movw	r22, r28
    1b60:	cd 01       	movw	r24, r26
    1b62:	00 0c       	add	r0, r0
    1b64:	08 95       	ret

00001b66 <__negdi2>:
    1b66:	60 95       	com	r22
    1b68:	70 95       	com	r23
    1b6a:	80 95       	com	r24
    1b6c:	90 95       	com	r25
    1b6e:	30 95       	com	r19
    1b70:	40 95       	com	r20
    1b72:	50 95       	com	r21
    1b74:	21 95       	neg	r18
    1b76:	3f 4f       	sbci	r19, 0xFF	; 255
    1b78:	4f 4f       	sbci	r20, 0xFF	; 255
    1b7a:	5f 4f       	sbci	r21, 0xFF	; 255
    1b7c:	6f 4f       	sbci	r22, 0xFF	; 255
    1b7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b80:	8f 4f       	sbci	r24, 0xFF	; 255
    1b82:	9f 4f       	sbci	r25, 0xFF	; 255
    1b84:	08 95       	ret

00001b86 <__prologue_saves__>:
    1b86:	2f 92       	push	r2
    1b88:	3f 92       	push	r3
    1b8a:	4f 92       	push	r4
    1b8c:	5f 92       	push	r5
    1b8e:	6f 92       	push	r6
    1b90:	7f 92       	push	r7
    1b92:	8f 92       	push	r8
    1b94:	9f 92       	push	r9
    1b96:	af 92       	push	r10
    1b98:	bf 92       	push	r11
    1b9a:	cf 92       	push	r12
    1b9c:	df 92       	push	r13
    1b9e:	ef 92       	push	r14
    1ba0:	ff 92       	push	r15
    1ba2:	0f 93       	push	r16
    1ba4:	1f 93       	push	r17
    1ba6:	cf 93       	push	r28
    1ba8:	df 93       	push	r29
    1baa:	cd b7       	in	r28, 0x3d	; 61
    1bac:	de b7       	in	r29, 0x3e	; 62
    1bae:	ca 1b       	sub	r28, r26
    1bb0:	db 0b       	sbc	r29, r27
    1bb2:	0f b6       	in	r0, 0x3f	; 63
    1bb4:	f8 94       	cli
    1bb6:	de bf       	out	0x3e, r29	; 62
    1bb8:	0f be       	out	0x3f, r0	; 63
    1bba:	cd bf       	out	0x3d, r28	; 61
    1bbc:	09 94       	ijmp

00001bbe <__epilogue_restores__>:
    1bbe:	2a 88       	ldd	r2, Y+18	; 0x12
    1bc0:	39 88       	ldd	r3, Y+17	; 0x11
    1bc2:	48 88       	ldd	r4, Y+16	; 0x10
    1bc4:	5f 84       	ldd	r5, Y+15	; 0x0f
    1bc6:	6e 84       	ldd	r6, Y+14	; 0x0e
    1bc8:	7d 84       	ldd	r7, Y+13	; 0x0d
    1bca:	8c 84       	ldd	r8, Y+12	; 0x0c
    1bcc:	9b 84       	ldd	r9, Y+11	; 0x0b
    1bce:	aa 84       	ldd	r10, Y+10	; 0x0a
    1bd0:	b9 84       	ldd	r11, Y+9	; 0x09
    1bd2:	c8 84       	ldd	r12, Y+8	; 0x08
    1bd4:	df 80       	ldd	r13, Y+7	; 0x07
    1bd6:	ee 80       	ldd	r14, Y+6	; 0x06
    1bd8:	fd 80       	ldd	r15, Y+5	; 0x05
    1bda:	0c 81       	ldd	r16, Y+4	; 0x04
    1bdc:	1b 81       	ldd	r17, Y+3	; 0x03
    1bde:	aa 81       	ldd	r26, Y+2	; 0x02
    1be0:	b9 81       	ldd	r27, Y+1	; 0x01
    1be2:	ce 0f       	add	r28, r30
    1be4:	d1 1d       	adc	r29, r1
    1be6:	0f b6       	in	r0, 0x3f	; 63
    1be8:	f8 94       	cli
    1bea:	de bf       	out	0x3e, r29	; 62
    1bec:	0f be       	out	0x3f, r0	; 63
    1bee:	cd bf       	out	0x3d, r28	; 61
    1bf0:	ed 01       	movw	r28, r26
    1bf2:	08 95       	ret

00001bf4 <__ashldi3>:
    1bf4:	0f 93       	push	r16
    1bf6:	08 30       	cpi	r16, 0x08	; 8
    1bf8:	90 f0       	brcs	.+36     	; 0x1c1e <__ashldi3+0x2a>
    1bfa:	98 2f       	mov	r25, r24
    1bfc:	87 2f       	mov	r24, r23
    1bfe:	76 2f       	mov	r23, r22
    1c00:	65 2f       	mov	r22, r21
    1c02:	54 2f       	mov	r21, r20
    1c04:	43 2f       	mov	r20, r19
    1c06:	32 2f       	mov	r19, r18
    1c08:	22 27       	eor	r18, r18
    1c0a:	08 50       	subi	r16, 0x08	; 8
    1c0c:	f4 cf       	rjmp	.-24     	; 0x1bf6 <__ashldi3+0x2>
    1c0e:	22 0f       	add	r18, r18
    1c10:	33 1f       	adc	r19, r19
    1c12:	44 1f       	adc	r20, r20
    1c14:	55 1f       	adc	r21, r21
    1c16:	66 1f       	adc	r22, r22
    1c18:	77 1f       	adc	r23, r23
    1c1a:	88 1f       	adc	r24, r24
    1c1c:	99 1f       	adc	r25, r25
    1c1e:	0a 95       	dec	r16
    1c20:	b2 f7       	brpl	.-20     	; 0x1c0e <__ashldi3+0x1a>
    1c22:	0f 91       	pop	r16
    1c24:	08 95       	ret

00001c26 <__ashrdi3>:
    1c26:	97 fb       	bst	r25, 7
    1c28:	10 f8       	bld	r1, 0

00001c2a <__lshrdi3>:
    1c2a:	16 94       	lsr	r1
    1c2c:	00 08       	sbc	r0, r0
    1c2e:	0f 93       	push	r16
    1c30:	08 30       	cpi	r16, 0x08	; 8
    1c32:	98 f0       	brcs	.+38     	; 0x1c5a <__lshrdi3+0x30>
    1c34:	08 50       	subi	r16, 0x08	; 8
    1c36:	23 2f       	mov	r18, r19
    1c38:	34 2f       	mov	r19, r20
    1c3a:	45 2f       	mov	r20, r21
    1c3c:	56 2f       	mov	r21, r22
    1c3e:	67 2f       	mov	r22, r23
    1c40:	78 2f       	mov	r23, r24
    1c42:	89 2f       	mov	r24, r25
    1c44:	90 2d       	mov	r25, r0
    1c46:	f4 cf       	rjmp	.-24     	; 0x1c30 <__lshrdi3+0x6>
    1c48:	05 94       	asr	r0
    1c4a:	97 95       	ror	r25
    1c4c:	87 95       	ror	r24
    1c4e:	77 95       	ror	r23
    1c50:	67 95       	ror	r22
    1c52:	57 95       	ror	r21
    1c54:	47 95       	ror	r20
    1c56:	37 95       	ror	r19
    1c58:	27 95       	ror	r18
    1c5a:	0a 95       	dec	r16
    1c5c:	aa f7       	brpl	.-22     	; 0x1c48 <__lshrdi3+0x1e>
    1c5e:	0f 91       	pop	r16
    1c60:	08 95       	ret

00001c62 <__adddi3>:
    1c62:	2a 0d       	add	r18, r10
    1c64:	3b 1d       	adc	r19, r11
    1c66:	4c 1d       	adc	r20, r12
    1c68:	5d 1d       	adc	r21, r13
    1c6a:	6e 1d       	adc	r22, r14
    1c6c:	7f 1d       	adc	r23, r15
    1c6e:	80 1f       	adc	r24, r16
    1c70:	91 1f       	adc	r25, r17
    1c72:	08 95       	ret

00001c74 <__subdi3>:
    1c74:	2a 19       	sub	r18, r10
    1c76:	3b 09       	sbc	r19, r11
    1c78:	4c 09       	sbc	r20, r12
    1c7a:	5d 09       	sbc	r21, r13
    1c7c:	6e 09       	sbc	r22, r14
    1c7e:	7f 09       	sbc	r23, r15
    1c80:	80 0b       	sbc	r24, r16
    1c82:	91 0b       	sbc	r25, r17
    1c84:	08 95       	ret

00001c86 <__cmpdi2_s8>:
    1c86:	00 24       	eor	r0, r0
    1c88:	a7 fd       	sbrc	r26, 7
    1c8a:	00 94       	com	r0
    1c8c:	2a 17       	cp	r18, r26
    1c8e:	30 05       	cpc	r19, r0
    1c90:	40 05       	cpc	r20, r0
    1c92:	50 05       	cpc	r21, r0
    1c94:	60 05       	cpc	r22, r0
    1c96:	70 05       	cpc	r23, r0
    1c98:	80 05       	cpc	r24, r0
    1c9a:	90 05       	cpc	r25, r0
    1c9c:	08 95       	ret

00001c9e <__umulhisi3>:
    1c9e:	a2 9f       	mul	r26, r18
    1ca0:	b0 01       	movw	r22, r0
    1ca2:	b3 9f       	mul	r27, r19
    1ca4:	c0 01       	movw	r24, r0
    1ca6:	a3 9f       	mul	r26, r19
    1ca8:	70 0d       	add	r23, r0
    1caa:	81 1d       	adc	r24, r1
    1cac:	11 24       	eor	r1, r1
    1cae:	91 1d       	adc	r25, r1
    1cb0:	b2 9f       	mul	r27, r18
    1cb2:	70 0d       	add	r23, r0
    1cb4:	81 1d       	adc	r24, r1
    1cb6:	11 24       	eor	r1, r1
    1cb8:	91 1d       	adc	r25, r1
    1cba:	08 95       	ret

00001cbc <printf>:
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	cd b7       	in	r28, 0x3d	; 61
    1cc2:	de b7       	in	r29, 0x3e	; 62
    1cc4:	ae 01       	movw	r20, r28
    1cc6:	4b 5f       	subi	r20, 0xFB	; 251
    1cc8:	5f 4f       	sbci	r21, 0xFF	; 255
    1cca:	fa 01       	movw	r30, r20
    1ccc:	61 91       	ld	r22, Z+
    1cce:	71 91       	ld	r23, Z+
    1cd0:	af 01       	movw	r20, r30
    1cd2:	80 91 dc 05 	lds	r24, 0x05DC	; 0x8005dc <__iob+0x2>
    1cd6:	90 91 dd 05 	lds	r25, 0x05DD	; 0x8005dd <__iob+0x3>
    1cda:	03 d0       	rcall	.+6      	; 0x1ce2 <vfprintf>
    1cdc:	df 91       	pop	r29
    1cde:	cf 91       	pop	r28
    1ce0:	08 95       	ret

00001ce2 <vfprintf>:
    1ce2:	2f 92       	push	r2
    1ce4:	3f 92       	push	r3
    1ce6:	4f 92       	push	r4
    1ce8:	5f 92       	push	r5
    1cea:	6f 92       	push	r6
    1cec:	7f 92       	push	r7
    1cee:	8f 92       	push	r8
    1cf0:	9f 92       	push	r9
    1cf2:	af 92       	push	r10
    1cf4:	bf 92       	push	r11
    1cf6:	cf 92       	push	r12
    1cf8:	df 92       	push	r13
    1cfa:	ef 92       	push	r14
    1cfc:	ff 92       	push	r15
    1cfe:	0f 93       	push	r16
    1d00:	1f 93       	push	r17
    1d02:	cf 93       	push	r28
    1d04:	df 93       	push	r29
    1d06:	cd b7       	in	r28, 0x3d	; 61
    1d08:	de b7       	in	r29, 0x3e	; 62
    1d0a:	2b 97       	sbiw	r28, 0x0b	; 11
    1d0c:	0f b6       	in	r0, 0x3f	; 63
    1d0e:	f8 94       	cli
    1d10:	de bf       	out	0x3e, r29	; 62
    1d12:	0f be       	out	0x3f, r0	; 63
    1d14:	cd bf       	out	0x3d, r28	; 61
    1d16:	6c 01       	movw	r12, r24
    1d18:	7b 01       	movw	r14, r22
    1d1a:	8a 01       	movw	r16, r20
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	17 82       	std	Z+7, r1	; 0x07
    1d20:	16 82       	std	Z+6, r1	; 0x06
    1d22:	83 81       	ldd	r24, Z+3	; 0x03
    1d24:	81 ff       	sbrs	r24, 1
    1d26:	bf c1       	rjmp	.+894    	; 0x20a6 <vfprintf+0x3c4>
    1d28:	ce 01       	movw	r24, r28
    1d2a:	01 96       	adiw	r24, 0x01	; 1
    1d2c:	3c 01       	movw	r6, r24
    1d2e:	f6 01       	movw	r30, r12
    1d30:	93 81       	ldd	r25, Z+3	; 0x03
    1d32:	f7 01       	movw	r30, r14
    1d34:	93 fd       	sbrc	r25, 3
    1d36:	85 91       	lpm	r24, Z+
    1d38:	93 ff       	sbrs	r25, 3
    1d3a:	81 91       	ld	r24, Z+
    1d3c:	7f 01       	movw	r14, r30
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <vfprintf+0x62>
    1d42:	ad c1       	rjmp	.+858    	; 0x209e <vfprintf+0x3bc>
    1d44:	85 32       	cpi	r24, 0x25	; 37
    1d46:	39 f4       	brne	.+14     	; 0x1d56 <vfprintf+0x74>
    1d48:	93 fd       	sbrc	r25, 3
    1d4a:	85 91       	lpm	r24, Z+
    1d4c:	93 ff       	sbrs	r25, 3
    1d4e:	81 91       	ld	r24, Z+
    1d50:	7f 01       	movw	r14, r30
    1d52:	85 32       	cpi	r24, 0x25	; 37
    1d54:	21 f4       	brne	.+8      	; 0x1d5e <vfprintf+0x7c>
    1d56:	b6 01       	movw	r22, r12
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	d6 d1       	rcall	.+940    	; 0x2108 <fputc>
    1d5c:	e8 cf       	rjmp	.-48     	; 0x1d2e <vfprintf+0x4c>
    1d5e:	91 2c       	mov	r9, r1
    1d60:	21 2c       	mov	r2, r1
    1d62:	31 2c       	mov	r3, r1
    1d64:	ff e1       	ldi	r31, 0x1F	; 31
    1d66:	f3 15       	cp	r31, r3
    1d68:	d8 f0       	brcs	.+54     	; 0x1da0 <vfprintf+0xbe>
    1d6a:	8b 32       	cpi	r24, 0x2B	; 43
    1d6c:	79 f0       	breq	.+30     	; 0x1d8c <vfprintf+0xaa>
    1d6e:	38 f4       	brcc	.+14     	; 0x1d7e <vfprintf+0x9c>
    1d70:	80 32       	cpi	r24, 0x20	; 32
    1d72:	79 f0       	breq	.+30     	; 0x1d92 <vfprintf+0xb0>
    1d74:	83 32       	cpi	r24, 0x23	; 35
    1d76:	a1 f4       	brne	.+40     	; 0x1da0 <vfprintf+0xbe>
    1d78:	23 2d       	mov	r18, r3
    1d7a:	20 61       	ori	r18, 0x10	; 16
    1d7c:	1d c0       	rjmp	.+58     	; 0x1db8 <vfprintf+0xd6>
    1d7e:	8d 32       	cpi	r24, 0x2D	; 45
    1d80:	61 f0       	breq	.+24     	; 0x1d9a <vfprintf+0xb8>
    1d82:	80 33       	cpi	r24, 0x30	; 48
    1d84:	69 f4       	brne	.+26     	; 0x1da0 <vfprintf+0xbe>
    1d86:	23 2d       	mov	r18, r3
    1d88:	21 60       	ori	r18, 0x01	; 1
    1d8a:	16 c0       	rjmp	.+44     	; 0x1db8 <vfprintf+0xd6>
    1d8c:	83 2d       	mov	r24, r3
    1d8e:	82 60       	ori	r24, 0x02	; 2
    1d90:	38 2e       	mov	r3, r24
    1d92:	e3 2d       	mov	r30, r3
    1d94:	e4 60       	ori	r30, 0x04	; 4
    1d96:	3e 2e       	mov	r3, r30
    1d98:	2a c0       	rjmp	.+84     	; 0x1dee <vfprintf+0x10c>
    1d9a:	f3 2d       	mov	r31, r3
    1d9c:	f8 60       	ori	r31, 0x08	; 8
    1d9e:	1d c0       	rjmp	.+58     	; 0x1dda <vfprintf+0xf8>
    1da0:	37 fc       	sbrc	r3, 7
    1da2:	2d c0       	rjmp	.+90     	; 0x1dfe <vfprintf+0x11c>
    1da4:	20 ed       	ldi	r18, 0xD0	; 208
    1da6:	28 0f       	add	r18, r24
    1da8:	2a 30       	cpi	r18, 0x0A	; 10
    1daa:	40 f0       	brcs	.+16     	; 0x1dbc <vfprintf+0xda>
    1dac:	8e 32       	cpi	r24, 0x2E	; 46
    1dae:	b9 f4       	brne	.+46     	; 0x1dde <vfprintf+0xfc>
    1db0:	36 fc       	sbrc	r3, 6
    1db2:	75 c1       	rjmp	.+746    	; 0x209e <vfprintf+0x3bc>
    1db4:	23 2d       	mov	r18, r3
    1db6:	20 64       	ori	r18, 0x40	; 64
    1db8:	32 2e       	mov	r3, r18
    1dba:	19 c0       	rjmp	.+50     	; 0x1dee <vfprintf+0x10c>
    1dbc:	36 fe       	sbrs	r3, 6
    1dbe:	06 c0       	rjmp	.+12     	; 0x1dcc <vfprintf+0xea>
    1dc0:	8a e0       	ldi	r24, 0x0A	; 10
    1dc2:	98 9e       	mul	r9, r24
    1dc4:	20 0d       	add	r18, r0
    1dc6:	11 24       	eor	r1, r1
    1dc8:	92 2e       	mov	r9, r18
    1dca:	11 c0       	rjmp	.+34     	; 0x1dee <vfprintf+0x10c>
    1dcc:	ea e0       	ldi	r30, 0x0A	; 10
    1dce:	2e 9e       	mul	r2, r30
    1dd0:	20 0d       	add	r18, r0
    1dd2:	11 24       	eor	r1, r1
    1dd4:	22 2e       	mov	r2, r18
    1dd6:	f3 2d       	mov	r31, r3
    1dd8:	f0 62       	ori	r31, 0x20	; 32
    1dda:	3f 2e       	mov	r3, r31
    1ddc:	08 c0       	rjmp	.+16     	; 0x1dee <vfprintf+0x10c>
    1dde:	8c 36       	cpi	r24, 0x6C	; 108
    1de0:	21 f4       	brne	.+8      	; 0x1dea <vfprintf+0x108>
    1de2:	83 2d       	mov	r24, r3
    1de4:	80 68       	ori	r24, 0x80	; 128
    1de6:	38 2e       	mov	r3, r24
    1de8:	02 c0       	rjmp	.+4      	; 0x1dee <vfprintf+0x10c>
    1dea:	88 36       	cpi	r24, 0x68	; 104
    1dec:	41 f4       	brne	.+16     	; 0x1dfe <vfprintf+0x11c>
    1dee:	f7 01       	movw	r30, r14
    1df0:	93 fd       	sbrc	r25, 3
    1df2:	85 91       	lpm	r24, Z+
    1df4:	93 ff       	sbrs	r25, 3
    1df6:	81 91       	ld	r24, Z+
    1df8:	7f 01       	movw	r14, r30
    1dfa:	81 11       	cpse	r24, r1
    1dfc:	b3 cf       	rjmp	.-154    	; 0x1d64 <vfprintf+0x82>
    1dfe:	98 2f       	mov	r25, r24
    1e00:	9f 7d       	andi	r25, 0xDF	; 223
    1e02:	95 54       	subi	r25, 0x45	; 69
    1e04:	93 30       	cpi	r25, 0x03	; 3
    1e06:	28 f4       	brcc	.+10     	; 0x1e12 <vfprintf+0x130>
    1e08:	0c 5f       	subi	r16, 0xFC	; 252
    1e0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e0c:	9f e3       	ldi	r25, 0x3F	; 63
    1e0e:	99 83       	std	Y+1, r25	; 0x01
    1e10:	0d c0       	rjmp	.+26     	; 0x1e2c <vfprintf+0x14a>
    1e12:	83 36       	cpi	r24, 0x63	; 99
    1e14:	31 f0       	breq	.+12     	; 0x1e22 <vfprintf+0x140>
    1e16:	83 37       	cpi	r24, 0x73	; 115
    1e18:	71 f0       	breq	.+28     	; 0x1e36 <vfprintf+0x154>
    1e1a:	83 35       	cpi	r24, 0x53	; 83
    1e1c:	09 f0       	breq	.+2      	; 0x1e20 <vfprintf+0x13e>
    1e1e:	55 c0       	rjmp	.+170    	; 0x1eca <vfprintf+0x1e8>
    1e20:	20 c0       	rjmp	.+64     	; 0x1e62 <vfprintf+0x180>
    1e22:	f8 01       	movw	r30, r16
    1e24:	80 81       	ld	r24, Z
    1e26:	89 83       	std	Y+1, r24	; 0x01
    1e28:	0e 5f       	subi	r16, 0xFE	; 254
    1e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e2c:	88 24       	eor	r8, r8
    1e2e:	83 94       	inc	r8
    1e30:	91 2c       	mov	r9, r1
    1e32:	53 01       	movw	r10, r6
    1e34:	12 c0       	rjmp	.+36     	; 0x1e5a <vfprintf+0x178>
    1e36:	28 01       	movw	r4, r16
    1e38:	f2 e0       	ldi	r31, 0x02	; 2
    1e3a:	4f 0e       	add	r4, r31
    1e3c:	51 1c       	adc	r5, r1
    1e3e:	f8 01       	movw	r30, r16
    1e40:	a0 80       	ld	r10, Z
    1e42:	b1 80       	ldd	r11, Z+1	; 0x01
    1e44:	36 fe       	sbrs	r3, 6
    1e46:	03 c0       	rjmp	.+6      	; 0x1e4e <vfprintf+0x16c>
    1e48:	69 2d       	mov	r22, r9
    1e4a:	70 e0       	ldi	r23, 0x00	; 0
    1e4c:	02 c0       	rjmp	.+4      	; 0x1e52 <vfprintf+0x170>
    1e4e:	6f ef       	ldi	r22, 0xFF	; 255
    1e50:	7f ef       	ldi	r23, 0xFF	; 255
    1e52:	c5 01       	movw	r24, r10
    1e54:	4e d1       	rcall	.+668    	; 0x20f2 <strnlen>
    1e56:	4c 01       	movw	r8, r24
    1e58:	82 01       	movw	r16, r4
    1e5a:	f3 2d       	mov	r31, r3
    1e5c:	ff 77       	andi	r31, 0x7F	; 127
    1e5e:	3f 2e       	mov	r3, r31
    1e60:	15 c0       	rjmp	.+42     	; 0x1e8c <vfprintf+0x1aa>
    1e62:	28 01       	movw	r4, r16
    1e64:	22 e0       	ldi	r18, 0x02	; 2
    1e66:	42 0e       	add	r4, r18
    1e68:	51 1c       	adc	r5, r1
    1e6a:	f8 01       	movw	r30, r16
    1e6c:	a0 80       	ld	r10, Z
    1e6e:	b1 80       	ldd	r11, Z+1	; 0x01
    1e70:	36 fe       	sbrs	r3, 6
    1e72:	03 c0       	rjmp	.+6      	; 0x1e7a <vfprintf+0x198>
    1e74:	69 2d       	mov	r22, r9
    1e76:	70 e0       	ldi	r23, 0x00	; 0
    1e78:	02 c0       	rjmp	.+4      	; 0x1e7e <vfprintf+0x19c>
    1e7a:	6f ef       	ldi	r22, 0xFF	; 255
    1e7c:	7f ef       	ldi	r23, 0xFF	; 255
    1e7e:	c5 01       	movw	r24, r10
    1e80:	2d d1       	rcall	.+602    	; 0x20dc <strnlen_P>
    1e82:	4c 01       	movw	r8, r24
    1e84:	f3 2d       	mov	r31, r3
    1e86:	f0 68       	ori	r31, 0x80	; 128
    1e88:	3f 2e       	mov	r3, r31
    1e8a:	82 01       	movw	r16, r4
    1e8c:	33 fc       	sbrc	r3, 3
    1e8e:	19 c0       	rjmp	.+50     	; 0x1ec2 <vfprintf+0x1e0>
    1e90:	82 2d       	mov	r24, r2
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	88 16       	cp	r8, r24
    1e96:	99 06       	cpc	r9, r25
    1e98:	a0 f4       	brcc	.+40     	; 0x1ec2 <vfprintf+0x1e0>
    1e9a:	b6 01       	movw	r22, r12
    1e9c:	80 e2       	ldi	r24, 0x20	; 32
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	33 d1       	rcall	.+614    	; 0x2108 <fputc>
    1ea2:	2a 94       	dec	r2
    1ea4:	f5 cf       	rjmp	.-22     	; 0x1e90 <vfprintf+0x1ae>
    1ea6:	f5 01       	movw	r30, r10
    1ea8:	37 fc       	sbrc	r3, 7
    1eaa:	85 91       	lpm	r24, Z+
    1eac:	37 fe       	sbrs	r3, 7
    1eae:	81 91       	ld	r24, Z+
    1eb0:	5f 01       	movw	r10, r30
    1eb2:	b6 01       	movw	r22, r12
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	28 d1       	rcall	.+592    	; 0x2108 <fputc>
    1eb8:	21 10       	cpse	r2, r1
    1eba:	2a 94       	dec	r2
    1ebc:	21 e0       	ldi	r18, 0x01	; 1
    1ebe:	82 1a       	sub	r8, r18
    1ec0:	91 08       	sbc	r9, r1
    1ec2:	81 14       	cp	r8, r1
    1ec4:	91 04       	cpc	r9, r1
    1ec6:	79 f7       	brne	.-34     	; 0x1ea6 <vfprintf+0x1c4>
    1ec8:	e1 c0       	rjmp	.+450    	; 0x208c <vfprintf+0x3aa>
    1eca:	84 36       	cpi	r24, 0x64	; 100
    1ecc:	11 f0       	breq	.+4      	; 0x1ed2 <vfprintf+0x1f0>
    1ece:	89 36       	cpi	r24, 0x69	; 105
    1ed0:	39 f5       	brne	.+78     	; 0x1f20 <vfprintf+0x23e>
    1ed2:	f8 01       	movw	r30, r16
    1ed4:	37 fe       	sbrs	r3, 7
    1ed6:	07 c0       	rjmp	.+14     	; 0x1ee6 <vfprintf+0x204>
    1ed8:	60 81       	ld	r22, Z
    1eda:	71 81       	ldd	r23, Z+1	; 0x01
    1edc:	82 81       	ldd	r24, Z+2	; 0x02
    1ede:	93 81       	ldd	r25, Z+3	; 0x03
    1ee0:	0c 5f       	subi	r16, 0xFC	; 252
    1ee2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ee4:	08 c0       	rjmp	.+16     	; 0x1ef6 <vfprintf+0x214>
    1ee6:	60 81       	ld	r22, Z
    1ee8:	71 81       	ldd	r23, Z+1	; 0x01
    1eea:	07 2e       	mov	r0, r23
    1eec:	00 0c       	add	r0, r0
    1eee:	88 0b       	sbc	r24, r24
    1ef0:	99 0b       	sbc	r25, r25
    1ef2:	0e 5f       	subi	r16, 0xFE	; 254
    1ef4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ef6:	f3 2d       	mov	r31, r3
    1ef8:	ff 76       	andi	r31, 0x6F	; 111
    1efa:	3f 2e       	mov	r3, r31
    1efc:	97 ff       	sbrs	r25, 7
    1efe:	09 c0       	rjmp	.+18     	; 0x1f12 <vfprintf+0x230>
    1f00:	90 95       	com	r25
    1f02:	80 95       	com	r24
    1f04:	70 95       	com	r23
    1f06:	61 95       	neg	r22
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0a:	8f 4f       	sbci	r24, 0xFF	; 255
    1f0c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f0e:	f0 68       	ori	r31, 0x80	; 128
    1f10:	3f 2e       	mov	r3, r31
    1f12:	2a e0       	ldi	r18, 0x0A	; 10
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	a3 01       	movw	r20, r6
    1f18:	33 d1       	rcall	.+614    	; 0x2180 <__ultoa_invert>
    1f1a:	88 2e       	mov	r8, r24
    1f1c:	86 18       	sub	r8, r6
    1f1e:	44 c0       	rjmp	.+136    	; 0x1fa8 <vfprintf+0x2c6>
    1f20:	85 37       	cpi	r24, 0x75	; 117
    1f22:	31 f4       	brne	.+12     	; 0x1f30 <vfprintf+0x24e>
    1f24:	23 2d       	mov	r18, r3
    1f26:	2f 7e       	andi	r18, 0xEF	; 239
    1f28:	b2 2e       	mov	r11, r18
    1f2a:	2a e0       	ldi	r18, 0x0A	; 10
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	25 c0       	rjmp	.+74     	; 0x1f7a <vfprintf+0x298>
    1f30:	93 2d       	mov	r25, r3
    1f32:	99 7f       	andi	r25, 0xF9	; 249
    1f34:	b9 2e       	mov	r11, r25
    1f36:	8f 36       	cpi	r24, 0x6F	; 111
    1f38:	c1 f0       	breq	.+48     	; 0x1f6a <vfprintf+0x288>
    1f3a:	18 f4       	brcc	.+6      	; 0x1f42 <vfprintf+0x260>
    1f3c:	88 35       	cpi	r24, 0x58	; 88
    1f3e:	79 f0       	breq	.+30     	; 0x1f5e <vfprintf+0x27c>
    1f40:	ae c0       	rjmp	.+348    	; 0x209e <vfprintf+0x3bc>
    1f42:	80 37       	cpi	r24, 0x70	; 112
    1f44:	19 f0       	breq	.+6      	; 0x1f4c <vfprintf+0x26a>
    1f46:	88 37       	cpi	r24, 0x78	; 120
    1f48:	21 f0       	breq	.+8      	; 0x1f52 <vfprintf+0x270>
    1f4a:	a9 c0       	rjmp	.+338    	; 0x209e <vfprintf+0x3bc>
    1f4c:	e9 2f       	mov	r30, r25
    1f4e:	e0 61       	ori	r30, 0x10	; 16
    1f50:	be 2e       	mov	r11, r30
    1f52:	b4 fe       	sbrs	r11, 4
    1f54:	0d c0       	rjmp	.+26     	; 0x1f70 <vfprintf+0x28e>
    1f56:	fb 2d       	mov	r31, r11
    1f58:	f4 60       	ori	r31, 0x04	; 4
    1f5a:	bf 2e       	mov	r11, r31
    1f5c:	09 c0       	rjmp	.+18     	; 0x1f70 <vfprintf+0x28e>
    1f5e:	34 fe       	sbrs	r3, 4
    1f60:	0a c0       	rjmp	.+20     	; 0x1f76 <vfprintf+0x294>
    1f62:	29 2f       	mov	r18, r25
    1f64:	26 60       	ori	r18, 0x06	; 6
    1f66:	b2 2e       	mov	r11, r18
    1f68:	06 c0       	rjmp	.+12     	; 0x1f76 <vfprintf+0x294>
    1f6a:	28 e0       	ldi	r18, 0x08	; 8
    1f6c:	30 e0       	ldi	r19, 0x00	; 0
    1f6e:	05 c0       	rjmp	.+10     	; 0x1f7a <vfprintf+0x298>
    1f70:	20 e1       	ldi	r18, 0x10	; 16
    1f72:	30 e0       	ldi	r19, 0x00	; 0
    1f74:	02 c0       	rjmp	.+4      	; 0x1f7a <vfprintf+0x298>
    1f76:	20 e1       	ldi	r18, 0x10	; 16
    1f78:	32 e0       	ldi	r19, 0x02	; 2
    1f7a:	f8 01       	movw	r30, r16
    1f7c:	b7 fe       	sbrs	r11, 7
    1f7e:	07 c0       	rjmp	.+14     	; 0x1f8e <vfprintf+0x2ac>
    1f80:	60 81       	ld	r22, Z
    1f82:	71 81       	ldd	r23, Z+1	; 0x01
    1f84:	82 81       	ldd	r24, Z+2	; 0x02
    1f86:	93 81       	ldd	r25, Z+3	; 0x03
    1f88:	0c 5f       	subi	r16, 0xFC	; 252
    1f8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f8c:	06 c0       	rjmp	.+12     	; 0x1f9a <vfprintf+0x2b8>
    1f8e:	60 81       	ld	r22, Z
    1f90:	71 81       	ldd	r23, Z+1	; 0x01
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	0e 5f       	subi	r16, 0xFE	; 254
    1f98:	1f 4f       	sbci	r17, 0xFF	; 255
    1f9a:	a3 01       	movw	r20, r6
    1f9c:	f1 d0       	rcall	.+482    	; 0x2180 <__ultoa_invert>
    1f9e:	88 2e       	mov	r8, r24
    1fa0:	86 18       	sub	r8, r6
    1fa2:	fb 2d       	mov	r31, r11
    1fa4:	ff 77       	andi	r31, 0x7F	; 127
    1fa6:	3f 2e       	mov	r3, r31
    1fa8:	36 fe       	sbrs	r3, 6
    1faa:	0d c0       	rjmp	.+26     	; 0x1fc6 <vfprintf+0x2e4>
    1fac:	23 2d       	mov	r18, r3
    1fae:	2e 7f       	andi	r18, 0xFE	; 254
    1fb0:	a2 2e       	mov	r10, r18
    1fb2:	89 14       	cp	r8, r9
    1fb4:	58 f4       	brcc	.+22     	; 0x1fcc <vfprintf+0x2ea>
    1fb6:	34 fe       	sbrs	r3, 4
    1fb8:	0b c0       	rjmp	.+22     	; 0x1fd0 <vfprintf+0x2ee>
    1fba:	32 fc       	sbrc	r3, 2
    1fbc:	09 c0       	rjmp	.+18     	; 0x1fd0 <vfprintf+0x2ee>
    1fbe:	83 2d       	mov	r24, r3
    1fc0:	8e 7e       	andi	r24, 0xEE	; 238
    1fc2:	a8 2e       	mov	r10, r24
    1fc4:	05 c0       	rjmp	.+10     	; 0x1fd0 <vfprintf+0x2ee>
    1fc6:	b8 2c       	mov	r11, r8
    1fc8:	a3 2c       	mov	r10, r3
    1fca:	03 c0       	rjmp	.+6      	; 0x1fd2 <vfprintf+0x2f0>
    1fcc:	b8 2c       	mov	r11, r8
    1fce:	01 c0       	rjmp	.+2      	; 0x1fd2 <vfprintf+0x2f0>
    1fd0:	b9 2c       	mov	r11, r9
    1fd2:	a4 fe       	sbrs	r10, 4
    1fd4:	0f c0       	rjmp	.+30     	; 0x1ff4 <vfprintf+0x312>
    1fd6:	fe 01       	movw	r30, r28
    1fd8:	e8 0d       	add	r30, r8
    1fda:	f1 1d       	adc	r31, r1
    1fdc:	80 81       	ld	r24, Z
    1fde:	80 33       	cpi	r24, 0x30	; 48
    1fe0:	21 f4       	brne	.+8      	; 0x1fea <vfprintf+0x308>
    1fe2:	9a 2d       	mov	r25, r10
    1fe4:	99 7e       	andi	r25, 0xE9	; 233
    1fe6:	a9 2e       	mov	r10, r25
    1fe8:	09 c0       	rjmp	.+18     	; 0x1ffc <vfprintf+0x31a>
    1fea:	a2 fe       	sbrs	r10, 2
    1fec:	06 c0       	rjmp	.+12     	; 0x1ffa <vfprintf+0x318>
    1fee:	b3 94       	inc	r11
    1ff0:	b3 94       	inc	r11
    1ff2:	04 c0       	rjmp	.+8      	; 0x1ffc <vfprintf+0x31a>
    1ff4:	8a 2d       	mov	r24, r10
    1ff6:	86 78       	andi	r24, 0x86	; 134
    1ff8:	09 f0       	breq	.+2      	; 0x1ffc <vfprintf+0x31a>
    1ffa:	b3 94       	inc	r11
    1ffc:	a3 fc       	sbrc	r10, 3
    1ffe:	10 c0       	rjmp	.+32     	; 0x2020 <vfprintf+0x33e>
    2000:	a0 fe       	sbrs	r10, 0
    2002:	06 c0       	rjmp	.+12     	; 0x2010 <vfprintf+0x32e>
    2004:	b2 14       	cp	r11, r2
    2006:	80 f4       	brcc	.+32     	; 0x2028 <vfprintf+0x346>
    2008:	28 0c       	add	r2, r8
    200a:	92 2c       	mov	r9, r2
    200c:	9b 18       	sub	r9, r11
    200e:	0d c0       	rjmp	.+26     	; 0x202a <vfprintf+0x348>
    2010:	b2 14       	cp	r11, r2
    2012:	58 f4       	brcc	.+22     	; 0x202a <vfprintf+0x348>
    2014:	b6 01       	movw	r22, r12
    2016:	80 e2       	ldi	r24, 0x20	; 32
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	76 d0       	rcall	.+236    	; 0x2108 <fputc>
    201c:	b3 94       	inc	r11
    201e:	f8 cf       	rjmp	.-16     	; 0x2010 <vfprintf+0x32e>
    2020:	b2 14       	cp	r11, r2
    2022:	18 f4       	brcc	.+6      	; 0x202a <vfprintf+0x348>
    2024:	2b 18       	sub	r2, r11
    2026:	02 c0       	rjmp	.+4      	; 0x202c <vfprintf+0x34a>
    2028:	98 2c       	mov	r9, r8
    202a:	21 2c       	mov	r2, r1
    202c:	a4 fe       	sbrs	r10, 4
    202e:	0f c0       	rjmp	.+30     	; 0x204e <vfprintf+0x36c>
    2030:	b6 01       	movw	r22, r12
    2032:	80 e3       	ldi	r24, 0x30	; 48
    2034:	90 e0       	ldi	r25, 0x00	; 0
    2036:	68 d0       	rcall	.+208    	; 0x2108 <fputc>
    2038:	a2 fe       	sbrs	r10, 2
    203a:	16 c0       	rjmp	.+44     	; 0x2068 <vfprintf+0x386>
    203c:	a1 fc       	sbrc	r10, 1
    203e:	03 c0       	rjmp	.+6      	; 0x2046 <vfprintf+0x364>
    2040:	88 e7       	ldi	r24, 0x78	; 120
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	02 c0       	rjmp	.+4      	; 0x204a <vfprintf+0x368>
    2046:	88 e5       	ldi	r24, 0x58	; 88
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	b6 01       	movw	r22, r12
    204c:	0c c0       	rjmp	.+24     	; 0x2066 <vfprintf+0x384>
    204e:	8a 2d       	mov	r24, r10
    2050:	86 78       	andi	r24, 0x86	; 134
    2052:	51 f0       	breq	.+20     	; 0x2068 <vfprintf+0x386>
    2054:	a1 fe       	sbrs	r10, 1
    2056:	02 c0       	rjmp	.+4      	; 0x205c <vfprintf+0x37a>
    2058:	8b e2       	ldi	r24, 0x2B	; 43
    205a:	01 c0       	rjmp	.+2      	; 0x205e <vfprintf+0x37c>
    205c:	80 e2       	ldi	r24, 0x20	; 32
    205e:	a7 fc       	sbrc	r10, 7
    2060:	8d e2       	ldi	r24, 0x2D	; 45
    2062:	b6 01       	movw	r22, r12
    2064:	90 e0       	ldi	r25, 0x00	; 0
    2066:	50 d0       	rcall	.+160    	; 0x2108 <fputc>
    2068:	89 14       	cp	r8, r9
    206a:	30 f4       	brcc	.+12     	; 0x2078 <vfprintf+0x396>
    206c:	b6 01       	movw	r22, r12
    206e:	80 e3       	ldi	r24, 0x30	; 48
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	4a d0       	rcall	.+148    	; 0x2108 <fputc>
    2074:	9a 94       	dec	r9
    2076:	f8 cf       	rjmp	.-16     	; 0x2068 <vfprintf+0x386>
    2078:	8a 94       	dec	r8
    207a:	f3 01       	movw	r30, r6
    207c:	e8 0d       	add	r30, r8
    207e:	f1 1d       	adc	r31, r1
    2080:	80 81       	ld	r24, Z
    2082:	b6 01       	movw	r22, r12
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	40 d0       	rcall	.+128    	; 0x2108 <fputc>
    2088:	81 10       	cpse	r8, r1
    208a:	f6 cf       	rjmp	.-20     	; 0x2078 <vfprintf+0x396>
    208c:	22 20       	and	r2, r2
    208e:	09 f4       	brne	.+2      	; 0x2092 <vfprintf+0x3b0>
    2090:	4e ce       	rjmp	.-868    	; 0x1d2e <vfprintf+0x4c>
    2092:	b6 01       	movw	r22, r12
    2094:	80 e2       	ldi	r24, 0x20	; 32
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	37 d0       	rcall	.+110    	; 0x2108 <fputc>
    209a:	2a 94       	dec	r2
    209c:	f7 cf       	rjmp	.-18     	; 0x208c <vfprintf+0x3aa>
    209e:	f6 01       	movw	r30, r12
    20a0:	86 81       	ldd	r24, Z+6	; 0x06
    20a2:	97 81       	ldd	r25, Z+7	; 0x07
    20a4:	02 c0       	rjmp	.+4      	; 0x20aa <vfprintf+0x3c8>
    20a6:	8f ef       	ldi	r24, 0xFF	; 255
    20a8:	9f ef       	ldi	r25, 0xFF	; 255
    20aa:	2b 96       	adiw	r28, 0x0b	; 11
    20ac:	0f b6       	in	r0, 0x3f	; 63
    20ae:	f8 94       	cli
    20b0:	de bf       	out	0x3e, r29	; 62
    20b2:	0f be       	out	0x3f, r0	; 63
    20b4:	cd bf       	out	0x3d, r28	; 61
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	bf 90       	pop	r11
    20c8:	af 90       	pop	r10
    20ca:	9f 90       	pop	r9
    20cc:	8f 90       	pop	r8
    20ce:	7f 90       	pop	r7
    20d0:	6f 90       	pop	r6
    20d2:	5f 90       	pop	r5
    20d4:	4f 90       	pop	r4
    20d6:	3f 90       	pop	r3
    20d8:	2f 90       	pop	r2
    20da:	08 95       	ret

000020dc <strnlen_P>:
    20dc:	fc 01       	movw	r30, r24
    20de:	05 90       	lpm	r0, Z+
    20e0:	61 50       	subi	r22, 0x01	; 1
    20e2:	70 40       	sbci	r23, 0x00	; 0
    20e4:	01 10       	cpse	r0, r1
    20e6:	d8 f7       	brcc	.-10     	; 0x20de <strnlen_P+0x2>
    20e8:	80 95       	com	r24
    20ea:	90 95       	com	r25
    20ec:	8e 0f       	add	r24, r30
    20ee:	9f 1f       	adc	r25, r31
    20f0:	08 95       	ret

000020f2 <strnlen>:
    20f2:	fc 01       	movw	r30, r24
    20f4:	61 50       	subi	r22, 0x01	; 1
    20f6:	70 40       	sbci	r23, 0x00	; 0
    20f8:	01 90       	ld	r0, Z+
    20fa:	01 10       	cpse	r0, r1
    20fc:	d8 f7       	brcc	.-10     	; 0x20f4 <strnlen+0x2>
    20fe:	80 95       	com	r24
    2100:	90 95       	com	r25
    2102:	8e 0f       	add	r24, r30
    2104:	9f 1f       	adc	r25, r31
    2106:	08 95       	ret

00002108 <fputc>:
    2108:	0f 93       	push	r16
    210a:	1f 93       	push	r17
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	fb 01       	movw	r30, r22
    2112:	23 81       	ldd	r18, Z+3	; 0x03
    2114:	21 fd       	sbrc	r18, 1
    2116:	03 c0       	rjmp	.+6      	; 0x211e <fputc+0x16>
    2118:	8f ef       	ldi	r24, 0xFF	; 255
    211a:	9f ef       	ldi	r25, 0xFF	; 255
    211c:	2c c0       	rjmp	.+88     	; 0x2176 <fputc+0x6e>
    211e:	22 ff       	sbrs	r18, 2
    2120:	16 c0       	rjmp	.+44     	; 0x214e <fputc+0x46>
    2122:	46 81       	ldd	r20, Z+6	; 0x06
    2124:	57 81       	ldd	r21, Z+7	; 0x07
    2126:	24 81       	ldd	r18, Z+4	; 0x04
    2128:	35 81       	ldd	r19, Z+5	; 0x05
    212a:	42 17       	cp	r20, r18
    212c:	53 07       	cpc	r21, r19
    212e:	44 f4       	brge	.+16     	; 0x2140 <fputc+0x38>
    2130:	a0 81       	ld	r26, Z
    2132:	b1 81       	ldd	r27, Z+1	; 0x01
    2134:	9d 01       	movw	r18, r26
    2136:	2f 5f       	subi	r18, 0xFF	; 255
    2138:	3f 4f       	sbci	r19, 0xFF	; 255
    213a:	31 83       	std	Z+1, r19	; 0x01
    213c:	20 83       	st	Z, r18
    213e:	8c 93       	st	X, r24
    2140:	26 81       	ldd	r18, Z+6	; 0x06
    2142:	37 81       	ldd	r19, Z+7	; 0x07
    2144:	2f 5f       	subi	r18, 0xFF	; 255
    2146:	3f 4f       	sbci	r19, 0xFF	; 255
    2148:	37 83       	std	Z+7, r19	; 0x07
    214a:	26 83       	std	Z+6, r18	; 0x06
    214c:	14 c0       	rjmp	.+40     	; 0x2176 <fputc+0x6e>
    214e:	8b 01       	movw	r16, r22
    2150:	ec 01       	movw	r28, r24
    2152:	fb 01       	movw	r30, r22
    2154:	00 84       	ldd	r0, Z+8	; 0x08
    2156:	f1 85       	ldd	r31, Z+9	; 0x09
    2158:	e0 2d       	mov	r30, r0
    215a:	09 95       	icall
    215c:	89 2b       	or	r24, r25
    215e:	e1 f6       	brne	.-72     	; 0x2118 <fputc+0x10>
    2160:	d8 01       	movw	r26, r16
    2162:	16 96       	adiw	r26, 0x06	; 6
    2164:	8d 91       	ld	r24, X+
    2166:	9c 91       	ld	r25, X
    2168:	17 97       	sbiw	r26, 0x07	; 7
    216a:	01 96       	adiw	r24, 0x01	; 1
    216c:	17 96       	adiw	r26, 0x07	; 7
    216e:	9c 93       	st	X, r25
    2170:	8e 93       	st	-X, r24
    2172:	16 97       	sbiw	r26, 0x06	; 6
    2174:	ce 01       	movw	r24, r28
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	08 95       	ret

00002180 <__ultoa_invert>:
    2180:	fa 01       	movw	r30, r20
    2182:	aa 27       	eor	r26, r26
    2184:	28 30       	cpi	r18, 0x08	; 8
    2186:	51 f1       	breq	.+84     	; 0x21dc <__ultoa_invert+0x5c>
    2188:	20 31       	cpi	r18, 0x10	; 16
    218a:	81 f1       	breq	.+96     	; 0x21ec <__ultoa_invert+0x6c>
    218c:	e8 94       	clt
    218e:	6f 93       	push	r22
    2190:	6e 7f       	andi	r22, 0xFE	; 254
    2192:	6e 5f       	subi	r22, 0xFE	; 254
    2194:	7f 4f       	sbci	r23, 0xFF	; 255
    2196:	8f 4f       	sbci	r24, 0xFF	; 255
    2198:	9f 4f       	sbci	r25, 0xFF	; 255
    219a:	af 4f       	sbci	r26, 0xFF	; 255
    219c:	b1 e0       	ldi	r27, 0x01	; 1
    219e:	3e d0       	rcall	.+124    	; 0x221c <__ultoa_invert+0x9c>
    21a0:	b4 e0       	ldi	r27, 0x04	; 4
    21a2:	3c d0       	rcall	.+120    	; 0x221c <__ultoa_invert+0x9c>
    21a4:	67 0f       	add	r22, r23
    21a6:	78 1f       	adc	r23, r24
    21a8:	89 1f       	adc	r24, r25
    21aa:	9a 1f       	adc	r25, r26
    21ac:	a1 1d       	adc	r26, r1
    21ae:	68 0f       	add	r22, r24
    21b0:	79 1f       	adc	r23, r25
    21b2:	8a 1f       	adc	r24, r26
    21b4:	91 1d       	adc	r25, r1
    21b6:	a1 1d       	adc	r26, r1
    21b8:	6a 0f       	add	r22, r26
    21ba:	71 1d       	adc	r23, r1
    21bc:	81 1d       	adc	r24, r1
    21be:	91 1d       	adc	r25, r1
    21c0:	a1 1d       	adc	r26, r1
    21c2:	20 d0       	rcall	.+64     	; 0x2204 <__ultoa_invert+0x84>
    21c4:	09 f4       	brne	.+2      	; 0x21c8 <__ultoa_invert+0x48>
    21c6:	68 94       	set
    21c8:	3f 91       	pop	r19
    21ca:	2a e0       	ldi	r18, 0x0A	; 10
    21cc:	26 9f       	mul	r18, r22
    21ce:	11 24       	eor	r1, r1
    21d0:	30 19       	sub	r19, r0
    21d2:	30 5d       	subi	r19, 0xD0	; 208
    21d4:	31 93       	st	Z+, r19
    21d6:	de f6       	brtc	.-74     	; 0x218e <__ultoa_invert+0xe>
    21d8:	cf 01       	movw	r24, r30
    21da:	08 95       	ret
    21dc:	46 2f       	mov	r20, r22
    21de:	47 70       	andi	r20, 0x07	; 7
    21e0:	40 5d       	subi	r20, 0xD0	; 208
    21e2:	41 93       	st	Z+, r20
    21e4:	b3 e0       	ldi	r27, 0x03	; 3
    21e6:	0f d0       	rcall	.+30     	; 0x2206 <__ultoa_invert+0x86>
    21e8:	c9 f7       	brne	.-14     	; 0x21dc <__ultoa_invert+0x5c>
    21ea:	f6 cf       	rjmp	.-20     	; 0x21d8 <__ultoa_invert+0x58>
    21ec:	46 2f       	mov	r20, r22
    21ee:	4f 70       	andi	r20, 0x0F	; 15
    21f0:	40 5d       	subi	r20, 0xD0	; 208
    21f2:	4a 33       	cpi	r20, 0x3A	; 58
    21f4:	18 f0       	brcs	.+6      	; 0x21fc <__ultoa_invert+0x7c>
    21f6:	49 5d       	subi	r20, 0xD9	; 217
    21f8:	31 fd       	sbrc	r19, 1
    21fa:	40 52       	subi	r20, 0x20	; 32
    21fc:	41 93       	st	Z+, r20
    21fe:	02 d0       	rcall	.+4      	; 0x2204 <__ultoa_invert+0x84>
    2200:	a9 f7       	brne	.-22     	; 0x21ec <__ultoa_invert+0x6c>
    2202:	ea cf       	rjmp	.-44     	; 0x21d8 <__ultoa_invert+0x58>
    2204:	b4 e0       	ldi	r27, 0x04	; 4
    2206:	a6 95       	lsr	r26
    2208:	97 95       	ror	r25
    220a:	87 95       	ror	r24
    220c:	77 95       	ror	r23
    220e:	67 95       	ror	r22
    2210:	ba 95       	dec	r27
    2212:	c9 f7       	brne	.-14     	; 0x2206 <__ultoa_invert+0x86>
    2214:	00 97       	sbiw	r24, 0x00	; 0
    2216:	61 05       	cpc	r22, r1
    2218:	71 05       	cpc	r23, r1
    221a:	08 95       	ret
    221c:	9b 01       	movw	r18, r22
    221e:	ac 01       	movw	r20, r24
    2220:	0a 2e       	mov	r0, r26
    2222:	06 94       	lsr	r0
    2224:	57 95       	ror	r21
    2226:	47 95       	ror	r20
    2228:	37 95       	ror	r19
    222a:	27 95       	ror	r18
    222c:	ba 95       	dec	r27
    222e:	c9 f7       	brne	.-14     	; 0x2222 <__ultoa_invert+0xa2>
    2230:	62 0f       	add	r22, r18
    2232:	73 1f       	adc	r23, r19
    2234:	84 1f       	adc	r24, r20
    2236:	95 1f       	adc	r25, r21
    2238:	a0 1d       	adc	r26, r0
    223a:	08 95       	ret

0000223c <eeprom_read_word>:
    223c:	a8 e1       	ldi	r26, 0x18	; 24
    223e:	b0 e0       	ldi	r27, 0x00	; 0
    2240:	42 e0       	ldi	r20, 0x02	; 2
    2242:	50 e0       	ldi	r21, 0x00	; 0
    2244:	02 c0       	rjmp	.+4      	; 0x224a <eeprom_read_blraw>

00002246 <eeprom_read_block>:
    2246:	dc 01       	movw	r26, r24
    2248:	cb 01       	movw	r24, r22

0000224a <eeprom_read_blraw>:
    224a:	fc 01       	movw	r30, r24
    224c:	f9 99       	sbic	0x1f, 1	; 31
    224e:	fe cf       	rjmp	.-4      	; 0x224c <eeprom_read_blraw+0x2>
    2250:	06 c0       	rjmp	.+12     	; 0x225e <eeprom_read_blraw+0x14>
    2252:	f2 bd       	out	0x22, r31	; 34
    2254:	e1 bd       	out	0x21, r30	; 33
    2256:	f8 9a       	sbi	0x1f, 0	; 31
    2258:	31 96       	adiw	r30, 0x01	; 1
    225a:	00 b4       	in	r0, 0x20	; 32
    225c:	0d 92       	st	X+, r0
    225e:	41 50       	subi	r20, 0x01	; 1
    2260:	50 40       	sbci	r21, 0x00	; 0
    2262:	b8 f7       	brcc	.-18     	; 0x2252 <eeprom_read_blraw+0x8>
    2264:	08 95       	ret

00002266 <_exit>:
    2266:	f8 94       	cli

00002268 <__stop_program>:
    2268:	ff cf       	rjmp	.-2      	; 0x2268 <__stop_program>
