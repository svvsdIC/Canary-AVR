
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ea  00800100  00002312  000023a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002312  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005ec  008001ea  008001ea  00002490  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002490  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000024ec  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000300  00000000  00000000  00002530  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004e80  00000000  00000000  00002830  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001863  00000000  00000000  000076b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023a1  00000000  00000000  00008f13  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009f8  00000000  00000000  0000b2b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001090  00000000  00000000  0000bcac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003a6d  00000000  00000000  0000cd3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000238  00000000  00000000  000107a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8e c0       	rjmp	.+284    	; 0x11e <__ctors_end>
       2:	00 00       	nop
       4:	a9 c0       	rjmp	.+338    	; 0x158 <__bad_interrupt>
       6:	00 00       	nop
       8:	a7 c0       	rjmp	.+334    	; 0x158 <__bad_interrupt>
       a:	00 00       	nop
       c:	a5 c0       	rjmp	.+330    	; 0x158 <__bad_interrupt>
       e:	00 00       	nop
      10:	a3 c0       	rjmp	.+326    	; 0x158 <__bad_interrupt>
      12:	00 00       	nop
      14:	a1 c0       	rjmp	.+322    	; 0x158 <__bad_interrupt>
      16:	00 00       	nop
      18:	9f c0       	rjmp	.+318    	; 0x158 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9d c0       	rjmp	.+314    	; 0x158 <__bad_interrupt>
      1e:	00 00       	nop
      20:	9b c0       	rjmp	.+310    	; 0x158 <__bad_interrupt>
      22:	00 00       	nop
      24:	99 c0       	rjmp	.+306    	; 0x158 <__bad_interrupt>
      26:	00 00       	nop
      28:	97 c0       	rjmp	.+302    	; 0x158 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	95 c0       	rjmp	.+298    	; 0x158 <__bad_interrupt>
      2e:	00 00       	nop
      30:	93 c0       	rjmp	.+294    	; 0x158 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 60 0b 	jmp	0x16c0	; 0x16c0 <__vector_13>
      38:	8f c0       	rjmp	.+286    	; 0x158 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8d c0       	rjmp	.+282    	; 0x158 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <__vector_16>
      44:	89 c0       	rjmp	.+274    	; 0x158 <__bad_interrupt>
      46:	00 00       	nop
      48:	87 c0       	rjmp	.+270    	; 0x158 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	85 c0       	rjmp	.+266    	; 0x158 <__bad_interrupt>
      4e:	00 00       	nop
      50:	83 c0       	rjmp	.+262    	; 0x158 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 99 0c 	jmp	0x1932	; 0x1932 <__vector_21>
      58:	7f c0       	rjmp	.+254    	; 0x158 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7d c0       	rjmp	.+250    	; 0x158 <__bad_interrupt>
      5e:	00 00       	nop
      60:	7b c0       	rjmp	.+246    	; 0x158 <__bad_interrupt>
      62:	00 00       	nop
      64:	79 c0       	rjmp	.+242    	; 0x158 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 ce 0b 	jmp	0x179c	; 0x179c <__vector_26>
      6c:	75 c0       	rjmp	.+234    	; 0x158 <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__vector_28>
      74:	0c 94 1d 0d 	jmp	0x1a3a	; 0x1a3a <__vector_29>
      78:	6f c0       	rjmp	.+222    	; 0x158 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e8 0b       	sbc	r30, r24
      7e:	3a 0c       	add	r3, r10
      80:	3a 0c       	add	r3, r10
      82:	3a 0c       	add	r3, r10
      84:	3a 0c       	add	r3, r10
      86:	3a 0c       	add	r3, r10
      88:	3a 0c       	add	r3, r10
      8a:	3a 0c       	add	r3, r10
      8c:	e8 0b       	sbc	r30, r24
      8e:	3a 0c       	add	r3, r10
      90:	3a 0c       	add	r3, r10
      92:	3a 0c       	add	r3, r10
      94:	3a 0c       	add	r3, r10
      96:	3a 0c       	add	r3, r10
      98:	3a 0c       	add	r3, r10
      9a:	3a 0c       	add	r3, r10
      9c:	ea 0b       	sbc	r30, r26
      9e:	3a 0c       	add	r3, r10
      a0:	3a 0c       	add	r3, r10
      a2:	3a 0c       	add	r3, r10
      a4:	3a 0c       	add	r3, r10
      a6:	3a 0c       	add	r3, r10
      a8:	3a 0c       	add	r3, r10
      aa:	3a 0c       	add	r3, r10
      ac:	3a 0c       	add	r3, r10
      ae:	3a 0c       	add	r3, r10
      b0:	3a 0c       	add	r3, r10
      b2:	3a 0c       	add	r3, r10
      b4:	3a 0c       	add	r3, r10
      b6:	3a 0c       	add	r3, r10
      b8:	3a 0c       	add	r3, r10
      ba:	3a 0c       	add	r3, r10
      bc:	ea 0b       	sbc	r30, r26
      be:	3a 0c       	add	r3, r10
      c0:	3a 0c       	add	r3, r10
      c2:	3a 0c       	add	r3, r10
      c4:	3a 0c       	add	r3, r10
      c6:	3a 0c       	add	r3, r10
      c8:	3a 0c       	add	r3, r10
      ca:	3a 0c       	add	r3, r10
      cc:	3a 0c       	add	r3, r10
      ce:	3a 0c       	add	r3, r10
      d0:	3a 0c       	add	r3, r10
      d2:	3a 0c       	add	r3, r10
      d4:	3a 0c       	add	r3, r10
      d6:	3a 0c       	add	r3, r10
      d8:	3a 0c       	add	r3, r10
      da:	3a 0c       	add	r3, r10
      dc:	36 0c       	add	r3, r6
      de:	3a 0c       	add	r3, r10
      e0:	3a 0c       	add	r3, r10
      e2:	3a 0c       	add	r3, r10
      e4:	3a 0c       	add	r3, r10
      e6:	3a 0c       	add	r3, r10
      e8:	3a 0c       	add	r3, r10
      ea:	3a 0c       	add	r3, r10
      ec:	13 0c       	add	r1, r3
      ee:	3a 0c       	add	r3, r10
      f0:	3a 0c       	add	r3, r10
      f2:	3a 0c       	add	r3, r10
      f4:	3a 0c       	add	r3, r10
      f6:	3a 0c       	add	r3, r10
      f8:	3a 0c       	add	r3, r10
      fa:	3a 0c       	add	r3, r10
      fc:	3a 0c       	add	r3, r10
      fe:	3a 0c       	add	r3, r10
     100:	3a 0c       	add	r3, r10
     102:	3a 0c       	add	r3, r10
     104:	3a 0c       	add	r3, r10
     106:	3a 0c       	add	r3, r10
     108:	3a 0c       	add	r3, r10
     10a:	3a 0c       	add	r3, r10
     10c:	07 0c       	add	r0, r7
     10e:	3a 0c       	add	r3, r10
     110:	3a 0c       	add	r3, r10
     112:	3a 0c       	add	r3, r10
     114:	3a 0c       	add	r3, r10
     116:	3a 0c       	add	r3, r10
     118:	3a 0c       	add	r3, r10
     11a:	3a 0c       	add	r3, r10
     11c:	25 0c       	add	r2, r5

0000011e <__ctors_end>:
     11e:	11 24       	eor	r1, r1
     120:	1f be       	out	0x3f, r1	; 63
     122:	cf ef       	ldi	r28, 0xFF	; 255
     124:	d8 e0       	ldi	r29, 0x08	; 8
     126:	de bf       	out	0x3e, r29	; 62
     128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
     12a:	11 e0       	ldi	r17, 0x01	; 1
     12c:	a0 e0       	ldi	r26, 0x00	; 0
     12e:	b1 e0       	ldi	r27, 0x01	; 1
     130:	e2 e1       	ldi	r30, 0x12	; 18
     132:	f3 e2       	ldi	r31, 0x23	; 35
     134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
     136:	05 90       	lpm	r0, Z+
     138:	0d 92       	st	X+, r0
     13a:	aa 3e       	cpi	r26, 0xEA	; 234
     13c:	b1 07       	cpc	r27, r17
     13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
     140:	27 e0       	ldi	r18, 0x07	; 7
     142:	aa ee       	ldi	r26, 0xEA	; 234
     144:	b1 e0       	ldi	r27, 0x01	; 1
     146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
     148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
     14a:	a6 3d       	cpi	r26, 0xD6	; 214
     14c:	b2 07       	cpc	r27, r18
     14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
     150:	0e 94 2a 0a 	call	0x1454	; 0x1454 <main>
     154:	0c 94 87 11 	jmp	0x230e	; 0x230e <_exit>

00000158 <__bad_interrupt>:
     158:	53 cf       	rjmp	.-346    	; 0x0 <__vectors>

0000015a <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     15a:	ec e7       	ldi	r30, 0x7C	; 124
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	90 81       	ld	r25, Z
     160:	90 7e       	andi	r25, 0xE0	; 224
     162:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     164:	90 81       	ld	r25, Z
     166:	89 2b       	or	r24, r25
     168:	80 83       	st	Z, r24
     16a:	08 95       	ret

0000016c <ADC_init>:
}

void ADC_init(void)
{
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	80 81       	ld	r24, Z
     176:	80 64       	ori	r24, 0x40	; 64
     178:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     17a:	ca e7       	ldi	r28, 0x7A	; 122
     17c:	d0 e0       	ldi	r29, 0x00	; 0
     17e:	88 81       	ld	r24, Y
     180:	81 60       	ori	r24, 0x01	; 1
     182:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     184:	88 81       	ld	r24, Y
     186:	82 60       	ori	r24, 0x02	; 2
     188:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     18a:	88 81       	ld	r24, Y
     18c:	84 60       	ori	r24, 0x04	; 4
     18e:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     190:	a4 e6       	ldi	r26, 0x64	; 100
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	8c 91       	ld	r24, X
     196:	8e 7f       	andi	r24, 0xFE	; 254
     198:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     19a:	80 81       	ld	r24, Z
     19c:	8f 7d       	andi	r24, 0xDF	; 223
     19e:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1a0:	8f e3       	ldi	r24, 0x3F	; 63
     1a2:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1a6:	88 81       	ld	r24, Y
     1a8:	80 68       	ori	r24, 0x80	; 128
     1aa:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1ac:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1b0:	8f e1       	ldi	r24, 0x1F	; 31
     1b2:	d3 df       	rcall	.-90     	; 0x15a <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1b4:	88 81       	ld	r24, Y
     1b6:	80 64       	ori	r24, 0x40	; 64
     1b8:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ba:	ea e7       	ldi	r30, 0x7A	; 122
     1bc:	f0 e0       	ldi	r31, 0x00	; 0
     1be:	80 81       	ld	r24, Z
     1c0:	84 ff       	sbrs	r24, 4
     1c2:	fd cf       	rjmp	.-6      	; 0x1be <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1c4:	ea e7       	ldi	r30, 0x7A	; 122
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	80 81       	ld	r24, Z
     1ca:	80 64       	ori	r24, 0x40	; 64
     1cc:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ce:	80 81       	ld	r24, Z
     1d0:	84 ff       	sbrs	r24, 4
     1d2:	fd cf       	rjmp	.-6      	; 0x1ce <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1d4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <__data_end+0x1>
     1de:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1e2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1e6:	20 91 ea 01 	lds	r18, 0x01EA	; 0x8001ea <__data_end>
     1ea:	30 91 eb 01 	lds	r19, 0x01EB	; 0x8001eb <__data_end+0x1>
     1ee:	89 2f       	mov	r24, r25
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	98 2f       	mov	r25, r24
     1f4:	88 27       	eor	r24, r24
     1f6:	82 0f       	add	r24, r18
     1f8:	93 1f       	adc	r25, r19
     1fa:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <__data_end+0x1>
     1fe:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     202:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <__data_end>
     206:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <__data_end+0x1>
     20a:	99 23       	and	r25, r25
     20c:	1c f4       	brge	.+6      	; 0x214 <ADC_init+0xa8>
     20e:	91 95       	neg	r25
     210:	81 95       	neg	r24
     212:	91 09       	sbc	r25, r1
     214:	05 97       	sbiw	r24, 0x05	; 5
     216:	2c f0       	brlt	.+10     	; 0x222 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     218:	80 91 49 04 	lds	r24, 0x0449	; 0x800449 <gas_sensor_initialization_errors>
     21c:	81 60       	ori	r24, 0x01	; 1
     21e:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     222:	8e e1       	ldi	r24, 0x1E	; 30
     224:	9a df       	rcall	.-204    	; 0x15a <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     226:	ea e7       	ldi	r30, 0x7A	; 122
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	80 81       	ld	r24, Z
     22c:	80 64       	ori	r24, 0x40	; 64
     22e:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     230:	80 81       	ld	r24, Z
     232:	84 ff       	sbrs	r24, 4
     234:	fd cf       	rjmp	.-6      	; 0x230 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     236:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <__data_end+0x1>
     240:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     244:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     248:	20 91 ea 01 	lds	r18, 0x01EA	; 0x8001ea <__data_end>
     24c:	30 91 eb 01 	lds	r19, 0x01EB	; 0x8001eb <__data_end+0x1>
     250:	89 2f       	mov	r24, r25
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	98 2f       	mov	r25, r24
     256:	88 27       	eor	r24, r24
     258:	82 0f       	add	r24, r18
     25a:	93 1f       	adc	r25, r19
     25c:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <__data_end+0x1>
     260:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     264:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <__data_end>
     268:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <__data_end+0x1>
     26c:	81 5e       	subi	r24, 0xE1	; 225
     26e:	91 09       	sbc	r25, r1
     270:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <__data_end+0x1>
     274:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     278:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <__data_end>
     27c:	90 91 eb 01 	lds	r25, 0x01EB	; 0x8001eb <__data_end+0x1>
     280:	99 23       	and	r25, r25
     282:	1c f4       	brge	.+6      	; 0x28a <ADC_init+0x11e>
     284:	91 95       	neg	r25
     286:	81 95       	neg	r24
     288:	91 09       	sbc	r25, r1
     28a:	05 97       	sbiw	r24, 0x05	; 5
     28c:	2c f0       	brlt	.+10     	; 0x298 <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     28e:	80 91 49 04 	lds	r24, 0x0449	; 0x800449 <gas_sensor_initialization_errors>
     292:	82 60       	ori	r24, 0x02	; 2
     294:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     298:	ea e7       	ldi	r30, 0x7A	; 122
     29a:	f0 e0       	ldi	r31, 0x00	; 0
     29c:	80 81       	ld	r24, Z
     29e:	8f 77       	andi	r24, 0x7F	; 127
     2a0:	80 83       	st	Z, r24
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	08 95       	ret

000002a8 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2a8:	87 e0       	ldi	r24, 0x07	; 7
     2aa:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2ac:	85 b1       	in	r24, 0x05	; 5
     2ae:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2b0:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2b2:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2b4:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2b6:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2b8:	41 9a       	sbi	0x08, 1	; 8
     2ba:	08 95       	ret

000002bc <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2c0:	2f ef       	ldi	r18, 0xFF	; 255
     2c2:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2c4:	fc 01       	movw	r30, r24
     2c6:	ee 0f       	add	r30, r30
     2c8:	ff 1f       	adc	r31, r31
     2ca:	ee 0f       	add	r30, r30
     2cc:	ff 1f       	adc	r31, r31
     2ce:	e1 5e       	subi	r30, 0xE1	; 225
     2d0:	fb 4f       	sbci	r31, 0xFB	; 251
     2d2:	11 82       	std	Z+1, r1	; 0x01
     2d4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2d6:	33 83       	std	Z+3, r19	; 0x03
     2d8:	22 83       	std	Z+2, r18	; 0x02
     2da:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2dc:	85 30       	cpi	r24, 0x05	; 5
     2de:	91 05       	cpc	r25, r1
     2e0:	89 f7       	brne	.-30     	; 0x2c4 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2e2:	08 95       	ret

000002e4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2e4:	ef 92       	push	r14
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	0f 2e       	mov	r0, r31
     2f2:	f9 e0       	ldi	r31, 0x09	; 9
     2f4:	ef 2e       	mov	r14, r31
     2f6:	f4 e0       	ldi	r31, 0x04	; 4
     2f8:	ff 2e       	mov	r15, r31
     2fa:	f0 2d       	mov	r31, r0
     2fc:	00 e0       	ldi	r16, 0x00	; 0
     2fe:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     300:	c7 01       	movw	r24, r14
     302:	0e 94 72 11 	call	0x22e4	; 0x22e4 <eeprom_read_word>
     306:	e8 01       	movw	r28, r16
     308:	cc 0f       	add	r28, r28
     30a:	dd 1f       	adc	r29, r29
     30c:	cc 0f       	add	r28, r28
     30e:	dd 1f       	adc	r29, r29
     310:	c1 5e       	subi	r28, 0xE1	; 225
     312:	db 4f       	sbci	r29, 0xFB	; 251
     314:	99 83       	std	Y+1, r25	; 0x01
     316:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     318:	c7 01       	movw	r24, r14
     31a:	02 96       	adiw	r24, 0x02	; 2
     31c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <eeprom_read_word>
     320:	9b 83       	std	Y+3, r25	; 0x03
     322:	8a 83       	std	Y+2, r24	; 0x02
     324:	0f 5f       	subi	r16, 0xFF	; 255
     326:	1f 4f       	sbci	r17, 0xFF	; 255
     328:	84 e0       	ldi	r24, 0x04	; 4
     32a:	e8 0e       	add	r14, r24
     32c:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     32e:	05 30       	cpi	r16, 0x05	; 5
     330:	11 05       	cpc	r17, r1
     332:	31 f7       	brne	.-52     	; 0x300 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     334:	df 91       	pop	r29
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	08 95       	ret

00000342 <gas_sensors_init>:

void gas_sensors_init(void)
{
     342:	af 92       	push	r10
     344:	bf 92       	push	r11
     346:	cf 92       	push	r12
     348:	df 92       	push	r13
     34a:	ef 92       	push	r14
     34c:	ff 92       	push	r15
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	1f 92       	push	r1
     358:	cd b7       	in	r28, 0x3d	; 61
     35a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     35c:	10 92 49 04 	sts	0x0449, r1	; 0x800449 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     360:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     364:	bf df       	rcall	.-130    	; 0x2e4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     366:	aa df       	rcall	.-172    	; 0x2bc <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     368:	ea e7       	ldi	r30, 0x7A	; 122
     36a:	f0 e0       	ldi	r31, 0x00	; 0
     36c:	80 81       	ld	r24, Z
     36e:	80 68       	ori	r24, 0x80	; 128
     370:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     372:	19 82       	std	Y+1, r1	; 0x01
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	85 30       	cpi	r24, 0x05	; 5
     378:	08 f0       	brcs	.+2      	; 0x37c <gas_sensors_init+0x3a>
     37a:	51 c0       	rjmp	.+162    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     37c:	0a e7       	ldi	r16, 0x7A	; 122
     37e:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     380:	0f 2e       	mov	r0, r31
     382:	f8 e7       	ldi	r31, 0x78	; 120
     384:	ef 2e       	mov	r14, r31
     386:	f1 2c       	mov	r15, r1
     388:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     38a:	bb 24       	eor	r11, r11
     38c:	b3 94       	inc	r11
     38e:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     390:	cc 24       	eor	r12, r12
     392:	c3 94       	inc	r12
     394:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	e0 de       	rcall	.-576    	; 0x15a <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
     39a:	f8 01       	movw	r30, r16
     39c:	80 81       	ld	r24, Z
     39e:	80 64       	ori	r24, 0x40	; 64
     3a0:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
     3a2:	f8 01       	movw	r30, r16
     3a4:	80 81       	ld	r24, Z
     3a6:	84 ff       	sbrs	r24, 4
     3a8:	fc cf       	rjmp	.-8      	; 0x3a2 <gas_sensors_init+0x60>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3aa:	f7 01       	movw	r30, r14
     3ac:	80 81       	ld	r24, Z
     3ae:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3b0:	e9 81       	ldd	r30, Y+1	; 0x01
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	ee 0f       	add	r30, r30
     3b6:	ff 1f       	adc	r31, r31
     3b8:	ee 0f       	add	r30, r30
     3ba:	ff 1f       	adc	r31, r31
     3bc:	e1 5e       	subi	r30, 0xE1	; 225
     3be:	fb 4f       	sbci	r31, 0xFB	; 251
     3c0:	20 81       	ld	r18, Z
     3c2:	31 81       	ldd	r19, Z+1	; 0x01
     3c4:	e9 81       	ldd	r30, Y+1	; 0x01
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	ee 0f       	add	r30, r30
     3ca:	ff 1f       	adc	r31, r31
     3cc:	ee 0f       	add	r30, r30
     3ce:	ff 1f       	adc	r31, r31
     3d0:	e1 5e       	subi	r30, 0xE1	; 225
     3d2:	fb 4f       	sbci	r31, 0xFB	; 251
     3d4:	62 81       	ldd	r22, Z+2	; 0x02
     3d6:	73 81       	ldd	r23, Z+3	; 0x03
     3d8:	4b 2d       	mov	r20, r11
     3da:	68 17       	cp	r22, r24
     3dc:	79 07       	cpc	r23, r25
     3de:	08 f0       	brcs	.+2      	; 0x3e2 <gas_sensors_init+0xa0>
     3e0:	4a 2d       	mov	r20, r10
     3e2:	41 11       	cpse	r20, r1
     3e4:	07 c0       	rjmp	.+14     	; 0x3f4 <gas_sensors_init+0xb2>
     3e6:	4b 2d       	mov	r20, r11
     3e8:	82 17       	cp	r24, r18
     3ea:	93 07       	cpc	r25, r19
     3ec:	08 f0       	brcs	.+2      	; 0x3f0 <gas_sensors_init+0xae>
     3ee:	4a 2d       	mov	r20, r10
     3f0:	44 23       	and	r20, r20
     3f2:	71 f0       	breq	.+28     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3f4:	99 81       	ldd	r25, Y+1	; 0x01
     3f6:	20 91 49 04 	lds	r18, 0x0449	; 0x800449 <gas_sensor_initialization_errors>
     3fa:	9d 5f       	subi	r25, 0xFD	; 253
     3fc:	a6 01       	movw	r20, r12
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     400:	44 0f       	add	r20, r20
     402:	55 1f       	adc	r21, r21
     404:	9a 95       	dec	r25
     406:	e2 f7       	brpl	.-8      	; 0x400 <__LOCK_REGION_LENGTH__>
     408:	ca 01       	movw	r24, r20
     40a:	82 2b       	or	r24, r18
     40c:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     410:	89 81       	ldd	r24, Y+1	; 0x01
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	89 83       	std	Y+1, r24	; 0x01
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	85 30       	cpi	r24, 0x05	; 5
     41a:	08 f4       	brcc	.+2      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     41c:	bc cf       	rjmp	.-136    	; 0x396 <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     41e:	ea e7       	ldi	r30, 0x7A	; 122
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	8f 77       	andi	r24, 0x7F	; 127
     426:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     428:	0f 90       	pop	r0
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	08 95       	ret

00000440 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
     440:	8f 92       	push	r8
     442:	9f 92       	push	r9
     444:	af 92       	push	r10
     446:	bf 92       	push	r11
     448:	cf 92       	push	r12
     44a:	df 92       	push	r13
     44c:	ef 92       	push	r14
     44e:	ff 92       	push	r15
     450:	0f 93       	push	r16
     452:	1f 93       	push	r17
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	00 d0       	rcall	.+0      	; 0x45a <start_gas_sensor_read+0x1a>
     45a:	1f 92       	push	r1
     45c:	cd b7       	in	r28, 0x3d	; 61
     45e:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     460:	ea e7       	ldi	r30, 0x7A	; 122
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	80 81       	ld	r24, Z
     466:	80 68       	ori	r24, 0x80	; 128
     468:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     46a:	19 82       	std	Y+1, r1	; 0x01
     46c:	89 81       	ldd	r24, Y+1	; 0x01
     46e:	85 30       	cpi	r24, 0x05	; 5
     470:	08 f0       	brcs	.+2      	; 0x474 <start_gas_sensor_read+0x34>
     472:	76 c0       	rjmp	.+236    	; 0x560 <start_gas_sensor_read+0x120>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
     474:	68 94       	set
     476:	88 24       	eor	r8, r8
     478:	82 f8       	bld	r8, 2
     47a:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     47c:	0a e7       	ldi	r16, 0x7A	; 122
     47e:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     480:	0f 2e       	mov	r0, r31
     482:	f8 e7       	ldi	r31, 0x78	; 120
     484:	ef 2e       	mov	r14, r31
     486:	f1 2c       	mov	r15, r1
     488:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     48a:	cc 24       	eor	r12, r12
     48c:	c3 94       	inc	r12
     48e:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     490:	bb 24       	eor	r11, r11
     492:	b3 94       	inc	r11
     494:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     496:	89 81       	ldd	r24, Y+1	; 0x01
     498:	60 de       	rcall	.-832    	; 0x15a <ADC_SetMux>
		total = 0;	// re-zero the average
     49a:	1b 82       	std	Y+3, r1	; 0x03
     49c:	1a 82       	std	Y+2, r1	; 0x02
     49e:	28 2d       	mov	r18, r8
     4a0:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4a2:	f8 01       	movw	r30, r16
     4a4:	80 81       	ld	r24, Z
     4a6:	80 64       	ori	r24, 0x40	; 64
     4a8:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4aa:	f8 01       	movw	r30, r16
     4ac:	80 81       	ld	r24, Z
     4ae:	84 ff       	sbrs	r24, 4
     4b0:	fc cf       	rjmp	.-8      	; 0x4aa <start_gas_sensor_read+0x6a>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4b2:	f7 01       	movw	r30, r14
     4b4:	80 81       	ld	r24, Z
     4b6:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4b8:	e9 81       	ldd	r30, Y+1	; 0x01
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	ee 0f       	add	r30, r30
     4c2:	ff 1f       	adc	r31, r31
     4c4:	e1 5e       	subi	r30, 0xE1	; 225
     4c6:	fb 4f       	sbci	r31, 0xFB	; 251
     4c8:	40 81       	ld	r20, Z
     4ca:	51 81       	ldd	r21, Z+1	; 0x01
     4cc:	e9 81       	ldd	r30, Y+1	; 0x01
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	e1 5e       	subi	r30, 0xE1	; 225
     4da:	fb 4f       	sbci	r31, 0xFB	; 251
     4dc:	62 81       	ldd	r22, Z+2	; 0x02
     4de:	73 81       	ldd	r23, Z+3	; 0x03
     4e0:	eb 2d       	mov	r30, r11
     4e2:	68 17       	cp	r22, r24
     4e4:	79 07       	cpc	r23, r25
     4e6:	08 f0       	brcs	.+2      	; 0x4ea <start_gas_sensor_read+0xaa>
     4e8:	ea 2d       	mov	r30, r10
     4ea:	e1 11       	cpse	r30, r1
     4ec:	07 c0       	rjmp	.+14     	; 0x4fc <start_gas_sensor_read+0xbc>
     4ee:	6b 2d       	mov	r22, r11
     4f0:	84 17       	cp	r24, r20
     4f2:	95 07       	cpc	r25, r21
     4f4:	08 f0       	brcs	.+2      	; 0x4f8 <start_gas_sensor_read+0xb8>
     4f6:	6a 2d       	mov	r22, r10
     4f8:	66 23       	and	r22, r22
     4fa:	71 f0       	breq	.+28     	; 0x518 <start_gas_sensor_read+0xd8>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     4fc:	59 81       	ldd	r21, Y+1	; 0x01
     4fe:	60 91 49 04 	lds	r22, 0x0449	; 0x800449 <gas_sensor_initialization_errors>
     502:	5d 5f       	subi	r21, 0xFD	; 253
     504:	f6 01       	movw	r30, r12
     506:	02 c0       	rjmp	.+4      	; 0x50c <start_gas_sensor_read+0xcc>
     508:	ee 0f       	add	r30, r30
     50a:	ff 1f       	adc	r31, r31
     50c:	5a 95       	dec	r21
     50e:	e2 f7       	brpl	.-8      	; 0x508 <start_gas_sensor_read+0xc8>
     510:	af 01       	movw	r20, r30
     512:	46 2b       	or	r20, r22
     514:	40 93 49 04 	sts	0x0449, r20	; 0x800449 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     518:	4a 81       	ldd	r20, Y+2	; 0x02
     51a:	5b 81       	ldd	r21, Y+3	; 0x03
     51c:	84 0f       	add	r24, r20
     51e:	95 1f       	adc	r25, r21
     520:	9b 83       	std	Y+3, r25	; 0x03
     522:	8a 83       	std	Y+2, r24	; 0x02
     524:	21 50       	subi	r18, 0x01	; 1
     526:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
     528:	09 f0       	breq	.+2      	; 0x52c <start_gas_sensor_read+0xec>
     52a:	bb cf       	rjmp	.-138    	; 0x4a2 <start_gas_sensor_read+0x62>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     52c:	8a 81       	ldd	r24, Y+2	; 0x02
     52e:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     530:	e9 81       	ldd	r30, Y+1	; 0x01
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	e3 5c       	subi	r30, 0xC3	; 195
     53a:	fb 4f       	sbci	r31, 0xFB	; 251
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     53c:	9c 01       	movw	r18, r24
     53e:	99 23       	and	r25, r25
     540:	14 f4       	brge	.+4      	; 0x546 <start_gas_sensor_read+0x106>
     542:	2d 5f       	subi	r18, 0xFD	; 253
     544:	3f 4f       	sbci	r19, 0xFF	; 255
     546:	35 95       	asr	r19
     548:	27 95       	ror	r18
     54a:	35 95       	asr	r19
     54c:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
     54e:	31 83       	std	Z+1, r19	; 0x01
     550:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     552:	89 81       	ldd	r24, Y+1	; 0x01
     554:	8f 5f       	subi	r24, 0xFF	; 255
     556:	89 83       	std	Y+1, r24	; 0x01
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	85 30       	cpi	r24, 0x05	; 5
     55c:	08 f4       	brcc	.+2      	; 0x560 <start_gas_sensor_read+0x120>
     55e:	9b cf       	rjmp	.-202    	; 0x496 <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	1f 91       	pop	r17
     56c:	0f 91       	pop	r16
     56e:	ff 90       	pop	r15
     570:	ef 90       	pop	r14
     572:	df 90       	pop	r13
     574:	cf 90       	pop	r12
     576:	bf 90       	pop	r11
     578:	af 90       	pop	r10
     57a:	9f 90       	pop	r9
     57c:	8f 90       	pop	r8
     57e:	08 95       	ret

00000580 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     580:	1f 93       	push	r17
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     586:	e0 e5       	ldi	r30, 0x50	; 80
     588:	f4 e0       	ldi	r31, 0x04	; 4
     58a:	84 ec       	ldi	r24, 0xC4	; 196
     58c:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     58e:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     590:	84 e0       	ldi	r24, 0x04	; 4
     592:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     594:	63 e0       	ldi	r22, 0x03	; 3
     596:	cf 01       	movw	r24, r30
     598:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     59c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     5a0:	81 11       	cpse	r24, r1
     5a2:	fc cf       	rjmp	.-8      	; 0x59c <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5a4:	e0 e5       	ldi	r30, 0x50	; 80
     5a6:	f4 e0       	ldi	r31, 0x04	; 4
     5a8:	84 ec       	ldi	r24, 0xC4	; 196
     5aa:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b0:	62 e0       	ldi	r22, 0x02	; 2
     5b2:	cf 01       	movw	r24, r30
     5b4:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5b8:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     5bc:	81 11       	cpse	r24, r1
     5be:	fc cf       	rjmp	.-8      	; 0x5b8 <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5c0:	c0 e5       	ldi	r28, 0x50	; 80
     5c2:	d4 e0       	ldi	r29, 0x04	; 4
     5c4:	15 ec       	ldi	r17, 0xC5	; 197
     5c6:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5c8:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5ca:	62 e0       	ldi	r22, 0x02	; 2
     5cc:	ce 01       	movw	r24, r28
     5ce:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5d2:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     5d6:	81 11       	cpse	r24, r1
     5d8:	fc cf       	rjmp	.-8      	; 0x5d2 <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5da:	62 e0       	ldi	r22, 0x02	; 2
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 af 0b 	call	0x175e	; 0x175e <TWI_Get_Data_From_Transceiver>
     5e2:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5e6:	89 81       	ldd	r24, Y+1	; 0x01
     5e8:	80 93 61 05 	sts	0x0561, r24	; 0x800561 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5ec:	80 fd       	sbrc	r24, 0
     5ee:	eb cf       	rjmp	.-42     	; 0x5c6 <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5f0:	e0 e5       	ldi	r30, 0x50	; 80
     5f2:	f4 e0       	ldi	r31, 0x04	; 4
     5f4:	84 ec       	ldi	r24, 0xC4	; 196
     5f6:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     5f8:	8f e8       	ldi	r24, 0x8F	; 143
     5fa:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5fc:	62 e0       	ldi	r22, 0x02	; 2
     5fe:	cf 01       	movw	r24, r30
     600:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     604:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     608:	81 11       	cpse	r24, r1
     60a:	fc cf       	rjmp	.-8      	; 0x604 <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     60c:	e0 e5       	ldi	r30, 0x50	; 80
     60e:	f4 e0       	ldi	r31, 0x04	; 4
     610:	85 ec       	ldi	r24, 0xC5	; 197
     612:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     614:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     616:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     618:	63 e0       	ldi	r22, 0x03	; 3
     61a:	cf 01       	movw	r24, r30
     61c:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     620:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     624:	81 11       	cpse	r24, r1
     626:	fc cf       	rjmp	.-8      	; 0x620 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     628:	63 e0       	ldi	r22, 0x03	; 3
     62a:	80 e5       	ldi	r24, 0x50	; 80
     62c:	94 e0       	ldi	r25, 0x04	; 4
     62e:	0e 94 af 0b 	call	0x175e	; 0x175e <TWI_Get_Data_From_Transceiver>
     632:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     636:	e0 e5       	ldi	r30, 0x50	; 80
     638:	f4 e0       	ldi	r31, 0x04	; 4
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	98 2f       	mov	r25, r24
     640:	88 27       	eor	r24, r24
     642:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
     644:	82 0f       	add	r24, r18
     646:	91 1d       	adc	r25, r1
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret

00000650 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     650:	ff 92       	push	r15
     652:	0f 93       	push	r16
     654:	1f 93       	push	r17
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     65a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     65e:	88 23       	and	r24, r24
     660:	59 f1       	breq	.+86     	; 0x6b8 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     662:	c1 e6       	ldi	r28, 0x61	; 97
     664:	d4 e0       	ldi	r29, 0x04	; 4
     666:	0f 2e       	mov	r0, r31
     668:	fc ee       	ldi	r31, 0xEC	; 236
     66a:	ff 2e       	mov	r15, r31
     66c:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     66e:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     670:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     672:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     674:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     676:	62 e0       	ldi	r22, 0x02	; 2
     678:	ce 01       	movw	r24, r28
     67a:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     67e:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     682:	81 11       	cpse	r24, r1
     684:	fc cf       	rjmp	.-8      	; 0x67e <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     686:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     688:	6a e1       	ldi	r22, 0x1A	; 26
     68a:	ce 01       	movw	r24, r28
     68c:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     690:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     694:	81 11       	cpse	r24, r1
     696:	fc cf       	rjmp	.-8      	; 0x690 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     698:	6a e1       	ldi	r22, 0x1A	; 26
     69a:	ce 01       	movw	r24, r28
     69c:	0e 94 af 0b 	call	0x175e	; 0x175e <TWI_Get_Data_From_Transceiver>
     6a0:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6a4:	89 81       	ldd	r24, Y+1	; 0x01
     6a6:	83 fb       	bst	r24, 3
     6a8:	88 27       	eor	r24, r24
     6aa:	80 f9       	bld	r24, 0
     6ac:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6b0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6b4:	81 11       	cpse	r24, r1
     6b6:	dd cf       	rjmp	.-70     	; 0x672 <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6b8:	e1 e6       	ldi	r30, 0x61	; 97
     6ba:	f4 e0       	ldi	r31, 0x04	; 4
     6bc:	8c ee       	ldi	r24, 0xEC	; 236
     6be:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6c0:	88 e8       	ldi	r24, 0x88	; 136
     6c2:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6c4:	62 e0       	ldi	r22, 0x02	; 2
     6c6:	cf 01       	movw	r24, r30
     6c8:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6cc:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     6d0:	81 11       	cpse	r24, r1
     6d2:	fc cf       	rjmp	.-8      	; 0x6cc <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6d4:	8d ee       	ldi	r24, 0xED	; 237
     6d6:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6da:	6b e1       	ldi	r22, 0x1B	; 27
     6dc:	81 e6       	ldi	r24, 0x61	; 97
     6de:	94 e0       	ldi	r25, 0x04	; 4
     6e0:	0e 94 83 0b 	call	0x1706	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6e4:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <TWI_Transceiver_Busy>
     6e8:	81 11       	cpse	r24, r1
     6ea:	fc cf       	rjmp	.-8      	; 0x6e4 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     6ec:	6b e1       	ldi	r22, 0x1B	; 27
     6ee:	81 e6       	ldi	r24, 0x61	; 97
     6f0:	94 e0       	ldi	r25, 0x04	; 4
     6f2:	0e 94 af 0b 	call	0x175e	; 0x175e <TWI_Get_Data_From_Transceiver>
     6f6:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
     6fa:	e2 e6       	ldi	r30, 0x62	; 98
     6fc:	f4 e0       	ldi	r31, 0x04	; 4
     6fe:	aa e6       	ldi	r26, 0x6A	; 106
     700:	b5 e0       	ldi	r27, 0x05	; 5
     702:	2d e7       	ldi	r18, 0x7D	; 125
     704:	34 e0       	ldi	r19, 0x04	; 4
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     706:	81 91       	ld	r24, Z+
     708:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     70a:	e2 17       	cp	r30, r18
     70c:	f3 07       	cpc	r31, r19
     70e:	d9 f7       	brne	.-10     	; 0x706 <BME_read_correction_coefficients+0xb6>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     710:	ea e6       	ldi	r30, 0x6A	; 106
     712:	f5 e0       	ldi	r31, 0x05	; 5
     714:	81 81       	ldd	r24, Z+1	; 0x01
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	98 2f       	mov	r25, r24
     71a:	88 27       	eor	r24, r24
     71c:	20 81       	ld	r18, Z
     71e:	82 2b       	or	r24, r18
     720:	90 93 65 05 	sts	0x0565, r25	; 0x800565 <dig_T1+0x1>
     724:	80 93 64 05 	sts	0x0564, r24	; 0x800564 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     728:	83 81       	ldd	r24, Z+3	; 0x03
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	98 2f       	mov	r25, r24
     72e:	88 27       	eor	r24, r24
     730:	22 81       	ldd	r18, Z+2	; 0x02
     732:	82 2b       	or	r24, r18
     734:	90 93 69 05 	sts	0x0569, r25	; 0x800569 <dig_T2+0x1>
     738:	80 93 68 05 	sts	0x0568, r24	; 0x800568 <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     73c:	85 81       	ldd	r24, Z+5	; 0x05
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	98 2f       	mov	r25, r24
     742:	88 27       	eor	r24, r24
     744:	24 81       	ldd	r18, Z+4	; 0x04
     746:	82 2b       	or	r24, r18
     748:	90 93 c7 05 	sts	0x05C7, r25	; 0x8005c7 <dig_T3+0x1>
     74c:	80 93 c6 05 	sts	0x05C6, r24	; 0x8005c6 <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     750:	87 81       	ldd	r24, Z+7	; 0x07
     752:	90 e0       	ldi	r25, 0x00	; 0
     754:	98 2f       	mov	r25, r24
     756:	88 27       	eor	r24, r24
     758:	26 81       	ldd	r18, Z+6	; 0x06
     75a:	82 2b       	or	r24, r18
     75c:	90 93 bb 05 	sts	0x05BB, r25	; 0x8005bb <dig_P1+0x1>
     760:	80 93 ba 05 	sts	0x05BA, r24	; 0x8005ba <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     764:	81 85       	ldd	r24, Z+9	; 0x09
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	98 2f       	mov	r25, r24
     76a:	88 27       	eor	r24, r24
     76c:	20 85       	ldd	r18, Z+8	; 0x08
     76e:	82 2b       	or	r24, r18
     770:	90 93 a1 05 	sts	0x05A1, r25	; 0x8005a1 <dig_P2+0x1>
     774:	80 93 a0 05 	sts	0x05A0, r24	; 0x8005a0 <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     778:	83 85       	ldd	r24, Z+11	; 0x0b
     77a:	90 e0       	ldi	r25, 0x00	; 0
     77c:	98 2f       	mov	r25, r24
     77e:	88 27       	eor	r24, r24
     780:	22 85       	ldd	r18, Z+10	; 0x0a
     782:	82 2b       	or	r24, r18
     784:	90 93 bd 05 	sts	0x05BD, r25	; 0x8005bd <dig_P3+0x1>
     788:	80 93 bc 05 	sts	0x05BC, r24	; 0x8005bc <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     78c:	85 85       	ldd	r24, Z+13	; 0x0d
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	98 2f       	mov	r25, r24
     792:	88 27       	eor	r24, r24
     794:	24 85       	ldd	r18, Z+12	; 0x0c
     796:	82 2b       	or	r24, r18
     798:	90 93 a3 05 	sts	0x05A3, r25	; 0x8005a3 <dig_P4+0x1>
     79c:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7a0:	87 85       	ldd	r24, Z+15	; 0x0f
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	98 2f       	mov	r25, r24
     7a6:	88 27       	eor	r24, r24
     7a8:	26 85       	ldd	r18, Z+14	; 0x0e
     7aa:	82 2b       	or	r24, r18
     7ac:	90 93 ae 05 	sts	0x05AE, r25	; 0x8005ae <dig_P5+0x1>
     7b0:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7b4:	81 89       	ldd	r24, Z+17	; 0x11
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	98 2f       	mov	r25, r24
     7ba:	88 27       	eor	r24, r24
     7bc:	20 89       	ldd	r18, Z+16	; 0x10
     7be:	82 2b       	or	r24, r18
     7c0:	90 93 c9 05 	sts	0x05C9, r25	; 0x8005c9 <dig_P6+0x1>
     7c4:	80 93 c8 05 	sts	0x05C8, r24	; 0x8005c8 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7c8:	83 89       	ldd	r24, Z+19	; 0x13
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	98 2f       	mov	r25, r24
     7ce:	88 27       	eor	r24, r24
     7d0:	22 89       	ldd	r18, Z+18	; 0x12
     7d2:	82 2b       	or	r24, r18
     7d4:	90 93 63 05 	sts	0x0563, r25	; 0x800563 <dig_P7+0x1>
     7d8:	80 93 62 05 	sts	0x0562, r24	; 0x800562 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7dc:	85 89       	ldd	r24, Z+21	; 0x15
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	98 2f       	mov	r25, r24
     7e2:	88 27       	eor	r24, r24
     7e4:	24 89       	ldd	r18, Z+20	; 0x14
     7e6:	82 2b       	or	r24, r18
     7e8:	90 93 bf 05 	sts	0x05BF, r25	; 0x8005bf <dig_P8+0x1>
     7ec:	80 93 be 05 	sts	0x05BE, r24	; 0x8005be <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     7f0:	87 89       	ldd	r24, Z+23	; 0x17
     7f2:	90 e0       	ldi	r25, 0x00	; 0
     7f4:	98 2f       	mov	r25, r24
     7f6:	88 27       	eor	r24, r24
     7f8:	26 89       	ldd	r18, Z+22	; 0x16
     7fa:	82 2b       	or	r24, r18
     7fc:	90 93 c5 05 	sts	0x05C5, r25	; 0x8005c5 <dig_P9+0x1>
     800:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <dig_P9>
	dig_H1 = RawBMEdata[25];
     804:	81 8d       	ldd	r24, Z+25	; 0x19
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	90 93 97 05 	sts	0x0597, r25	; 0x800597 <dig_H1+0x1>
     80c:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <dig_H1>
	BMEmessageBuf[26] = 0xE1; // The register we want to start reading from 
     810:	81 ee       	ldi	r24, 0xE1	; 225
     812:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <BMEmessageBuf+0x1a>
     816:	ec e7       	ldi	r30, 0x7C	; 124
     818:	f4 e0       	ldi	r31, 0x04	; 4
     81a:	a4 e8       	ldi	r26, 0x84	; 132
     81c:	b5 e0       	ldi	r27, 0x05	; 5
     81e:	23 e8       	ldi	r18, 0x83	; 131
     820:	34 e0       	ldi	r19, 0x04	; 4
	for (i=26;i<33;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     822:	81 91       	ld	r24, Z+
     824:	8d 93       	st	X+, r24
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
	dig_H1 = RawBMEdata[25];
	BMEmessageBuf[26] = 0xE1; // The register we want to start reading from 
	for (i=26;i<33;i++) 	{
     826:	e2 17       	cp	r30, r18
     828:	f3 07       	cpc	r31, r19
     82a:	d9 f7       	brne	.-10     	; 0x822 <BME_read_correction_coefficients+0x1d2>
     82c:	81 e2       	ldi	r24, 0x21	; 33
     82e:	80 93 ed 01 	sts	0x01ED, r24	; 0x8001ed <i.2287>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[26] | (RawBMEdata[27]<<8); 
     832:	ea e6       	ldi	r30, 0x6A	; 106
     834:	f5 e0       	ldi	r31, 0x05	; 5
     836:	83 8d       	ldd	r24, Z+27	; 0x1b
     838:	90 e0       	ldi	r25, 0x00	; 0
     83a:	98 2f       	mov	r25, r24
     83c:	88 27       	eor	r24, r24
     83e:	22 8d       	ldd	r18, Z+26	; 0x1a
     840:	82 2b       	or	r24, r18
     842:	90 93 cb 05 	sts	0x05CB, r25	; 0x8005cb <dig_H2+0x1>
     846:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <dig_H2>
	dig_H3 = RawBMEdata[28]; 
     84a:	84 8d       	ldd	r24, Z+28	; 0x1c
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	90 93 c3 05 	sts	0x05C3, r25	; 0x8005c3 <dig_H3+0x1>
     852:	80 93 c2 05 	sts	0x05C2, r24	; 0x8005c2 <dig_H3>
	dig_H4 = (RawBMEdata[29]<<4) | (RawBMEdata[30]>>5);
     856:	26 8d       	ldd	r18, Z+30	; 0x1e
     858:	22 95       	swap	r18
     85a:	26 95       	lsr	r18
     85c:	27 70       	andi	r18, 0x07	; 7
     85e:	85 8d       	ldd	r24, Z+29	; 0x1d
     860:	30 e1       	ldi	r19, 0x10	; 16
     862:	83 9f       	mul	r24, r19
     864:	c0 01       	movw	r24, r0
     866:	11 24       	eor	r1, r1
     868:	82 2b       	or	r24, r18
     86a:	90 93 67 05 	sts	0x0567, r25	; 0x800567 <dig_H4+0x1>
     86e:	80 93 66 05 	sts	0x0566, r24	; 0x800566 <dig_H4>
	dig_H5 = (RawBMEdata[31]>>5) | (RawBMEdata[32]<<4);
     872:	80 a1       	ldd	r24, Z+32	; 0x20
     874:	20 e1       	ldi	r18, 0x10	; 16
     876:	82 9f       	mul	r24, r18
     878:	c0 01       	movw	r24, r0
     87a:	11 24       	eor	r1, r1
     87c:	27 8d       	ldd	r18, Z+31	; 0x1f
     87e:	22 95       	swap	r18
     880:	26 95       	lsr	r18
     882:	27 70       	andi	r18, 0x07	; 7
     884:	82 2b       	or	r24, r18
     886:	90 93 c1 05 	sts	0x05C1, r25	; 0x8005c1 <dig_H5+0x1>
     88a:	80 93 c0 05 	sts	0x05C0, r24	; 0x8005c0 <dig_H5>
	dig_H6 = RawBMEdata[33];
     88e:	81 a1       	ldd	r24, Z+33	; 0x21
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	90 93 ac 05 	sts	0x05AC, r25	; 0x8005ac <dig_H6+0x1>
     896:	80 93 ab 05 	sts	0x05AB, r24	; 0x8005ab <dig_H6>
}
     89a:	df 91       	pop	r29
     89c:	cf 91       	pop	r28
     89e:	1f 91       	pop	r17
     8a0:	0f 91       	pop	r16
     8a2:	ff 90       	pop	r15
     8a4:	08 95       	ret

000008a6 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8a6:	e1 e6       	ldi	r30, 0x61	; 97
     8a8:	f4 e0       	ldi	r31, 0x04	; 4
     8aa:	8c ee       	ldi	r24, 0xEC	; 236
     8ac:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     8ae:	80 ee       	ldi	r24, 0xE0	; 224
     8b0:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     8b2:	86 eb       	ldi	r24, 0xB6	; 182
     8b4:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     8b6:	63 e0       	ldi	r22, 0x03	; 3
     8b8:	cf 01       	movw	r24, r30
     8ba:	25 d7       	rcall	.+3658   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     8bc:	20 d7       	rcall	.+3648   	; 0x16fe <TWI_Transceiver_Busy>
     8be:	81 11       	cpse	r24, r1
     8c0:	fd cf       	rjmp	.-6      	; 0x8bc <bme280basic_init+0x16>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8c2:	e1 e6       	ldi	r30, 0x61	; 97
     8c4:	f4 e0       	ldi	r31, 0x04	; 4
     8c6:	8c ee       	ldi	r24, 0xEC	; 236
     8c8:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     8ca:	80 ed       	ldi	r24, 0xD0	; 208
     8cc:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     8ce:	62 e0       	ldi	r22, 0x02	; 2
     8d0:	cf 01       	movw	r24, r30
     8d2:	19 d7       	rcall	.+3634   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     8d4:	14 d7       	rcall	.+3624   	; 0x16fe <TWI_Transceiver_Busy>
     8d6:	81 11       	cpse	r24, r1
     8d8:	fd cf       	rjmp	.-6      	; 0x8d4 <bme280basic_init+0x2e>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     8da:	8d ee       	ldi	r24, 0xED	; 237
     8dc:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     8e0:	62 e0       	ldi	r22, 0x02	; 2
     8e2:	81 e6       	ldi	r24, 0x61	; 97
     8e4:	94 e0       	ldi	r25, 0x04	; 4
     8e6:	0f d7       	rcall	.+3614   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     8e8:	0a d7       	rcall	.+3604   	; 0x16fe <TWI_Transceiver_Busy>
     8ea:	81 11       	cpse	r24, r1
     8ec:	fd cf       	rjmp	.-6      	; 0x8e8 <bme280basic_init+0x42>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     8ee:	62 e0       	ldi	r22, 0x02	; 2
     8f0:	81 e6       	ldi	r24, 0x61	; 97
     8f2:	94 e0       	ldi	r25, 0x04	; 4
     8f4:	34 d7       	rcall	.+3688   	; 0x175e <TWI_Get_Data_From_Transceiver>
     8f6:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     8fa:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <BMEmessageBuf+0x1>
     8fe:	80 36       	cpi	r24, 0x60	; 96
     900:	69 f5       	brne	.+90     	; 0x95c <__stack+0x5d>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     902:	e1 e6       	ldi	r30, 0x61	; 97
     904:	f4 e0       	ldi	r31, 0x04	; 4
     906:	8c ee       	ldi	r24, 0xEC	; 236
     908:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     90a:	82 ef       	ldi	r24, 0xF2	; 242
     90c:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     912:	63 e0       	ldi	r22, 0x03	; 3
     914:	cf 01       	movw	r24, r30
     916:	f7 d6       	rcall	.+3566   	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     918:	f2 d6       	rcall	.+3556   	; 0x16fe <TWI_Transceiver_Busy>
     91a:	81 11       	cpse	r24, r1
     91c:	fd cf       	rjmp	.-6      	; 0x918 <__stack+0x19>
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     91e:	e1 e6       	ldi	r30, 0x61	; 97
     920:	f4 e0       	ldi	r31, 0x04	; 4
     922:	8c ee       	ldi	r24, 0xEC	; 236
     924:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     926:	85 ef       	ldi	r24, 0xF5	; 245
     928:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     92a:	80 e1       	ldi	r24, 0x10	; 16
     92c:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     92e:	63 e0       	ldi	r22, 0x03	; 3
     930:	cf 01       	movw	r24, r30
     932:	e9 d6       	rcall	.+3538   	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     934:	e4 d6       	rcall	.+3528   	; 0x16fe <TWI_Transceiver_Busy>
     936:	81 11       	cpse	r24, r1
     938:	fd cf       	rjmp	.-6      	; 0x934 <__stack+0x35>
		//
		BME_read_correction_coefficients();
     93a:	8a de       	rcall	.-748    	; 0x650 <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     93c:	81 e3       	ldi	r24, 0x31	; 49
     93e:	80 93 a4 05 	sts	0x05A4, r24	; 0x8005a4 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     942:	e1 e6       	ldi	r30, 0x61	; 97
     944:	f4 e0       	ldi	r31, 0x04	; 4
     946:	9c ee       	ldi	r25, 0xEC	; 236
     948:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     94a:	94 ef       	ldi	r25, 0xF4	; 244
     94c:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     94e:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     950:	63 e0       	ldi	r22, 0x03	; 3
     952:	cf 01       	movw	r24, r30
     954:	d8 d6       	rcall	.+3504   	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     956:	d3 d6       	rcall	.+3494   	; 0x16fe <TWI_Transceiver_Busy>
     958:	81 11       	cpse	r24, r1
     95a:	fd cf       	rjmp	.-6      	; 0x956 <__stack+0x57>
     95c:	08 95       	ret

0000095e <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     95e:	ff 92       	push	r15
     960:	0f 93       	push	r16
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     968:	81 e0       	ldi	r24, 0x01	; 1
     96a:	80 93 ec 01 	sts	0x01EC, r24	; 0x8001ec <BMEbusy.2335>
	while (BMEbusy) {
     96e:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <BMEbusy.2335>
     972:	88 23       	and	r24, r24
     974:	31 f1       	breq	.+76     	; 0x9c2 <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     976:	c1 e6       	ldi	r28, 0x61	; 97
     978:	d4 e0       	ldi	r29, 0x04	; 4
     97a:	0f 2e       	mov	r0, r31
     97c:	fc ee       	ldi	r31, 0xEC	; 236
     97e:	ff 2e       	mov	r15, r31
     980:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     982:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     984:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     986:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     988:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     98a:	62 e0       	ldi	r22, 0x02	; 2
     98c:	ce 01       	movw	r24, r28
     98e:	bb d6       	rcall	.+3446   	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     990:	b6 d6       	rcall	.+3436   	; 0x16fe <TWI_Transceiver_Busy>
     992:	81 11       	cpse	r24, r1
     994:	fd cf       	rjmp	.-6      	; 0x990 <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     996:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     998:	62 e0       	ldi	r22, 0x02	; 2
     99a:	ce 01       	movw	r24, r28
     99c:	b4 d6       	rcall	.+3432   	; 0x1706 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     99e:	af d6       	rcall	.+3422   	; 0x16fe <TWI_Transceiver_Busy>
     9a0:	81 11       	cpse	r24, r1
     9a2:	fd cf       	rjmp	.-6      	; 0x99e <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9a4:	62 e0       	ldi	r22, 0x02	; 2
     9a6:	ce 01       	movw	r24, r28
     9a8:	da d6       	rcall	.+3508   	; 0x175e <TWI_Get_Data_From_Transceiver>
     9aa:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     9ae:	89 81       	ldd	r24, Y+1	; 0x01
     9b0:	83 fb       	bst	r24, 3
     9b2:	88 27       	eor	r24, r24
     9b4:	80 f9       	bld	r24, 0
     9b6:	80 93 ec 01 	sts	0x01EC, r24	; 0x8001ec <BMEbusy.2335>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     9ba:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <BMEbusy.2335>
     9be:	81 11       	cpse	r24, r1
     9c0:	e2 cf       	rjmp	.-60     	; 0x986 <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9c2:	e1 e6       	ldi	r30, 0x61	; 97
     9c4:	f4 e0       	ldi	r31, 0x04	; 4
     9c6:	8c ee       	ldi	r24, 0xEC	; 236
     9c8:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     9ca:	87 ef       	ldi	r24, 0xF7	; 247
     9cc:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9ce:	62 e0       	ldi	r22, 0x02	; 2
     9d0:	cf 01       	movw	r24, r30
     9d2:	99 d6       	rcall	.+3378   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     9d4:	94 d6       	rcall	.+3368   	; 0x16fe <TWI_Transceiver_Busy>
     9d6:	81 11       	cpse	r24, r1
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9da:	8d ee       	ldi	r24, 0xED	; 237
     9dc:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     9e0:	69 e0       	ldi	r22, 0x09	; 9
     9e2:	81 e6       	ldi	r24, 0x61	; 97
     9e4:	94 e0       	ldi	r25, 0x04	; 4
     9e6:	8f d6       	rcall	.+3358   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     9e8:	8a d6       	rcall	.+3348   	; 0x16fe <TWI_Transceiver_Busy>
     9ea:	81 11       	cpse	r24, r1
     9ec:	fd cf       	rjmp	.-6      	; 0x9e8 <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     9ee:	69 e0       	ldi	r22, 0x09	; 9
     9f0:	81 e6       	ldi	r24, 0x61	; 97
     9f2:	94 e0       	ldi	r25, 0x04	; 4
     9f4:	b4 d6       	rcall	.+3432   	; 0x175e <TWI_Get_Data_From_Transceiver>
     9f6:	80 93 60 04 	sts	0x0460, r24	; 0x800460 <TWI_XFER_STATUS>
     9fa:	e2 e6       	ldi	r30, 0x62	; 98
     9fc:	f4 e0       	ldi	r31, 0x04	; 4
     9fe:	aa e6       	ldi	r26, 0x6A	; 106
     a00:	b5 e0       	ldi	r27, 0x05	; 5
     a02:	2a e6       	ldi	r18, 0x6A	; 106
     a04:	34 e0       	ldi	r19, 0x04	; 4
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a06:	81 91       	ld	r24, Z+
     a08:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a0a:	e2 17       	cp	r30, r18
     a0c:	f3 07       	cpc	r31, r19
     a0e:	d9 f7       	brne	.-10     	; 0xa06 <bme280basic_bulk_data_read+0xa8>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a10:	ea e6       	ldi	r30, 0x6A	; 106
     a12:	f5 e0       	ldi	r31, 0x05	; 5
     a14:	81 81       	ldd	r24, Z+1	; 0x01
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	a0 e0       	ldi	r26, 0x00	; 0
     a1a:	b0 e0       	ldi	r27, 0x00	; 0
     a1c:	88 0f       	add	r24, r24
     a1e:	99 1f       	adc	r25, r25
     a20:	aa 1f       	adc	r26, r26
     a22:	bb 1f       	adc	r27, r27
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	aa 1f       	adc	r26, r26
     a2a:	bb 1f       	adc	r27, r27
     a2c:	88 0f       	add	r24, r24
     a2e:	99 1f       	adc	r25, r25
     a30:	aa 1f       	adc	r26, r26
     a32:	bb 1f       	adc	r27, r27
     a34:	88 0f       	add	r24, r24
     a36:	99 1f       	adc	r25, r25
     a38:	aa 1f       	adc	r26, r26
     a3a:	bb 1f       	adc	r27, r27
     a3c:	40 81       	ld	r20, Z
     a3e:	50 e0       	ldi	r21, 0x00	; 0
     a40:	60 e0       	ldi	r22, 0x00	; 0
     a42:	70 e0       	ldi	r23, 0x00	; 0
     a44:	03 2e       	mov	r0, r19
     a46:	3c e0       	ldi	r19, 0x0C	; 12
     a48:	44 0f       	add	r20, r20
     a4a:	55 1f       	adc	r21, r21
     a4c:	66 1f       	adc	r22, r22
     a4e:	77 1f       	adc	r23, r23
     a50:	3a 95       	dec	r19
     a52:	d1 f7       	brne	.-12     	; 0xa48 <bme280basic_bulk_data_read+0xea>
     a54:	30 2d       	mov	r19, r0
     a56:	84 2b       	or	r24, r20
     a58:	95 2b       	or	r25, r21
     a5a:	a6 2b       	or	r26, r22
     a5c:	b7 2b       	or	r27, r23
     a5e:	22 81       	ldd	r18, Z+2	; 0x02
     a60:	22 95       	swap	r18
     a62:	2f 70       	andi	r18, 0x0F	; 15
     a64:	82 2b       	or	r24, r18
     a66:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <rawPress>
     a6a:	90 93 b1 05 	sts	0x05B1, r25	; 0x8005b1 <rawPress+0x1>
     a6e:	a0 93 b2 05 	sts	0x05B2, r26	; 0x8005b2 <rawPress+0x2>
     a72:	b0 93 b3 05 	sts	0x05B3, r27	; 0x8005b3 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     a76:	84 81       	ldd	r24, Z+4	; 0x04
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	a0 e0       	ldi	r26, 0x00	; 0
     a7c:	b0 e0       	ldi	r27, 0x00	; 0
     a7e:	88 0f       	add	r24, r24
     a80:	99 1f       	adc	r25, r25
     a82:	aa 1f       	adc	r26, r26
     a84:	bb 1f       	adc	r27, r27
     a86:	88 0f       	add	r24, r24
     a88:	99 1f       	adc	r25, r25
     a8a:	aa 1f       	adc	r26, r26
     a8c:	bb 1f       	adc	r27, r27
     a8e:	88 0f       	add	r24, r24
     a90:	99 1f       	adc	r25, r25
     a92:	aa 1f       	adc	r26, r26
     a94:	bb 1f       	adc	r27, r27
     a96:	88 0f       	add	r24, r24
     a98:	99 1f       	adc	r25, r25
     a9a:	aa 1f       	adc	r26, r26
     a9c:	bb 1f       	adc	r27, r27
     a9e:	43 81       	ldd	r20, Z+3	; 0x03
     aa0:	50 e0       	ldi	r21, 0x00	; 0
     aa2:	60 e0       	ldi	r22, 0x00	; 0
     aa4:	70 e0       	ldi	r23, 0x00	; 0
     aa6:	03 2e       	mov	r0, r19
     aa8:	3c e0       	ldi	r19, 0x0C	; 12
     aaa:	44 0f       	add	r20, r20
     aac:	55 1f       	adc	r21, r21
     aae:	66 1f       	adc	r22, r22
     ab0:	77 1f       	adc	r23, r23
     ab2:	3a 95       	dec	r19
     ab4:	d1 f7       	brne	.-12     	; 0xaaa <bme280basic_bulk_data_read+0x14c>
     ab6:	30 2d       	mov	r19, r0
     ab8:	84 2b       	or	r24, r20
     aba:	95 2b       	or	r25, r21
     abc:	a6 2b       	or	r26, r22
     abe:	b7 2b       	or	r27, r23
     ac0:	25 81       	ldd	r18, Z+5	; 0x05
     ac2:	22 95       	swap	r18
     ac4:	2f 70       	andi	r18, 0x0F	; 15
     ac6:	82 2b       	or	r24, r18
     ac8:	80 93 9c 05 	sts	0x059C, r24	; 0x80059c <rawTemp>
     acc:	90 93 9d 05 	sts	0x059D, r25	; 0x80059d <rawTemp+0x1>
     ad0:	a0 93 9e 05 	sts	0x059E, r26	; 0x80059e <rawTemp+0x2>
     ad4:	b0 93 9f 05 	sts	0x059F, r27	; 0x80059f <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     ad8:	86 81       	ldd	r24, Z+6	; 0x06
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	ba 2f       	mov	r27, r26
     ae2:	a9 2f       	mov	r26, r25
     ae4:	98 2f       	mov	r25, r24
     ae6:	88 27       	eor	r24, r24
     ae8:	27 81       	ldd	r18, Z+7	; 0x07
     aea:	82 2b       	or	r24, r18
     aec:	80 93 b4 05 	sts	0x05B4, r24	; 0x8005b4 <rawHum>
     af0:	90 93 b5 05 	sts	0x05B5, r25	; 0x8005b5 <rawHum+0x1>
     af4:	a0 93 b6 05 	sts	0x05B6, r26	; 0x8005b6 <rawHum+0x2>
     af8:	b0 93 b7 05 	sts	0x05B7, r27	; 0x8005b7 <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     afc:	e1 e6       	ldi	r30, 0x61	; 97
     afe:	f4 e0       	ldi	r31, 0x04	; 4
     b00:	8c ee       	ldi	r24, 0xEC	; 236
     b02:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b04:	84 ef       	ldi	r24, 0xF4	; 244
     b06:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b08:	81 e3       	ldi	r24, 0x31	; 49
     b0a:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b0c:	63 e0       	ldi	r22, 0x03	; 3
     b0e:	cf 01       	movw	r24, r30
     b10:	fa d5       	rcall	.+3060   	; 0x1706 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b12:	f5 d5       	rcall	.+3050   	; 0x16fe <TWI_Transceiver_Busy>
     b14:	81 11       	cpse	r24, r1
     b16:	fd cf       	rjmp	.-6      	; 0xb12 <bme280basic_bulk_data_read+0x1b4>
	//  All done - and the next measurement cycle has  been kicked off!
}
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
     b1c:	1f 91       	pop	r17
     b1e:	0f 91       	pop	r16
     b20:	ff 90       	pop	r15
     b22:	08 95       	ret

00000b24 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b24:	8f 92       	push	r8
     b26:	9f 92       	push	r9
     b28:	af 92       	push	r10
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b34:	20 91 64 05 	lds	r18, 0x0564	; 0x800564 <dig_T1>
     b38:	30 91 65 05 	lds	r19, 0x0565	; 0x800565 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b3c:	6b 01       	movw	r12, r22
     b3e:	7c 01       	movw	r14, r24
     b40:	68 94       	set
     b42:	13 f8       	bld	r1, 3
     b44:	f5 94       	asr	r15
     b46:	e7 94       	ror	r14
     b48:	d7 94       	ror	r13
     b4a:	c7 94       	ror	r12
     b4c:	16 94       	lsr	r1
     b4e:	d1 f7       	brne	.-12     	; 0xb44 <BME280_compensate_T_int32+0x20>
     b50:	c2 1a       	sub	r12, r18
     b52:	d3 0a       	sbc	r13, r19
     b54:	e1 08       	sbc	r14, r1
     b56:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b58:	dc 01       	movw	r26, r24
     b5a:	cb 01       	movw	r24, r22
     b5c:	68 94       	set
     b5e:	12 f8       	bld	r1, 2
     b60:	b5 95       	asr	r27
     b62:	a7 95       	ror	r26
     b64:	97 95       	ror	r25
     b66:	87 95       	ror	r24
     b68:	16 94       	lsr	r1
     b6a:	d1 f7       	brne	.-12     	; 0xb60 <BME280_compensate_T_int32+0x3c>
     b6c:	22 0f       	add	r18, r18
     b6e:	33 1f       	adc	r19, r19
     b70:	4c 01       	movw	r8, r24
     b72:	5d 01       	movw	r10, r26
     b74:	82 1a       	sub	r8, r18
     b76:	93 0a       	sbc	r9, r19
     b78:	a1 08       	sbc	r10, r1
     b7a:	b1 08       	sbc	r11, r1
     b7c:	a5 01       	movw	r20, r10
     b7e:	94 01       	movw	r18, r8
     b80:	a0 91 68 05 	lds	r26, 0x0568	; 0x800568 <dig_T2>
     b84:	b0 91 69 05 	lds	r27, 0x0569	; 0x800569 <dig_T2+0x1>
     b88:	a0 d7       	rcall	.+3904   	; 0x1aca <__mulshisi3>
     b8a:	4b 01       	movw	r8, r22
     b8c:	5c 01       	movw	r10, r24
     b8e:	07 2e       	mov	r0, r23
     b90:	7b e0       	ldi	r23, 0x0B	; 11
     b92:	b5 94       	asr	r11
     b94:	a7 94       	ror	r10
     b96:	97 94       	ror	r9
     b98:	87 94       	ror	r8
     b9a:	7a 95       	dec	r23
     b9c:	d1 f7       	brne	.-12     	; 0xb92 <BME280_compensate_T_int32+0x6e>
     b9e:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     ba0:	a7 01       	movw	r20, r14
     ba2:	96 01       	movw	r18, r12
     ba4:	c7 01       	movw	r24, r14
     ba6:	b6 01       	movw	r22, r12
     ba8:	71 d7       	rcall	.+3810   	; 0x1a8c <__mulsi3>
     baa:	9b 01       	movw	r18, r22
     bac:	ac 01       	movw	r20, r24
     bae:	01 2e       	mov	r0, r17
     bb0:	1c e0       	ldi	r17, 0x0C	; 12
     bb2:	55 95       	asr	r21
     bb4:	47 95       	ror	r20
     bb6:	37 95       	ror	r19
     bb8:	27 95       	ror	r18
     bba:	1a 95       	dec	r17
     bbc:	d1 f7       	brne	.-12     	; 0xbb2 <BME280_compensate_T_int32+0x8e>
     bbe:	10 2d       	mov	r17, r0
     bc0:	a0 91 c6 05 	lds	r26, 0x05C6	; 0x8005c6 <dig_T3>
     bc4:	b0 91 c7 05 	lds	r27, 0x05C7	; 0x8005c7 <dig_T3+0x1>
     bc8:	80 d7       	rcall	.+3840   	; 0x1aca <__mulshisi3>
     bca:	dc 01       	movw	r26, r24
     bcc:	cb 01       	movw	r24, r22
     bce:	07 2e       	mov	r0, r23
     bd0:	7e e0       	ldi	r23, 0x0E	; 14
     bd2:	b5 95       	asr	r27
     bd4:	a7 95       	ror	r26
     bd6:	97 95       	ror	r25
     bd8:	87 95       	ror	r24
     bda:	7a 95       	dec	r23
     bdc:	d1 f7       	brne	.-12     	; 0xbd2 <BME280_compensate_T_int32+0xae>
     bde:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     be0:	88 0d       	add	r24, r8
     be2:	99 1d       	adc	r25, r9
     be4:	aa 1d       	adc	r26, r10
     be6:	bb 1d       	adc	r27, r11
     be8:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <t_fine>
     bec:	90 93 cd 05 	sts	0x05CD, r25	; 0x8005cd <t_fine+0x1>
     bf0:	a0 93 ce 05 	sts	0x05CE, r26	; 0x8005ce <t_fine+0x2>
     bf4:	b0 93 cf 05 	sts	0x05CF, r27	; 0x8005cf <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     bf8:	6c 01       	movw	r12, r24
     bfa:	7d 01       	movw	r14, r26
     bfc:	cc 0c       	add	r12, r12
     bfe:	dd 1c       	adc	r13, r13
     c00:	ee 1c       	adc	r14, r14
     c02:	ff 1c       	adc	r15, r15
     c04:	cc 0c       	add	r12, r12
     c06:	dd 1c       	adc	r13, r13
     c08:	ee 1c       	adc	r14, r14
     c0a:	ff 1c       	adc	r15, r15
     c0c:	8c 0d       	add	r24, r12
     c0e:	9d 1d       	adc	r25, r13
     c10:	ae 1d       	adc	r26, r14
     c12:	bf 1d       	adc	r27, r15
     c14:	80 58       	subi	r24, 0x80	; 128
     c16:	9f 4f       	sbci	r25, 0xFF	; 255
     c18:	af 4f       	sbci	r26, 0xFF	; 255
     c1a:	bf 4f       	sbci	r27, 0xFF	; 255
     c1c:	69 2f       	mov	r22, r25
     c1e:	7a 2f       	mov	r23, r26
     c20:	8b 2f       	mov	r24, r27
     c22:	99 27       	eor	r25, r25
     c24:	87 fd       	sbrc	r24, 7
     c26:	9a 95       	dec	r25
	return T;
}
     c28:	ff 90       	pop	r15
     c2a:	ef 90       	pop	r14
     c2c:	df 90       	pop	r13
     c2e:	cf 90       	pop	r12
     c30:	bf 90       	pop	r11
     c32:	af 90       	pop	r10
     c34:	9f 90       	pop	r9
     c36:	8f 90       	pop	r8
     c38:	08 95       	ret

00000c3a <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c3a:	2f 92       	push	r2
     c3c:	3f 92       	push	r3
     c3e:	4f 92       	push	r4
     c40:	5f 92       	push	r5
     c42:	6f 92       	push	r6
     c44:	7f 92       	push	r7
     c46:	8f 92       	push	r8
     c48:	9f 92       	push	r9
     c4a:	af 92       	push	r10
     c4c:	bf 92       	push	r11
     c4e:	cf 92       	push	r12
     c50:	df 92       	push	r13
     c52:	ef 92       	push	r14
     c54:	ff 92       	push	r15
     c56:	0f 93       	push	r16
     c58:	1f 93       	push	r17
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	cd b7       	in	r28, 0x3d	; 61
     c60:	de b7       	in	r29, 0x3e	; 62
     c62:	6e 97       	sbiw	r28, 0x1e	; 30
     c64:	0f b6       	in	r0, 0x3f	; 63
     c66:	f8 94       	cli
     c68:	de bf       	out	0x3e, r29	; 62
     c6a:	0f be       	out	0x3f, r0	; 63
     c6c:	cd bf       	out	0x3d, r28	; 61
     c6e:	6e 8b       	std	Y+22, r22	; 0x16
     c70:	7f 8b       	std	Y+23, r23	; 0x17
     c72:	88 8f       	std	Y+24, r24	; 0x18
     c74:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     c76:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <t_fine>
     c7a:	90 91 cd 05 	lds	r25, 0x05CD	; 0x8005cd <t_fine+0x1>
     c7e:	a0 91 ce 05 	lds	r26, 0x05CE	; 0x8005ce <t_fine+0x2>
     c82:	b0 91 cf 05 	lds	r27, 0x05CF	; 0x8005cf <t_fine+0x3>
     c86:	8c 01       	movw	r16, r24
     c88:	9d 01       	movw	r18, r26
     c8a:	14 5f       	subi	r17, 0xF4	; 244
     c8c:	21 40       	sbci	r18, 0x01	; 1
     c8e:	31 09       	sbc	r19, r1
     c90:	09 83       	std	Y+1, r16	; 0x01
     c92:	1a 83       	std	Y+2, r17	; 0x02
     c94:	2b 83       	std	Y+3, r18	; 0x03
     c96:	3c 83       	std	Y+4, r19	; 0x04
     c98:	33 0f       	add	r19, r19
     c9a:	00 0b       	sbc	r16, r16
     c9c:	10 2f       	mov	r17, r16
     c9e:	98 01       	movw	r18, r16
     ca0:	0d 83       	std	Y+5, r16	; 0x05
     ca2:	1e 83       	std	Y+6, r17	; 0x06
     ca4:	2f 83       	std	Y+7, r18	; 0x07
     ca6:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     ca8:	a9 80       	ldd	r10, Y+1	; 0x01
     caa:	ba 80       	ldd	r11, Y+2	; 0x02
     cac:	cb 80       	ldd	r12, Y+3	; 0x03
     cae:	dc 80       	ldd	r13, Y+4	; 0x04
     cb0:	ed 80       	ldd	r14, Y+5	; 0x05
     cb2:	fe 2c       	mov	r15, r14
     cb4:	0e 2d       	mov	r16, r14
     cb6:	1e 2d       	mov	r17, r14
     cb8:	2a 2d       	mov	r18, r10
     cba:	3b 2d       	mov	r19, r11
     cbc:	4c 2d       	mov	r20, r12
     cbe:	5d 2d       	mov	r21, r13
     cc0:	60 2f       	mov	r22, r16
     cc2:	70 2f       	mov	r23, r16
     cc4:	80 2f       	mov	r24, r16
     cc6:	9e 2d       	mov	r25, r14
     cc8:	06 d7       	rcall	.+3596   	; 0x1ad6 <__muldi3>
     cca:	2d 87       	std	Y+13, r18	; 0x0d
     ccc:	3e 87       	std	Y+14, r19	; 0x0e
     cce:	4f 87       	std	Y+15, r20	; 0x0f
     cd0:	58 8b       	std	Y+16, r21	; 0x10
     cd2:	69 8b       	std	Y+17, r22	; 0x11
     cd4:	7a 8b       	std	Y+18, r23	; 0x12
     cd6:	8b 8b       	std	Y+19, r24	; 0x13
     cd8:	9c 8b       	std	Y+20, r25	; 0x14
     cda:	10 91 c8 05 	lds	r17, 0x05C8	; 0x8005c8 <dig_P6>
     cde:	1a 8f       	std	Y+26, r17	; 0x1a
     ce0:	20 91 c9 05 	lds	r18, 0x05C9	; 0x8005c9 <dig_P6+0x1>
     ce4:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     ce6:	30 91 ad 05 	lds	r19, 0x05AD	; 0x8005ad <dig_P5>
     cea:	3b 8f       	std	Y+27, r19	; 0x1b
     cec:	40 91 ae 05 	lds	r20, 0x05AE	; 0x8005ae <dig_P5+0x1>
     cf0:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     cf2:	50 91 a2 05 	lds	r21, 0x05A2	; 0x8005a2 <dig_P4>
     cf6:	5c 8f       	std	Y+28, r21	; 0x1c
     cf8:	80 91 a3 05 	lds	r24, 0x05A3	; 0x8005a3 <dig_P4+0x1>
     cfc:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     cfe:	30 91 a1 05 	lds	r19, 0x05A1	; 0x8005a1 <dig_P2+0x1>
     d02:	20 91 a0 05 	lds	r18, 0x05A0	; 0x8005a0 <dig_P2>
     d06:	93 2f       	mov	r25, r19
     d08:	99 0f       	add	r25, r25
     d0a:	99 0b       	sbc	r25, r25
     d0c:	fe 2c       	mov	r15, r14
     d0e:	0e 2d       	mov	r16, r14
     d10:	1e 2d       	mov	r17, r14
     d12:	49 2f       	mov	r20, r25
     d14:	59 2f       	mov	r21, r25
     d16:	69 2f       	mov	r22, r25
     d18:	79 2f       	mov	r23, r25
     d1a:	89 2f       	mov	r24, r25
     d1c:	dc d6       	rcall	.+3512   	; 0x1ad6 <__muldi3>
     d1e:	0c e0       	ldi	r16, 0x0C	; 12
     d20:	fb d7       	rcall	.+4086   	; 0x1d18 <__ashldi3>
     d22:	42 2e       	mov	r4, r18
     d24:	53 2e       	mov	r5, r19
     d26:	64 2e       	mov	r6, r20
     d28:	75 2e       	mov	r7, r21
     d2a:	86 2e       	mov	r8, r22
     d2c:	97 2e       	mov	r9, r23
     d2e:	28 2e       	mov	r2, r24
     d30:	39 2e       	mov	r3, r25
     d32:	b0 90 bd 05 	lds	r11, 0x05BD	; 0x8005bd <dig_P3+0x1>
     d36:	a0 90 bc 05 	lds	r10, 0x05BC	; 0x8005bc <dig_P3>
     d3a:	1b 2d       	mov	r17, r11
     d3c:	11 0f       	add	r17, r17
     d3e:	11 0b       	sbc	r17, r17
     d40:	c1 2e       	mov	r12, r17
     d42:	d1 2e       	mov	r13, r17
     d44:	e1 2e       	mov	r14, r17
     d46:	f1 2e       	mov	r15, r17
     d48:	01 2f       	mov	r16, r17
     d4a:	2d 85       	ldd	r18, Y+13	; 0x0d
     d4c:	3e 85       	ldd	r19, Y+14	; 0x0e
     d4e:	4f 85       	ldd	r20, Y+15	; 0x0f
     d50:	58 89       	ldd	r21, Y+16	; 0x10
     d52:	69 89       	ldd	r22, Y+17	; 0x11
     d54:	7a 89       	ldd	r23, Y+18	; 0x12
     d56:	8b 89       	ldd	r24, Y+19	; 0x13
     d58:	9c 89       	ldd	r25, Y+20	; 0x14
     d5a:	bd d6       	rcall	.+3450   	; 0x1ad6 <__muldi3>
     d5c:	08 e0       	ldi	r16, 0x08	; 8
     d5e:	f5 d7       	rcall	.+4074   	; 0x1d4a <__ashrdi3>
     d60:	a4 2c       	mov	r10, r4
     d62:	b5 2c       	mov	r11, r5
     d64:	c6 2c       	mov	r12, r6
     d66:	d7 2c       	mov	r13, r7
     d68:	e8 2c       	mov	r14, r8
     d6a:	f9 2c       	mov	r15, r9
     d6c:	02 2d       	mov	r16, r2
     d6e:	13 2d       	mov	r17, r3
     d70:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     d74:	70 58       	subi	r23, 0x80	; 128
     d76:	8f 4f       	sbci	r24, 0xFF	; 255
     d78:	9f 4f       	sbci	r25, 0xFF	; 255
     d7a:	20 90 ba 05 	lds	r2, 0x05BA	; 0x8005ba <dig_P1>
     d7e:	30 90 bb 05 	lds	r3, 0x05BB	; 0x8005bb <dig_P1+0x1>
     d82:	a2 2c       	mov	r10, r2
     d84:	b3 2c       	mov	r11, r3
     d86:	c1 2c       	mov	r12, r1
     d88:	d1 2c       	mov	r13, r1
     d8a:	e1 2c       	mov	r14, r1
     d8c:	f1 2c       	mov	r15, r1
     d8e:	00 e0       	ldi	r16, 0x00	; 0
     d90:	10 e0       	ldi	r17, 0x00	; 0
     d92:	a1 d6       	rcall	.+3394   	; 0x1ad6 <__muldi3>
     d94:	01 e2       	ldi	r16, 0x21	; 33
     d96:	d9 d7       	rcall	.+4018   	; 0x1d4a <__ashrdi3>
     d98:	29 87       	std	Y+9, r18	; 0x09
     d9a:	3a 87       	std	Y+10, r19	; 0x0a
     d9c:	4b 87       	std	Y+11, r20	; 0x0b
     d9e:	45 2e       	mov	r4, r21
     da0:	56 2e       	mov	r5, r22
     da2:	7c 87       	std	Y+12, r23	; 0x0c
     da4:	38 2e       	mov	r3, r24
     da6:	29 2e       	mov	r2, r25
	if (var1 == 0)
     da8:	65 2d       	mov	r22, r5
     daa:	83 2d       	mov	r24, r3
     dac:	92 2d       	mov	r25, r2
     dae:	a0 e0       	ldi	r26, 0x00	; 0
     db0:	fc d7       	rcall	.+4088   	; 0x1daa <__cmpdi2_s8>
     db2:	09 f4       	brne	.+2      	; 0xdb6 <BME280_compensate_P_int64+0x17c>
     db4:	6c c1       	rjmp	.+728    	; 0x108e <BME280_compensate_P_int64+0x454>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     db6:	aa 8c       	ldd	r10, Y+26	; 0x1a
     db8:	1e 8d       	ldd	r17, Y+30	; 0x1e
     dba:	11 0f       	add	r17, r17
     dbc:	11 0b       	sbc	r17, r17
     dbe:	be 8c       	ldd	r11, Y+30	; 0x1e
     dc0:	c1 2e       	mov	r12, r17
     dc2:	d1 2e       	mov	r13, r17
     dc4:	e1 2e       	mov	r14, r17
     dc6:	f1 2e       	mov	r15, r17
     dc8:	01 2f       	mov	r16, r17
     dca:	2d 85       	ldd	r18, Y+13	; 0x0d
     dcc:	3e 85       	ldd	r19, Y+14	; 0x0e
     dce:	4f 85       	ldd	r20, Y+15	; 0x0f
     dd0:	58 89       	ldd	r21, Y+16	; 0x10
     dd2:	69 89       	ldd	r22, Y+17	; 0x11
     dd4:	7a 89       	ldd	r23, Y+18	; 0x12
     dd6:	8b 89       	ldd	r24, Y+19	; 0x13
     dd8:	9c 89       	ldd	r25, Y+20	; 0x14
     dda:	7d d6       	rcall	.+3322   	; 0x1ad6 <__muldi3>
     ddc:	2d 87       	std	Y+13, r18	; 0x0d
     dde:	3e 87       	std	Y+14, r19	; 0x0e
     de0:	64 2e       	mov	r6, r20
     de2:	75 2e       	mov	r7, r21
     de4:	86 2e       	mov	r8, r22
     de6:	97 2e       	mov	r9, r23
     de8:	88 8b       	std	Y+16, r24	; 0x10
     dea:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     dec:	2b 8d       	ldd	r18, Y+27	; 0x1b
     dee:	9d 8d       	ldd	r25, Y+29	; 0x1d
     df0:	99 0f       	add	r25, r25
     df2:	99 0b       	sbc	r25, r25
     df4:	a9 80       	ldd	r10, Y+1	; 0x01
     df6:	ba 80       	ldd	r11, Y+2	; 0x02
     df8:	cb 80       	ldd	r12, Y+3	; 0x03
     dfa:	dc 80       	ldd	r13, Y+4	; 0x04
     dfc:	ed 80       	ldd	r14, Y+5	; 0x05
     dfe:	fe 2c       	mov	r15, r14
     e00:	0e 2d       	mov	r16, r14
     e02:	1e 2d       	mov	r17, r14
     e04:	3d 8d       	ldd	r19, Y+29	; 0x1d
     e06:	49 2f       	mov	r20, r25
     e08:	59 2f       	mov	r21, r25
     e0a:	69 2f       	mov	r22, r25
     e0c:	79 2f       	mov	r23, r25
     e0e:	89 2f       	mov	r24, r25
     e10:	62 d6       	rcall	.+3268   	; 0x1ad6 <__muldi3>
     e12:	01 e1       	ldi	r16, 0x11	; 17
     e14:	81 d7       	rcall	.+3842   	; 0x1d18 <__ashldi3>
     e16:	ad 84       	ldd	r10, Y+13	; 0x0d
     e18:	be 84       	ldd	r11, Y+14	; 0x0e
     e1a:	c6 2c       	mov	r12, r6
     e1c:	d7 2c       	mov	r13, r7
     e1e:	e8 2c       	mov	r14, r8
     e20:	f9 2c       	mov	r15, r9
     e22:	08 89       	ldd	r16, Y+16	; 0x10
     e24:	1f 85       	ldd	r17, Y+15	; 0x0f
     e26:	af d7       	rcall	.+3934   	; 0x1d86 <__adddi3>
     e28:	a2 2e       	mov	r10, r18
     e2a:	b3 2e       	mov	r11, r19
     e2c:	c4 2e       	mov	r12, r20
     e2e:	d5 2e       	mov	r13, r21
     e30:	e6 2e       	mov	r14, r22
     e32:	f7 2e       	mov	r15, r23
     e34:	e8 2f       	mov	r30, r24
     e36:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	a0 e1       	ldi	r26, 0x10	; 16
     e3e:	b0 e0       	ldi	r27, 0x00	; 0
     e40:	2e 89       	ldd	r18, Y+22	; 0x16
     e42:	3f 89       	ldd	r19, Y+23	; 0x17
     e44:	48 8d       	ldd	r20, Y+24	; 0x18
     e46:	59 8d       	ldd	r21, Y+25	; 0x19
     e48:	82 1b       	sub	r24, r18
     e4a:	93 0b       	sbc	r25, r19
     e4c:	a4 0b       	sbc	r26, r20
     e4e:	b5 0b       	sbc	r27, r21
     e50:	3c 01       	movw	r6, r24
     e52:	4d 01       	movw	r8, r26
     e54:	99 0c       	add	r9, r9
     e56:	66 08       	sbc	r6, r6
     e58:	76 2c       	mov	r7, r6
     e5a:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     e5c:	28 2f       	mov	r18, r24
     e5e:	39 2f       	mov	r19, r25
     e60:	4a 2f       	mov	r20, r26
     e62:	5b 2f       	mov	r21, r27
     e64:	66 2d       	mov	r22, r6
     e66:	76 2d       	mov	r23, r6
     e68:	86 2d       	mov	r24, r6
     e6a:	96 2d       	mov	r25, r6
     e6c:	0f e1       	ldi	r16, 0x1F	; 31
     e6e:	54 d7       	rcall	.+3752   	; 0x1d18 <__ashldi3>
     e70:	82 2e       	mov	r8, r18
     e72:	93 2e       	mov	r9, r19
     e74:	f4 2f       	mov	r31, r20
     e76:	75 2e       	mov	r7, r21
     e78:	b6 2f       	mov	r27, r22
     e7a:	a7 2f       	mov	r26, r23
     e7c:	68 2e       	mov	r6, r24
     e7e:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     e80:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e82:	9d 89       	ldd	r25, Y+21	; 0x15
     e84:	99 0f       	add	r25, r25
     e86:	99 0b       	sbc	r25, r25
     e88:	3d 89       	ldd	r19, Y+21	; 0x15
     e8a:	49 2f       	mov	r20, r25
     e8c:	59 2f       	mov	r21, r25
     e8e:	69 2f       	mov	r22, r25
     e90:	79 2f       	mov	r23, r25
     e92:	89 2f       	mov	r24, r25
     e94:	03 e2       	ldi	r16, 0x23	; 35
     e96:	40 d7       	rcall	.+3712   	; 0x1d18 <__ashldi3>
     e98:	0e 2f       	mov	r16, r30
     e9a:	75 d7       	rcall	.+3818   	; 0x1d86 <__adddi3>
     e9c:	a2 2e       	mov	r10, r18
     e9e:	b3 2e       	mov	r11, r19
     ea0:	c4 2e       	mov	r12, r20
     ea2:	d5 2e       	mov	r13, r21
     ea4:	e6 2e       	mov	r14, r22
     ea6:	f7 2e       	mov	r15, r23
     ea8:	08 2f       	mov	r16, r24
     eaa:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     eac:	28 2d       	mov	r18, r8
     eae:	39 2d       	mov	r19, r9
     eb0:	4f 2f       	mov	r20, r31
     eb2:	57 2d       	mov	r21, r7
     eb4:	6b 2f       	mov	r22, r27
     eb6:	7a 2f       	mov	r23, r26
     eb8:	86 2d       	mov	r24, r6
     eba:	9d 81       	ldd	r25, Y+5	; 0x05
     ebc:	6d d7       	rcall	.+3802   	; 0x1d98 <__subdi3>
     ebe:	82 2e       	mov	r8, r18
     ec0:	93 2e       	mov	r9, r19
     ec2:	49 83       	std	Y+1, r20	; 0x01
     ec4:	65 2e       	mov	r6, r21
     ec6:	b6 2f       	mov	r27, r22
     ec8:	a7 2f       	mov	r26, r23
     eca:	f8 2f       	mov	r31, r24
     ecc:	e9 2f       	mov	r30, r25
     ece:	03 e0       	ldi	r16, 0x03	; 3
     ed0:	23 d7       	rcall	.+3654   	; 0x1d18 <__ashldi3>
     ed2:	a8 2c       	mov	r10, r8
     ed4:	b9 2c       	mov	r11, r9
     ed6:	c9 80       	ldd	r12, Y+1	; 0x01
     ed8:	d6 2c       	mov	r13, r6
     eda:	eb 2e       	mov	r14, r27
     edc:	fa 2e       	mov	r15, r26
     ede:	0f 2f       	mov	r16, r31
     ee0:	1e 2f       	mov	r17, r30
     ee2:	5a d7       	rcall	.+3764   	; 0x1d98 <__subdi3>
     ee4:	a2 2e       	mov	r10, r18
     ee6:	b3 2e       	mov	r11, r19
     ee8:	c4 2e       	mov	r12, r20
     eea:	d5 2e       	mov	r13, r21
     eec:	e6 2e       	mov	r14, r22
     eee:	f7 2e       	mov	r15, r23
     ef0:	78 2e       	mov	r7, r24
     ef2:	19 2f       	mov	r17, r25
     ef4:	03 e0       	ldi	r16, 0x03	; 3
     ef6:	10 d7       	rcall	.+3616   	; 0x1d18 <__ashldi3>
     ef8:	07 2d       	mov	r16, r7
     efa:	4e d7       	rcall	.+3740   	; 0x1d98 <__subdi3>
     efc:	03 e0       	ldi	r16, 0x03	; 3
     efe:	0c d7       	rcall	.+3608   	; 0x1d18 <__ashldi3>
     f00:	a8 2c       	mov	r10, r8
     f02:	b9 2c       	mov	r11, r9
     f04:	c9 80       	ldd	r12, Y+1	; 0x01
     f06:	d6 2c       	mov	r13, r6
     f08:	eb 2e       	mov	r14, r27
     f0a:	fa 2e       	mov	r15, r26
     f0c:	0f 2f       	mov	r16, r31
     f0e:	1e 2f       	mov	r17, r30
     f10:	43 d7       	rcall	.+3718   	; 0x1d98 <__subdi3>
     f12:	02 e0       	ldi	r16, 0x02	; 2
     f14:	01 d7       	rcall	.+3586   	; 0x1d18 <__ashldi3>
     f16:	0f 2f       	mov	r16, r31
     f18:	3f d7       	rcall	.+3710   	; 0x1d98 <__subdi3>
     f1a:	01 e0       	ldi	r16, 0x01	; 1
     f1c:	fd d6       	rcall	.+3578   	; 0x1d18 <__ashldi3>
     f1e:	0f 2f       	mov	r16, r31
     f20:	3b d7       	rcall	.+3702   	; 0x1d98 <__subdi3>
     f22:	a9 84       	ldd	r10, Y+9	; 0x09
     f24:	ba 84       	ldd	r11, Y+10	; 0x0a
     f26:	cb 84       	ldd	r12, Y+11	; 0x0b
     f28:	d4 2c       	mov	r13, r4
     f2a:	e5 2c       	mov	r14, r5
     f2c:	fc 84       	ldd	r15, Y+12	; 0x0c
     f2e:	03 2d       	mov	r16, r3
     f30:	12 2d       	mov	r17, r2
     f32:	24 d6       	rcall	.+3144   	; 0x1b7c <__divdi3>
     f34:	2e 87       	std	Y+14, r18	; 0x0e
     f36:	3d 87       	std	Y+13, r19	; 0x0d
     f38:	49 83       	std	Y+1, r20	; 0x01
     f3a:	5d 83       	std	Y+5, r21	; 0x05
     f3c:	69 87       	std	Y+9, r22	; 0x09
     f3e:	7a 87       	std	Y+10, r23	; 0x0a
     f40:	8b 87       	std	Y+11, r24	; 0x0b
     f42:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     f44:	0d e0       	ldi	r16, 0x0D	; 13
     f46:	01 d7       	rcall	.+3586   	; 0x1d4a <__ashrdi3>
     f48:	82 2e       	mov	r8, r18
     f4a:	93 2e       	mov	r9, r19
     f4c:	74 2e       	mov	r7, r20
     f4e:	65 2e       	mov	r6, r21
     f50:	56 2e       	mov	r5, r22
     f52:	47 2e       	mov	r4, r23
     f54:	38 2e       	mov	r3, r24
     f56:	29 2e       	mov	r2, r25
     f58:	30 91 c5 05 	lds	r19, 0x05C5	; 0x8005c5 <dig_P9+0x1>
     f5c:	20 91 c4 05 	lds	r18, 0x05C4	; 0x8005c4 <dig_P9>
     f60:	93 2f       	mov	r25, r19
     f62:	99 0f       	add	r25, r25
     f64:	99 0b       	sbc	r25, r25
     f66:	a8 2c       	mov	r10, r8
     f68:	b9 2c       	mov	r11, r9
     f6a:	c7 2c       	mov	r12, r7
     f6c:	d6 2c       	mov	r13, r6
     f6e:	e5 2c       	mov	r14, r5
     f70:	f4 2c       	mov	r15, r4
     f72:	03 2d       	mov	r16, r3
     f74:	12 2d       	mov	r17, r2
     f76:	49 2f       	mov	r20, r25
     f78:	59 2f       	mov	r21, r25
     f7a:	69 2f       	mov	r22, r25
     f7c:	79 2f       	mov	r23, r25
     f7e:	89 2f       	mov	r24, r25
     f80:	aa d5       	rcall	.+2900   	; 0x1ad6 <__muldi3>
     f82:	a2 2e       	mov	r10, r18
     f84:	b3 2e       	mov	r11, r19
     f86:	c4 2e       	mov	r12, r20
     f88:	d5 2e       	mov	r13, r21
     f8a:	e6 2e       	mov	r14, r22
     f8c:	f7 2e       	mov	r15, r23
     f8e:	08 2f       	mov	r16, r24
     f90:	19 2f       	mov	r17, r25
     f92:	28 2d       	mov	r18, r8
     f94:	39 2d       	mov	r19, r9
     f96:	47 2d       	mov	r20, r7
     f98:	56 2d       	mov	r21, r6
     f9a:	65 2d       	mov	r22, r5
     f9c:	74 2d       	mov	r23, r4
     f9e:	83 2d       	mov	r24, r3
     fa0:	92 2d       	mov	r25, r2
     fa2:	99 d5       	rcall	.+2866   	; 0x1ad6 <__muldi3>
     fa4:	09 e1       	ldi	r16, 0x19	; 25
     fa6:	d1 d6       	rcall	.+3490   	; 0x1d4a <__ashrdi3>
     fa8:	a2 2e       	mov	r10, r18
     faa:	b3 2e       	mov	r11, r19
     fac:	c4 2e       	mov	r12, r20
     fae:	d5 2e       	mov	r13, r21
     fb0:	e6 2e       	mov	r14, r22
     fb2:	f7 2e       	mov	r15, r23
     fb4:	08 2f       	mov	r16, r24
     fb6:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     fb8:	2e 85       	ldd	r18, Y+14	; 0x0e
     fba:	3d 85       	ldd	r19, Y+13	; 0x0d
     fbc:	49 81       	ldd	r20, Y+1	; 0x01
     fbe:	5d 81       	ldd	r21, Y+5	; 0x05
     fc0:	69 85       	ldd	r22, Y+9	; 0x09
     fc2:	7a 85       	ldd	r23, Y+10	; 0x0a
     fc4:	8b 85       	ldd	r24, Y+11	; 0x0b
     fc6:	9c 85       	ldd	r25, Y+12	; 0x0c
     fc8:	de d6       	rcall	.+3516   	; 0x1d86 <__adddi3>
     fca:	22 2e       	mov	r2, r18
     fcc:	33 2e       	mov	r3, r19
     fce:	44 2e       	mov	r4, r20
     fd0:	55 2e       	mov	r5, r21
     fd2:	66 2e       	mov	r6, r22
     fd4:	77 2e       	mov	r7, r23
     fd6:	88 2e       	mov	r8, r24
     fd8:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
     fda:	30 91 bf 05 	lds	r19, 0x05BF	; 0x8005bf <dig_P8+0x1>
     fde:	20 91 be 05 	lds	r18, 0x05BE	; 0x8005be <dig_P8>
     fe2:	93 2f       	mov	r25, r19
     fe4:	99 0f       	add	r25, r25
     fe6:	99 0b       	sbc	r25, r25
     fe8:	ae 84       	ldd	r10, Y+14	; 0x0e
     fea:	bd 84       	ldd	r11, Y+13	; 0x0d
     fec:	c9 80       	ldd	r12, Y+1	; 0x01
     fee:	dd 80       	ldd	r13, Y+5	; 0x05
     ff0:	e9 84       	ldd	r14, Y+9	; 0x09
     ff2:	fa 84       	ldd	r15, Y+10	; 0x0a
     ff4:	0b 85       	ldd	r16, Y+11	; 0x0b
     ff6:	1c 85       	ldd	r17, Y+12	; 0x0c
     ff8:	49 2f       	mov	r20, r25
     ffa:	59 2f       	mov	r21, r25
     ffc:	69 2f       	mov	r22, r25
     ffe:	79 2f       	mov	r23, r25
    1000:	89 2f       	mov	r24, r25
    1002:	69 d5       	rcall	.+2770   	; 0x1ad6 <__muldi3>
    1004:	03 e1       	ldi	r16, 0x13	; 19
    1006:	a1 d6       	rcall	.+3394   	; 0x1d4a <__ashrdi3>
    1008:	a2 2e       	mov	r10, r18
    100a:	b3 2e       	mov	r11, r19
    100c:	c4 2e       	mov	r12, r20
    100e:	d5 2e       	mov	r13, r21
    1010:	e6 2e       	mov	r14, r22
    1012:	f7 2e       	mov	r15, r23
    1014:	08 2f       	mov	r16, r24
    1016:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1018:	22 2d       	mov	r18, r2
    101a:	33 2d       	mov	r19, r3
    101c:	44 2d       	mov	r20, r4
    101e:	55 2d       	mov	r21, r5
    1020:	66 2d       	mov	r22, r6
    1022:	77 2d       	mov	r23, r7
    1024:	88 2d       	mov	r24, r8
    1026:	99 2d       	mov	r25, r9
    1028:	ae d6       	rcall	.+3420   	; 0x1d86 <__adddi3>
    102a:	08 e0       	ldi	r16, 0x08	; 8
    102c:	8e d6       	rcall	.+3356   	; 0x1d4a <__ashrdi3>
    102e:	40 90 62 05 	lds	r4, 0x0562	; 0x800562 <dig_P7>
    1032:	50 90 63 05 	lds	r5, 0x0563	; 0x800563 <dig_P7+0x1>
    1036:	05 2c       	mov	r0, r5
    1038:	00 0c       	add	r0, r0
    103a:	66 08       	sbc	r6, r6
    103c:	77 08       	sbc	r7, r7
    103e:	44 0c       	add	r4, r4
    1040:	55 1c       	adc	r5, r5
    1042:	66 1c       	adc	r6, r6
    1044:	77 1c       	adc	r7, r7
    1046:	44 0c       	add	r4, r4
    1048:	55 1c       	adc	r5, r5
    104a:	66 1c       	adc	r6, r6
    104c:	77 1c       	adc	r7, r7
    104e:	44 0c       	add	r4, r4
    1050:	55 1c       	adc	r5, r5
    1052:	66 1c       	adc	r6, r6
    1054:	77 1c       	adc	r7, r7
    1056:	44 0c       	add	r4, r4
    1058:	55 1c       	adc	r5, r5
    105a:	66 1c       	adc	r6, r6
    105c:	77 1c       	adc	r7, r7
    105e:	83 01       	movw	r16, r6
    1060:	72 01       	movw	r14, r4
    1062:	11 0f       	add	r17, r17
    1064:	ee 08       	sbc	r14, r14
    1066:	fe 2c       	mov	r15, r14
    1068:	87 01       	movw	r16, r14
    106a:	e9 82       	std	Y+1, r14	; 0x01
    106c:	fa 82       	std	Y+2, r15	; 0x02
    106e:	0b 83       	std	Y+3, r16	; 0x03
    1070:	1c 83       	std	Y+4, r17	; 0x04
    1072:	a4 2c       	mov	r10, r4
    1074:	b5 2c       	mov	r11, r5
    1076:	c6 2c       	mov	r12, r6
    1078:	d7 2c       	mov	r13, r7
    107a:	e9 80       	ldd	r14, Y+1	; 0x01
    107c:	fe 2c       	mov	r15, r14
    107e:	0e 2d       	mov	r16, r14
    1080:	1e 2d       	mov	r17, r14
    1082:	81 d6       	rcall	.+3330   	; 0x1d86 <__adddi3>
	return(long)p;
    1084:	62 2f       	mov	r22, r18
    1086:	73 2f       	mov	r23, r19
    1088:	84 2f       	mov	r24, r20
    108a:	95 2f       	mov	r25, r21
    108c:	04 c0       	rjmp	.+8      	; 0x1096 <BME280_compensate_P_int64+0x45c>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    108e:	60 e0       	ldi	r22, 0x00	; 0
    1090:	70 e0       	ldi	r23, 0x00	; 0
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    1096:	6e 96       	adiw	r28, 0x1e	; 30
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	de bf       	out	0x3e, r29	; 62
    109e:	0f be       	out	0x3f, r0	; 63
    10a0:	cd bf       	out	0x3d, r28	; 61
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	1f 91       	pop	r17
    10a8:	0f 91       	pop	r16
    10aa:	ff 90       	pop	r15
    10ac:	ef 90       	pop	r14
    10ae:	df 90       	pop	r13
    10b0:	cf 90       	pop	r12
    10b2:	bf 90       	pop	r11
    10b4:	af 90       	pop	r10
    10b6:	9f 90       	pop	r9
    10b8:	8f 90       	pop	r8
    10ba:	7f 90       	pop	r7
    10bc:	6f 90       	pop	r6
    10be:	5f 90       	pop	r5
    10c0:	4f 90       	pop	r4
    10c2:	3f 90       	pop	r3
    10c4:	2f 90       	pop	r2
    10c6:	08 95       	ret

000010c8 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    10c8:	2f 92       	push	r2
    10ca:	3f 92       	push	r3
    10cc:	4f 92       	push	r4
    10ce:	5f 92       	push	r5
    10d0:	6f 92       	push	r6
    10d2:	7f 92       	push	r7
    10d4:	8f 92       	push	r8
    10d6:	9f 92       	push	r9
    10d8:	af 92       	push	r10
    10da:	bf 92       	push	r11
    10dc:	cf 92       	push	r12
    10de:	df 92       	push	r13
    10e0:	ef 92       	push	r14
    10e2:	ff 92       	push	r15
    10e4:	0f 93       	push	r16
    10e6:	1f 93       	push	r17
    10e8:	cf 93       	push	r28
    10ea:	df 93       	push	r29
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	67 97       	sbiw	r28, 0x17	; 23
    10f2:	0f b6       	in	r0, 0x3f	; 63
    10f4:	f8 94       	cli
    10f6:	de bf       	out	0x3e, r29	; 62
    10f8:	0f be       	out	0x3f, r0	; 63
    10fa:	cd bf       	out	0x3d, r28	; 61
    10fc:	2b 01       	movw	r4, r22
    10fe:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    1100:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <t_fine>
    1104:	90 91 cd 05 	lds	r25, 0x05CD	; 0x8005cd <t_fine+0x1>
    1108:	a0 91 ce 05 	lds	r26, 0x05CE	; 0x8005ce <t_fine+0x2>
    110c:	b0 91 cf 05 	lds	r27, 0x05CF	; 0x8005cf <t_fine+0x3>
    1110:	6c 01       	movw	r12, r24
    1112:	7d 01       	movw	r14, r26
    1114:	ff 0c       	add	r15, r15
    1116:	cc 08       	sbc	r12, r12
    1118:	dc 2c       	mov	r13, r12
    111a:	76 01       	movw	r14, r12
    111c:	28 2f       	mov	r18, r24
    111e:	39 2f       	mov	r19, r25
    1120:	4a 2f       	mov	r20, r26
    1122:	5b 2f       	mov	r21, r27
    1124:	6c 2d       	mov	r22, r12
    1126:	7c 2d       	mov	r23, r12
    1128:	8c 2d       	mov	r24, r12
    112a:	9c 2d       	mov	r25, r12
    112c:	3c 52       	subi	r19, 0x2C	; 44
    112e:	41 40       	sbci	r20, 0x01	; 1
    1130:	51 09       	sbc	r21, r1
    1132:	61 09       	sbc	r22, r1
    1134:	71 09       	sbc	r23, r1
    1136:	81 09       	sbc	r24, r1
    1138:	91 09       	sbc	r25, r1
    113a:	2f 8b       	std	Y+23, r18	; 0x17
    113c:	3e 8b       	std	Y+22, r19	; 0x16
    113e:	49 83       	std	Y+1, r20	; 0x01
    1140:	59 87       	std	Y+9, r21	; 0x09
    1142:	6a 87       	std	Y+10, r22	; 0x0a
    1144:	7b 87       	std	Y+11, r23	; 0x0b
    1146:	8c 87       	std	Y+12, r24	; 0x0c
    1148:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    114a:	03 2e       	mov	r0, r19
    114c:	3e e0       	ldi	r19, 0x0E	; 14
    114e:	44 0c       	add	r4, r4
    1150:	55 1c       	adc	r5, r5
    1152:	66 1c       	adc	r6, r6
    1154:	77 1c       	adc	r7, r7
    1156:	3a 95       	dec	r19
    1158:	d1 f7       	brne	.-12     	; 0x114e <bme280_compensate_H_int32+0x86>
    115a:	30 2d       	mov	r19, r0
    115c:	53 01       	movw	r10, r6
    115e:	42 01       	movw	r8, r4
    1160:	bb 0c       	add	r11, r11
    1162:	88 08       	sbc	r8, r8
    1164:	98 2c       	mov	r9, r8
    1166:	54 01       	movw	r10, r8
    1168:	30 91 67 05 	lds	r19, 0x0567	; 0x800567 <dig_H4+0x1>
    116c:	20 91 66 05 	lds	r18, 0x0566	; 0x800566 <dig_H4>
    1170:	93 2f       	mov	r25, r19
    1172:	99 0f       	add	r25, r25
    1174:	99 0b       	sbc	r25, r25
    1176:	49 2f       	mov	r20, r25
    1178:	59 2f       	mov	r21, r25
    117a:	69 2f       	mov	r22, r25
    117c:	79 2f       	mov	r23, r25
    117e:	89 2f       	mov	r24, r25
    1180:	04 e1       	ldi	r16, 0x14	; 20
    1182:	ca d5       	rcall	.+2964   	; 0x1d18 <__ashldi3>
    1184:	f2 2f       	mov	r31, r18
    1186:	e3 2f       	mov	r30, r19
    1188:	c4 2e       	mov	r12, r20
    118a:	d5 2e       	mov	r13, r21
    118c:	e6 2e       	mov	r14, r22
    118e:	f7 2e       	mov	r15, r23
    1190:	08 2f       	mov	r16, r24
    1192:	19 2f       	mov	r17, r25
    1194:	24 2d       	mov	r18, r4
    1196:	35 2d       	mov	r19, r5
    1198:	46 2d       	mov	r20, r6
    119a:	57 2d       	mov	r21, r7
    119c:	68 2d       	mov	r22, r8
    119e:	78 2d       	mov	r23, r8
    11a0:	88 2d       	mov	r24, r8
    11a2:	98 2d       	mov	r25, r8
    11a4:	af 2e       	mov	r10, r31
    11a6:	be 2e       	mov	r11, r30
    11a8:	f7 d5       	rcall	.+3054   	; 0x1d98 <__subdi3>
    11aa:	22 2e       	mov	r2, r18
    11ac:	33 2e       	mov	r3, r19
    11ae:	44 2e       	mov	r4, r20
    11b0:	55 2e       	mov	r5, r21
    11b2:	66 2e       	mov	r6, r22
    11b4:	77 2e       	mov	r7, r23
    11b6:	88 2e       	mov	r8, r24
    11b8:	99 2e       	mov	r9, r25
    11ba:	30 91 c1 05 	lds	r19, 0x05C1	; 0x8005c1 <dig_H5+0x1>
    11be:	20 91 c0 05 	lds	r18, 0x05C0	; 0x8005c0 <dig_H5>
    11c2:	93 2f       	mov	r25, r19
    11c4:	99 0f       	add	r25, r25
    11c6:	99 0b       	sbc	r25, r25
    11c8:	af 88       	ldd	r10, Y+23	; 0x17
    11ca:	be 88       	ldd	r11, Y+22	; 0x16
    11cc:	c9 80       	ldd	r12, Y+1	; 0x01
    11ce:	d9 84       	ldd	r13, Y+9	; 0x09
    11d0:	ea 84       	ldd	r14, Y+10	; 0x0a
    11d2:	fb 84       	ldd	r15, Y+11	; 0x0b
    11d4:	0c 85       	ldd	r16, Y+12	; 0x0c
    11d6:	1d 85       	ldd	r17, Y+13	; 0x0d
    11d8:	49 2f       	mov	r20, r25
    11da:	59 2f       	mov	r21, r25
    11dc:	69 2f       	mov	r22, r25
    11de:	79 2f       	mov	r23, r25
    11e0:	89 2f       	mov	r24, r25
    11e2:	79 d4       	rcall	.+2290   	; 0x1ad6 <__muldi3>
    11e4:	a2 2e       	mov	r10, r18
    11e6:	b3 2e       	mov	r11, r19
    11e8:	c4 2e       	mov	r12, r20
    11ea:	d5 2e       	mov	r13, r21
    11ec:	e6 2e       	mov	r14, r22
    11ee:	f7 2e       	mov	r15, r23
    11f0:	08 2f       	mov	r16, r24
    11f2:	19 2f       	mov	r17, r25
    11f4:	22 2d       	mov	r18, r2
    11f6:	33 2d       	mov	r19, r3
    11f8:	44 2d       	mov	r20, r4
    11fa:	55 2d       	mov	r21, r5
    11fc:	66 2d       	mov	r22, r6
    11fe:	77 2d       	mov	r23, r7
    1200:	88 2d       	mov	r24, r8
    1202:	99 2d       	mov	r25, r9
    1204:	c9 d5       	rcall	.+2962   	; 0x1d98 <__subdi3>
    1206:	30 5c       	subi	r19, 0xC0	; 192
    1208:	4f 4f       	sbci	r20, 0xFF	; 255
    120a:	5f 4f       	sbci	r21, 0xFF	; 255
    120c:	6f 4f       	sbci	r22, 0xFF	; 255
    120e:	7f 4f       	sbci	r23, 0xFF	; 255
    1210:	8f 4f       	sbci	r24, 0xFF	; 255
    1212:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1214:	0f e0       	ldi	r16, 0x0F	; 15
    1216:	99 d5       	rcall	.+2866   	; 0x1d4a <__ashrdi3>
    1218:	2e 87       	std	Y+14, r18	; 0x0e
    121a:	3f 87       	std	Y+15, r19	; 0x0f
    121c:	48 8b       	std	Y+16, r20	; 0x10
    121e:	59 8b       	std	Y+17, r21	; 0x11
    1220:	6a 8b       	std	Y+18, r22	; 0x12
    1222:	7b 8b       	std	Y+19, r23	; 0x13
    1224:	8c 8b       	std	Y+20, r24	; 0x14
    1226:	9d 8b       	std	Y+21, r25	; 0x15
    1228:	30 91 ac 05 	lds	r19, 0x05AC	; 0x8005ac <dig_H6+0x1>
    122c:	20 91 ab 05 	lds	r18, 0x05AB	; 0x8005ab <dig_H6>
    1230:	93 2f       	mov	r25, r19
    1232:	99 0f       	add	r25, r25
    1234:	99 0b       	sbc	r25, r25
    1236:	af 88       	ldd	r10, Y+23	; 0x17
    1238:	be 88       	ldd	r11, Y+22	; 0x16
    123a:	c9 80       	ldd	r12, Y+1	; 0x01
    123c:	d9 84       	ldd	r13, Y+9	; 0x09
    123e:	ea 84       	ldd	r14, Y+10	; 0x0a
    1240:	fb 84       	ldd	r15, Y+11	; 0x0b
    1242:	0c 85       	ldd	r16, Y+12	; 0x0c
    1244:	1d 85       	ldd	r17, Y+13	; 0x0d
    1246:	49 2f       	mov	r20, r25
    1248:	59 2f       	mov	r21, r25
    124a:	69 2f       	mov	r22, r25
    124c:	79 2f       	mov	r23, r25
    124e:	89 2f       	mov	r24, r25
    1250:	42 d4       	rcall	.+2180   	; 0x1ad6 <__muldi3>
    1252:	0a e0       	ldi	r16, 0x0A	; 10
    1254:	7a d5       	rcall	.+2804   	; 0x1d4a <__ashrdi3>
    1256:	82 2e       	mov	r8, r18
    1258:	93 2e       	mov	r9, r19
    125a:	74 2e       	mov	r7, r20
    125c:	65 2e       	mov	r6, r21
    125e:	56 2e       	mov	r5, r22
    1260:	47 2e       	mov	r4, r23
    1262:	38 2e       	mov	r3, r24
    1264:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1266:	40 91 c2 05 	lds	r20, 0x05C2	; 0x8005c2 <dig_H3>
    126a:	50 91 c3 05 	lds	r21, 0x05C3	; 0x8005c3 <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    126e:	0c 85       	ldd	r16, Y+12	; 0x0c
    1270:	24 2f       	mov	r18, r20
    1272:	35 2f       	mov	r19, r21
    1274:	40 e0       	ldi	r20, 0x00	; 0
    1276:	50 e0       	ldi	r21, 0x00	; 0
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	70 e0       	ldi	r23, 0x00	; 0
    127c:	80 e0       	ldi	r24, 0x00	; 0
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	2a d4       	rcall	.+2132   	; 0x1ad6 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1282:	0b e0       	ldi	r16, 0x0B	; 11
    1284:	62 d5       	rcall	.+2756   	; 0x1d4a <__ashrdi3>
    1286:	30 58       	subi	r19, 0x80	; 128
    1288:	4f 4f       	sbci	r20, 0xFF	; 255
    128a:	5f 4f       	sbci	r21, 0xFF	; 255
    128c:	6f 4f       	sbci	r22, 0xFF	; 255
    128e:	7f 4f       	sbci	r23, 0xFF	; 255
    1290:	8f 4f       	sbci	r24, 0xFF	; 255
    1292:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1294:	a2 2e       	mov	r10, r18
    1296:	b3 2e       	mov	r11, r19
    1298:	c4 2e       	mov	r12, r20
    129a:	d5 2e       	mov	r13, r21
    129c:	e6 2e       	mov	r14, r22
    129e:	f7 2e       	mov	r15, r23
    12a0:	08 2f       	mov	r16, r24
    12a2:	19 2f       	mov	r17, r25
    12a4:	28 2d       	mov	r18, r8
    12a6:	39 2d       	mov	r19, r9
    12a8:	47 2d       	mov	r20, r7
    12aa:	56 2d       	mov	r21, r6
    12ac:	65 2d       	mov	r22, r5
    12ae:	74 2d       	mov	r23, r4
    12b0:	83 2d       	mov	r24, r3
    12b2:	92 2d       	mov	r25, r2
    12b4:	10 d4       	rcall	.+2080   	; 0x1ad6 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12b6:	0a e0       	ldi	r16, 0x0A	; 10
    12b8:	48 d5       	rcall	.+2704   	; 0x1d4a <__ashrdi3>
    12ba:	40 5e       	subi	r20, 0xE0	; 224
    12bc:	5f 4f       	sbci	r21, 0xFF	; 255
    12be:	6f 4f       	sbci	r22, 0xFF	; 255
    12c0:	7f 4f       	sbci	r23, 0xFF	; 255
    12c2:	8f 4f       	sbci	r24, 0xFF	; 255
    12c4:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
    12c6:	b0 90 cb 05 	lds	r11, 0x05CB	; 0x8005cb <dig_H2+0x1>
    12ca:	a0 90 ca 05 	lds	r10, 0x05CA	; 0x8005ca <dig_H2>
    12ce:	1b 2d       	mov	r17, r11
    12d0:	11 0f       	add	r17, r17
    12d2:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12d4:	c1 2e       	mov	r12, r17
    12d6:	d1 2e       	mov	r13, r17
    12d8:	e1 2e       	mov	r14, r17
    12da:	f1 2e       	mov	r15, r17
    12dc:	01 2f       	mov	r16, r17
    12de:	fb d3       	rcall	.+2038   	; 0x1ad6 <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    12e0:	30 5e       	subi	r19, 0xE0	; 224
    12e2:	4f 4f       	sbci	r20, 0xFF	; 255
    12e4:	5f 4f       	sbci	r21, 0xFF	; 255
    12e6:	6f 4f       	sbci	r22, 0xFF	; 255
    12e8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ea:	8f 4f       	sbci	r24, 0xFF	; 255
    12ec:	9f 4f       	sbci	r25, 0xFF	; 255
    12ee:	0e e0       	ldi	r16, 0x0E	; 14
    12f0:	2c d5       	rcall	.+2648   	; 0x1d4a <__ashrdi3>
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    12f2:	a2 2e       	mov	r10, r18
    12f4:	b3 2e       	mov	r11, r19
    12f6:	c4 2e       	mov	r12, r20
    12f8:	d5 2e       	mov	r13, r21
    12fa:	e6 2e       	mov	r14, r22
    12fc:	f7 2e       	mov	r15, r23
    12fe:	08 2f       	mov	r16, r24
    1300:	19 2f       	mov	r17, r25
    1302:	2e 85       	ldd	r18, Y+14	; 0x0e
    1304:	3f 85       	ldd	r19, Y+15	; 0x0f
    1306:	48 89       	ldd	r20, Y+16	; 0x10
    1308:	59 89       	ldd	r21, Y+17	; 0x11
    130a:	6a 89       	ldd	r22, Y+18	; 0x12
    130c:	7b 89       	ldd	r23, Y+19	; 0x13
    130e:	8c 89       	ldd	r24, Y+20	; 0x14
    1310:	9d 89       	ldd	r25, Y+21	; 0x15
    1312:	e1 d3       	rcall	.+1986   	; 0x1ad6 <__muldi3>
    1314:	42 2e       	mov	r4, r18
    1316:	53 2e       	mov	r5, r19
    1318:	64 2e       	mov	r6, r20
    131a:	75 2e       	mov	r7, r21
    131c:	86 2e       	mov	r8, r22
    131e:	97 2e       	mov	r9, r23
    1320:	28 2e       	mov	r2, r24
    1322:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1324:	0f e0       	ldi	r16, 0x0F	; 15
    1326:	11 d5       	rcall	.+2594   	; 0x1d4a <__ashrdi3>
    1328:	a2 2e       	mov	r10, r18
    132a:	b3 2e       	mov	r11, r19
    132c:	c4 2e       	mov	r12, r20
    132e:	d5 2e       	mov	r13, r21
    1330:	e6 2e       	mov	r14, r22
    1332:	f7 2e       	mov	r15, r23
    1334:	08 2f       	mov	r16, r24
    1336:	19 2f       	mov	r17, r25
    1338:	ce d3       	rcall	.+1948   	; 0x1ad6 <__muldi3>
    133a:	07 e0       	ldi	r16, 0x07	; 7
    133c:	06 d5       	rcall	.+2572   	; 0x1d4a <__ashrdi3>
    133e:	e0 91 96 05 	lds	r30, 0x0596	; 0x800596 <dig_H1>
    1342:	f0 91 97 05 	lds	r31, 0x0597	; 0x800597 <dig_H1+0x1>
    1346:	5f 01       	movw	r10, r30
    1348:	c1 2c       	mov	r12, r1
    134a:	d1 2c       	mov	r13, r1
    134c:	e1 2c       	mov	r14, r1
    134e:	f1 2c       	mov	r15, r1
    1350:	87 01       	movw	r16, r14
    1352:	e9 83       	std	Y+1, r30	; 0x01
    1354:	ba 82       	std	Y+2, r11	; 0x02
    1356:	cb 82       	std	Y+3, r12	; 0x03
    1358:	dc 82       	std	Y+4, r13	; 0x04
    135a:	ed 82       	std	Y+5, r14	; 0x05
    135c:	fe 82       	std	Y+6, r15	; 0x06
    135e:	0f 83       	std	Y+7, r16	; 0x07
    1360:	18 87       	std	Y+8, r17	; 0x08
    1362:	c1 2c       	mov	r12, r1
    1364:	d1 2c       	mov	r13, r1
    1366:	e1 2c       	mov	r14, r1
    1368:	f1 2c       	mov	r15, r1
    136a:	00 e0       	ldi	r16, 0x00	; 0
    136c:	10 e0       	ldi	r17, 0x00	; 0
    136e:	b3 d3       	rcall	.+1894   	; 0x1ad6 <__muldi3>
    1370:	04 e0       	ldi	r16, 0x04	; 4
    1372:	eb d4       	rcall	.+2518   	; 0x1d4a <__ashrdi3>
    1374:	a2 2e       	mov	r10, r18
    1376:	b3 2e       	mov	r11, r19
    1378:	c4 2e       	mov	r12, r20
    137a:	d5 2e       	mov	r13, r21
    137c:	e6 2e       	mov	r14, r22
    137e:	f7 2e       	mov	r15, r23
    1380:	08 2f       	mov	r16, r24
    1382:	19 2f       	mov	r17, r25
    1384:	24 2d       	mov	r18, r4
    1386:	35 2d       	mov	r19, r5
    1388:	46 2d       	mov	r20, r6
    138a:	57 2d       	mov	r21, r7
    138c:	68 2d       	mov	r22, r8
    138e:	79 2d       	mov	r23, r9
    1390:	82 2d       	mov	r24, r2
    1392:	93 2d       	mov	r25, r3
    1394:	01 d5       	rcall	.+2562   	; 0x1d98 <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    1396:	f2 2e       	mov	r15, r18
    1398:	03 2f       	mov	r16, r19
    139a:	14 2f       	mov	r17, r20
    139c:	65 2e       	mov	r6, r21
    139e:	76 2e       	mov	r7, r22
    13a0:	b7 2f       	mov	r27, r23
    13a2:	f8 2f       	mov	r31, r24
    13a4:	e9 2f       	mov	r30, r25
    13a6:	a0 e0       	ldi	r26, 0x00	; 0
    13a8:	00 d5       	rcall	.+2560   	; 0x1daa <__cmpdi2_s8>
    13aa:	44 f4       	brge	.+16     	; 0x13bc <bme280_compensate_H_int32+0x2f4>
    13ac:	f1 2c       	mov	r15, r1
    13ae:	00 e0       	ldi	r16, 0x00	; 0
    13b0:	10 e0       	ldi	r17, 0x00	; 0
    13b2:	61 2c       	mov	r6, r1
    13b4:	71 2c       	mov	r7, r1
    13b6:	b0 e0       	ldi	r27, 0x00	; 0
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    13bc:	8f 2c       	mov	r8, r15
    13be:	90 2e       	mov	r9, r16
    13c0:	a1 2e       	mov	r10, r17
    13c2:	b6 2c       	mov	r11, r6
    13c4:	c7 2c       	mov	r12, r7
    13c6:	db 2e       	mov	r13, r27
    13c8:	ef 2e       	mov	r14, r31
    13ca:	ae 2f       	mov	r26, r30
    13cc:	2f 2d       	mov	r18, r15
    13ce:	30 2f       	mov	r19, r16
    13d0:	41 2f       	mov	r20, r17
    13d2:	56 2d       	mov	r21, r6
    13d4:	67 2d       	mov	r22, r7
    13d6:	7b 2f       	mov	r23, r27
    13d8:	8f 2f       	mov	r24, r31
    13da:	9e 2f       	mov	r25, r30
    13dc:	21 15       	cp	r18, r1
    13de:	31 05       	cpc	r19, r1
    13e0:	41 05       	cpc	r20, r1
    13e2:	59 41       	sbci	r21, 0x19	; 25
    13e4:	61 05       	cpc	r22, r1
    13e6:	71 05       	cpc	r23, r1
    13e8:	81 05       	cpc	r24, r1
    13ea:	91 05       	cpc	r25, r1
    13ec:	61 f0       	breq	.+24     	; 0x1406 <bme280_compensate_H_int32+0x33e>
    13ee:	5c f0       	brlt	.+22     	; 0x1406 <bme280_compensate_H_int32+0x33e>
    13f0:	81 2c       	mov	r8, r1
    13f2:	91 2c       	mov	r9, r1
    13f4:	a1 2c       	mov	r10, r1
    13f6:	0f 2e       	mov	r0, r31
    13f8:	f9 e1       	ldi	r31, 0x19	; 25
    13fa:	bf 2e       	mov	r11, r31
    13fc:	f0 2d       	mov	r31, r0
    13fe:	c1 2c       	mov	r12, r1
    1400:	d1 2c       	mov	r13, r1
    1402:	e1 2c       	mov	r14, r1
    1404:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    1406:	28 2d       	mov	r18, r8
    1408:	39 2d       	mov	r19, r9
    140a:	4a 2d       	mov	r20, r10
    140c:	5b 2d       	mov	r21, r11
    140e:	6c 2d       	mov	r22, r12
    1410:	7d 2d       	mov	r23, r13
    1412:	8e 2d       	mov	r24, r14
    1414:	9a 2f       	mov	r25, r26
    1416:	0c e0       	ldi	r16, 0x0C	; 12
    1418:	98 d4       	rcall	.+2352   	; 0x1d4a <__ashrdi3>
    141a:	62 2f       	mov	r22, r18
    141c:	73 2f       	mov	r23, r19
    141e:	84 2f       	mov	r24, r20
    1420:	95 2f       	mov	r25, r21
}
    1422:	67 96       	adiw	r28, 0x17	; 23
    1424:	0f b6       	in	r0, 0x3f	; 63
    1426:	f8 94       	cli
    1428:	de bf       	out	0x3e, r29	; 62
    142a:	0f be       	out	0x3f, r0	; 63
    142c:	cd bf       	out	0x3d, r28	; 61
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	ff 90       	pop	r15
    1438:	ef 90       	pop	r14
    143a:	df 90       	pop	r13
    143c:	cf 90       	pop	r12
    143e:	bf 90       	pop	r11
    1440:	af 90       	pop	r10
    1442:	9f 90       	pop	r9
    1444:	8f 90       	pop	r8
    1446:	7f 90       	pop	r7
    1448:	6f 90       	pop	r6
    144a:	5f 90       	pop	r5
    144c:	4f 90       	pop	r4
    144e:	3f 90       	pop	r3
    1450:	2f 90       	pop	r2
    1452:	08 95       	ret

00001454 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    1454:	0e 94 54 01 	call	0x2a8	; 0x2a8 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    1458:	10 92 b9 05 	sts	0x05B9, r1	; 0x8005b9 <seconds+0x1>
    145c:	10 92 b8 05 	sts	0x05B8, r1	; 0x8005b8 <seconds>
	ItsTime=0;
    1460:	10 92 1e 04 	sts	0x041E, r1	; 0x80041e <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout0;
    1464:	8b e2       	ldi	r24, 0x2B	; 43
    1466:	91 e0       	ldi	r25, 0x01	; 1
    1468:	90 93 d3 07 	sts	0x07D3, r25	; 0x8007d3 <__iob+0x3>
    146c:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
    1470:	19 d1       	rcall	.+562    	; 0x16a4 <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    1472:	81 e8       	ldi	r24, 0x81	; 129
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	12 d2       	rcall	.+1060   	; 0x189c <USART0_init>
	USART1_init(MYUBRR1);
    1478:	81 e8       	ldi	r24, 0x81	; 129
    147a:	90 e0       	ldi	r25, 0x00	; 0
    147c:	83 d2       	rcall	.+1286   	; 0x1984 <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    147e:	35 d1       	rcall	.+618    	; 0x16ea <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    1480:	0e 94 b6 00 	call	0x16c	; 0x16c <ADC_init>
	//
	// FOR DEBUG ONLY: Initialize the RGB sensor - Craig uses this to ensure I2C is working
//	RGBsensor_init();
	//
 	// initialize the gas sensors
	gas_sensors_init();
    1484:	0e 94 a1 01 	call	0x342	; 0x342 <gas_sensors_init>
	// 
	// Start all interrupts
	sei();
    1488:	78 94       	sei
	//
	// Initialize the pressure / temperature /  humidity sensor
	// BME280_init(); 
	//
	// Check the BME interface...
	bme280basic_init();
    148a:	0d da       	rcall	.-3046   	; 0x8a6 <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	91 e0       	ldi	r25, 0x01	; 1
    1490:	42 d2       	rcall	.+1156   	; 0x1916 <USART0_putstring>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1492:	2f e7       	ldi	r18, 0x7F	; 127
    1494:	84 e8       	ldi	r24, 0x84	; 132
    1496:	9e e1       	ldi	r25, 0x1E	; 30
    1498:	21 50       	subi	r18, 0x01	; 1
    149a:	80 40       	sbci	r24, 0x00	; 0
    149c:	90 40       	sbci	r25, 0x00	; 0
    149e:	e1 f7       	brne	.-8      	; 0x1498 <main+0x44>
    14a0:	00 c0       	rjmp	.+0      	; 0x14a2 <main+0x4e>
    14a2:	00 00       	nop
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
    printf("hi ");
    14a4:	8a e3       	ldi	r24, 0x3A	; 58
    14a6:	91 e0       	ldi	r25, 0x01	; 1
    14a8:	9f 93       	push	r25
    14aa:	8f 93       	push	r24
    14ac:	99 d4       	rcall	.+2354   	; 0x1de0 <printf>
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u \n", seconds);
    14b2:	0f 2e       	mov	r0, r31
    14b4:	fe e3       	ldi	r31, 0x3E	; 62
    14b6:	af 2e       	mov	r10, r31
    14b8:	f1 e0       	ldi	r31, 0x01	; 1
    14ba:	bf 2e       	mov	r11, r31
    14bc:	f0 2d       	mov	r31, r0
    14be:	c4 e0       	ldi	r28, 0x04	; 4
    14c0:	d7 e0       	ldi	r29, 0x07	; 7
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
    14c2:	0f 2e       	mov	r0, r31
    14c4:	fe e4       	ldi	r31, 0x4E	; 78
    14c6:	cf 2e       	mov	r12, r31
    14c8:	f1 e0       	ldi	r31, 0x01	; 1
    14ca:	df 2e       	mov	r13, r31
    14cc:	f0 2d       	mov	r31, r0
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    14ce:	0d e3       	ldi	r16, 0x3D	; 61
    14d0:	14 e0       	ldi	r17, 0x04	; 4
    14d2:	0f 2e       	mov	r0, r31
    14d4:	f3 e6       	ldi	r31, 0x63	; 99
    14d6:	ef 2e       	mov	r14, r31
    14d8:	f1 e0       	ldi	r31, 0x01	; 1
    14da:	ff 2e       	mov	r15, r31
    14dc:	f0 2d       	mov	r31, r0
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
    14de:	0f 2e       	mov	r0, r31
    14e0:	f9 e7       	ldi	r31, 0x79	; 121
    14e2:	6f 2e       	mov	r6, r31
    14e4:	f1 e0       	ldi	r31, 0x01	; 1
    14e6:	7f 2e       	mov	r7, r31
    14e8:	f0 2d       	mov	r31, r0
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
    14ea:	0f 2e       	mov	r0, r31
    14ec:	f8 e8       	ldi	r31, 0x88	; 136
    14ee:	4f 2e       	mov	r4, r31
    14f0:	f1 e0       	ldi	r31, 0x01	; 1
    14f2:	5f 2e       	mov	r5, r31
    14f4:	f0 2d       	mov	r31, r0
 			printf("\nMethane = %u", raw_gas_vector[3]);
    14f6:	0f 2e       	mov	r0, r31
    14f8:	f6 e9       	ldi	r31, 0x96	; 150
    14fa:	2f 2e       	mov	r2, r31
    14fc:	f1 e0       	ldi	r31, 0x01	; 1
    14fe:	3f 2e       	mov	r3, r31
    1500:	f0 2d       	mov	r31, r0
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
    1502:	80 91 1e 04 	lds	r24, 0x041E	; 0x80041e <ItsTime>
    1506:	81 30       	cpi	r24, 0x01	; 1
    1508:	e1 f7       	brne	.-8      	; 0x1502 <main+0xae>
			ItsTime = 0; 
    150a:	10 92 1e 04 	sts	0x041E, r1	; 0x80041e <ItsTime>
			seconds++;
    150e:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <seconds>
    1512:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <seconds+0x1>
    1516:	01 96       	adiw	r24, 0x01	; 1
    1518:	90 93 b9 05 	sts	0x05B9, r25	; 0x8005b9 <seconds+0x1>
    151c:	80 93 b8 05 	sts	0x05B8, r24	; 0x8005b8 <seconds>
			printf("\nSeconds = %u \n", seconds);
    1520:	80 91 b8 05 	lds	r24, 0x05B8	; 0x8005b8 <seconds>
    1524:	90 91 b9 05 	lds	r25, 0x05B9	; 0x8005b9 <seconds+0x1>
    1528:	9f 93       	push	r25
    152a:	8f 93       	push	r24
    152c:	bf 92       	push	r11
    152e:	af 92       	push	r10
    1530:	57 d4       	rcall	.+2222   	; 0x1de0 <printf>
    1532:	0f 2e       	mov	r0, r31
    1534:	f0 ed       	ldi	r31, 0xD0	; 208
    1536:	8f 2e       	mov	r8, r31
    1538:	f6 e0       	ldi	r31, 0x06	; 6
    153a:	9f 2e       	mov	r9, r31
    153c:	f0 2d       	mov	r31, r0
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 51; i++)
			{
				USART0_TransmitByte(messageWant[i]);
    1546:	d4 01       	movw	r26, r8
    1548:	8d 91       	ld	r24, X+
    154a:	4d 01       	movw	r8, r26
    154c:	ba d1       	rcall	.+884    	; 0x18c2 <USART0_TransmitByte>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 51; i++)
    154e:	8c 16       	cp	r8, r28
    1550:	9d 06       	cpc	r9, r29
    1552:	c9 f7       	brne	.-14     	; 0x1546 <main+0xf2>
			printf("\n=================");
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
    1554:	15 d8       	rcall	.-4054   	; 0x580 <LIDAR_distance>
    1556:	80 93 38 04 	sts	0x0438, r24	; 0x800438 <distance>
    155a:	90 93 39 04 	sts	0x0439, r25	; 0x800439 <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
    155e:	9f 93       	push	r25
    1560:	8f 93       	push	r24
    1562:	df 92       	push	r13
    1564:	cf 92       	push	r12
    1566:	3c d4       	rcall	.+2168   	; 0x1de0 <printf>
			// Davita has this routine specified in the notebook.
			//============================
			//
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    1568:	0e 94 20 02 	call	0x440	; 0x440 <start_gas_sensor_read>
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    156c:	f8 01       	movw	r30, r16
    156e:	81 81       	ldd	r24, Z+1	; 0x01
    1570:	8f 93       	push	r24
    1572:	80 81       	ld	r24, Z
    1574:	8f 93       	push	r24
    1576:	ff 92       	push	r15
    1578:	ef 92       	push	r14
    157a:	32 d4       	rcall	.+2148   	; 0x1de0 <printf>
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
    157c:	d8 01       	movw	r26, r16
    157e:	13 96       	adiw	r26, 0x03	; 3
    1580:	8c 91       	ld	r24, X
    1582:	13 97       	sbiw	r26, 0x03	; 3
    1584:	8f 93       	push	r24
    1586:	12 96       	adiw	r26, 0x02	; 2
    1588:	8c 91       	ld	r24, X
    158a:	8f 93       	push	r24
    158c:	7f 92       	push	r7
    158e:	6f 92       	push	r6
    1590:	27 d4       	rcall	.+2126   	; 0x1de0 <printf>
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
    1592:	f8 01       	movw	r30, r16
    1594:	85 81       	ldd	r24, Z+5	; 0x05
    1596:	8f 93       	push	r24
    1598:	84 81       	ldd	r24, Z+4	; 0x04
    159a:	8f 93       	push	r24
    159c:	5f 92       	push	r5
    159e:	4f 92       	push	r4
    15a0:	1f d4       	rcall	.+2110   	; 0x1de0 <printf>
 			printf("\nMethane = %u", raw_gas_vector[3]);
    15a2:	d8 01       	movw	r26, r16
    15a4:	17 96       	adiw	r26, 0x07	; 7
    15a6:	8c 91       	ld	r24, X
    15a8:	17 97       	sbiw	r26, 0x07	; 7
    15aa:	8f 93       	push	r24
    15ac:	16 96       	adiw	r26, 0x06	; 6
    15ae:	8c 91       	ld	r24, X
    15b0:	8f 93       	push	r24
    15b2:	3f 92       	push	r3
    15b4:	2f 92       	push	r2
    15b6:	14 d4       	rcall	.+2088   	; 0x1de0 <printf>
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
    15b8:	f8 01       	movw	r30, r16
    15ba:	81 85       	ldd	r24, Z+9	; 0x09
    15bc:	8f 93       	push	r24
    15be:	80 85       	ldd	r24, Z+8	; 0x08
    15c0:	8f 93       	push	r24
    15c2:	a4 ea       	ldi	r26, 0xA4	; 164
    15c4:	b1 e0       	ldi	r27, 0x01	; 1
    15c6:	bf 93       	push	r27
    15c8:	af 93       	push	r26
    15ca:	0a d4       	rcall	.+2068   	; 0x1de0 <printf>
			// Now test the BME interface...
			// THIS ROUTINE NOT YET WRITTEN
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
    15cc:	c8 d9       	rcall	.-3184   	; 0x95e <bme280basic_bulk_data_read>
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    15ce:	60 91 9c 05 	lds	r22, 0x059C	; 0x80059c <rawTemp>
    15d2:	70 91 9d 05 	lds	r23, 0x059D	; 0x80059d <rawTemp+0x1>
    15d6:	80 91 9e 05 	lds	r24, 0x059E	; 0x80059e <rawTemp+0x2>
    15da:	90 91 9f 05 	lds	r25, 0x059F	; 0x80059f <rawTemp+0x3>
    15de:	a2 da       	rcall	.-2748   	; 0xb24 <BME280_compensate_T_int32>
    15e0:	60 93 92 05 	sts	0x0592, r22	; 0x800592 <tempCelsius>
    15e4:	70 93 93 05 	sts	0x0593, r23	; 0x800593 <tempCelsius+0x1>
    15e8:	80 93 94 05 	sts	0x0594, r24	; 0x800594 <tempCelsius+0x2>
    15ec:	90 93 95 05 	sts	0x0595, r25	; 0x800595 <tempCelsius+0x3>
 			printf("\nCelsius = %lu\n", tempCelsius);
    15f0:	9f 93       	push	r25
    15f2:	8f 93       	push	r24
    15f4:	7f 93       	push	r23
    15f6:	6f 93       	push	r22
    15f8:	a1 eb       	ldi	r26, 0xB1	; 177
    15fa:	b1 e0       	ldi	r27, 0x01	; 1
    15fc:	bf 93       	push	r27
    15fe:	af 93       	push	r26
    1600:	ef d3       	rcall	.+2014   	; 0x1de0 <printf>
			pressure = BME280_compensate_P_int64(rawPress);
    1602:	60 91 b0 05 	lds	r22, 0x05B0	; 0x8005b0 <rawPress>
    1606:	70 91 b1 05 	lds	r23, 0x05B1	; 0x8005b1 <rawPress+0x1>
    160a:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <rawPress+0x2>
    160e:	90 91 b3 05 	lds	r25, 0x05B3	; 0x8005b3 <rawPress+0x3>
    1612:	13 db       	rcall	.-2522   	; 0xc3a <BME280_compensate_P_int64>
    1614:	60 93 a5 05 	sts	0x05A5, r22	; 0x8005a5 <pressure>
    1618:	70 93 a6 05 	sts	0x05A6, r23	; 0x8005a6 <pressure+0x1>
    161c:	80 93 a7 05 	sts	0x05A7, r24	; 0x8005a7 <pressure+0x2>
    1620:	90 93 a8 05 	sts	0x05A8, r25	; 0x8005a8 <pressure+0x3>
			printf("\nPressure in Pa = %lu\n", pressure/256);
    1624:	9b 01       	movw	r18, r22
    1626:	ac 01       	movw	r20, r24
    1628:	99 23       	and	r25, r25
    162a:	24 f4       	brge	.+8      	; 0x1634 <main+0x1e0>
    162c:	21 50       	subi	r18, 0x01	; 1
    162e:	3f 4f       	sbci	r19, 0xFF	; 255
    1630:	4f 4f       	sbci	r20, 0xFF	; 255
    1632:	5f 4f       	sbci	r21, 0xFF	; 255
    1634:	bb 27       	eor	r27, r27
    1636:	57 fd       	sbrc	r21, 7
    1638:	ba 95       	dec	r27
    163a:	a5 2f       	mov	r26, r21
    163c:	94 2f       	mov	r25, r20
    163e:	83 2f       	mov	r24, r19
    1640:	bf 93       	push	r27
    1642:	af 93       	push	r26
    1644:	9f 93       	push	r25
    1646:	8f 93       	push	r24
    1648:	a1 ec       	ldi	r26, 0xC1	; 193
    164a:	b1 e0       	ldi	r27, 0x01	; 1
    164c:	bf 93       	push	r27
    164e:	af 93       	push	r26
    1650:	c7 d3       	rcall	.+1934   	; 0x1de0 <printf>
			temperature = bme280_compensate_H_int32(rawHum);
    1652:	8d b7       	in	r24, 0x3d	; 61
    1654:	9e b7       	in	r25, 0x3e	; 62
    1656:	84 96       	adiw	r24, 0x24	; 36
    1658:	0f b6       	in	r0, 0x3f	; 63
    165a:	f8 94       	cli
    165c:	9e bf       	out	0x3e, r25	; 62
    165e:	0f be       	out	0x3f, r0	; 63
    1660:	8d bf       	out	0x3d, r24	; 61
    1662:	60 91 b4 05 	lds	r22, 0x05B4	; 0x8005b4 <rawHum>
    1666:	70 91 b5 05 	lds	r23, 0x05B5	; 0x8005b5 <rawHum+0x1>
    166a:	80 91 b6 05 	lds	r24, 0x05B6	; 0x8005b6 <rawHum+0x2>
    166e:	90 91 b7 05 	lds	r25, 0x05B7	; 0x8005b7 <rawHum+0x3>
    1672:	2a dd       	rcall	.-1452   	; 0x10c8 <bme280_compensate_H_int32>
    1674:	60 93 98 05 	sts	0x0598, r22	; 0x800598 <temperature>
    1678:	70 93 99 05 	sts	0x0599, r23	; 0x800599 <temperature+0x1>
    167c:	80 93 9a 05 	sts	0x059A, r24	; 0x80059a <temperature+0x2>
    1680:	90 93 9b 05 	sts	0x059B, r25	; 0x80059b <temperature+0x3>
			printf("\n Humidity = %lu\n", temperature);
    1684:	9f 93       	push	r25
    1686:	8f 93       	push	r24
    1688:	7f 93       	push	r23
    168a:	6f 93       	push	r22
    168c:	a8 ed       	ldi	r26, 0xD8	; 216
    168e:	b1 e0       	ldi	r27, 0x01	; 1
    1690:	bf 93       	push	r27
    1692:	af 93       	push	r26
    1694:	a5 d3       	rcall	.+1866   	; 0x1de0 <printf>
    1696:	0f 90       	pop	r0
    1698:	0f 90       	pop	r0
    169a:	0f 90       	pop	r0
    169c:	0f 90       	pop	r0
    169e:	0f 90       	pop	r0
    16a0:	0f 90       	pop	r0
    16a2:	2f cf       	rjmp	.-418    	; 0x1502 <main+0xae>

000016a4 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    16a4:	8d e0       	ldi	r24, 0x0D	; 13
    16a6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    16aa:	8a e4       	ldi	r24, 0x4A	; 74
    16ac:	9c e4       	ldi	r25, 0x4C	; 76
    16ae:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16b2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
    16b6:	82 e0       	ldi	r24, 0x02	; 2
    16b8:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    16bc:	08 95       	ret

000016be <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    16be:	18 95       	reti

000016c0 <__vector_13>:
}
*/


ISR(TIMER1_COMPA_vect)
{
    16c0:	1f 92       	push	r1
    16c2:	0f 92       	push	r0
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	0f 92       	push	r0
    16c8:	11 24       	eor	r1, r1
    16ca:	8f 93       	push	r24
    16cc:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    16ce:	95 b1       	in	r25, 0x05	; 5
    16d0:	82 e0       	ldi	r24, 0x02	; 2
    16d2:	89 27       	eor	r24, r25
    16d4:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	80 93 1e 04 	sts	0x041E, r24	; 0x80041e <ItsTime>
}
    16dc:	9f 91       	pop	r25
    16de:	8f 91       	pop	r24
    16e0:	0f 90       	pop	r0
    16e2:	0f be       	out	0x3f, r0	; 63
    16e4:	0f 90       	pop	r0
    16e6:	1f 90       	pop	r1
    16e8:	18 95       	reti

000016ea <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    16ea:	81 e1       	ldi	r24, 0x11	; 17
    16ec:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    16f0:	8f ef       	ldi	r24, 0xFF	; 255
    16f2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    16f6:	84 e0       	ldi	r24, 0x04	; 4
    16f8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    16fc:	08 95       	ret

000016fe <TWI_Transceiver_Busy>:
    16fe:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1702:	81 78       	andi	r24, 0x81	; 129
    1704:	08 95       	ret

00001706 <TWI_Start_Transceiver_With_Data>:
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	ec 01       	movw	r28, r24
    170c:	ec eb       	ldi	r30, 0xBC	; 188
    170e:	f0 e0       	ldi	r31, 0x00	; 0
    1710:	90 81       	ld	r25, Z
    1712:	91 78       	andi	r25, 0x81	; 129
    1714:	e9 f7       	brne	.-6      	; 0x1710 <TWI_Start_Transceiver_With_Data+0xa>
    1716:	60 93 f0 01 	sts	0x01F0, r22	; 0x8001f0 <TWI_msgSize>
    171a:	88 81       	ld	r24, Y
    171c:	80 93 f1 01 	sts	0x01F1, r24	; 0x8001f1 <TWI_buf>
    1720:	80 fd       	sbrc	r24, 0
    1722:	12 c0       	rjmp	.+36     	; 0x1748 <TWI_Start_Transceiver_With_Data+0x42>
    1724:	62 30       	cpi	r22, 0x02	; 2
    1726:	80 f0       	brcs	.+32     	; 0x1748 <TWI_Start_Transceiver_With_Data+0x42>
    1728:	fe 01       	movw	r30, r28
    172a:	31 96       	adiw	r30, 0x01	; 1
    172c:	a2 ef       	ldi	r26, 0xF2	; 242
    172e:	b1 e0       	ldi	r27, 0x01	; 1
    1730:	62 50       	subi	r22, 0x02	; 2
    1732:	26 2f       	mov	r18, r22
    1734:	30 e0       	ldi	r19, 0x00	; 0
    1736:	2e 5f       	subi	r18, 0xFE	; 254
    1738:	3f 4f       	sbci	r19, 0xFF	; 255
    173a:	2c 0f       	add	r18, r28
    173c:	3d 1f       	adc	r19, r29
    173e:	91 91       	ld	r25, Z+
    1740:	9d 93       	st	X+, r25
    1742:	e2 17       	cp	r30, r18
    1744:	f3 07       	cpc	r31, r19
    1746:	d9 f7       	brne	.-10     	; 0x173e <TWI_Start_Transceiver_With_Data+0x38>
    1748:	10 92 ef 01 	sts	0x01EF, r1	; 0x8001ef <TWI_statusReg>
    174c:	88 ef       	ldi	r24, 0xF8	; 248
    174e:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    1752:	85 ea       	ldi	r24, 0xA5	; 165
    1754:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1758:	df 91       	pop	r29
    175a:	cf 91       	pop	r28
    175c:	08 95       	ret

0000175e <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    175e:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1760:	ec eb       	ldi	r30, 0xBC	; 188
    1762:	f0 e0       	ldi	r31, 0x00	; 0
    1764:	90 81       	ld	r25, Z
    1766:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1768:	e9 f7       	brne	.-6      	; 0x1764 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    176a:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <TWI_statusReg>
    176e:	80 ff       	sbrs	r24, 0
    1770:	11 c0       	rjmp	.+34     	; 0x1794 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1772:	66 23       	and	r22, r22
    1774:	79 f0       	breq	.+30     	; 0x1794 <TWI_Get_Data_From_Transceiver+0x36>
    1776:	a1 ef       	ldi	r26, 0xF1	; 241
    1778:	b1 e0       	ldi	r27, 0x01	; 1
    177a:	fa 01       	movw	r30, r20
    177c:	61 50       	subi	r22, 0x01	; 1
    177e:	26 2f       	mov	r18, r22
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	2f 5f       	subi	r18, 0xFF	; 255
    1784:	3f 4f       	sbci	r19, 0xFF	; 255
    1786:	24 0f       	add	r18, r20
    1788:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    178a:	9d 91       	ld	r25, X+
    178c:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    178e:	e2 17       	cp	r30, r18
    1790:	f3 07       	cpc	r31, r19
    1792:	d9 f7       	brne	.-10     	; 0x178a <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    1794:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <TWI_statusReg>
}
    1798:	81 70       	andi	r24, 0x01	; 1
    179a:	08 95       	ret

0000179c <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    179c:	1f 92       	push	r1
    179e:	0f 92       	push	r0
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	0f 92       	push	r0
    17a4:	11 24       	eor	r1, r1
    17a6:	2f 93       	push	r18
    17a8:	3f 93       	push	r19
    17aa:	8f 93       	push	r24
    17ac:	9f 93       	push	r25
    17ae:	af 93       	push	r26
    17b0:	bf 93       	push	r27
    17b2:	ef 93       	push	r30
    17b4:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    17b6:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    17ba:	8e 2f       	mov	r24, r30
    17bc:	90 e0       	ldi	r25, 0x00	; 0
    17be:	fc 01       	movw	r30, r24
    17c0:	38 97       	sbiw	r30, 0x08	; 8
    17c2:	e1 35       	cpi	r30, 0x51	; 81
    17c4:	f1 05       	cpc	r31, r1
    17c6:	08 f0       	brcs	.+2      	; 0x17ca <__vector_26+0x2e>
    17c8:	55 c0       	rjmp	.+170    	; 0x1874 <__vector_26+0xd8>
    17ca:	e2 5c       	subi	r30, 0xC2	; 194
    17cc:	ff 4f       	sbci	r31, 0xFF	; 255
    17ce:	6d c1       	rjmp	.+730    	; 0x1aaa <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    17d0:	10 92 ee 01 	sts	0x01EE, r1	; 0x8001ee <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    17d4:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <TWI_bufPtr.1555>
    17d8:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_msgSize>
    17dc:	e8 17       	cp	r30, r24
    17de:	70 f4       	brcc	.+28     	; 0x17fc <__vector_26+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    17e0:	81 e0       	ldi	r24, 0x01	; 1
    17e2:	8e 0f       	add	r24, r30
    17e4:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <TWI_bufPtr.1555>
    17e8:	f0 e0       	ldi	r31, 0x00	; 0
    17ea:	ef 50       	subi	r30, 0x0F	; 15
    17ec:	fe 4f       	sbci	r31, 0xFE	; 254
    17ee:	80 81       	ld	r24, Z
    17f0:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    17f4:	85 e8       	ldi	r24, 0x85	; 133
    17f6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17fa:	43 c0       	rjmp	.+134    	; 0x1882 <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    17fc:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <TWI_statusReg>
    1800:	81 60       	ori	r24, 0x01	; 1
    1802:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1806:	84 e9       	ldi	r24, 0x94	; 148
    1808:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    180c:	3a c0       	rjmp	.+116    	; 0x1882 <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    180e:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <TWI_bufPtr.1555>
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	8e 0f       	add	r24, r30
    1816:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <TWI_bufPtr.1555>
    181a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	ef 50       	subi	r30, 0x0F	; 15
    1822:	fe 4f       	sbci	r31, 0xFE	; 254
    1824:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1826:	20 91 ee 01 	lds	r18, 0x01EE	; 0x8001ee <TWI_bufPtr.1555>
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <TWI_msgSize>
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	01 97       	sbiw	r24, 0x01	; 1
    1834:	28 17       	cp	r18, r24
    1836:	39 07       	cpc	r19, r25
    1838:	24 f4       	brge	.+8      	; 0x1842 <__vector_26+0xa6>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    183a:	85 ec       	ldi	r24, 0xC5	; 197
    183c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1840:	20 c0       	rjmp	.+64     	; 0x1882 <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1842:	85 e8       	ldi	r24, 0x85	; 133
    1844:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1848:	1c c0       	rjmp	.+56     	; 0x1882 <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    184a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    184e:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <TWI_bufPtr.1555>
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	ef 50       	subi	r30, 0x0F	; 15
    1856:	fe 4f       	sbci	r31, 0xFE	; 254
    1858:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    185a:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <TWI_statusReg>
    185e:	81 60       	ori	r24, 0x01	; 1
    1860:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1864:	84 e9       	ldi	r24, 0x94	; 148
    1866:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    186a:	0b c0       	rjmp	.+22     	; 0x1882 <__vector_26+0xe6>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    186c:	85 ea       	ldi	r24, 0xA5	; 165
    186e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    1872:	07 c0       	rjmp	.+14     	; 0x1882 <__vector_26+0xe6>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    1874:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1878:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    187c:	84 e0       	ldi	r24, 0x04	; 4
    187e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    1882:	ff 91       	pop	r31
    1884:	ef 91       	pop	r30
    1886:	bf 91       	pop	r27
    1888:	af 91       	pop	r26
    188a:	9f 91       	pop	r25
    188c:	8f 91       	pop	r24
    188e:	3f 91       	pop	r19
    1890:	2f 91       	pop	r18
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63
    1896:	0f 90       	pop	r0
    1898:	1f 90       	pop	r1
    189a:	18 95       	reti

0000189c <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    189c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    18a0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    18a4:	88 e9       	ldi	r24, 0x98	; 152
    18a6:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    18aa:	8e e0       	ldi	r24, 0x0E	; 14
    18ac:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    18b0:	10 92 03 03 	sts	0x0303, r1	; 0x800303 <UART0_RxTail>
    18b4:	10 92 04 03 	sts	0x0304, r1	; 0x800304 <UART0_RxHead>
    18b8:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <UART0_TxTail>
    18bc:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <UART0_TxHead>
    18c0:	08 95       	ret

000018c2 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    18c2:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <UART0_TxHead>
    18c6:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    18c8:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <UART0_TxTail>
    18cc:	29 17       	cp	r18, r25
    18ce:	e1 f3       	breq	.-8      	; 0x18c8 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    18d0:	e2 2f       	mov	r30, r18
    18d2:	f0 e0       	ldi	r31, 0x00	; 0
    18d4:	ed 5f       	subi	r30, 0xFD	; 253
    18d6:	fd 4f       	sbci	r31, 0xFD	; 253
    18d8:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    18da:	20 93 02 02 	sts	0x0202, r18	; 0x800202 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    18de:	e1 ec       	ldi	r30, 0xC1	; 193
    18e0:	f0 e0       	ldi	r31, 0x00	; 0
    18e2:	80 81       	ld	r24, Z
    18e4:	80 62       	ori	r24, 0x20	; 32
    18e6:	80 83       	st	Z, r24
    18e8:	08 95       	ret

000018ea <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    18ea:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <UART0_TxHead>
    18ee:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    18f0:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <UART0_TxTail>
    18f4:	29 17       	cp	r18, r25
    18f6:	e1 f3       	breq	.-8      	; 0x18f0 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    18f8:	e2 2f       	mov	r30, r18
    18fa:	f0 e0       	ldi	r31, 0x00	; 0
    18fc:	ed 5f       	subi	r30, 0xFD	; 253
    18fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1900:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    1902:	20 93 02 02 	sts	0x0202, r18	; 0x800202 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    1906:	e1 ec       	ldi	r30, 0xC1	; 193
    1908:	f0 e0       	ldi	r31, 0x00	; 0
    190a:	80 81       	ld	r24, Z
    190c:	80 62       	ori	r24, 0x20	; 32
    190e:	80 83       	st	Z, r24
	return(0);
}
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	08 95       	ret

00001916 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    1916:	cf 93       	push	r28
    1918:	df 93       	push	r29
    191a:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    191c:	88 81       	ld	r24, Y
    191e:	88 23       	and	r24, r24
    1920:	29 f0       	breq	.+10     	; 0x192c <USART0_putstring+0x16>
    1922:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    1924:	ce df       	rcall	.-100    	; 0x18c2 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    1926:	89 91       	ld	r24, Y+
    1928:	81 11       	cpse	r24, r1
    192a:	fc cf       	rjmp	.-8      	; 0x1924 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    192c:	df 91       	pop	r29
    192e:	cf 91       	pop	r28
    1930:	08 95       	ret

00001932 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1932:	1f 92       	push	r1
    1934:	0f 92       	push	r0
    1936:	0f b6       	in	r0, 0x3f	; 63
    1938:	0f 92       	push	r0
    193a:	11 24       	eor	r1, r1
    193c:	8f 93       	push	r24
    193e:	9f 93       	push	r25
    1940:	ef 93       	push	r30
    1942:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1944:	90 91 02 02 	lds	r25, 0x0202	; 0x800202 <UART0_TxHead>
    1948:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <UART0_TxTail>
    194c:	98 17       	cp	r25, r24
    194e:	61 f0       	breq	.+24     	; 0x1968 <__vector_21+0x36>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1950:	e0 91 01 02 	lds	r30, 0x0201	; 0x800201 <UART0_TxTail>
    1954:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1956:	e0 93 01 02 	sts	0x0201, r30	; 0x800201 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    195a:	f0 e0       	ldi	r31, 0x00	; 0
    195c:	ed 5f       	subi	r30, 0xFD	; 253
    195e:	fd 4f       	sbci	r31, 0xFD	; 253
    1960:	80 81       	ld	r24, Z
    1962:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1966:	05 c0       	rjmp	.+10     	; 0x1972 <__vector_21+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1968:	e1 ec       	ldi	r30, 0xC1	; 193
    196a:	f0 e0       	ldi	r31, 0x00	; 0
    196c:	80 81       	ld	r24, Z
    196e:	8f 7d       	andi	r24, 0xDF	; 223
    1970:	80 83       	st	Z, r24
	}
    1972:	ff 91       	pop	r31
    1974:	ef 91       	pop	r30
    1976:	9f 91       	pop	r25
    1978:	8f 91       	pop	r24
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63
    197e:	0f 90       	pop	r0
    1980:	1f 90       	pop	r1
    1982:	18 95       	reti

00001984 <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1984:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1988:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    198c:	88 e9       	ldi	r24, 0x98	; 152
    198e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1992:	86 e0       	ldi	r24, 0x06	; 6
    1994:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1998:	10 92 07 04 	sts	0x0407, r1	; 0x800407 <UART1_RxTail>
    199c:	10 92 08 04 	sts	0x0408, r1	; 0x800408 <UART1_RxHead>
    19a0:	10 92 05 03 	sts	0x0305, r1	; 0x800305 <UART1_TxTail>
    19a4:	10 92 06 03 	sts	0x0306, r1	; 0x800306 <UART1_TxHead>
    19a8:	08 95       	ret

000019aa <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    19aa:	1f 92       	push	r1
    19ac:	0f 92       	push	r0
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	0f 92       	push	r0
    19b2:	11 24       	eor	r1, r1
    19b4:	2f 93       	push	r18
    19b6:	3f 93       	push	r19
    19b8:	8f 93       	push	r24
    19ba:	9f 93       	push	r25
    19bc:	af 93       	push	r26
    19be:	bf 93       	push	r27
    19c0:	cf 93       	push	r28
    19c2:	df 93       	push	r29
    19c4:	ef 93       	push	r30
    19c6:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    19c8:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    19cc:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <UART1_RxHead>
    19d0:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    19d2:	80 93 08 04 	sts	0x0408, r24	; 0x800408 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    19d6:	20 91 07 04 	lds	r18, 0x0407	; 0x800407 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    19da:	e8 2f       	mov	r30, r24
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	e0 53       	subi	r30, 0x30	; 48
    19e0:	fa 4f       	sbci	r31, 0xFA	; 250
    19e2:	90 83       	st	Z, r25
	
	if (data == 10)
    19e4:	9a 30       	cpi	r25, 0x0A	; 10
    19e6:	d1 f4       	brne	.+52     	; 0x1a1c <__vector_28+0x72>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'L')
    19e8:	90 91 d5 05 	lds	r25, 0x05D5	; 0x8005d5 <UART1_RxBuf+0x5>
    19ec:	9c 34       	cpi	r25, 0x4C	; 76
    19ee:	91 f4       	brne	.+36     	; 0x1a14 <__vector_28+0x6a>
    19f0:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
    19f2:	2e 2f       	mov	r18, r30
    19f4:	30 e0       	ldi	r19, 0x00	; 0
    19f6:	d9 01       	movw	r26, r18
    19f8:	a0 53       	subi	r26, 0x30	; 48
    19fa:	b9 4f       	sbci	r27, 0xF9	; 249
    19fc:	e9 01       	movw	r28, r18
    19fe:	c0 53       	subi	r28, 0x30	; 48
    1a00:	da 4f       	sbci	r29, 0xFA	; 250
    1a02:	98 81       	ld	r25, Y
    1a04:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'L')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1a06:	ef 5f       	subi	r30, 0xFF	; 255
    1a08:	8e 17       	cp	r24, r30
    1a0a:	98 f7       	brcc	.-26     	; 0x19f2 <__vector_28+0x48>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
    1a0c:	f0 e0       	ldi	r31, 0x00	; 0
    1a0e:	e0 53       	subi	r30, 0x30	; 48
    1a10:	f9 4f       	sbci	r31, 0xF9	; 249
    1a12:	11 82       	std	Z+1, r1	; 0x01
		}
		UART1_RxTail = 0;
    1a14:	10 92 07 04 	sts	0x0407, r1	; 0x800407 <UART1_RxTail>
		UART1_RxHead = 0;
    1a18:	10 92 08 04 	sts	0x0408, r1	; 0x800408 <UART1_RxHead>
	}
}
    1a1c:	ff 91       	pop	r31
    1a1e:	ef 91       	pop	r30
    1a20:	df 91       	pop	r29
    1a22:	cf 91       	pop	r28
    1a24:	bf 91       	pop	r27
    1a26:	af 91       	pop	r26
    1a28:	9f 91       	pop	r25
    1a2a:	8f 91       	pop	r24
    1a2c:	3f 91       	pop	r19
    1a2e:	2f 91       	pop	r18
    1a30:	0f 90       	pop	r0
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	0f 90       	pop	r0
    1a36:	1f 90       	pop	r1
    1a38:	18 95       	reti

00001a3a <__vector_29>:

ISR(USART1_UDRE_vect)
{
    1a3a:	1f 92       	push	r1
    1a3c:	0f 92       	push	r0
    1a3e:	0f b6       	in	r0, 0x3f	; 63
    1a40:	0f 92       	push	r0
    1a42:	11 24       	eor	r1, r1
    1a44:	8f 93       	push	r24
    1a46:	9f 93       	push	r25
    1a48:	ef 93       	push	r30
    1a4a:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
    1a4c:	90 91 06 03 	lds	r25, 0x0306	; 0x800306 <UART1_TxHead>
    1a50:	80 91 05 03 	lds	r24, 0x0305	; 0x800305 <UART1_TxTail>
    1a54:	98 17       	cp	r25, r24
    1a56:	61 f0       	breq	.+24     	; 0x1a70 <__vector_29+0x36>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
    1a58:	e0 91 05 03 	lds	r30, 0x0305	; 0x800305 <UART1_TxTail>
    1a5c:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
    1a5e:	e0 93 05 03 	sts	0x0305, r30	; 0x800305 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	e9 5f       	subi	r30, 0xF9	; 249
    1a66:	fc 4f       	sbci	r31, 0xFC	; 252
    1a68:	80 81       	ld	r24, Z
    1a6a:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1a6e:	05 c0       	rjmp	.+10     	; 0x1a7a <__vector_29+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
    1a70:	e9 ec       	ldi	r30, 0xC9	; 201
    1a72:	f0 e0       	ldi	r31, 0x00	; 0
    1a74:	80 81       	ld	r24, Z
    1a76:	8f 7d       	andi	r24, 0xDF	; 223
    1a78:	80 83       	st	Z, r24
	}
    1a7a:	ff 91       	pop	r31
    1a7c:	ef 91       	pop	r30
    1a7e:	9f 91       	pop	r25
    1a80:	8f 91       	pop	r24
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	0f 90       	pop	r0
    1a88:	1f 90       	pop	r1
    1a8a:	18 95       	reti

00001a8c <__mulsi3>:
    1a8c:	db 01       	movw	r26, r22
    1a8e:	8f 93       	push	r24
    1a90:	9f 93       	push	r25
    1a92:	11 d0       	rcall	.+34     	; 0x1ab6 <__muluhisi3>
    1a94:	bf 91       	pop	r27
    1a96:	af 91       	pop	r26
    1a98:	a2 9f       	mul	r26, r18
    1a9a:	80 0d       	add	r24, r0
    1a9c:	91 1d       	adc	r25, r1
    1a9e:	a3 9f       	mul	r26, r19
    1aa0:	90 0d       	add	r25, r0
    1aa2:	b2 9f       	mul	r27, r18
    1aa4:	90 0d       	add	r25, r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	08 95       	ret

00001aaa <__tablejump2__>:
    1aaa:	ee 0f       	add	r30, r30
    1aac:	ff 1f       	adc	r31, r31
    1aae:	05 90       	lpm	r0, Z+
    1ab0:	f4 91       	lpm	r31, Z
    1ab2:	e0 2d       	mov	r30, r0
    1ab4:	09 94       	ijmp

00001ab6 <__muluhisi3>:
    1ab6:	85 d1       	rcall	.+778    	; 0x1dc2 <__umulhisi3>
    1ab8:	a5 9f       	mul	r26, r21
    1aba:	90 0d       	add	r25, r0
    1abc:	b4 9f       	mul	r27, r20
    1abe:	90 0d       	add	r25, r0
    1ac0:	a4 9f       	mul	r26, r20
    1ac2:	80 0d       	add	r24, r0
    1ac4:	91 1d       	adc	r25, r1
    1ac6:	11 24       	eor	r1, r1
    1ac8:	08 95       	ret

00001aca <__mulshisi3>:
    1aca:	b7 ff       	sbrs	r27, 7
    1acc:	f4 cf       	rjmp	.-24     	; 0x1ab6 <__muluhisi3>

00001ace <__mulohisi3>:
    1ace:	f3 df       	rcall	.-26     	; 0x1ab6 <__muluhisi3>
    1ad0:	82 1b       	sub	r24, r18
    1ad2:	93 0b       	sbc	r25, r19
    1ad4:	08 95       	ret

00001ad6 <__muldi3>:
    1ad6:	df 93       	push	r29
    1ad8:	cf 93       	push	r28
    1ada:	1f 93       	push	r17
    1adc:	0f 93       	push	r16
    1ade:	9a 9d       	mul	r25, r10
    1ae0:	f0 2d       	mov	r31, r0
    1ae2:	21 9f       	mul	r18, r17
    1ae4:	f0 0d       	add	r31, r0
    1ae6:	8b 9d       	mul	r24, r11
    1ae8:	f0 0d       	add	r31, r0
    1aea:	8a 9d       	mul	r24, r10
    1aec:	e0 2d       	mov	r30, r0
    1aee:	f1 0d       	add	r31, r1
    1af0:	03 9f       	mul	r16, r19
    1af2:	f0 0d       	add	r31, r0
    1af4:	02 9f       	mul	r16, r18
    1af6:	e0 0d       	add	r30, r0
    1af8:	f1 1d       	adc	r31, r1
    1afa:	4e 9d       	mul	r20, r14
    1afc:	e0 0d       	add	r30, r0
    1afe:	f1 1d       	adc	r31, r1
    1b00:	5e 9d       	mul	r21, r14
    1b02:	f0 0d       	add	r31, r0
    1b04:	4f 9d       	mul	r20, r15
    1b06:	f0 0d       	add	r31, r0
    1b08:	7f 93       	push	r23
    1b0a:	6f 93       	push	r22
    1b0c:	bf 92       	push	r11
    1b0e:	af 92       	push	r10
    1b10:	5f 93       	push	r21
    1b12:	4f 93       	push	r20
    1b14:	d5 01       	movw	r26, r10
    1b16:	55 d1       	rcall	.+682    	; 0x1dc2 <__umulhisi3>
    1b18:	8b 01       	movw	r16, r22
    1b1a:	ac 01       	movw	r20, r24
    1b1c:	d7 01       	movw	r26, r14
    1b1e:	51 d1       	rcall	.+674    	; 0x1dc2 <__umulhisi3>
    1b20:	eb 01       	movw	r28, r22
    1b22:	e8 0f       	add	r30, r24
    1b24:	f9 1f       	adc	r31, r25
    1b26:	d6 01       	movw	r26, r12
    1b28:	1f d0       	rcall	.+62     	; 0x1b68 <__muldi3_6>
    1b2a:	2f 91       	pop	r18
    1b2c:	3f 91       	pop	r19
    1b2e:	d6 01       	movw	r26, r12
    1b30:	48 d1       	rcall	.+656    	; 0x1dc2 <__umulhisi3>
    1b32:	c6 0f       	add	r28, r22
    1b34:	d7 1f       	adc	r29, r23
    1b36:	e8 1f       	adc	r30, r24
    1b38:	f9 1f       	adc	r31, r25
    1b3a:	af 91       	pop	r26
    1b3c:	bf 91       	pop	r27
    1b3e:	14 d0       	rcall	.+40     	; 0x1b68 <__muldi3_6>
    1b40:	2f 91       	pop	r18
    1b42:	3f 91       	pop	r19
    1b44:	3e d1       	rcall	.+636    	; 0x1dc2 <__umulhisi3>
    1b46:	c6 0f       	add	r28, r22
    1b48:	d7 1f       	adc	r29, r23
    1b4a:	e8 1f       	adc	r30, r24
    1b4c:	f9 1f       	adc	r31, r25
    1b4e:	d6 01       	movw	r26, r12
    1b50:	38 d1       	rcall	.+624    	; 0x1dc2 <__umulhisi3>
    1b52:	e6 0f       	add	r30, r22
    1b54:	f7 1f       	adc	r31, r23
    1b56:	98 01       	movw	r18, r16
    1b58:	be 01       	movw	r22, r28
    1b5a:	cf 01       	movw	r24, r30
    1b5c:	11 24       	eor	r1, r1
    1b5e:	0f 91       	pop	r16
    1b60:	1f 91       	pop	r17
    1b62:	cf 91       	pop	r28
    1b64:	df 91       	pop	r29
    1b66:	08 95       	ret

00001b68 <__muldi3_6>:
    1b68:	2c d1       	rcall	.+600    	; 0x1dc2 <__umulhisi3>
    1b6a:	46 0f       	add	r20, r22
    1b6c:	57 1f       	adc	r21, r23
    1b6e:	c8 1f       	adc	r28, r24
    1b70:	d9 1f       	adc	r29, r25
    1b72:	08 f4       	brcc	.+2      	; 0x1b76 <__muldi3_6+0xe>
    1b74:	31 96       	adiw	r30, 0x01	; 1
    1b76:	08 95       	ret

00001b78 <__moddi3>:
    1b78:	68 94       	set
    1b7a:	01 c0       	rjmp	.+2      	; 0x1b7e <__divdi3_moddi3>

00001b7c <__divdi3>:
    1b7c:	e8 94       	clt

00001b7e <__divdi3_moddi3>:
    1b7e:	f9 2f       	mov	r31, r25
    1b80:	f1 2b       	or	r31, r17
    1b82:	0a f0       	brmi	.+2      	; 0x1b86 <__divdi3_moddi3+0x8>
    1b84:	27 c0       	rjmp	.+78     	; 0x1bd4 <__udivdi3_umoddi3>
    1b86:	a0 e0       	ldi	r26, 0x00	; 0
    1b88:	b0 e0       	ldi	r27, 0x00	; 0
    1b8a:	e8 ec       	ldi	r30, 0xC8	; 200
    1b8c:	fd e0       	ldi	r31, 0x0D	; 13
    1b8e:	93 c0       	rjmp	.+294    	; 0x1cb6 <__prologue_saves__+0xc>
    1b90:	09 2e       	mov	r0, r25
    1b92:	05 94       	asr	r0
    1b94:	1a f4       	brpl	.+6      	; 0x1b9c <__divdi3_moddi3+0x1e>
    1b96:	79 d0       	rcall	.+242    	; 0x1c8a <__negdi2>
    1b98:	11 23       	and	r17, r17
    1b9a:	92 f4       	brpl	.+36     	; 0x1bc0 <__divdi3_moddi3+0x42>
    1b9c:	f0 e8       	ldi	r31, 0x80	; 128
    1b9e:	0f 26       	eor	r0, r31
    1ba0:	ff ef       	ldi	r31, 0xFF	; 255
    1ba2:	e0 94       	com	r14
    1ba4:	f0 94       	com	r15
    1ba6:	00 95       	com	r16
    1ba8:	10 95       	com	r17
    1baa:	b0 94       	com	r11
    1bac:	c0 94       	com	r12
    1bae:	d0 94       	com	r13
    1bb0:	a1 94       	neg	r10
    1bb2:	bf 0a       	sbc	r11, r31
    1bb4:	cf 0a       	sbc	r12, r31
    1bb6:	df 0a       	sbc	r13, r31
    1bb8:	ef 0a       	sbc	r14, r31
    1bba:	ff 0a       	sbc	r15, r31
    1bbc:	0f 0b       	sbc	r16, r31
    1bbe:	1f 0b       	sbc	r17, r31
    1bc0:	13 d0       	rcall	.+38     	; 0x1be8 <__udivmod64>
    1bc2:	07 fc       	sbrc	r0, 7
    1bc4:	62 d0       	rcall	.+196    	; 0x1c8a <__negdi2>
    1bc6:	cd b7       	in	r28, 0x3d	; 61
    1bc8:	de b7       	in	r29, 0x3e	; 62
    1bca:	ec e0       	ldi	r30, 0x0C	; 12
    1bcc:	90 c0       	rjmp	.+288    	; 0x1cee <__epilogue_restores__+0xc>

00001bce <__umoddi3>:
    1bce:	68 94       	set
    1bd0:	01 c0       	rjmp	.+2      	; 0x1bd4 <__udivdi3_umoddi3>

00001bd2 <__udivdi3>:
    1bd2:	e8 94       	clt

00001bd4 <__udivdi3_umoddi3>:
    1bd4:	8f 92       	push	r8
    1bd6:	9f 92       	push	r9
    1bd8:	cf 93       	push	r28
    1bda:	df 93       	push	r29
    1bdc:	05 d0       	rcall	.+10     	; 0x1be8 <__udivmod64>
    1bde:	df 91       	pop	r29
    1be0:	cf 91       	pop	r28
    1be2:	9f 90       	pop	r9
    1be4:	8f 90       	pop	r8
    1be6:	08 95       	ret

00001be8 <__udivmod64>:
    1be8:	88 24       	eor	r8, r8
    1bea:	99 24       	eor	r9, r9
    1bec:	f4 01       	movw	r30, r8
    1bee:	e4 01       	movw	r28, r8
    1bf0:	b0 e4       	ldi	r27, 0x40	; 64
    1bf2:	9f 93       	push	r25
    1bf4:	aa 27       	eor	r26, r26
    1bf6:	9a 15       	cp	r25, r10
    1bf8:	8b 04       	cpc	r8, r11
    1bfa:	9c 04       	cpc	r9, r12
    1bfc:	ed 05       	cpc	r30, r13
    1bfe:	fe 05       	cpc	r31, r14
    1c00:	cf 05       	cpc	r28, r15
    1c02:	d0 07       	cpc	r29, r16
    1c04:	a1 07       	cpc	r26, r17
    1c06:	98 f4       	brcc	.+38     	; 0x1c2e <__udivmod64+0x46>
    1c08:	ad 2f       	mov	r26, r29
    1c0a:	dc 2f       	mov	r29, r28
    1c0c:	cf 2f       	mov	r28, r31
    1c0e:	fe 2f       	mov	r31, r30
    1c10:	e9 2d       	mov	r30, r9
    1c12:	98 2c       	mov	r9, r8
    1c14:	89 2e       	mov	r8, r25
    1c16:	98 2f       	mov	r25, r24
    1c18:	87 2f       	mov	r24, r23
    1c1a:	76 2f       	mov	r23, r22
    1c1c:	65 2f       	mov	r22, r21
    1c1e:	54 2f       	mov	r21, r20
    1c20:	43 2f       	mov	r20, r19
    1c22:	32 2f       	mov	r19, r18
    1c24:	22 27       	eor	r18, r18
    1c26:	b8 50       	subi	r27, 0x08	; 8
    1c28:	31 f7       	brne	.-52     	; 0x1bf6 <__udivmod64+0xe>
    1c2a:	bf 91       	pop	r27
    1c2c:	27 c0       	rjmp	.+78     	; 0x1c7c <__udivmod64+0x94>
    1c2e:	1b 2e       	mov	r1, r27
    1c30:	bf 91       	pop	r27
    1c32:	bb 27       	eor	r27, r27
    1c34:	22 0f       	add	r18, r18
    1c36:	33 1f       	adc	r19, r19
    1c38:	44 1f       	adc	r20, r20
    1c3a:	55 1f       	adc	r21, r21
    1c3c:	66 1f       	adc	r22, r22
    1c3e:	77 1f       	adc	r23, r23
    1c40:	88 1f       	adc	r24, r24
    1c42:	99 1f       	adc	r25, r25
    1c44:	88 1c       	adc	r8, r8
    1c46:	99 1c       	adc	r9, r9
    1c48:	ee 1f       	adc	r30, r30
    1c4a:	ff 1f       	adc	r31, r31
    1c4c:	cc 1f       	adc	r28, r28
    1c4e:	dd 1f       	adc	r29, r29
    1c50:	aa 1f       	adc	r26, r26
    1c52:	bb 1f       	adc	r27, r27
    1c54:	8a 14       	cp	r8, r10
    1c56:	9b 04       	cpc	r9, r11
    1c58:	ec 05       	cpc	r30, r12
    1c5a:	fd 05       	cpc	r31, r13
    1c5c:	ce 05       	cpc	r28, r14
    1c5e:	df 05       	cpc	r29, r15
    1c60:	a0 07       	cpc	r26, r16
    1c62:	b1 07       	cpc	r27, r17
    1c64:	48 f0       	brcs	.+18     	; 0x1c78 <__udivmod64+0x90>
    1c66:	8a 18       	sub	r8, r10
    1c68:	9b 08       	sbc	r9, r11
    1c6a:	ec 09       	sbc	r30, r12
    1c6c:	fd 09       	sbc	r31, r13
    1c6e:	ce 09       	sbc	r28, r14
    1c70:	df 09       	sbc	r29, r15
    1c72:	a0 0b       	sbc	r26, r16
    1c74:	b1 0b       	sbc	r27, r17
    1c76:	21 60       	ori	r18, 0x01	; 1
    1c78:	1a 94       	dec	r1
    1c7a:	e1 f6       	brne	.-72     	; 0x1c34 <__udivmod64+0x4c>
    1c7c:	2e f4       	brtc	.+10     	; 0x1c88 <__udivmod64+0xa0>
    1c7e:	94 01       	movw	r18, r8
    1c80:	af 01       	movw	r20, r30
    1c82:	be 01       	movw	r22, r28
    1c84:	cd 01       	movw	r24, r26
    1c86:	00 0c       	add	r0, r0
    1c88:	08 95       	ret

00001c8a <__negdi2>:
    1c8a:	60 95       	com	r22
    1c8c:	70 95       	com	r23
    1c8e:	80 95       	com	r24
    1c90:	90 95       	com	r25
    1c92:	30 95       	com	r19
    1c94:	40 95       	com	r20
    1c96:	50 95       	com	r21
    1c98:	21 95       	neg	r18
    1c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c9c:	4f 4f       	sbci	r20, 0xFF	; 255
    1c9e:	5f 4f       	sbci	r21, 0xFF	; 255
    1ca0:	6f 4f       	sbci	r22, 0xFF	; 255
    1ca2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca4:	8f 4f       	sbci	r24, 0xFF	; 255
    1ca6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ca8:	08 95       	ret

00001caa <__prologue_saves__>:
    1caa:	2f 92       	push	r2
    1cac:	3f 92       	push	r3
    1cae:	4f 92       	push	r4
    1cb0:	5f 92       	push	r5
    1cb2:	6f 92       	push	r6
    1cb4:	7f 92       	push	r7
    1cb6:	8f 92       	push	r8
    1cb8:	9f 92       	push	r9
    1cba:	af 92       	push	r10
    1cbc:	bf 92       	push	r11
    1cbe:	cf 92       	push	r12
    1cc0:	df 92       	push	r13
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	ca 1b       	sub	r28, r26
    1cd4:	db 0b       	sbc	r29, r27
    1cd6:	0f b6       	in	r0, 0x3f	; 63
    1cd8:	f8 94       	cli
    1cda:	de bf       	out	0x3e, r29	; 62
    1cdc:	0f be       	out	0x3f, r0	; 63
    1cde:	cd bf       	out	0x3d, r28	; 61
    1ce0:	09 94       	ijmp

00001ce2 <__epilogue_restores__>:
    1ce2:	2a 88       	ldd	r2, Y+18	; 0x12
    1ce4:	39 88       	ldd	r3, Y+17	; 0x11
    1ce6:	48 88       	ldd	r4, Y+16	; 0x10
    1ce8:	5f 84       	ldd	r5, Y+15	; 0x0f
    1cea:	6e 84       	ldd	r6, Y+14	; 0x0e
    1cec:	7d 84       	ldd	r7, Y+13	; 0x0d
    1cee:	8c 84       	ldd	r8, Y+12	; 0x0c
    1cf0:	9b 84       	ldd	r9, Y+11	; 0x0b
    1cf2:	aa 84       	ldd	r10, Y+10	; 0x0a
    1cf4:	b9 84       	ldd	r11, Y+9	; 0x09
    1cf6:	c8 84       	ldd	r12, Y+8	; 0x08
    1cf8:	df 80       	ldd	r13, Y+7	; 0x07
    1cfa:	ee 80       	ldd	r14, Y+6	; 0x06
    1cfc:	fd 80       	ldd	r15, Y+5	; 0x05
    1cfe:	0c 81       	ldd	r16, Y+4	; 0x04
    1d00:	1b 81       	ldd	r17, Y+3	; 0x03
    1d02:	aa 81       	ldd	r26, Y+2	; 0x02
    1d04:	b9 81       	ldd	r27, Y+1	; 0x01
    1d06:	ce 0f       	add	r28, r30
    1d08:	d1 1d       	adc	r29, r1
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	de bf       	out	0x3e, r29	; 62
    1d10:	0f be       	out	0x3f, r0	; 63
    1d12:	cd bf       	out	0x3d, r28	; 61
    1d14:	ed 01       	movw	r28, r26
    1d16:	08 95       	ret

00001d18 <__ashldi3>:
    1d18:	0f 93       	push	r16
    1d1a:	08 30       	cpi	r16, 0x08	; 8
    1d1c:	90 f0       	brcs	.+36     	; 0x1d42 <__ashldi3+0x2a>
    1d1e:	98 2f       	mov	r25, r24
    1d20:	87 2f       	mov	r24, r23
    1d22:	76 2f       	mov	r23, r22
    1d24:	65 2f       	mov	r22, r21
    1d26:	54 2f       	mov	r21, r20
    1d28:	43 2f       	mov	r20, r19
    1d2a:	32 2f       	mov	r19, r18
    1d2c:	22 27       	eor	r18, r18
    1d2e:	08 50       	subi	r16, 0x08	; 8
    1d30:	f4 cf       	rjmp	.-24     	; 0x1d1a <__ashldi3+0x2>
    1d32:	22 0f       	add	r18, r18
    1d34:	33 1f       	adc	r19, r19
    1d36:	44 1f       	adc	r20, r20
    1d38:	55 1f       	adc	r21, r21
    1d3a:	66 1f       	adc	r22, r22
    1d3c:	77 1f       	adc	r23, r23
    1d3e:	88 1f       	adc	r24, r24
    1d40:	99 1f       	adc	r25, r25
    1d42:	0a 95       	dec	r16
    1d44:	b2 f7       	brpl	.-20     	; 0x1d32 <__ashldi3+0x1a>
    1d46:	0f 91       	pop	r16
    1d48:	08 95       	ret

00001d4a <__ashrdi3>:
    1d4a:	97 fb       	bst	r25, 7
    1d4c:	10 f8       	bld	r1, 0

00001d4e <__lshrdi3>:
    1d4e:	16 94       	lsr	r1
    1d50:	00 08       	sbc	r0, r0
    1d52:	0f 93       	push	r16
    1d54:	08 30       	cpi	r16, 0x08	; 8
    1d56:	98 f0       	brcs	.+38     	; 0x1d7e <__lshrdi3+0x30>
    1d58:	08 50       	subi	r16, 0x08	; 8
    1d5a:	23 2f       	mov	r18, r19
    1d5c:	34 2f       	mov	r19, r20
    1d5e:	45 2f       	mov	r20, r21
    1d60:	56 2f       	mov	r21, r22
    1d62:	67 2f       	mov	r22, r23
    1d64:	78 2f       	mov	r23, r24
    1d66:	89 2f       	mov	r24, r25
    1d68:	90 2d       	mov	r25, r0
    1d6a:	f4 cf       	rjmp	.-24     	; 0x1d54 <__lshrdi3+0x6>
    1d6c:	05 94       	asr	r0
    1d6e:	97 95       	ror	r25
    1d70:	87 95       	ror	r24
    1d72:	77 95       	ror	r23
    1d74:	67 95       	ror	r22
    1d76:	57 95       	ror	r21
    1d78:	47 95       	ror	r20
    1d7a:	37 95       	ror	r19
    1d7c:	27 95       	ror	r18
    1d7e:	0a 95       	dec	r16
    1d80:	aa f7       	brpl	.-22     	; 0x1d6c <__lshrdi3+0x1e>
    1d82:	0f 91       	pop	r16
    1d84:	08 95       	ret

00001d86 <__adddi3>:
    1d86:	2a 0d       	add	r18, r10
    1d88:	3b 1d       	adc	r19, r11
    1d8a:	4c 1d       	adc	r20, r12
    1d8c:	5d 1d       	adc	r21, r13
    1d8e:	6e 1d       	adc	r22, r14
    1d90:	7f 1d       	adc	r23, r15
    1d92:	80 1f       	adc	r24, r16
    1d94:	91 1f       	adc	r25, r17
    1d96:	08 95       	ret

00001d98 <__subdi3>:
    1d98:	2a 19       	sub	r18, r10
    1d9a:	3b 09       	sbc	r19, r11
    1d9c:	4c 09       	sbc	r20, r12
    1d9e:	5d 09       	sbc	r21, r13
    1da0:	6e 09       	sbc	r22, r14
    1da2:	7f 09       	sbc	r23, r15
    1da4:	80 0b       	sbc	r24, r16
    1da6:	91 0b       	sbc	r25, r17
    1da8:	08 95       	ret

00001daa <__cmpdi2_s8>:
    1daa:	00 24       	eor	r0, r0
    1dac:	a7 fd       	sbrc	r26, 7
    1dae:	00 94       	com	r0
    1db0:	2a 17       	cp	r18, r26
    1db2:	30 05       	cpc	r19, r0
    1db4:	40 05       	cpc	r20, r0
    1db6:	50 05       	cpc	r21, r0
    1db8:	60 05       	cpc	r22, r0
    1dba:	70 05       	cpc	r23, r0
    1dbc:	80 05       	cpc	r24, r0
    1dbe:	90 05       	cpc	r25, r0
    1dc0:	08 95       	ret

00001dc2 <__umulhisi3>:
    1dc2:	a2 9f       	mul	r26, r18
    1dc4:	b0 01       	movw	r22, r0
    1dc6:	b3 9f       	mul	r27, r19
    1dc8:	c0 01       	movw	r24, r0
    1dca:	a3 9f       	mul	r26, r19
    1dcc:	70 0d       	add	r23, r0
    1dce:	81 1d       	adc	r24, r1
    1dd0:	11 24       	eor	r1, r1
    1dd2:	91 1d       	adc	r25, r1
    1dd4:	b2 9f       	mul	r27, r18
    1dd6:	70 0d       	add	r23, r0
    1dd8:	81 1d       	adc	r24, r1
    1dda:	11 24       	eor	r1, r1
    1ddc:	91 1d       	adc	r25, r1
    1dde:	08 95       	ret

00001de0 <printf>:
    1de0:	a0 e0       	ldi	r26, 0x00	; 0
    1de2:	b0 e0       	ldi	r27, 0x00	; 0
    1de4:	e5 ef       	ldi	r30, 0xF5	; 245
    1de6:	fe e0       	ldi	r31, 0x0E	; 14
    1de8:	70 cf       	rjmp	.-288    	; 0x1cca <__prologue_saves__+0x20>
    1dea:	ae 01       	movw	r20, r28
    1dec:	4b 5f       	subi	r20, 0xFB	; 251
    1dee:	5f 4f       	sbci	r21, 0xFF	; 255
    1df0:	fa 01       	movw	r30, r20
    1df2:	61 91       	ld	r22, Z+
    1df4:	71 91       	ld	r23, Z+
    1df6:	af 01       	movw	r20, r30
    1df8:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <__iob+0x2>
    1dfc:	90 91 d3 07 	lds	r25, 0x07D3	; 0x8007d3 <__iob+0x3>
    1e00:	02 d0       	rcall	.+4      	; 0x1e06 <vfprintf>
    1e02:	e2 e0       	ldi	r30, 0x02	; 2
    1e04:	7e cf       	rjmp	.-260    	; 0x1d02 <__epilogue_restores__+0x20>

00001e06 <vfprintf>:
    1e06:	ac e0       	ldi	r26, 0x0C	; 12
    1e08:	b0 e0       	ldi	r27, 0x00	; 0
    1e0a:	e8 e0       	ldi	r30, 0x08	; 8
    1e0c:	ff e0       	ldi	r31, 0x0F	; 15
    1e0e:	4d cf       	rjmp	.-358    	; 0x1caa <__prologue_saves__>
    1e10:	7c 01       	movw	r14, r24
    1e12:	6b 01       	movw	r12, r22
    1e14:	8a 01       	movw	r16, r20
    1e16:	fc 01       	movw	r30, r24
    1e18:	17 82       	std	Z+7, r1	; 0x07
    1e1a:	16 82       	std	Z+6, r1	; 0x06
    1e1c:	83 81       	ldd	r24, Z+3	; 0x03
    1e1e:	81 ff       	sbrs	r24, 1
    1e20:	b0 c1       	rjmp	.+864    	; 0x2182 <vfprintf+0x37c>
    1e22:	ce 01       	movw	r24, r28
    1e24:	01 96       	adiw	r24, 0x01	; 1
    1e26:	4c 01       	movw	r8, r24
    1e28:	f7 01       	movw	r30, r14
    1e2a:	93 81       	ldd	r25, Z+3	; 0x03
    1e2c:	f6 01       	movw	r30, r12
    1e2e:	93 fd       	sbrc	r25, 3
    1e30:	85 91       	lpm	r24, Z+
    1e32:	93 ff       	sbrs	r25, 3
    1e34:	81 91       	ld	r24, Z+
    1e36:	6f 01       	movw	r12, r30
    1e38:	88 23       	and	r24, r24
    1e3a:	09 f4       	brne	.+2      	; 0x1e3e <vfprintf+0x38>
    1e3c:	9e c1       	rjmp	.+828    	; 0x217a <vfprintf+0x374>
    1e3e:	85 32       	cpi	r24, 0x25	; 37
    1e40:	39 f4       	brne	.+14     	; 0x1e50 <vfprintf+0x4a>
    1e42:	93 fd       	sbrc	r25, 3
    1e44:	85 91       	lpm	r24, Z+
    1e46:	93 ff       	sbrs	r25, 3
    1e48:	81 91       	ld	r24, Z+
    1e4a:	6f 01       	movw	r12, r30
    1e4c:	85 32       	cpi	r24, 0x25	; 37
    1e4e:	21 f4       	brne	.+8      	; 0x1e58 <vfprintf+0x52>
    1e50:	b7 01       	movw	r22, r14
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	b1 d1       	rcall	.+866    	; 0x21b8 <fputc>
    1e56:	e8 cf       	rjmp	.-48     	; 0x1e28 <vfprintf+0x22>
    1e58:	51 2c       	mov	r5, r1
    1e5a:	31 2c       	mov	r3, r1
    1e5c:	20 e0       	ldi	r18, 0x00	; 0
    1e5e:	20 32       	cpi	r18, 0x20	; 32
    1e60:	a0 f4       	brcc	.+40     	; 0x1e8a <vfprintf+0x84>
    1e62:	8b 32       	cpi	r24, 0x2B	; 43
    1e64:	69 f0       	breq	.+26     	; 0x1e80 <vfprintf+0x7a>
    1e66:	30 f4       	brcc	.+12     	; 0x1e74 <vfprintf+0x6e>
    1e68:	80 32       	cpi	r24, 0x20	; 32
    1e6a:	59 f0       	breq	.+22     	; 0x1e82 <vfprintf+0x7c>
    1e6c:	83 32       	cpi	r24, 0x23	; 35
    1e6e:	69 f4       	brne	.+26     	; 0x1e8a <vfprintf+0x84>
    1e70:	20 61       	ori	r18, 0x10	; 16
    1e72:	2c c0       	rjmp	.+88     	; 0x1ecc <vfprintf+0xc6>
    1e74:	8d 32       	cpi	r24, 0x2D	; 45
    1e76:	39 f0       	breq	.+14     	; 0x1e86 <vfprintf+0x80>
    1e78:	80 33       	cpi	r24, 0x30	; 48
    1e7a:	39 f4       	brne	.+14     	; 0x1e8a <vfprintf+0x84>
    1e7c:	21 60       	ori	r18, 0x01	; 1
    1e7e:	26 c0       	rjmp	.+76     	; 0x1ecc <vfprintf+0xc6>
    1e80:	22 60       	ori	r18, 0x02	; 2
    1e82:	24 60       	ori	r18, 0x04	; 4
    1e84:	23 c0       	rjmp	.+70     	; 0x1ecc <vfprintf+0xc6>
    1e86:	28 60       	ori	r18, 0x08	; 8
    1e88:	21 c0       	rjmp	.+66     	; 0x1ecc <vfprintf+0xc6>
    1e8a:	27 fd       	sbrc	r18, 7
    1e8c:	27 c0       	rjmp	.+78     	; 0x1edc <vfprintf+0xd6>
    1e8e:	30 ed       	ldi	r19, 0xD0	; 208
    1e90:	38 0f       	add	r19, r24
    1e92:	3a 30       	cpi	r19, 0x0A	; 10
    1e94:	78 f4       	brcc	.+30     	; 0x1eb4 <vfprintf+0xae>
    1e96:	26 ff       	sbrs	r18, 6
    1e98:	06 c0       	rjmp	.+12     	; 0x1ea6 <vfprintf+0xa0>
    1e9a:	fa e0       	ldi	r31, 0x0A	; 10
    1e9c:	5f 9e       	mul	r5, r31
    1e9e:	30 0d       	add	r19, r0
    1ea0:	11 24       	eor	r1, r1
    1ea2:	53 2e       	mov	r5, r19
    1ea4:	13 c0       	rjmp	.+38     	; 0x1ecc <vfprintf+0xc6>
    1ea6:	8a e0       	ldi	r24, 0x0A	; 10
    1ea8:	38 9e       	mul	r3, r24
    1eaa:	30 0d       	add	r19, r0
    1eac:	11 24       	eor	r1, r1
    1eae:	33 2e       	mov	r3, r19
    1eb0:	20 62       	ori	r18, 0x20	; 32
    1eb2:	0c c0       	rjmp	.+24     	; 0x1ecc <vfprintf+0xc6>
    1eb4:	8e 32       	cpi	r24, 0x2E	; 46
    1eb6:	21 f4       	brne	.+8      	; 0x1ec0 <vfprintf+0xba>
    1eb8:	26 fd       	sbrc	r18, 6
    1eba:	5f c1       	rjmp	.+702    	; 0x217a <vfprintf+0x374>
    1ebc:	20 64       	ori	r18, 0x40	; 64
    1ebe:	06 c0       	rjmp	.+12     	; 0x1ecc <vfprintf+0xc6>
    1ec0:	8c 36       	cpi	r24, 0x6C	; 108
    1ec2:	11 f4       	brne	.+4      	; 0x1ec8 <vfprintf+0xc2>
    1ec4:	20 68       	ori	r18, 0x80	; 128
    1ec6:	02 c0       	rjmp	.+4      	; 0x1ecc <vfprintf+0xc6>
    1ec8:	88 36       	cpi	r24, 0x68	; 104
    1eca:	41 f4       	brne	.+16     	; 0x1edc <vfprintf+0xd6>
    1ecc:	f6 01       	movw	r30, r12
    1ece:	93 fd       	sbrc	r25, 3
    1ed0:	85 91       	lpm	r24, Z+
    1ed2:	93 ff       	sbrs	r25, 3
    1ed4:	81 91       	ld	r24, Z+
    1ed6:	6f 01       	movw	r12, r30
    1ed8:	81 11       	cpse	r24, r1
    1eda:	c1 cf       	rjmp	.-126    	; 0x1e5e <vfprintf+0x58>
    1edc:	98 2f       	mov	r25, r24
    1ede:	9f 7d       	andi	r25, 0xDF	; 223
    1ee0:	95 54       	subi	r25, 0x45	; 69
    1ee2:	93 30       	cpi	r25, 0x03	; 3
    1ee4:	28 f4       	brcc	.+10     	; 0x1ef0 <vfprintf+0xea>
    1ee6:	0c 5f       	subi	r16, 0xFC	; 252
    1ee8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eea:	ff e3       	ldi	r31, 0x3F	; 63
    1eec:	f9 83       	std	Y+1, r31	; 0x01
    1eee:	0d c0       	rjmp	.+26     	; 0x1f0a <vfprintf+0x104>
    1ef0:	83 36       	cpi	r24, 0x63	; 99
    1ef2:	31 f0       	breq	.+12     	; 0x1f00 <vfprintf+0xfa>
    1ef4:	83 37       	cpi	r24, 0x73	; 115
    1ef6:	71 f0       	breq	.+28     	; 0x1f14 <vfprintf+0x10e>
    1ef8:	83 35       	cpi	r24, 0x53	; 83
    1efa:	09 f0       	breq	.+2      	; 0x1efe <vfprintf+0xf8>
    1efc:	57 c0       	rjmp	.+174    	; 0x1fac <vfprintf+0x1a6>
    1efe:	21 c0       	rjmp	.+66     	; 0x1f42 <vfprintf+0x13c>
    1f00:	f8 01       	movw	r30, r16
    1f02:	80 81       	ld	r24, Z
    1f04:	89 83       	std	Y+1, r24	; 0x01
    1f06:	0e 5f       	subi	r16, 0xFE	; 254
    1f08:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0a:	44 24       	eor	r4, r4
    1f0c:	43 94       	inc	r4
    1f0e:	51 2c       	mov	r5, r1
    1f10:	54 01       	movw	r10, r8
    1f12:	14 c0       	rjmp	.+40     	; 0x1f3c <vfprintf+0x136>
    1f14:	38 01       	movw	r6, r16
    1f16:	f2 e0       	ldi	r31, 0x02	; 2
    1f18:	6f 0e       	add	r6, r31
    1f1a:	71 1c       	adc	r7, r1
    1f1c:	f8 01       	movw	r30, r16
    1f1e:	a0 80       	ld	r10, Z
    1f20:	b1 80       	ldd	r11, Z+1	; 0x01
    1f22:	26 ff       	sbrs	r18, 6
    1f24:	03 c0       	rjmp	.+6      	; 0x1f2c <vfprintf+0x126>
    1f26:	65 2d       	mov	r22, r5
    1f28:	70 e0       	ldi	r23, 0x00	; 0
    1f2a:	02 c0       	rjmp	.+4      	; 0x1f30 <vfprintf+0x12a>
    1f2c:	6f ef       	ldi	r22, 0xFF	; 255
    1f2e:	7f ef       	ldi	r23, 0xFF	; 255
    1f30:	c5 01       	movw	r24, r10
    1f32:	2c 87       	std	Y+12, r18	; 0x0c
    1f34:	36 d1       	rcall	.+620    	; 0x21a2 <strnlen>
    1f36:	2c 01       	movw	r4, r24
    1f38:	83 01       	movw	r16, r6
    1f3a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f3c:	2f 77       	andi	r18, 0x7F	; 127
    1f3e:	22 2e       	mov	r2, r18
    1f40:	16 c0       	rjmp	.+44     	; 0x1f6e <vfprintf+0x168>
    1f42:	38 01       	movw	r6, r16
    1f44:	f2 e0       	ldi	r31, 0x02	; 2
    1f46:	6f 0e       	add	r6, r31
    1f48:	71 1c       	adc	r7, r1
    1f4a:	f8 01       	movw	r30, r16
    1f4c:	a0 80       	ld	r10, Z
    1f4e:	b1 80       	ldd	r11, Z+1	; 0x01
    1f50:	26 ff       	sbrs	r18, 6
    1f52:	03 c0       	rjmp	.+6      	; 0x1f5a <vfprintf+0x154>
    1f54:	65 2d       	mov	r22, r5
    1f56:	70 e0       	ldi	r23, 0x00	; 0
    1f58:	02 c0       	rjmp	.+4      	; 0x1f5e <vfprintf+0x158>
    1f5a:	6f ef       	ldi	r22, 0xFF	; 255
    1f5c:	7f ef       	ldi	r23, 0xFF	; 255
    1f5e:	c5 01       	movw	r24, r10
    1f60:	2c 87       	std	Y+12, r18	; 0x0c
    1f62:	14 d1       	rcall	.+552    	; 0x218c <strnlen_P>
    1f64:	2c 01       	movw	r4, r24
    1f66:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f68:	20 68       	ori	r18, 0x80	; 128
    1f6a:	22 2e       	mov	r2, r18
    1f6c:	83 01       	movw	r16, r6
    1f6e:	23 fc       	sbrc	r2, 3
    1f70:	19 c0       	rjmp	.+50     	; 0x1fa4 <vfprintf+0x19e>
    1f72:	83 2d       	mov	r24, r3
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	48 16       	cp	r4, r24
    1f78:	59 06       	cpc	r5, r25
    1f7a:	a0 f4       	brcc	.+40     	; 0x1fa4 <vfprintf+0x19e>
    1f7c:	b7 01       	movw	r22, r14
    1f7e:	80 e2       	ldi	r24, 0x20	; 32
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	1a d1       	rcall	.+564    	; 0x21b8 <fputc>
    1f84:	3a 94       	dec	r3
    1f86:	f5 cf       	rjmp	.-22     	; 0x1f72 <vfprintf+0x16c>
    1f88:	f5 01       	movw	r30, r10
    1f8a:	27 fc       	sbrc	r2, 7
    1f8c:	85 91       	lpm	r24, Z+
    1f8e:	27 fe       	sbrs	r2, 7
    1f90:	81 91       	ld	r24, Z+
    1f92:	5f 01       	movw	r10, r30
    1f94:	b7 01       	movw	r22, r14
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	0f d1       	rcall	.+542    	; 0x21b8 <fputc>
    1f9a:	31 10       	cpse	r3, r1
    1f9c:	3a 94       	dec	r3
    1f9e:	f1 e0       	ldi	r31, 0x01	; 1
    1fa0:	4f 1a       	sub	r4, r31
    1fa2:	51 08       	sbc	r5, r1
    1fa4:	41 14       	cp	r4, r1
    1fa6:	51 04       	cpc	r5, r1
    1fa8:	79 f7       	brne	.-34     	; 0x1f88 <vfprintf+0x182>
    1faa:	de c0       	rjmp	.+444    	; 0x2168 <vfprintf+0x362>
    1fac:	84 36       	cpi	r24, 0x64	; 100
    1fae:	11 f0       	breq	.+4      	; 0x1fb4 <vfprintf+0x1ae>
    1fb0:	89 36       	cpi	r24, 0x69	; 105
    1fb2:	31 f5       	brne	.+76     	; 0x2000 <vfprintf+0x1fa>
    1fb4:	f8 01       	movw	r30, r16
    1fb6:	27 ff       	sbrs	r18, 7
    1fb8:	07 c0       	rjmp	.+14     	; 0x1fc8 <vfprintf+0x1c2>
    1fba:	60 81       	ld	r22, Z
    1fbc:	71 81       	ldd	r23, Z+1	; 0x01
    1fbe:	82 81       	ldd	r24, Z+2	; 0x02
    1fc0:	93 81       	ldd	r25, Z+3	; 0x03
    1fc2:	0c 5f       	subi	r16, 0xFC	; 252
    1fc4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc6:	08 c0       	rjmp	.+16     	; 0x1fd8 <vfprintf+0x1d2>
    1fc8:	60 81       	ld	r22, Z
    1fca:	71 81       	ldd	r23, Z+1	; 0x01
    1fcc:	07 2e       	mov	r0, r23
    1fce:	00 0c       	add	r0, r0
    1fd0:	88 0b       	sbc	r24, r24
    1fd2:	99 0b       	sbc	r25, r25
    1fd4:	0e 5f       	subi	r16, 0xFE	; 254
    1fd6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd8:	2f 76       	andi	r18, 0x6F	; 111
    1fda:	72 2e       	mov	r7, r18
    1fdc:	97 ff       	sbrs	r25, 7
    1fde:	09 c0       	rjmp	.+18     	; 0x1ff2 <vfprintf+0x1ec>
    1fe0:	90 95       	com	r25
    1fe2:	80 95       	com	r24
    1fe4:	70 95       	com	r23
    1fe6:	61 95       	neg	r22
    1fe8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fea:	8f 4f       	sbci	r24, 0xFF	; 255
    1fec:	9f 4f       	sbci	r25, 0xFF	; 255
    1fee:	20 68       	ori	r18, 0x80	; 128
    1ff0:	72 2e       	mov	r7, r18
    1ff2:	2a e0       	ldi	r18, 0x0A	; 10
    1ff4:	30 e0       	ldi	r19, 0x00	; 0
    1ff6:	a4 01       	movw	r20, r8
    1ff8:	17 d1       	rcall	.+558    	; 0x2228 <__ultoa_invert>
    1ffa:	a8 2e       	mov	r10, r24
    1ffc:	a8 18       	sub	r10, r8
    1ffe:	43 c0       	rjmp	.+134    	; 0x2086 <vfprintf+0x280>
    2000:	85 37       	cpi	r24, 0x75	; 117
    2002:	29 f4       	brne	.+10     	; 0x200e <vfprintf+0x208>
    2004:	2f 7e       	andi	r18, 0xEF	; 239
    2006:	b2 2e       	mov	r11, r18
    2008:	2a e0       	ldi	r18, 0x0A	; 10
    200a:	30 e0       	ldi	r19, 0x00	; 0
    200c:	25 c0       	rjmp	.+74     	; 0x2058 <vfprintf+0x252>
    200e:	f2 2f       	mov	r31, r18
    2010:	f9 7f       	andi	r31, 0xF9	; 249
    2012:	bf 2e       	mov	r11, r31
    2014:	8f 36       	cpi	r24, 0x6F	; 111
    2016:	c1 f0       	breq	.+48     	; 0x2048 <vfprintf+0x242>
    2018:	18 f4       	brcc	.+6      	; 0x2020 <vfprintf+0x21a>
    201a:	88 35       	cpi	r24, 0x58	; 88
    201c:	79 f0       	breq	.+30     	; 0x203c <vfprintf+0x236>
    201e:	ad c0       	rjmp	.+346    	; 0x217a <vfprintf+0x374>
    2020:	80 37       	cpi	r24, 0x70	; 112
    2022:	19 f0       	breq	.+6      	; 0x202a <vfprintf+0x224>
    2024:	88 37       	cpi	r24, 0x78	; 120
    2026:	21 f0       	breq	.+8      	; 0x2030 <vfprintf+0x22a>
    2028:	a8 c0       	rjmp	.+336    	; 0x217a <vfprintf+0x374>
    202a:	2f 2f       	mov	r18, r31
    202c:	20 61       	ori	r18, 0x10	; 16
    202e:	b2 2e       	mov	r11, r18
    2030:	b4 fe       	sbrs	r11, 4
    2032:	0d c0       	rjmp	.+26     	; 0x204e <vfprintf+0x248>
    2034:	8b 2d       	mov	r24, r11
    2036:	84 60       	ori	r24, 0x04	; 4
    2038:	b8 2e       	mov	r11, r24
    203a:	09 c0       	rjmp	.+18     	; 0x204e <vfprintf+0x248>
    203c:	24 ff       	sbrs	r18, 4
    203e:	0a c0       	rjmp	.+20     	; 0x2054 <vfprintf+0x24e>
    2040:	9f 2f       	mov	r25, r31
    2042:	96 60       	ori	r25, 0x06	; 6
    2044:	b9 2e       	mov	r11, r25
    2046:	06 c0       	rjmp	.+12     	; 0x2054 <vfprintf+0x24e>
    2048:	28 e0       	ldi	r18, 0x08	; 8
    204a:	30 e0       	ldi	r19, 0x00	; 0
    204c:	05 c0       	rjmp	.+10     	; 0x2058 <vfprintf+0x252>
    204e:	20 e1       	ldi	r18, 0x10	; 16
    2050:	30 e0       	ldi	r19, 0x00	; 0
    2052:	02 c0       	rjmp	.+4      	; 0x2058 <vfprintf+0x252>
    2054:	20 e1       	ldi	r18, 0x10	; 16
    2056:	32 e0       	ldi	r19, 0x02	; 2
    2058:	f8 01       	movw	r30, r16
    205a:	b7 fe       	sbrs	r11, 7
    205c:	07 c0       	rjmp	.+14     	; 0x206c <vfprintf+0x266>
    205e:	60 81       	ld	r22, Z
    2060:	71 81       	ldd	r23, Z+1	; 0x01
    2062:	82 81       	ldd	r24, Z+2	; 0x02
    2064:	93 81       	ldd	r25, Z+3	; 0x03
    2066:	0c 5f       	subi	r16, 0xFC	; 252
    2068:	1f 4f       	sbci	r17, 0xFF	; 255
    206a:	06 c0       	rjmp	.+12     	; 0x2078 <vfprintf+0x272>
    206c:	60 81       	ld	r22, Z
    206e:	71 81       	ldd	r23, Z+1	; 0x01
    2070:	80 e0       	ldi	r24, 0x00	; 0
    2072:	90 e0       	ldi	r25, 0x00	; 0
    2074:	0e 5f       	subi	r16, 0xFE	; 254
    2076:	1f 4f       	sbci	r17, 0xFF	; 255
    2078:	a4 01       	movw	r20, r8
    207a:	d6 d0       	rcall	.+428    	; 0x2228 <__ultoa_invert>
    207c:	a8 2e       	mov	r10, r24
    207e:	a8 18       	sub	r10, r8
    2080:	fb 2d       	mov	r31, r11
    2082:	ff 77       	andi	r31, 0x7F	; 127
    2084:	7f 2e       	mov	r7, r31
    2086:	76 fe       	sbrs	r7, 6
    2088:	0b c0       	rjmp	.+22     	; 0x20a0 <vfprintf+0x29a>
    208a:	37 2d       	mov	r19, r7
    208c:	3e 7f       	andi	r19, 0xFE	; 254
    208e:	a5 14       	cp	r10, r5
    2090:	50 f4       	brcc	.+20     	; 0x20a6 <vfprintf+0x2a0>
    2092:	74 fe       	sbrs	r7, 4
    2094:	0a c0       	rjmp	.+20     	; 0x20aa <vfprintf+0x2a4>
    2096:	72 fc       	sbrc	r7, 2
    2098:	08 c0       	rjmp	.+16     	; 0x20aa <vfprintf+0x2a4>
    209a:	37 2d       	mov	r19, r7
    209c:	3e 7e       	andi	r19, 0xEE	; 238
    209e:	05 c0       	rjmp	.+10     	; 0x20aa <vfprintf+0x2a4>
    20a0:	ba 2c       	mov	r11, r10
    20a2:	37 2d       	mov	r19, r7
    20a4:	03 c0       	rjmp	.+6      	; 0x20ac <vfprintf+0x2a6>
    20a6:	ba 2c       	mov	r11, r10
    20a8:	01 c0       	rjmp	.+2      	; 0x20ac <vfprintf+0x2a6>
    20aa:	b5 2c       	mov	r11, r5
    20ac:	34 ff       	sbrs	r19, 4
    20ae:	0d c0       	rjmp	.+26     	; 0x20ca <vfprintf+0x2c4>
    20b0:	fe 01       	movw	r30, r28
    20b2:	ea 0d       	add	r30, r10
    20b4:	f1 1d       	adc	r31, r1
    20b6:	80 81       	ld	r24, Z
    20b8:	80 33       	cpi	r24, 0x30	; 48
    20ba:	11 f4       	brne	.+4      	; 0x20c0 <vfprintf+0x2ba>
    20bc:	39 7e       	andi	r19, 0xE9	; 233
    20be:	09 c0       	rjmp	.+18     	; 0x20d2 <vfprintf+0x2cc>
    20c0:	32 ff       	sbrs	r19, 2
    20c2:	06 c0       	rjmp	.+12     	; 0x20d0 <vfprintf+0x2ca>
    20c4:	b3 94       	inc	r11
    20c6:	b3 94       	inc	r11
    20c8:	04 c0       	rjmp	.+8      	; 0x20d2 <vfprintf+0x2cc>
    20ca:	83 2f       	mov	r24, r19
    20cc:	86 78       	andi	r24, 0x86	; 134
    20ce:	09 f0       	breq	.+2      	; 0x20d2 <vfprintf+0x2cc>
    20d0:	b3 94       	inc	r11
    20d2:	33 fd       	sbrc	r19, 3
    20d4:	12 c0       	rjmp	.+36     	; 0x20fa <vfprintf+0x2f4>
    20d6:	30 ff       	sbrs	r19, 0
    20d8:	06 c0       	rjmp	.+12     	; 0x20e6 <vfprintf+0x2e0>
    20da:	5a 2c       	mov	r5, r10
    20dc:	b3 14       	cp	r11, r3
    20de:	18 f4       	brcc	.+6      	; 0x20e6 <vfprintf+0x2e0>
    20e0:	53 0c       	add	r5, r3
    20e2:	5b 18       	sub	r5, r11
    20e4:	b3 2c       	mov	r11, r3
    20e6:	b3 14       	cp	r11, r3
    20e8:	60 f4       	brcc	.+24     	; 0x2102 <vfprintf+0x2fc>
    20ea:	b7 01       	movw	r22, r14
    20ec:	80 e2       	ldi	r24, 0x20	; 32
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	3c 87       	std	Y+12, r19	; 0x0c
    20f2:	62 d0       	rcall	.+196    	; 0x21b8 <fputc>
    20f4:	b3 94       	inc	r11
    20f6:	3c 85       	ldd	r19, Y+12	; 0x0c
    20f8:	f6 cf       	rjmp	.-20     	; 0x20e6 <vfprintf+0x2e0>
    20fa:	b3 14       	cp	r11, r3
    20fc:	10 f4       	brcc	.+4      	; 0x2102 <vfprintf+0x2fc>
    20fe:	3b 18       	sub	r3, r11
    2100:	01 c0       	rjmp	.+2      	; 0x2104 <vfprintf+0x2fe>
    2102:	31 2c       	mov	r3, r1
    2104:	34 ff       	sbrs	r19, 4
    2106:	11 c0       	rjmp	.+34     	; 0x212a <vfprintf+0x324>
    2108:	b7 01       	movw	r22, r14
    210a:	80 e3       	ldi	r24, 0x30	; 48
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	3c 87       	std	Y+12, r19	; 0x0c
    2110:	53 d0       	rcall	.+166    	; 0x21b8 <fputc>
    2112:	3c 85       	ldd	r19, Y+12	; 0x0c
    2114:	32 ff       	sbrs	r19, 2
    2116:	16 c0       	rjmp	.+44     	; 0x2144 <vfprintf+0x33e>
    2118:	31 fd       	sbrc	r19, 1
    211a:	03 c0       	rjmp	.+6      	; 0x2122 <vfprintf+0x31c>
    211c:	88 e7       	ldi	r24, 0x78	; 120
    211e:	90 e0       	ldi	r25, 0x00	; 0
    2120:	02 c0       	rjmp	.+4      	; 0x2126 <vfprintf+0x320>
    2122:	88 e5       	ldi	r24, 0x58	; 88
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	b7 01       	movw	r22, r14
    2128:	0c c0       	rjmp	.+24     	; 0x2142 <vfprintf+0x33c>
    212a:	83 2f       	mov	r24, r19
    212c:	86 78       	andi	r24, 0x86	; 134
    212e:	51 f0       	breq	.+20     	; 0x2144 <vfprintf+0x33e>
    2130:	31 ff       	sbrs	r19, 1
    2132:	02 c0       	rjmp	.+4      	; 0x2138 <vfprintf+0x332>
    2134:	8b e2       	ldi	r24, 0x2B	; 43
    2136:	01 c0       	rjmp	.+2      	; 0x213a <vfprintf+0x334>
    2138:	80 e2       	ldi	r24, 0x20	; 32
    213a:	37 fd       	sbrc	r19, 7
    213c:	8d e2       	ldi	r24, 0x2D	; 45
    213e:	b7 01       	movw	r22, r14
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	3a d0       	rcall	.+116    	; 0x21b8 <fputc>
    2144:	a5 14       	cp	r10, r5
    2146:	30 f4       	brcc	.+12     	; 0x2154 <vfprintf+0x34e>
    2148:	b7 01       	movw	r22, r14
    214a:	80 e3       	ldi	r24, 0x30	; 48
    214c:	90 e0       	ldi	r25, 0x00	; 0
    214e:	34 d0       	rcall	.+104    	; 0x21b8 <fputc>
    2150:	5a 94       	dec	r5
    2152:	f8 cf       	rjmp	.-16     	; 0x2144 <vfprintf+0x33e>
    2154:	aa 94       	dec	r10
    2156:	f4 01       	movw	r30, r8
    2158:	ea 0d       	add	r30, r10
    215a:	f1 1d       	adc	r31, r1
    215c:	80 81       	ld	r24, Z
    215e:	b7 01       	movw	r22, r14
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	2a d0       	rcall	.+84     	; 0x21b8 <fputc>
    2164:	a1 10       	cpse	r10, r1
    2166:	f6 cf       	rjmp	.-20     	; 0x2154 <vfprintf+0x34e>
    2168:	33 20       	and	r3, r3
    216a:	09 f4       	brne	.+2      	; 0x216e <vfprintf+0x368>
    216c:	5d ce       	rjmp	.-838    	; 0x1e28 <vfprintf+0x22>
    216e:	b7 01       	movw	r22, r14
    2170:	80 e2       	ldi	r24, 0x20	; 32
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	21 d0       	rcall	.+66     	; 0x21b8 <fputc>
    2176:	3a 94       	dec	r3
    2178:	f7 cf       	rjmp	.-18     	; 0x2168 <vfprintf+0x362>
    217a:	f7 01       	movw	r30, r14
    217c:	86 81       	ldd	r24, Z+6	; 0x06
    217e:	97 81       	ldd	r25, Z+7	; 0x07
    2180:	02 c0       	rjmp	.+4      	; 0x2186 <vfprintf+0x380>
    2182:	8f ef       	ldi	r24, 0xFF	; 255
    2184:	9f ef       	ldi	r25, 0xFF	; 255
    2186:	2c 96       	adiw	r28, 0x0c	; 12
    2188:	e2 e1       	ldi	r30, 0x12	; 18
    218a:	ab cd       	rjmp	.-1194   	; 0x1ce2 <__epilogue_restores__>

0000218c <strnlen_P>:
    218c:	fc 01       	movw	r30, r24
    218e:	05 90       	lpm	r0, Z+
    2190:	61 50       	subi	r22, 0x01	; 1
    2192:	70 40       	sbci	r23, 0x00	; 0
    2194:	01 10       	cpse	r0, r1
    2196:	d8 f7       	brcc	.-10     	; 0x218e <strnlen_P+0x2>
    2198:	80 95       	com	r24
    219a:	90 95       	com	r25
    219c:	8e 0f       	add	r24, r30
    219e:	9f 1f       	adc	r25, r31
    21a0:	08 95       	ret

000021a2 <strnlen>:
    21a2:	fc 01       	movw	r30, r24
    21a4:	61 50       	subi	r22, 0x01	; 1
    21a6:	70 40       	sbci	r23, 0x00	; 0
    21a8:	01 90       	ld	r0, Z+
    21aa:	01 10       	cpse	r0, r1
    21ac:	d8 f7       	brcc	.-10     	; 0x21a4 <strnlen+0x2>
    21ae:	80 95       	com	r24
    21b0:	90 95       	com	r25
    21b2:	8e 0f       	add	r24, r30
    21b4:	9f 1f       	adc	r25, r31
    21b6:	08 95       	ret

000021b8 <fputc>:
    21b8:	0f 93       	push	r16
    21ba:	1f 93       	push	r17
    21bc:	cf 93       	push	r28
    21be:	df 93       	push	r29
    21c0:	fb 01       	movw	r30, r22
    21c2:	23 81       	ldd	r18, Z+3	; 0x03
    21c4:	21 fd       	sbrc	r18, 1
    21c6:	03 c0       	rjmp	.+6      	; 0x21ce <fputc+0x16>
    21c8:	8f ef       	ldi	r24, 0xFF	; 255
    21ca:	9f ef       	ldi	r25, 0xFF	; 255
    21cc:	28 c0       	rjmp	.+80     	; 0x221e <fputc+0x66>
    21ce:	22 ff       	sbrs	r18, 2
    21d0:	16 c0       	rjmp	.+44     	; 0x21fe <fputc+0x46>
    21d2:	46 81       	ldd	r20, Z+6	; 0x06
    21d4:	57 81       	ldd	r21, Z+7	; 0x07
    21d6:	24 81       	ldd	r18, Z+4	; 0x04
    21d8:	35 81       	ldd	r19, Z+5	; 0x05
    21da:	42 17       	cp	r20, r18
    21dc:	53 07       	cpc	r21, r19
    21de:	44 f4       	brge	.+16     	; 0x21f0 <fputc+0x38>
    21e0:	a0 81       	ld	r26, Z
    21e2:	b1 81       	ldd	r27, Z+1	; 0x01
    21e4:	9d 01       	movw	r18, r26
    21e6:	2f 5f       	subi	r18, 0xFF	; 255
    21e8:	3f 4f       	sbci	r19, 0xFF	; 255
    21ea:	31 83       	std	Z+1, r19	; 0x01
    21ec:	20 83       	st	Z, r18
    21ee:	8c 93       	st	X, r24
    21f0:	26 81       	ldd	r18, Z+6	; 0x06
    21f2:	37 81       	ldd	r19, Z+7	; 0x07
    21f4:	2f 5f       	subi	r18, 0xFF	; 255
    21f6:	3f 4f       	sbci	r19, 0xFF	; 255
    21f8:	37 83       	std	Z+7, r19	; 0x07
    21fa:	26 83       	std	Z+6, r18	; 0x06
    21fc:	10 c0       	rjmp	.+32     	; 0x221e <fputc+0x66>
    21fe:	eb 01       	movw	r28, r22
    2200:	09 2f       	mov	r16, r25
    2202:	18 2f       	mov	r17, r24
    2204:	00 84       	ldd	r0, Z+8	; 0x08
    2206:	f1 85       	ldd	r31, Z+9	; 0x09
    2208:	e0 2d       	mov	r30, r0
    220a:	09 95       	icall
    220c:	89 2b       	or	r24, r25
    220e:	e1 f6       	brne	.-72     	; 0x21c8 <fputc+0x10>
    2210:	8e 81       	ldd	r24, Y+6	; 0x06
    2212:	9f 81       	ldd	r25, Y+7	; 0x07
    2214:	01 96       	adiw	r24, 0x01	; 1
    2216:	9f 83       	std	Y+7, r25	; 0x07
    2218:	8e 83       	std	Y+6, r24	; 0x06
    221a:	81 2f       	mov	r24, r17
    221c:	90 2f       	mov	r25, r16
    221e:	df 91       	pop	r29
    2220:	cf 91       	pop	r28
    2222:	1f 91       	pop	r17
    2224:	0f 91       	pop	r16
    2226:	08 95       	ret

00002228 <__ultoa_invert>:
    2228:	fa 01       	movw	r30, r20
    222a:	aa 27       	eor	r26, r26
    222c:	28 30       	cpi	r18, 0x08	; 8
    222e:	51 f1       	breq	.+84     	; 0x2284 <__ultoa_invert+0x5c>
    2230:	20 31       	cpi	r18, 0x10	; 16
    2232:	81 f1       	breq	.+96     	; 0x2294 <__ultoa_invert+0x6c>
    2234:	e8 94       	clt
    2236:	6f 93       	push	r22
    2238:	6e 7f       	andi	r22, 0xFE	; 254
    223a:	6e 5f       	subi	r22, 0xFE	; 254
    223c:	7f 4f       	sbci	r23, 0xFF	; 255
    223e:	8f 4f       	sbci	r24, 0xFF	; 255
    2240:	9f 4f       	sbci	r25, 0xFF	; 255
    2242:	af 4f       	sbci	r26, 0xFF	; 255
    2244:	b1 e0       	ldi	r27, 0x01	; 1
    2246:	3e d0       	rcall	.+124    	; 0x22c4 <__ultoa_invert+0x9c>
    2248:	b4 e0       	ldi	r27, 0x04	; 4
    224a:	3c d0       	rcall	.+120    	; 0x22c4 <__ultoa_invert+0x9c>
    224c:	67 0f       	add	r22, r23
    224e:	78 1f       	adc	r23, r24
    2250:	89 1f       	adc	r24, r25
    2252:	9a 1f       	adc	r25, r26
    2254:	a1 1d       	adc	r26, r1
    2256:	68 0f       	add	r22, r24
    2258:	79 1f       	adc	r23, r25
    225a:	8a 1f       	adc	r24, r26
    225c:	91 1d       	adc	r25, r1
    225e:	a1 1d       	adc	r26, r1
    2260:	6a 0f       	add	r22, r26
    2262:	71 1d       	adc	r23, r1
    2264:	81 1d       	adc	r24, r1
    2266:	91 1d       	adc	r25, r1
    2268:	a1 1d       	adc	r26, r1
    226a:	20 d0       	rcall	.+64     	; 0x22ac <__ultoa_invert+0x84>
    226c:	09 f4       	brne	.+2      	; 0x2270 <__ultoa_invert+0x48>
    226e:	68 94       	set
    2270:	3f 91       	pop	r19
    2272:	2a e0       	ldi	r18, 0x0A	; 10
    2274:	26 9f       	mul	r18, r22
    2276:	11 24       	eor	r1, r1
    2278:	30 19       	sub	r19, r0
    227a:	30 5d       	subi	r19, 0xD0	; 208
    227c:	31 93       	st	Z+, r19
    227e:	de f6       	brtc	.-74     	; 0x2236 <__ultoa_invert+0xe>
    2280:	cf 01       	movw	r24, r30
    2282:	08 95       	ret
    2284:	46 2f       	mov	r20, r22
    2286:	47 70       	andi	r20, 0x07	; 7
    2288:	40 5d       	subi	r20, 0xD0	; 208
    228a:	41 93       	st	Z+, r20
    228c:	b3 e0       	ldi	r27, 0x03	; 3
    228e:	0f d0       	rcall	.+30     	; 0x22ae <__ultoa_invert+0x86>
    2290:	c9 f7       	brne	.-14     	; 0x2284 <__ultoa_invert+0x5c>
    2292:	f6 cf       	rjmp	.-20     	; 0x2280 <__ultoa_invert+0x58>
    2294:	46 2f       	mov	r20, r22
    2296:	4f 70       	andi	r20, 0x0F	; 15
    2298:	40 5d       	subi	r20, 0xD0	; 208
    229a:	4a 33       	cpi	r20, 0x3A	; 58
    229c:	18 f0       	brcs	.+6      	; 0x22a4 <__ultoa_invert+0x7c>
    229e:	49 5d       	subi	r20, 0xD9	; 217
    22a0:	31 fd       	sbrc	r19, 1
    22a2:	40 52       	subi	r20, 0x20	; 32
    22a4:	41 93       	st	Z+, r20
    22a6:	02 d0       	rcall	.+4      	; 0x22ac <__ultoa_invert+0x84>
    22a8:	a9 f7       	brne	.-22     	; 0x2294 <__ultoa_invert+0x6c>
    22aa:	ea cf       	rjmp	.-44     	; 0x2280 <__ultoa_invert+0x58>
    22ac:	b4 e0       	ldi	r27, 0x04	; 4
    22ae:	a6 95       	lsr	r26
    22b0:	97 95       	ror	r25
    22b2:	87 95       	ror	r24
    22b4:	77 95       	ror	r23
    22b6:	67 95       	ror	r22
    22b8:	ba 95       	dec	r27
    22ba:	c9 f7       	brne	.-14     	; 0x22ae <__ultoa_invert+0x86>
    22bc:	00 97       	sbiw	r24, 0x00	; 0
    22be:	61 05       	cpc	r22, r1
    22c0:	71 05       	cpc	r23, r1
    22c2:	08 95       	ret
    22c4:	9b 01       	movw	r18, r22
    22c6:	ac 01       	movw	r20, r24
    22c8:	0a 2e       	mov	r0, r26
    22ca:	06 94       	lsr	r0
    22cc:	57 95       	ror	r21
    22ce:	47 95       	ror	r20
    22d0:	37 95       	ror	r19
    22d2:	27 95       	ror	r18
    22d4:	ba 95       	dec	r27
    22d6:	c9 f7       	brne	.-14     	; 0x22ca <__ultoa_invert+0xa2>
    22d8:	62 0f       	add	r22, r18
    22da:	73 1f       	adc	r23, r19
    22dc:	84 1f       	adc	r24, r20
    22de:	95 1f       	adc	r25, r21
    22e0:	a0 1d       	adc	r26, r0
    22e2:	08 95       	ret

000022e4 <eeprom_read_word>:
    22e4:	a8 e1       	ldi	r26, 0x18	; 24
    22e6:	b0 e0       	ldi	r27, 0x00	; 0
    22e8:	42 e0       	ldi	r20, 0x02	; 2
    22ea:	50 e0       	ldi	r21, 0x00	; 0
    22ec:	02 c0       	rjmp	.+4      	; 0x22f2 <eeprom_read_blraw>

000022ee <eeprom_read_block>:
    22ee:	dc 01       	movw	r26, r24
    22f0:	cb 01       	movw	r24, r22

000022f2 <eeprom_read_blraw>:
    22f2:	fc 01       	movw	r30, r24
    22f4:	f9 99       	sbic	0x1f, 1	; 31
    22f6:	fe cf       	rjmp	.-4      	; 0x22f4 <eeprom_read_blraw+0x2>
    22f8:	06 c0       	rjmp	.+12     	; 0x2306 <eeprom_read_blraw+0x14>
    22fa:	f2 bd       	out	0x22, r31	; 34
    22fc:	e1 bd       	out	0x21, r30	; 33
    22fe:	f8 9a       	sbi	0x1f, 0	; 31
    2300:	31 96       	adiw	r30, 0x01	; 1
    2302:	00 b4       	in	r0, 0x20	; 32
    2304:	0d 92       	st	X+, r0
    2306:	41 50       	subi	r20, 0x01	; 1
    2308:	50 40       	sbci	r21, 0x00	; 0
    230a:	b8 f7       	brcc	.-18     	; 0x22fa <eeprom_read_blraw+0x8>
    230c:	08 95       	ret

0000230e <_exit>:
    230e:	f8 94       	cli

00002310 <__stop_program>:
    2310:	ff cf       	rjmp	.-2      	; 0x2310 <__stop_program>
