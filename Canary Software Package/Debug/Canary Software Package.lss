
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ca  00800100  00002358  000023ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002358  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000507  008001ca  008001ca  000024b6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000024b6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002514  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000308  00000000  00000000  00002558  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000051c9  00000000  00000000  00002860  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001978  00000000  00000000  00007a29  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000022f8  00000000  00000000  000093a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009f8  00000000  00000000  0000b69c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010c4  00000000  00000000  0000c094  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000038a6  00000000  00000000  0000d158  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  000109fe  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 54 0b 	jmp	0x16a8	; 0x16a8 <__vector_13>
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 53 0b 	jmp	0x16a6	; 0x16a6 <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 c2 0b 	jmp	0x1784	; 0x1784 <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 d1 0c 	jmp	0x19a2	; 0x19a2 <__vector_28>
      74:	7b c0       	rjmp	.+246    	; 0x16c <__bad_interrupt>
      76:	00 00       	nop
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	de 0b       	sbc	r29, r30
      8e:	30 0c       	add	r3, r0
      90:	30 0c       	add	r3, r0
      92:	30 0c       	add	r3, r0
      94:	30 0c       	add	r3, r0
      96:	30 0c       	add	r3, r0
      98:	30 0c       	add	r3, r0
      9a:	30 0c       	add	r3, r0
      9c:	de 0b       	sbc	r29, r30
      9e:	30 0c       	add	r3, r0
      a0:	30 0c       	add	r3, r0
      a2:	30 0c       	add	r3, r0
      a4:	30 0c       	add	r3, r0
      a6:	30 0c       	add	r3, r0
      a8:	30 0c       	add	r3, r0
      aa:	30 0c       	add	r3, r0
      ac:	e0 0b       	sbc	r30, r16
      ae:	30 0c       	add	r3, r0
      b0:	30 0c       	add	r3, r0
      b2:	30 0c       	add	r3, r0
      b4:	30 0c       	add	r3, r0
      b6:	30 0c       	add	r3, r0
      b8:	30 0c       	add	r3, r0
      ba:	30 0c       	add	r3, r0
      bc:	30 0c       	add	r3, r0
      be:	30 0c       	add	r3, r0
      c0:	30 0c       	add	r3, r0
      c2:	30 0c       	add	r3, r0
      c4:	30 0c       	add	r3, r0
      c6:	30 0c       	add	r3, r0
      c8:	30 0c       	add	r3, r0
      ca:	30 0c       	add	r3, r0
      cc:	e0 0b       	sbc	r30, r16
      ce:	30 0c       	add	r3, r0
      d0:	30 0c       	add	r3, r0
      d2:	30 0c       	add	r3, r0
      d4:	30 0c       	add	r3, r0
      d6:	30 0c       	add	r3, r0
      d8:	30 0c       	add	r3, r0
      da:	30 0c       	add	r3, r0
      dc:	30 0c       	add	r3, r0
      de:	30 0c       	add	r3, r0
      e0:	30 0c       	add	r3, r0
      e2:	30 0c       	add	r3, r0
      e4:	30 0c       	add	r3, r0
      e6:	30 0c       	add	r3, r0
      e8:	30 0c       	add	r3, r0
      ea:	30 0c       	add	r3, r0
      ec:	2c 0c       	add	r2, r12
      ee:	30 0c       	add	r3, r0
      f0:	30 0c       	add	r3, r0
      f2:	30 0c       	add	r3, r0
      f4:	30 0c       	add	r3, r0
      f6:	30 0c       	add	r3, r0
      f8:	30 0c       	add	r3, r0
      fa:	30 0c       	add	r3, r0
      fc:	09 0c       	add	r0, r9
      fe:	30 0c       	add	r3, r0
     100:	30 0c       	add	r3, r0
     102:	30 0c       	add	r3, r0
     104:	30 0c       	add	r3, r0
     106:	30 0c       	add	r3, r0
     108:	30 0c       	add	r3, r0
     10a:	30 0c       	add	r3, r0
     10c:	30 0c       	add	r3, r0
     10e:	30 0c       	add	r3, r0
     110:	30 0c       	add	r3, r0
     112:	30 0c       	add	r3, r0
     114:	30 0c       	add	r3, r0
     116:	30 0c       	add	r3, r0
     118:	30 0c       	add	r3, r0
     11a:	30 0c       	add	r3, r0
     11c:	fd 0b       	sbc	r31, r29
     11e:	30 0c       	add	r3, r0
     120:	30 0c       	add	r3, r0
     122:	30 0c       	add	r3, r0
     124:	30 0c       	add	r3, r0
     126:	30 0c       	add	r3, r0
     128:	30 0c       	add	r3, r0
     12a:	30 0c       	add	r3, r0
     12c:	1b 0c       	add	r1, r11

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	e8 e5       	ldi	r30, 0x58	; 88
     142:	f3 e2       	ldi	r31, 0x23	; 35
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	aa 3c       	cpi	r26, 0xCA	; 202
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	26 e0       	ldi	r18, 0x06	; 6
     156:	aa ec       	ldi	r26, 0xCA	; 202
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a1 3d       	cpi	r26, 0xD1	; 209
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 02 0a 	call	0x1404	; 0x1404 <main>
     168:	0c 94 aa 11 	jmp	0x2354	; 0x2354 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 3e 0b 	jmp	0x167c	; 0x167c <__vector_default>

00000170 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	90 81       	ld	r25, Z
     176:	90 7e       	andi	r25, 0xE0	; 224
     178:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     17a:	90 81       	ld	r25, Z
     17c:	89 2b       	or	r24, r25
     17e:	80 83       	st	Z, r24
     180:	08 95       	ret

00000182 <ADC_init>:
}

void ADC_init(void)
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     186:	ec e7       	ldi	r30, 0x7C	; 124
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	80 64       	ori	r24, 0x40	; 64
     18e:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     190:	ca e7       	ldi	r28, 0x7A	; 122
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	88 81       	ld	r24, Y
     196:	81 60       	ori	r24, 0x01	; 1
     198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     19a:	88 81       	ld	r24, Y
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     1a0:	88 81       	ld	r24, Y
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a6:	a4 e6       	ldi	r26, 0x64	; 100
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	8c 91       	ld	r24, X
     1ac:	8e 7f       	andi	r24, 0xFE	; 254
     1ae:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 7d       	andi	r24, 0xDF	; 223
     1b4:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b6:	8f e3       	ldi	r24, 0x3F	; 63
     1b8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1bc:	88 81       	ld	r24, Y
     1be:	80 68       	ori	r24, 0x80	; 128
     1c0:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c2:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c6:	8f e1       	ldi	r24, 0x1F	; 31
     1c8:	d3 df       	rcall	.-90     	; 0x170 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1ca:	88 81       	ld	r24, Y
     1cc:	80 64       	ori	r24, 0x40	; 64
     1ce:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1d0:	ea e7       	ldi	r30, 0x7A	; 122
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	84 ff       	sbrs	r24, 4
     1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1da:	ea e7       	ldi	r30, 0x7A	; 122
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	80 64       	ori	r24, 0x40	; 64
     1e2:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e4:	80 81       	ld	r24, Z
     1e6:	84 ff       	sbrs	r24, 4
     1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1ea:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     1f4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fc:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     200:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     204:	89 2f       	mov	r24, r25
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	98 2f       	mov	r25, r24
     20a:	88 27       	eor	r24, r24
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     214:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     218:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     21c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     220:	99 23       	and	r25, r25
     222:	1c f4       	brge	.+6      	; 0x22a <ADC_init+0xa8>
     224:	91 95       	neg	r25
     226:	81 95       	neg	r24
     228:	91 09       	sbc	r25, r1
     22a:	05 97       	sbiw	r24, 0x05	; 5
     22c:	2c f0       	brlt	.+10     	; 0x238 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22e:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <gas_sensor_initialization_errors>
     232:	81 60       	ori	r24, 0x01	; 1
     234:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     238:	8e e1       	ldi	r24, 0x1E	; 30
     23a:	9a df       	rcall	.-204    	; 0x170 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23c:	ea e7       	ldi	r30, 0x7A	; 122
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	80 64       	ori	r24, 0x40	; 64
     244:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     246:	80 81       	ld	r24, Z
     248:	84 ff       	sbrs	r24, 4
     24a:	fd cf       	rjmp	.-6      	; 0x246 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     256:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     25a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25e:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     262:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     266:	89 2f       	mov	r24, r25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	98 2f       	mov	r25, r24
     26c:	88 27       	eor	r24, r24
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     276:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     27a:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     27e:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     282:	81 5e       	subi	r24, 0xE1	; 225
     284:	91 09       	sbc	r25, r1
     286:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     28a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     292:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     296:	99 23       	and	r25, r25
     298:	1c f4       	brge	.+6      	; 0x2a0 <ADC_init+0x11e>
     29a:	91 95       	neg	r25
     29c:	81 95       	neg	r24
     29e:	91 09       	sbc	r25, r1
     2a0:	05 97       	sbiw	r24, 0x05	; 5
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a4:	80 91 2a 03 	lds	r24, 0x032A	; 0x80032a <gas_sensor_initialization_errors>
     2a8:	82 60       	ori	r24, 0x02	; 2
     2aa:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ae:	ea e7       	ldi	r30, 0x7A	; 122
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8f 77       	andi	r24, 0x7F	; 127
     2b6:	80 83       	st	Z, r24
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2be:	87 e0       	ldi	r24, 0x07	; 7
     2c0:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2c2:	85 b1       	in	r24, 0x05	; 5
     2c4:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2c6:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2c8:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2ca:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2cc:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2ce:	41 9a       	sbi	0x08, 1	; 8
     2d0:	08 95       	ret

000002d2 <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2d2:	80 e0       	ldi	r24, 0x00	; 0
     2d4:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2d6:	2f ef       	ldi	r18, 0xFF	; 255
     2d8:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2da:	fc 01       	movw	r30, r24
     2dc:	ee 0f       	add	r30, r30
     2de:	ff 1f       	adc	r31, r31
     2e0:	ee 0f       	add	r30, r30
     2e2:	ff 1f       	adc	r31, r31
     2e4:	e1 50       	subi	r30, 0x01	; 1
     2e6:	fd 4f       	sbci	r31, 0xFD	; 253
     2e8:	11 82       	std	Z+1, r1	; 0x01
     2ea:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2ec:	33 83       	std	Z+3, r19	; 0x03
     2ee:	22 83       	std	Z+2, r18	; 0x02
     2f0:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2f2:	85 30       	cpi	r24, 0x05	; 5
     2f4:	91 05       	cpc	r25, r1
     2f6:	89 f7       	brne	.-30     	; 0x2da <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2f8:	08 95       	ret

000002fa <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2fa:	ef 92       	push	r14
     2fc:	ff 92       	push	r15
     2fe:	0f 93       	push	r16
     300:	1f 93       	push	r17
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	0f 2e       	mov	r0, r31
     308:	f9 ee       	ldi	r31, 0xE9	; 233
     30a:	ef 2e       	mov	r14, r31
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	ff 2e       	mov	r15, r31
     310:	f0 2d       	mov	r31, r0
     312:	00 e0       	ldi	r16, 0x00	; 0
     314:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     316:	c7 01       	movw	r24, r14
     318:	0e 94 95 11 	call	0x232a	; 0x232a <eeprom_read_word>
     31c:	e8 01       	movw	r28, r16
     31e:	cc 0f       	add	r28, r28
     320:	dd 1f       	adc	r29, r29
     322:	cc 0f       	add	r28, r28
     324:	dd 1f       	adc	r29, r29
     326:	c1 50       	subi	r28, 0x01	; 1
     328:	dd 4f       	sbci	r29, 0xFD	; 253
     32a:	99 83       	std	Y+1, r25	; 0x01
     32c:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     32e:	c7 01       	movw	r24, r14
     330:	02 96       	adiw	r24, 0x02	; 2
     332:	0e 94 95 11 	call	0x232a	; 0x232a <eeprom_read_word>
     336:	9b 83       	std	Y+3, r25	; 0x03
     338:	8a 83       	std	Y+2, r24	; 0x02
     33a:	0f 5f       	subi	r16, 0xFF	; 255
     33c:	1f 4f       	sbci	r17, 0xFF	; 255
     33e:	84 e0       	ldi	r24, 0x04	; 4
     340:	e8 0e       	add	r14, r24
     342:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     344:	05 30       	cpi	r16, 0x05	; 5
     346:	11 05       	cpc	r17, r1
     348:	31 f7       	brne	.-52     	; 0x316 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	1f 91       	pop	r17
     350:	0f 91       	pop	r16
     352:	ff 90       	pop	r15
     354:	ef 90       	pop	r14
     356:	08 95       	ret

00000358 <gas_sensors_init>:

void gas_sensors_init(void)
{
     358:	af 92       	push	r10
     35a:	bf 92       	push	r11
     35c:	cf 92       	push	r12
     35e:	df 92       	push	r13
     360:	ef 92       	push	r14
     362:	ff 92       	push	r15
     364:	0f 93       	push	r16
     366:	1f 93       	push	r17
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	1f 92       	push	r1
     36e:	cd b7       	in	r28, 0x3d	; 61
     370:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     372:	10 92 2a 03 	sts	0x032A, r1	; 0x80032a <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     376:	10 92 1d 03 	sts	0x031D, r1	; 0x80031d <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     37a:	bf df       	rcall	.-130    	; 0x2fa <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     37c:	aa df       	rcall	.-172    	; 0x2d2 <get_gas_sensor_limits>
     37e:	ea e7       	ldi	r30, 0x7A	; 122
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     380:	f0 e0       	ldi	r31, 0x00	; 0
     382:	80 81       	ld	r24, Z
     384:	80 68       	ori	r24, 0x80	; 128
     386:	80 83       	st	Z, r24
     388:	19 82       	std	Y+1, r1	; 0x01
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     38a:	89 81       	ldd	r24, Y+1	; 0x01
     38c:	85 30       	cpi	r24, 0x05	; 5
     38e:	08 f0       	brcs	.+2      	; 0x392 <gas_sensors_init+0x3a>
     390:	51 c0       	rjmp	.+162    	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
     392:	0a e7       	ldi	r16, 0x7A	; 122
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     394:	10 e0       	ldi	r17, 0x00	; 0
     396:	0f 2e       	mov	r0, r31
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     398:	f8 e7       	ldi	r31, 0x78	; 120
     39a:	ef 2e       	mov	r14, r31
     39c:	f1 2c       	mov	r15, r1
     39e:	f0 2d       	mov	r31, r0
     3a0:	bb 24       	eor	r11, r11
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3a2:	b3 94       	inc	r11
     3a4:	a1 2c       	mov	r10, r1
     3a6:	cc 24       	eor	r12, r12
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3a8:	c3 94       	inc	r12
     3aa:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     3ac:	89 81       	ldd	r24, Y+1	; 0x01
     3ae:	e0 de       	rcall	.-576    	; 0x170 <ADC_SetMux>
     3b0:	f8 01       	movw	r30, r16
		// Start conversion
		SetBit(ADCSRA, ADSC);
     3b2:	80 81       	ld	r24, Z
     3b4:	80 64       	ori	r24, 0x40	; 64
     3b6:	80 83       	st	Z, r24
     3b8:	f8 01       	movw	r30, r16
		while (BitIsClear(ADCSRA, ADIF))
     3ba:	80 81       	ld	r24, Z
     3bc:	84 ff       	sbrs	r24, 4
     3be:	fc cf       	rjmp	.-8      	; 0x3b8 <gas_sensors_init+0x60>
     3c0:	f7 01       	movw	r30, r14
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3c2:	80 81       	ld	r24, Z
     3c4:	91 81       	ldd	r25, Z+1	; 0x01
     3c6:	e9 81       	ldd	r30, Y+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	ee 0f       	add	r30, r30
     3cc:	ff 1f       	adc	r31, r31
     3ce:	ee 0f       	add	r30, r30
     3d0:	ff 1f       	adc	r31, r31
     3d2:	e1 50       	subi	r30, 0x01	; 1
     3d4:	fd 4f       	sbci	r31, 0xFD	; 253
     3d6:	20 81       	ld	r18, Z
     3d8:	31 81       	ldd	r19, Z+1	; 0x01
     3da:	e9 81       	ldd	r30, Y+1	; 0x01
     3dc:	f0 e0       	ldi	r31, 0x00	; 0
     3de:	ee 0f       	add	r30, r30
     3e0:	ff 1f       	adc	r31, r31
     3e2:	ee 0f       	add	r30, r30
     3e4:	ff 1f       	adc	r31, r31
     3e6:	e1 50       	subi	r30, 0x01	; 1
     3e8:	fd 4f       	sbci	r31, 0xFD	; 253
     3ea:	62 81       	ldd	r22, Z+2	; 0x02
     3ec:	73 81       	ldd	r23, Z+3	; 0x03
     3ee:	4b 2d       	mov	r20, r11
     3f0:	82 17       	cp	r24, r18
     3f2:	93 07       	cpc	r25, r19
     3f4:	08 f0       	brcs	.+2      	; 0x3f8 <gas_sensors_init+0xa0>
     3f6:	4a 2d       	mov	r20, r10
     3f8:	41 11       	cpse	r20, r1
     3fa:	07 c0       	rjmp	.+14     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     3fc:	2b 2d       	mov	r18, r11
     3fe:	68 17       	cp	r22, r24
     400:	79 07       	cpc	r23, r25
     402:	08 f0       	brcs	.+2      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     404:	2a 2d       	mov	r18, r10
     406:	22 23       	and	r18, r18
     408:	71 f0       	breq	.+28     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
     40a:	99 81       	ldd	r25, Y+1	; 0x01
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     40c:	20 91 2a 03 	lds	r18, 0x032A	; 0x80032a <gas_sensor_initialization_errors>
     410:	9d 5f       	subi	r25, 0xFD	; 253
     412:	a6 01       	movw	r20, r12
     414:	02 c0       	rjmp	.+4      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
     416:	44 0f       	add	r20, r20
     418:	55 1f       	adc	r21, r21
     41a:	9a 95       	dec	r25
     41c:	e2 f7       	brpl	.-8      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
     41e:	ca 01       	movw	r24, r20
     420:	82 2b       	or	r24, r18
     422:	80 93 2a 03 	sts	0x032A, r24	; 0x80032a <gas_sensor_initialization_errors>
     426:	89 81       	ldd	r24, Y+1	; 0x01
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     428:	8f 5f       	subi	r24, 0xFF	; 255
     42a:	89 83       	std	Y+1, r24	; 0x01
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	85 30       	cpi	r24, 0x05	; 5
     430:	08 f4       	brcc	.+2      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
     432:	bc cf       	rjmp	.-136    	; 0x3ac <gas_sensors_init+0x54>
     434:	ea e7       	ldi	r30, 0x7A	; 122
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	80 81       	ld	r24, Z
     43a:	8f 77       	andi	r24, 0x7F	; 127
     43c:	80 83       	st	Z, r24
     43e:	0f 90       	pop	r0
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     440:	df 91       	pop	r29
     442:	cf 91       	pop	r28
     444:	1f 91       	pop	r17
     446:	0f 91       	pop	r16
     448:	ff 90       	pop	r15
     44a:	ef 90       	pop	r14
     44c:	df 90       	pop	r13
     44e:	cf 90       	pop	r12
     450:	bf 90       	pop	r11
     452:	af 90       	pop	r10
     454:	08 95       	ret

00000456 <start_gas_sensor_read>:
     456:	af 92       	push	r10

void start_gas_sensor_read(void)
{
     458:	bf 92       	push	r11
     45a:	cf 92       	push	r12
     45c:	df 92       	push	r13
     45e:	ef 92       	push	r14
     460:	ff 92       	push	r15
     462:	0f 93       	push	r16
     464:	1f 93       	push	r17
     466:	cf 93       	push	r28
     468:	df 93       	push	r29
     46a:	00 d0       	rcall	.+0      	; 0x46c <start_gas_sensor_read+0x16>
     46c:	1f 92       	push	r1
     46e:	cd b7       	in	r28, 0x3d	; 61
     470:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     472:	ea e7       	ldi	r30, 0x7A	; 122
     474:	f0 e0       	ldi	r31, 0x00	; 0
     476:	80 81       	ld	r24, Z
     478:	80 68       	ori	r24, 0x80	; 128
     47a:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     47c:	19 82       	std	Y+1, r1	; 0x01
     47e:	89 81       	ldd	r24, Y+1	; 0x01
     480:	85 30       	cpi	r24, 0x05	; 5
     482:	08 f0       	brcs	.+2      	; 0x486 <start_gas_sensor_read+0x30>
     484:	73 c0       	rjmp	.+230    	; 0x56c <start_gas_sensor_read+0x116>
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     486:	0a e7       	ldi	r16, 0x7A	; 122
     488:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     48a:	0f 2e       	mov	r0, r31
     48c:	f8 e7       	ldi	r31, 0x78	; 120
     48e:	ef 2e       	mov	r14, r31
     490:	f1 2c       	mov	r15, r1
     492:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     494:	cc 24       	eor	r12, r12
     496:	c3 94       	inc	r12
     498:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     49a:	bb 24       	eor	r11, r11
     49c:	b3 94       	inc	r11
     49e:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     4a0:	89 81       	ldd	r24, Y+1	; 0x01
     4a2:	66 de       	rcall	.-820    	; 0x170 <ADC_SetMux>
		total = 0;	// re-zero the average
     4a4:	1b 82       	std	Y+3, r1	; 0x03
     4a6:	1a 82       	std	Y+2, r1	; 0x02
     4a8:	24 e0       	ldi	r18, 0x04	; 4
     4aa:	30 e0       	ldi	r19, 0x00	; 0
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4ac:	f8 01       	movw	r30, r16
     4ae:	80 81       	ld	r24, Z
     4b0:	80 64       	ori	r24, 0x40	; 64
     4b2:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4b4:	f8 01       	movw	r30, r16
     4b6:	80 81       	ld	r24, Z
     4b8:	84 ff       	sbrs	r24, 4
     4ba:	fc cf       	rjmp	.-8      	; 0x4b4 <start_gas_sensor_read+0x5e>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4bc:	f7 01       	movw	r30, r14
     4be:	80 81       	ld	r24, Z
     4c0:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4c2:	e9 81       	ldd	r30, Y+1	; 0x01
     4c4:	f0 e0       	ldi	r31, 0x00	; 0
     4c6:	ee 0f       	add	r30, r30
     4c8:	ff 1f       	adc	r31, r31
     4ca:	ee 0f       	add	r30, r30
     4cc:	ff 1f       	adc	r31, r31
     4ce:	e1 50       	subi	r30, 0x01	; 1
     4d0:	fd 4f       	sbci	r31, 0xFD	; 253
     4d2:	40 81       	ld	r20, Z
     4d4:	51 81       	ldd	r21, Z+1	; 0x01
     4d6:	e9 81       	ldd	r30, Y+1	; 0x01
     4d8:	f0 e0       	ldi	r31, 0x00	; 0
     4da:	ee 0f       	add	r30, r30
     4dc:	ff 1f       	adc	r31, r31
     4de:	ee 0f       	add	r30, r30
     4e0:	ff 1f       	adc	r31, r31
     4e2:	e1 50       	subi	r30, 0x01	; 1
     4e4:	fd 4f       	sbci	r31, 0xFD	; 253
     4e6:	02 80       	ldd	r0, Z+2	; 0x02
     4e8:	f3 81       	ldd	r31, Z+3	; 0x03
     4ea:	e0 2d       	mov	r30, r0
     4ec:	6b 2d       	mov	r22, r11
     4ee:	84 17       	cp	r24, r20
     4f0:	95 07       	cpc	r25, r21
     4f2:	08 f0       	brcs	.+2      	; 0x4f6 <start_gas_sensor_read+0xa0>
     4f4:	6a 2d       	mov	r22, r10
     4f6:	61 11       	cpse	r22, r1
     4f8:	07 c0       	rjmp	.+14     	; 0x508 <start_gas_sensor_read+0xb2>
     4fa:	4b 2d       	mov	r20, r11
     4fc:	e8 17       	cp	r30, r24
     4fe:	f9 07       	cpc	r31, r25
     500:	08 f0       	brcs	.+2      	; 0x504 <start_gas_sensor_read+0xae>
     502:	4a 2d       	mov	r20, r10
     504:	44 23       	and	r20, r20
     506:	71 f0       	breq	.+28     	; 0x524 <start_gas_sensor_read+0xce>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     508:	59 81       	ldd	r21, Y+1	; 0x01
     50a:	60 91 2a 03 	lds	r22, 0x032A	; 0x80032a <gas_sensor_initialization_errors>
     50e:	5d 5f       	subi	r21, 0xFD	; 253
     510:	f6 01       	movw	r30, r12
     512:	02 c0       	rjmp	.+4      	; 0x518 <start_gas_sensor_read+0xc2>
     514:	ee 0f       	add	r30, r30
     516:	ff 1f       	adc	r31, r31
     518:	5a 95       	dec	r21
     51a:	e2 f7       	brpl	.-8      	; 0x514 <start_gas_sensor_read+0xbe>
     51c:	af 01       	movw	r20, r30
     51e:	46 2b       	or	r20, r22
     520:	40 93 2a 03 	sts	0x032A, r20	; 0x80032a <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     524:	4a 81       	ldd	r20, Y+2	; 0x02
     526:	5b 81       	ldd	r21, Y+3	; 0x03
     528:	84 0f       	add	r24, r20
     52a:	95 1f       	adc	r25, r21
     52c:	9b 83       	std	Y+3, r25	; 0x03
     52e:	8a 83       	std	Y+2, r24	; 0x02
     530:	21 50       	subi	r18, 0x01	; 1
     532:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
     534:	09 f0       	breq	.+2      	; 0x538 <start_gas_sensor_read+0xe2>
     536:	ba cf       	rjmp	.-140    	; 0x4ac <start_gas_sensor_read+0x56>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     538:	8a 81       	ldd	r24, Y+2	; 0x02
     53a:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     53c:	e9 81       	ldd	r30, Y+1	; 0x01
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	ee 0f       	add	r30, r30
     542:	ff 1f       	adc	r31, r31
     544:	e2 5e       	subi	r30, 0xE2	; 226
     546:	fc 4f       	sbci	r31, 0xFC	; 252
     548:	9c 01       	movw	r18, r24
     54a:	99 23       	and	r25, r25
     54c:	14 f4       	brge	.+4      	; 0x552 <start_gas_sensor_read+0xfc>
     54e:	2d 5f       	subi	r18, 0xFD	; 253
     550:	3f 4f       	sbci	r19, 0xFF	; 255
     552:	35 95       	asr	r19
     554:	27 95       	ror	r18
     556:	35 95       	asr	r19
     558:	27 95       	ror	r18
     55a:	31 83       	std	Z+1, r19	; 0x01
     55c:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     55e:	89 81       	ldd	r24, Y+1	; 0x01
     560:	8f 5f       	subi	r24, 0xFF	; 255
     562:	89 83       	std	Y+1, r24	; 0x01
     564:	89 81       	ldd	r24, Y+1	; 0x01
     566:	85 30       	cpi	r24, 0x05	; 5
     568:	08 f4       	brcc	.+2      	; 0x56c <start_gas_sensor_read+0x116>
     56a:	9a cf       	rjmp	.-204    	; 0x4a0 <start_gas_sensor_read+0x4a>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     56c:	0f 90       	pop	r0
     56e:	0f 90       	pop	r0
     570:	0f 90       	pop	r0
     572:	df 91       	pop	r29
     574:	cf 91       	pop	r28
     576:	1f 91       	pop	r17
     578:	0f 91       	pop	r16
     57a:	ff 90       	pop	r15
     57c:	ef 90       	pop	r14
     57e:	df 90       	pop	r13
     580:	cf 90       	pop	r12
     582:	bf 90       	pop	r11
     584:	af 90       	pop	r10
     586:	08 95       	ret

00000588 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     588:	1f 93       	push	r17
     58a:	cf 93       	push	r28
     58c:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     58e:	e1 e3       	ldi	r30, 0x31	; 49
     590:	f3 e0       	ldi	r31, 0x03	; 3
     592:	84 ec       	ldi	r24, 0xC4	; 196
     594:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     596:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     598:	84 e0       	ldi	r24, 0x04	; 4
     59a:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     59c:	63 e0       	ldi	r22, 0x03	; 3
     59e:	cf 01       	movw	r24, r30
     5a0:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5a4:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     5a8:	81 11       	cpse	r24, r1
     5aa:	fc cf       	rjmp	.-8      	; 0x5a4 <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5ac:	e1 e3       	ldi	r30, 0x31	; 49
     5ae:	f3 e0       	ldi	r31, 0x03	; 3
     5b0:	84 ec       	ldi	r24, 0xC4	; 196
     5b2:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5b4:	81 e0       	ldi	r24, 0x01	; 1
     5b6:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b8:	62 e0       	ldi	r22, 0x02	; 2
     5ba:	cf 01       	movw	r24, r30
     5bc:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5c0:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     5c4:	81 11       	cpse	r24, r1
     5c6:	fc cf       	rjmp	.-8      	; 0x5c0 <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5c8:	c1 e3       	ldi	r28, 0x31	; 49
     5ca:	d3 e0       	ldi	r29, 0x03	; 3
     5cc:	15 ec       	ldi	r17, 0xC5	; 197
     5ce:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5d0:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5d2:	62 e0       	ldi	r22, 0x02	; 2
     5d4:	ce 01       	movw	r24, r28
     5d6:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5da:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     5de:	81 11       	cpse	r24, r1
     5e0:	fc cf       	rjmp	.-8      	; 0x5da <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5e2:	62 e0       	ldi	r22, 0x02	; 2
     5e4:	ce 01       	movw	r24, r28
     5e6:	0e 94 a3 0b 	call	0x1746	; 0x1746 <TWI_Get_Data_From_Transceiver>
     5ea:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5ee:	89 81       	ldd	r24, Y+1	; 0x01
     5f0:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5f4:	80 fd       	sbrc	r24, 0
     5f6:	eb cf       	rjmp	.-42     	; 0x5ce <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5f8:	e1 e3       	ldi	r30, 0x31	; 49
     5fa:	f3 e0       	ldi	r31, 0x03	; 3
     5fc:	84 ec       	ldi	r24, 0xC4	; 196
     5fe:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     600:	8f e8       	ldi	r24, 0x8F	; 143
     602:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     604:	62 e0       	ldi	r22, 0x02	; 2
     606:	cf 01       	movw	r24, r30
     608:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     60c:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     610:	81 11       	cpse	r24, r1
     612:	fc cf       	rjmp	.-8      	; 0x60c <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     614:	e1 e3       	ldi	r30, 0x31	; 49
     616:	f3 e0       	ldi	r31, 0x03	; 3
     618:	85 ec       	ldi	r24, 0xC5	; 197
     61a:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     61c:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     61e:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     620:	63 e0       	ldi	r22, 0x03	; 3
     622:	cf 01       	movw	r24, r30
     624:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     628:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     62c:	81 11       	cpse	r24, r1
     62e:	fc cf       	rjmp	.-8      	; 0x628 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     630:	63 e0       	ldi	r22, 0x03	; 3
     632:	81 e3       	ldi	r24, 0x31	; 49
     634:	93 e0       	ldi	r25, 0x03	; 3
     636:	0e 94 a3 0b 	call	0x1746	; 0x1746 <TWI_Get_Data_From_Transceiver>
     63a:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     63e:	e1 e3       	ldi	r30, 0x31	; 49
     640:	f3 e0       	ldi	r31, 0x03	; 3
	// That's all, folks...
	return(Ldistance);
     642:	81 81       	ldd	r24, Z+1	; 0x01
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	98 2f       	mov	r25, r24
     648:	88 27       	eor	r24, r24
     64a:	22 81       	ldd	r18, Z+2	; 0x02
}
     64c:	82 0f       	add	r24, r18
     64e:	91 1d       	adc	r25, r1
     650:	df 91       	pop	r29
     652:	cf 91       	pop	r28
     654:	1f 91       	pop	r17
     656:	08 95       	ret

00000658 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     658:	ff 92       	push	r15
     65a:	0f 93       	push	r16
     65c:	1f 93       	push	r17
     65e:	cf 93       	push	r28
     660:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     662:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     666:	88 23       	and	r24, r24
     668:	59 f1       	breq	.+86     	; 0x6c0 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     66a:	c2 e4       	ldi	r28, 0x42	; 66
     66c:	d3 e0       	ldi	r29, 0x03	; 3
     66e:	0f 2e       	mov	r0, r31
     670:	fc ee       	ldi	r31, 0xEC	; 236
     672:	ff 2e       	mov	r15, r31
     674:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     676:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     678:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     67a:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     67c:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     67e:	62 e0       	ldi	r22, 0x02	; 2
     680:	ce 01       	movw	r24, r28
     682:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     686:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     68a:	81 11       	cpse	r24, r1
     68c:	fc cf       	rjmp	.-8      	; 0x686 <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     68e:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     690:	6a e1       	ldi	r22, 0x1A	; 26
     692:	ce 01       	movw	r24, r28
     694:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     698:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     69c:	81 11       	cpse	r24, r1
     69e:	fc cf       	rjmp	.-8      	; 0x698 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     6a0:	6a e1       	ldi	r22, 0x1A	; 26
     6a2:	ce 01       	movw	r24, r28
     6a4:	0e 94 a3 0b 	call	0x1746	; 0x1746 <TWI_Get_Data_From_Transceiver>
     6a8:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6ac:	89 81       	ldd	r24, Y+1	; 0x01
     6ae:	83 fb       	bst	r24, 3
     6b0:	88 27       	eor	r24, r24
     6b2:	80 f9       	bld	r24, 0
     6b4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6b8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6bc:	81 11       	cpse	r24, r1
     6be:	dd cf       	rjmp	.-70     	; 0x67a <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6c0:	e2 e4       	ldi	r30, 0x42	; 66
     6c2:	f3 e0       	ldi	r31, 0x03	; 3
     6c4:	8c ee       	ldi	r24, 0xEC	; 236
     6c6:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6c8:	88 e8       	ldi	r24, 0x88	; 136
     6ca:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6cc:	62 e0       	ldi	r22, 0x02	; 2
     6ce:	cf 01       	movw	r24, r30
     6d0:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6d4:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <TWI_Transceiver_Busy>
     6d8:	81 11       	cpse	r24, r1
     6da:	fc cf       	rjmp	.-8      	; 0x6d4 <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6dc:	8d ee       	ldi	r24, 0xED	; 237
     6de:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6e2:	6b e1       	ldi	r22, 0x1B	; 27
     6e4:	82 e4       	ldi	r24, 0x42	; 66
     6e6:	93 e0       	ldi	r25, 0x03	; 3
     6e8:	0e 94 77 0b 	call	0x16ee	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6ec:	fc d7       	rcall	.+4088   	; 0x16e6 <TWI_Transceiver_Busy>
     6ee:	81 11       	cpse	r24, r1
     6f0:	fd cf       	rjmp	.-6      	; 0x6ec <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     6f2:	6b e1       	ldi	r22, 0x1B	; 27
     6f4:	82 e4       	ldi	r24, 0x42	; 66
     6f6:	93 e0       	ldi	r25, 0x03	; 3
     6f8:	0e 94 a3 0b 	call	0x1746	; 0x1746 <TWI_Get_Data_From_Transceiver>
     6fc:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
     700:	c3 e4       	ldi	r28, 0x43	; 67
     702:	d3 e0       	ldi	r29, 0x03	; 3
     704:	0b e4       	ldi	r16, 0x4B	; 75
     706:	14 e0       	ldi	r17, 0x04	; 4
     708:	2e e5       	ldi	r18, 0x5E	; 94
     70a:	33 e0       	ldi	r19, 0x03	; 3
     70c:	d8 01       	movw	r26, r16
     70e:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     710:	81 91       	ld	r24, Z+
     712:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     714:	e2 17       	cp	r30, r18
     716:	f3 07       	cpc	r31, r19
     718:	d9 f7       	brne	.-10     	; 0x710 <BME_read_correction_coefficients+0xb8>
     71a:	8b e1       	ldi	r24, 0x1B	; 27
     71c:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2424>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     720:	eb e4       	ldi	r30, 0x4B	; 75
     722:	f4 e0       	ldi	r31, 0x04	; 4
     724:	81 81       	ldd	r24, Z+1	; 0x01
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	98 2f       	mov	r25, r24
     72a:	88 27       	eor	r24, r24
     72c:	20 81       	ld	r18, Z
     72e:	82 2b       	or	r24, r18
     730:	90 93 46 04 	sts	0x0446, r25	; 0x800446 <dig_T1+0x1>
     734:	80 93 45 04 	sts	0x0445, r24	; 0x800445 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     738:	83 81       	ldd	r24, Z+3	; 0x03
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	98 2f       	mov	r25, r24
     73e:	88 27       	eor	r24, r24
     740:	22 81       	ldd	r18, Z+2	; 0x02
     742:	82 2b       	or	r24, r18
     744:	90 93 4a 04 	sts	0x044A, r25	; 0x80044a <dig_T2+0x1>
     748:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     74c:	85 81       	ldd	r24, Z+5	; 0x05
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	98 2f       	mov	r25, r24
     752:	88 27       	eor	r24, r24
     754:	24 81       	ldd	r18, Z+4	; 0x04
     756:	82 2b       	or	r24, r18
     758:	90 93 c2 04 	sts	0x04C2, r25	; 0x8004c2 <dig_T3+0x1>
     75c:	80 93 c1 04 	sts	0x04C1, r24	; 0x8004c1 <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     760:	87 81       	ldd	r24, Z+7	; 0x07
     762:	90 e0       	ldi	r25, 0x00	; 0
     764:	98 2f       	mov	r25, r24
     766:	88 27       	eor	r24, r24
     768:	26 81       	ldd	r18, Z+6	; 0x06
     76a:	82 2b       	or	r24, r18
     76c:	90 93 b6 04 	sts	0x04B6, r25	; 0x8004b6 <dig_P1+0x1>
     770:	80 93 b5 04 	sts	0x04B5, r24	; 0x8004b5 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     774:	81 85       	ldd	r24, Z+9	; 0x09
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	98 2f       	mov	r25, r24
     77a:	88 27       	eor	r24, r24
     77c:	20 85       	ldd	r18, Z+8	; 0x08
     77e:	82 2b       	or	r24, r18
     780:	90 93 7e 04 	sts	0x047E, r25	; 0x80047e <dig_P2+0x1>
     784:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     788:	83 85       	ldd	r24, Z+11	; 0x0b
     78a:	90 e0       	ldi	r25, 0x00	; 0
     78c:	98 2f       	mov	r25, r24
     78e:	88 27       	eor	r24, r24
     790:	22 85       	ldd	r18, Z+10	; 0x0a
     792:	82 2b       	or	r24, r18
     794:	90 93 b8 04 	sts	0x04B8, r25	; 0x8004b8 <dig_P3+0x1>
     798:	80 93 b7 04 	sts	0x04B7, r24	; 0x8004b7 <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     79c:	85 85       	ldd	r24, Z+13	; 0x0d
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	98 2f       	mov	r25, r24
     7a2:	88 27       	eor	r24, r24
     7a4:	24 85       	ldd	r18, Z+12	; 0x0c
     7a6:	82 2b       	or	r24, r18
     7a8:	90 93 80 04 	sts	0x0480, r25	; 0x800480 <dig_P4+0x1>
     7ac:	80 93 7f 04 	sts	0x047F, r24	; 0x80047f <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7b0:	87 85       	ldd	r24, Z+15	; 0x0f
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	98 2f       	mov	r25, r24
     7b6:	88 27       	eor	r24, r24
     7b8:	26 85       	ldd	r18, Z+14	; 0x0e
     7ba:	82 2b       	or	r24, r18
     7bc:	90 93 8f 04 	sts	0x048F, r25	; 0x80048f <dig_P5+0x1>
     7c0:	80 93 8e 04 	sts	0x048E, r24	; 0x80048e <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7c4:	81 89       	ldd	r24, Z+17	; 0x11
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	98 2f       	mov	r25, r24
     7ca:	88 27       	eor	r24, r24
     7cc:	20 89       	ldd	r18, Z+16	; 0x10
     7ce:	82 2b       	or	r24, r18
     7d0:	90 93 c4 04 	sts	0x04C4, r25	; 0x8004c4 <dig_P6+0x1>
     7d4:	80 93 c3 04 	sts	0x04C3, r24	; 0x8004c3 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7d8:	83 89       	ldd	r24, Z+19	; 0x13
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	98 2f       	mov	r25, r24
     7de:	88 27       	eor	r24, r24
     7e0:	22 89       	ldd	r18, Z+18	; 0x12
     7e2:	82 2b       	or	r24, r18
     7e4:	90 93 44 04 	sts	0x0444, r25	; 0x800444 <dig_P7+0x1>
     7e8:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7ec:	85 89       	ldd	r24, Z+21	; 0x15
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	98 2f       	mov	r25, r24
     7f2:	88 27       	eor	r24, r24
     7f4:	24 89       	ldd	r18, Z+20	; 0x14
     7f6:	82 2b       	or	r24, r18
     7f8:	90 93 ba 04 	sts	0x04BA, r25	; 0x8004ba <dig_P8+0x1>
     7fc:	80 93 b9 04 	sts	0x04B9, r24	; 0x8004b9 <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     800:	87 89       	ldd	r24, Z+23	; 0x17
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	98 2f       	mov	r25, r24
     806:	88 27       	eor	r24, r24
     808:	26 89       	ldd	r18, Z+22	; 0x16
     80a:	82 2b       	or	r24, r18
     80c:	90 93 c0 04 	sts	0x04C0, r25	; 0x8004c0 <dig_P9+0x1>
     810:	80 93 bf 04 	sts	0x04BF, r24	; 0x8004bf <dig_P9>
	dig_H1 = RawBMEdata[25];
     814:	81 8d       	ldd	r24, Z+25	; 0x19
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	90 93 78 04 	sts	0x0478, r25	; 0x800478 <dig_H1+0x1>
     81c:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     820:	e2 e4       	ldi	r30, 0x42	; 66
     822:	f3 e0       	ldi	r31, 0x03	; 3
     824:	8c ee       	ldi	r24, 0xEC	; 236
     826:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     828:	81 ee       	ldi	r24, 0xE1	; 225
     82a:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     82c:	62 e0       	ldi	r22, 0x02	; 2
     82e:	cf 01       	movw	r24, r30
     830:	5e d7       	rcall	.+3772   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     832:	59 d7       	rcall	.+3762   	; 0x16e6 <TWI_Transceiver_Busy>
     834:	81 11       	cpse	r24, r1
     836:	fd cf       	rjmp	.-6      	; 0x832 <BME_read_correction_coefficients+0x1da>
     838:	8d ee       	ldi	r24, 0xED	; 237
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     83a:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <BMEmessageBuf>
     83e:	68 e0       	ldi	r22, 0x08	; 8
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     840:	82 e4       	ldi	r24, 0x42	; 66
     842:	93 e0       	ldi	r25, 0x03	; 3
     844:	54 d7       	rcall	.+3752   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     846:	4f d7       	rcall	.+3742   	; 0x16e6 <TWI_Transceiver_Busy>
     848:	81 11       	cpse	r24, r1
     84a:	fd cf       	rjmp	.-6      	; 0x846 <BME_read_correction_coefficients+0x1ee>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     84c:	68 e0       	ldi	r22, 0x08	; 8
     84e:	82 e4       	ldi	r24, 0x42	; 66
     850:	93 e0       	ldi	r25, 0x03	; 3
     852:	79 d7       	rcall	.+3826   	; 0x1746 <TWI_Get_Data_From_Transceiver>
     854:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
     858:	2a e4       	ldi	r18, 0x4A	; 74
     85a:	33 e0       	ldi	r19, 0x03	; 3
     85c:	89 91       	ld	r24, Y+
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     85e:	f8 01       	movw	r30, r16
     860:	81 93       	st	Z+, r24
     862:	8f 01       	movw	r16, r30
     864:	c2 17       	cp	r28, r18
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     866:	d3 07       	cpc	r29, r19
     868:	c9 f7       	brne	.-14     	; 0x85c <BME_read_correction_coefficients+0x204>
     86a:	87 e0       	ldi	r24, 0x07	; 7
     86c:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2424>
     870:	eb e4       	ldi	r30, 0x4B	; 75
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8); 
     872:	f4 e0       	ldi	r31, 0x04	; 4
     874:	82 81       	ldd	r24, Z+2	; 0x02
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	98 2f       	mov	r25, r24
     87a:	88 27       	eor	r24, r24
     87c:	21 81       	ldd	r18, Z+1	; 0x01
     87e:	82 2b       	or	r24, r18
     880:	90 93 c6 04 	sts	0x04C6, r25	; 0x8004c6 <dig_H2+0x1>
     884:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <dig_H2>
     888:	83 81       	ldd	r24, Z+3	; 0x03
	dig_H3 = RawBMEdata[3]; 
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	90 93 be 04 	sts	0x04BE, r25	; 0x8004be <dig_H3+0x1>
     890:	80 93 bd 04 	sts	0x04BD, r24	; 0x8004bd <dig_H3>
     894:	85 81       	ldd	r24, Z+5	; 0x05
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     896:	82 95       	swap	r24
     898:	86 95       	lsr	r24
     89a:	87 70       	andi	r24, 0x07	; 7
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	24 81       	ldd	r18, Z+4	; 0x04
     8a0:	40 e1       	ldi	r20, 0x10	; 16
     8a2:	24 9f       	mul	r18, r20
     8a4:	90 01       	movw	r18, r0
     8a6:	11 24       	eor	r1, r1
     8a8:	28 2b       	or	r18, r24
     8aa:	39 2b       	or	r19, r25
     8ac:	30 93 48 04 	sts	0x0448, r19	; 0x800448 <dig_H4+0x1>
     8b0:	20 93 47 04 	sts	0x0447, r18	; 0x800447 <dig_H4>
     8b4:	26 81       	ldd	r18, Z+6	; 0x06
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     8b6:	40 e1       	ldi	r20, 0x10	; 16
     8b8:	24 9f       	mul	r18, r20
     8ba:	90 01       	movw	r18, r0
     8bc:	11 24       	eor	r1, r1
     8be:	82 2b       	or	r24, r18
     8c0:	93 2b       	or	r25, r19
     8c2:	90 93 bc 04 	sts	0x04BC, r25	; 0x8004bc <dig_H5+0x1>
     8c6:	80 93 bb 04 	sts	0x04BB, r24	; 0x8004bb <dig_H5>
     8ca:	87 81       	ldd	r24, Z+7	; 0x07
	dig_H6 = RawBMEdata[7];
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <dig_H6+0x1>
     8d2:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <dig_H6>
     8d6:	df 91       	pop	r29
}
     8d8:	cf 91       	pop	r28
     8da:	1f 91       	pop	r17
     8dc:	0f 91       	pop	r16
     8de:	ff 90       	pop	r15
     8e0:	08 95       	ret

000008e2 <bme280basic_init>:
     8e2:	e2 e4       	ldi	r30, 0x42	; 66
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8e4:	f3 e0       	ldi	r31, 0x03	; 3
     8e6:	8c ee       	ldi	r24, 0xEC	; 236
     8e8:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     8ea:	80 ee       	ldi	r24, 0xE0	; 224
     8ec:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     8ee:	86 eb       	ldi	r24, 0xB6	; 182
     8f0:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     8f2:	63 e0       	ldi	r22, 0x03	; 3
     8f4:	cf 01       	movw	r24, r30
     8f6:	fb d6       	rcall	.+3574   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     8f8:	f6 d6       	rcall	.+3564   	; 0x16e6 <TWI_Transceiver_Busy>
     8fa:	81 11       	cpse	r24, r1
     8fc:	fd cf       	rjmp	.-6      	; 0x8f8 <bme280basic_init+0x16>
     8fe:	e2 e4       	ldi	r30, 0x42	; 66
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     900:	f3 e0       	ldi	r31, 0x03	; 3
     902:	8c ee       	ldi	r24, 0xEC	; 236
     904:	80 83       	st	Z, r24
     906:	80 ed       	ldi	r24, 0xD0	; 208
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     908:	81 83       	std	Z+1, r24	; 0x01
     90a:	62 e0       	ldi	r22, 0x02	; 2
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     90c:	cf 01       	movw	r24, r30
     90e:	ef d6       	rcall	.+3550   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     910:	ea d6       	rcall	.+3540   	; 0x16e6 <TWI_Transceiver_Busy>
     912:	81 11       	cpse	r24, r1
     914:	fd cf       	rjmp	.-6      	; 0x910 <bme280basic_init+0x2e>
     916:	8d ee       	ldi	r24, 0xED	; 237
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     918:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     91c:	62 e0       	ldi	r22, 0x02	; 2
     91e:	82 e4       	ldi	r24, 0x42	; 66
     920:	93 e0       	ldi	r25, 0x03	; 3
     922:	e5 d6       	rcall	.+3530   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     924:	e0 d6       	rcall	.+3520   	; 0x16e6 <TWI_Transceiver_Busy>
     926:	81 11       	cpse	r24, r1
     928:	fd cf       	rjmp	.-6      	; 0x924 <bme280basic_init+0x42>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     92a:	62 e0       	ldi	r22, 0x02	; 2
     92c:	82 e4       	ldi	r24, 0x42	; 66
     92e:	93 e0       	ldi	r25, 0x03	; 3
     930:	0a d7       	rcall	.+3604   	; 0x1746 <TWI_Get_Data_From_Transceiver>
     932:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
     936:	80 91 43 03 	lds	r24, 0x0343	; 0x800343 <BMEmessageBuf+0x1>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     93a:	80 36       	cpi	r24, 0x60	; 96
     93c:	69 f5       	brne	.+90     	; 0x998 <bme280basic_init+0xb6>
     93e:	e2 e4       	ldi	r30, 0x42	; 66
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     940:	f3 e0       	ldi	r31, 0x03	; 3
     942:	8c ee       	ldi	r24, 0xEC	; 236
     944:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     946:	82 ef       	ldi	r24, 0xF2	; 242
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     948:	81 83       	std	Z+1, r24	; 0x01
     94a:	81 e0       	ldi	r24, 0x01	; 1
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     94c:	82 83       	std	Z+2, r24	; 0x02
     94e:	63 e0       	ldi	r22, 0x03	; 3
     950:	cf 01       	movw	r24, r30
     952:	cd d6       	rcall	.+3482   	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     954:	c8 d6       	rcall	.+3472   	; 0x16e6 <TWI_Transceiver_Busy>
     956:	81 11       	cpse	r24, r1
     958:	fd cf       	rjmp	.-6      	; 0x954 <bme280basic_init+0x72>
     95a:	e2 e4       	ldi	r30, 0x42	; 66
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     95c:	f3 e0       	ldi	r31, 0x03	; 3
     95e:	8c ee       	ldi	r24, 0xEC	; 236
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     960:	80 83       	st	Z, r24
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     962:	85 ef       	ldi	r24, 0xF5	; 245
     964:	81 83       	std	Z+1, r24	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     966:	80 e1       	ldi	r24, 0x10	; 16
     968:	82 83       	std	Z+2, r24	; 0x02
     96a:	63 e0       	ldi	r22, 0x03	; 3
     96c:	cf 01       	movw	r24, r30
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     96e:	bf d6       	rcall	.+3454   	; 0x16ee <TWI_Start_Transceiver_With_Data>
     970:	ba d6       	rcall	.+3444   	; 0x16e6 <TWI_Transceiver_Busy>
     972:	81 11       	cpse	r24, r1
     974:	fd cf       	rjmp	.-6      	; 0x970 <bme280basic_init+0x8e>
		//
		BME_read_correction_coefficients();
     976:	70 de       	rcall	.-800    	; 0x658 <BME_read_correction_coefficients>
     978:	81 e3       	ldi	r24, 0x31	; 49
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     97a:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     97e:	e2 e4       	ldi	r30, 0x42	; 66
     980:	f3 e0       	ldi	r31, 0x03	; 3
     982:	9c ee       	ldi	r25, 0xEC	; 236
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     984:	90 83       	st	Z, r25
     986:	94 ef       	ldi	r25, 0xF4	; 244
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     988:	91 83       	std	Z+1, r25	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     98a:	82 83       	std	Z+2, r24	; 0x02
     98c:	63 e0       	ldi	r22, 0x03	; 3
     98e:	cf 01       	movw	r24, r30
     990:	ae d6       	rcall	.+3420   	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     992:	a9 d6       	rcall	.+3410   	; 0x16e6 <TWI_Transceiver_Busy>
     994:	81 11       	cpse	r24, r1
     996:	fd cf       	rjmp	.-6      	; 0x992 <bme280basic_init+0xb0>
     998:	08 95       	ret

0000099a <bme280basic_bulk_data_read>:
     99a:	ff 92       	push	r15
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     9a4:	81 e0       	ldi	r24, 0x01	; 1
     9a6:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2478>
	while (BMEbusy) {
     9aa:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2478>
     9ae:	88 23       	and	r24, r24
     9b0:	31 f1       	breq	.+76     	; 0x9fe <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9b2:	c2 e4       	ldi	r28, 0x42	; 66
     9b4:	d3 e0       	ldi	r29, 0x03	; 3
     9b6:	0f 2e       	mov	r0, r31
     9b8:	fc ee       	ldi	r31, 0xEC	; 236
     9ba:	ff 2e       	mov	r15, r31
     9bc:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9be:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9c0:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9c2:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9c4:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9c6:	62 e0       	ldi	r22, 0x02	; 2
     9c8:	ce 01       	movw	r24, r28
     9ca:	91 d6       	rcall	.+3362   	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9cc:	8c d6       	rcall	.+3352   	; 0x16e6 <TWI_Transceiver_Busy>
     9ce:	81 11       	cpse	r24, r1
     9d0:	fd cf       	rjmp	.-6      	; 0x9cc <bme280basic_bulk_data_read+0x32>
     9d2:	18 83       	st	Y, r17
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9d4:	62 e0       	ldi	r22, 0x02	; 2
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     9d6:	ce 01       	movw	r24, r28
     9d8:	8a d6       	rcall	.+3348   	; 0x16ee <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9da:	85 d6       	rcall	.+3338   	; 0x16e6 <TWI_Transceiver_Busy>
     9dc:	81 11       	cpse	r24, r1
     9de:	fd cf       	rjmp	.-6      	; 0x9da <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9e0:	62 e0       	ldi	r22, 0x02	; 2
     9e2:	ce 01       	movw	r24, r28
     9e4:	b0 d6       	rcall	.+3424   	; 0x1746 <TWI_Get_Data_From_Transceiver>
     9e6:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     9ec:	83 fb       	bst	r24, 3
     9ee:	88 27       	eor	r24, r24
     9f0:	80 f9       	bld	r24, 0
     9f2:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2478>
     9f6:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2478>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     9fa:	81 11       	cpse	r24, r1
     9fc:	e2 cf       	rjmp	.-60     	; 0x9c2 <bme280basic_bulk_data_read+0x28>
     9fe:	e2 e4       	ldi	r30, 0x42	; 66
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     a00:	f3 e0       	ldi	r31, 0x03	; 3
     a02:	8c ee       	ldi	r24, 0xEC	; 236
     a04:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     a06:	87 ef       	ldi	r24, 0xF7	; 247
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     a08:	81 83       	std	Z+1, r24	; 0x01
     a0a:	62 e0       	ldi	r22, 0x02	; 2
     a0c:	cf 01       	movw	r24, r30
     a0e:	6f d6       	rcall	.+3294   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a10:	6a d6       	rcall	.+3284   	; 0x16e6 <TWI_Transceiver_Busy>
     a12:	81 11       	cpse	r24, r1
     a14:	fd cf       	rjmp	.-6      	; 0xa10 <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     a16:	8d ee       	ldi	r24, 0xED	; 237
     a18:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     a1c:	69 e0       	ldi	r22, 0x09	; 9
     a1e:	82 e4       	ldi	r24, 0x42	; 66
     a20:	93 e0       	ldi	r25, 0x03	; 3
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a22:	65 d6       	rcall	.+3274   	; 0x16ee <TWI_Start_Transceiver_With_Data>
     a24:	60 d6       	rcall	.+3264   	; 0x16e6 <TWI_Transceiver_Busy>
     a26:	81 11       	cpse	r24, r1
     a28:	fd cf       	rjmp	.-6      	; 0xa24 <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     a2a:	69 e0       	ldi	r22, 0x09	; 9
     a2c:	82 e4       	ldi	r24, 0x42	; 66
     a2e:	93 e0       	ldi	r25, 0x03	; 3
     a30:	8a d6       	rcall	.+3348   	; 0x1746 <TWI_Get_Data_From_Transceiver>
     a32:	80 93 41 03 	sts	0x0341, r24	; 0x800341 <TWI_XFER_STATUS>
     a36:	e3 e4       	ldi	r30, 0x43	; 67
     a38:	f3 e0       	ldi	r31, 0x03	; 3
     a3a:	ab e4       	ldi	r26, 0x4B	; 75
     a3c:	b4 e0       	ldi	r27, 0x04	; 4
     a3e:	2b e4       	ldi	r18, 0x4B	; 75
     a40:	33 e0       	ldi	r19, 0x03	; 3
     a42:	81 91       	ld	r24, Z+
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a44:	8d 93       	st	X+, r24
     a46:	e2 17       	cp	r30, r18
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a48:	f3 07       	cpc	r31, r19
     a4a:	d9 f7       	brne	.-10     	; 0xa42 <bme280basic_bulk_data_read+0xa8>
     a4c:	eb e4       	ldi	r30, 0x4B	; 75
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a4e:	f4 e0       	ldi	r31, 0x04	; 4
     a50:	80 81       	ld	r24, Z
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	a0 e0       	ldi	r26, 0x00	; 0
     a56:	b0 e0       	ldi	r27, 0x00	; 0
     a58:	ac 01       	movw	r20, r24
     a5a:	bd 01       	movw	r22, r26
     a5c:	03 2e       	mov	r0, r19
     a5e:	3c e0       	ldi	r19, 0x0C	; 12
     a60:	44 0f       	add	r20, r20
     a62:	55 1f       	adc	r21, r21
     a64:	66 1f       	adc	r22, r22
     a66:	77 1f       	adc	r23, r23
     a68:	3a 95       	dec	r19
     a6a:	d1 f7       	brne	.-12     	; 0xa60 <bme280basic_bulk_data_read+0xc6>
     a6c:	30 2d       	mov	r19, r0
     a6e:	91 81       	ldd	r25, Z+1	; 0x01
     a70:	89 2f       	mov	r24, r25
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	aa 1f       	adc	r26, r26
     a7e:	bb 1f       	adc	r27, r27
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	aa 1f       	adc	r26, r26
     a86:	bb 1f       	adc	r27, r27
     a88:	88 0f       	add	r24, r24
     a8a:	99 1f       	adc	r25, r25
     a8c:	aa 1f       	adc	r26, r26
     a8e:	bb 1f       	adc	r27, r27
     a90:	88 0f       	add	r24, r24
     a92:	99 1f       	adc	r25, r25
     a94:	aa 1f       	adc	r26, r26
     a96:	bb 1f       	adc	r27, r27
     a98:	84 2b       	or	r24, r20
     a9a:	95 2b       	or	r25, r21
     a9c:	a6 2b       	or	r26, r22
     a9e:	b7 2b       	or	r27, r23
     aa0:	22 81       	ldd	r18, Z+2	; 0x02
     aa2:	22 95       	swap	r18
     aa4:	2f 70       	andi	r18, 0x0F	; 15
     aa6:	82 2b       	or	r24, r18
     aa8:	80 93 91 04 	sts	0x0491, r24	; 0x800491 <rawPress>
     aac:	90 93 92 04 	sts	0x0492, r25	; 0x800492 <rawPress+0x1>
     ab0:	a0 93 93 04 	sts	0x0493, r26	; 0x800493 <rawPress+0x2>
     ab4:	b0 93 94 04 	sts	0x0494, r27	; 0x800494 <rawPress+0x3>
     ab8:	83 81       	ldd	r24, Z+3	; 0x03
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	a0 e0       	ldi	r26, 0x00	; 0
     abe:	b0 e0       	ldi	r27, 0x00	; 0
     ac0:	ac 01       	movw	r20, r24
     ac2:	bd 01       	movw	r22, r26
     ac4:	03 2e       	mov	r0, r19
     ac6:	3c e0       	ldi	r19, 0x0C	; 12
     ac8:	44 0f       	add	r20, r20
     aca:	55 1f       	adc	r21, r21
     acc:	66 1f       	adc	r22, r22
     ace:	77 1f       	adc	r23, r23
     ad0:	3a 95       	dec	r19
     ad2:	d1 f7       	brne	.-12     	; 0xac8 <bme280basic_bulk_data_read+0x12e>
     ad4:	30 2d       	mov	r19, r0
     ad6:	94 81       	ldd	r25, Z+4	; 0x04
     ad8:	89 2f       	mov	r24, r25
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	a0 e0       	ldi	r26, 0x00	; 0
     ade:	b0 e0       	ldi	r27, 0x00	; 0
     ae0:	88 0f       	add	r24, r24
     ae2:	99 1f       	adc	r25, r25
     ae4:	aa 1f       	adc	r26, r26
     ae6:	bb 1f       	adc	r27, r27
     ae8:	88 0f       	add	r24, r24
     aea:	99 1f       	adc	r25, r25
     aec:	aa 1f       	adc	r26, r26
     aee:	bb 1f       	adc	r27, r27
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	aa 1f       	adc	r26, r26
     af6:	bb 1f       	adc	r27, r27
     af8:	88 0f       	add	r24, r24
     afa:	99 1f       	adc	r25, r25
     afc:	aa 1f       	adc	r26, r26
     afe:	bb 1f       	adc	r27, r27
     b00:	84 2b       	or	r24, r20
     b02:	95 2b       	or	r25, r21
     b04:	a6 2b       	or	r26, r22
     b06:	b7 2b       	or	r27, r23
     b08:	25 81       	ldd	r18, Z+5	; 0x05
     b0a:	22 95       	swap	r18
     b0c:	2f 70       	andi	r18, 0x0F	; 15
     b0e:	82 2b       	or	r24, r18
     b10:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <rawTemp>
     b14:	90 93 7a 04 	sts	0x047A, r25	; 0x80047a <rawTemp+0x1>
     b18:	a0 93 7b 04 	sts	0x047B, r26	; 0x80047b <rawTemp+0x2>
     b1c:	b0 93 7c 04 	sts	0x047C, r27	; 0x80047c <rawTemp+0x3>
     b20:	86 81       	ldd	r24, Z+6	; 0x06
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	a0 e0       	ldi	r26, 0x00	; 0
     b26:	b0 e0       	ldi	r27, 0x00	; 0
     b28:	ba 2f       	mov	r27, r26
     b2a:	a9 2f       	mov	r26, r25
     b2c:	98 2f       	mov	r25, r24
     b2e:	88 27       	eor	r24, r24
     b30:	27 81       	ldd	r18, Z+7	; 0x07
     b32:	82 2b       	or	r24, r18
     b34:	80 93 95 04 	sts	0x0495, r24	; 0x800495 <rawHum>
     b38:	90 93 96 04 	sts	0x0496, r25	; 0x800496 <rawHum+0x1>
     b3c:	a0 93 97 04 	sts	0x0497, r26	; 0x800497 <rawHum+0x2>
     b40:	b0 93 98 04 	sts	0x0498, r27	; 0x800498 <rawHum+0x3>
     b44:	e2 e4       	ldi	r30, 0x42	; 66
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     b46:	f3 e0       	ldi	r31, 0x03	; 3
     b48:	8c ee       	ldi	r24, 0xEC	; 236
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b4a:	80 83       	st	Z, r24
     b4c:	84 ef       	ldi	r24, 0xF4	; 244
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b4e:	81 83       	std	Z+1, r24	; 0x01
     b50:	81 e3       	ldi	r24, 0x31	; 49
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b52:	82 83       	std	Z+2, r24	; 0x02
     b54:	63 e0       	ldi	r22, 0x03	; 3
     b56:	cf 01       	movw	r24, r30
     b58:	ca d5       	rcall	.+2964   	; 0x16ee <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b5a:	c5 d5       	rcall	.+2954   	; 0x16e6 <TWI_Transceiver_Busy>
     b5c:	81 11       	cpse	r24, r1
     b5e:	fd cf       	rjmp	.-6      	; 0xb5a <bme280basic_bulk_data_read+0x1c0>
     b60:	df 91       	pop	r29
	//  All done - and the next measurement cycle has  been kicked off!
}
     b62:	cf 91       	pop	r28
     b64:	1f 91       	pop	r17
     b66:	0f 91       	pop	r16
     b68:	ff 90       	pop	r15
     b6a:	08 95       	ret

00000b6c <BME280_compensate_T_int32>:
     b6c:	8f 92       	push	r8

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b6e:	9f 92       	push	r9
     b70:	af 92       	push	r10
     b72:	bf 92       	push	r11
     b74:	cf 92       	push	r12
     b76:	df 92       	push	r13
     b78:	ef 92       	push	r14
     b7a:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b7c:	20 91 45 04 	lds	r18, 0x0445	; 0x800445 <dig_T1>
     b80:	30 91 46 04 	lds	r19, 0x0446	; 0x800446 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b84:	6b 01       	movw	r12, r22
     b86:	7c 01       	movw	r14, r24
     b88:	68 94       	set
     b8a:	13 f8       	bld	r1, 3
     b8c:	f5 94       	asr	r15
     b8e:	e7 94       	ror	r14
     b90:	d7 94       	ror	r13
     b92:	c7 94       	ror	r12
     b94:	16 94       	lsr	r1
     b96:	d1 f7       	brne	.-12     	; 0xb8c <BME280_compensate_T_int32+0x20>
     b98:	c2 1a       	sub	r12, r18
     b9a:	d3 0a       	sbc	r13, r19
     b9c:	e1 08       	sbc	r14, r1
     b9e:	f1 08       	sbc	r15, r1
	t_fine = var1 + var2;
     ba0:	dc 01       	movw	r26, r24
     ba2:	cb 01       	movw	r24, r22
     ba4:	68 94       	set
     ba6:	12 f8       	bld	r1, 2
     ba8:	b5 95       	asr	r27
     baa:	a7 95       	ror	r26
     bac:	97 95       	ror	r25
     bae:	87 95       	ror	r24
     bb0:	16 94       	lsr	r1
     bb2:	d1 f7       	brne	.-12     	; 0xba8 <BME280_compensate_T_int32+0x3c>
     bb4:	22 0f       	add	r18, r18
     bb6:	33 1f       	adc	r19, r19
     bb8:	4c 01       	movw	r8, r24
     bba:	5d 01       	movw	r10, r26
     bbc:	82 1a       	sub	r8, r18
     bbe:	93 0a       	sbc	r9, r19
     bc0:	a1 08       	sbc	r10, r1
     bc2:	b1 08       	sbc	r11, r1
     bc4:	a5 01       	movw	r20, r10
     bc6:	94 01       	movw	r18, r8
     bc8:	a0 91 49 04 	lds	r26, 0x0449	; 0x800449 <dig_T2>
     bcc:	b0 91 4a 04 	lds	r27, 0x044A	; 0x80044a <dig_T2+0x1>
     bd0:	61 d7       	rcall	.+3778   	; 0x1a94 <__mulshisi3>
     bd2:	4b 01       	movw	r8, r22
     bd4:	5c 01       	movw	r10, r24
     bd6:	07 2e       	mov	r0, r23
     bd8:	7b e0       	ldi	r23, 0x0B	; 11
     bda:	b5 94       	asr	r11
     bdc:	a7 94       	ror	r10
     bde:	97 94       	ror	r9
     be0:	87 94       	ror	r8
     be2:	7a 95       	dec	r23
     be4:	d1 f7       	brne	.-12     	; 0xbda <BME280_compensate_T_int32+0x6e>
     be6:	70 2d       	mov	r23, r0
     be8:	a7 01       	movw	r20, r14
     bea:	96 01       	movw	r18, r12
     bec:	c7 01       	movw	r24, r14
     bee:	b6 01       	movw	r22, r12
     bf0:	2f d7       	rcall	.+3678   	; 0x1a50 <__mulsi3>
     bf2:	9b 01       	movw	r18, r22
     bf4:	ac 01       	movw	r20, r24
     bf6:	01 2e       	mov	r0, r17
     bf8:	1c e0       	ldi	r17, 0x0C	; 12
     bfa:	55 95       	asr	r21
     bfc:	47 95       	ror	r20
     bfe:	37 95       	ror	r19
     c00:	27 95       	ror	r18
     c02:	1a 95       	dec	r17
     c04:	d1 f7       	brne	.-12     	; 0xbfa <BME280_compensate_T_int32+0x8e>
     c06:	10 2d       	mov	r17, r0
     c08:	a0 91 c1 04 	lds	r26, 0x04C1	; 0x8004c1 <dig_T3>
     c0c:	b0 91 c2 04 	lds	r27, 0x04C2	; 0x8004c2 <dig_T3+0x1>
     c10:	41 d7       	rcall	.+3714   	; 0x1a94 <__mulshisi3>
     c12:	dc 01       	movw	r26, r24
     c14:	cb 01       	movw	r24, r22
     c16:	07 2e       	mov	r0, r23
     c18:	7e e0       	ldi	r23, 0x0E	; 14
     c1a:	b5 95       	asr	r27
     c1c:	a7 95       	ror	r26
     c1e:	97 95       	ror	r25
     c20:	87 95       	ror	r24
     c22:	7a 95       	dec	r23
     c24:	d1 f7       	brne	.-12     	; 0xc1a <BME280_compensate_T_int32+0xae>
     c26:	70 2d       	mov	r23, r0
     c28:	88 0d       	add	r24, r8
     c2a:	99 1d       	adc	r25, r9
     c2c:	aa 1d       	adc	r26, r10
     c2e:	bb 1d       	adc	r27, r11
     c30:	80 93 c7 04 	sts	0x04C7, r24	; 0x8004c7 <t_fine>
     c34:	90 93 c8 04 	sts	0x04C8, r25	; 0x8004c8 <t_fine+0x1>
     c38:	a0 93 c9 04 	sts	0x04C9, r26	; 0x8004c9 <t_fine+0x2>
     c3c:	b0 93 ca 04 	sts	0x04CA, r27	; 0x8004ca <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
	return T;
     c40:	6c 01       	movw	r12, r24
     c42:	7d 01       	movw	r14, r26
     c44:	cc 0c       	add	r12, r12
     c46:	dd 1c       	adc	r13, r13
     c48:	ee 1c       	adc	r14, r14
     c4a:	ff 1c       	adc	r15, r15
     c4c:	cc 0c       	add	r12, r12
     c4e:	dd 1c       	adc	r13, r13
     c50:	ee 1c       	adc	r14, r14
     c52:	ff 1c       	adc	r15, r15
     c54:	8c 0d       	add	r24, r12
     c56:	9d 1d       	adc	r25, r13
     c58:	ae 1d       	adc	r26, r14
     c5a:	bf 1d       	adc	r27, r15
     c5c:	80 58       	subi	r24, 0x80	; 128
     c5e:	9f 4f       	sbci	r25, 0xFF	; 255
     c60:	af 4f       	sbci	r26, 0xFF	; 255
     c62:	bf 4f       	sbci	r27, 0xFF	; 255
     c64:	69 2f       	mov	r22, r25
     c66:	7a 2f       	mov	r23, r26
     c68:	8b 2f       	mov	r24, r27
     c6a:	99 27       	eor	r25, r25
     c6c:	87 fd       	sbrc	r24, 7
     c6e:	9a 95       	dec	r25
}
     c70:	ff 90       	pop	r15
     c72:	ef 90       	pop	r14
     c74:	df 90       	pop	r13
     c76:	cf 90       	pop	r12
     c78:	bf 90       	pop	r11
     c7a:	af 90       	pop	r10
     c7c:	9f 90       	pop	r9
     c7e:	8f 90       	pop	r8
     c80:	08 95       	ret

00000c82 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c82:	2f 92       	push	r2
     c84:	3f 92       	push	r3
     c86:	4f 92       	push	r4
     c88:	5f 92       	push	r5
     c8a:	6f 92       	push	r6
     c8c:	7f 92       	push	r7
     c8e:	8f 92       	push	r8
     c90:	9f 92       	push	r9
     c92:	af 92       	push	r10
     c94:	bf 92       	push	r11
     c96:	cf 92       	push	r12
     c98:	df 92       	push	r13
     c9a:	ef 92       	push	r14
     c9c:	ff 92       	push	r15
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	cd b7       	in	r28, 0x3d	; 61
     ca8:	de b7       	in	r29, 0x3e	; 62
     caa:	66 97       	sbiw	r28, 0x16	; 22
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	f8 94       	cli
     cb0:	de bf       	out	0x3e, r29	; 62
     cb2:	0f be       	out	0x3f, r0	; 63
     cb4:	cd bf       	out	0x3d, r28	; 61
     cb6:	69 8b       	std	Y+17, r22	; 0x11
     cb8:	7a 8b       	std	Y+18, r23	; 0x12
     cba:	8b 8b       	std	Y+19, r24	; 0x13
     cbc:	9c 8b       	std	Y+20, r25	; 0x14
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     cbe:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <t_fine>
     cc2:	90 91 c8 04 	lds	r25, 0x04C8	; 0x8004c8 <t_fine+0x1>
     cc6:	a0 91 c9 04 	lds	r26, 0x04C9	; 0x8004c9 <t_fine+0x2>
     cca:	b0 91 ca 04 	lds	r27, 0x04CA	; 0x8004ca <t_fine+0x3>
     cce:	9c 01       	movw	r18, r24
     cd0:	ad 01       	movw	r20, r26
     cd2:	34 5f       	subi	r19, 0xF4	; 244
     cd4:	41 40       	sbci	r20, 0x01	; 1
     cd6:	51 09       	sbc	r21, r1
     cd8:	29 83       	std	Y+1, r18	; 0x01
     cda:	3a 83       	std	Y+2, r19	; 0x02
     cdc:	4b 83       	std	Y+3, r20	; 0x03
     cde:	5c 83       	std	Y+4, r21	; 0x04
     ce0:	55 0f       	add	r21, r21
     ce2:	22 0b       	sbc	r18, r18
     ce4:	32 2f       	mov	r19, r18
     ce6:	a9 01       	movw	r20, r18
     ce8:	2d 83       	std	Y+5, r18	; 0x05
     cea:	3e 83       	std	Y+6, r19	; 0x06
     cec:	4f 83       	std	Y+7, r20	; 0x07
     cee:	58 87       	std	Y+8, r21	; 0x08
	var2 = var1*var1*(long)dig_P6;
     cf0:	a9 80       	ldd	r10, Y+1	; 0x01
     cf2:	ba 80       	ldd	r11, Y+2	; 0x02
     cf4:	cb 80       	ldd	r12, Y+3	; 0x03
     cf6:	dc 80       	ldd	r13, Y+4	; 0x04
     cf8:	ed 80       	ldd	r14, Y+5	; 0x05
     cfa:	fe 2c       	mov	r15, r14
     cfc:	0e 2d       	mov	r16, r14
     cfe:	1e 2d       	mov	r17, r14
     d00:	2a 2d       	mov	r18, r10
     d02:	3b 2d       	mov	r19, r11
     d04:	4c 2d       	mov	r20, r12
     d06:	5d 2d       	mov	r21, r13
     d08:	60 2f       	mov	r22, r16
     d0a:	70 2f       	mov	r23, r16
     d0c:	80 2f       	mov	r24, r16
     d0e:	9e 2d       	mov	r25, r14
     d10:	c7 d6       	rcall	.+3470   	; 0x1aa0 <__muldi3>
     d12:	29 87       	std	Y+9, r18	; 0x09
     d14:	3a 87       	std	Y+10, r19	; 0x0a
     d16:	4b 87       	std	Y+11, r20	; 0x0b
     d18:	5c 87       	std	Y+12, r21	; 0x0c
     d1a:	6d 87       	std	Y+13, r22	; 0x0d
     d1c:	7e 87       	std	Y+14, r23	; 0x0e
     d1e:	8f 87       	std	Y+15, r24	; 0x0f
     d20:	98 8b       	std	Y+16, r25	; 0x10
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     d22:	30 91 7e 04 	lds	r19, 0x047E	; 0x80047e <dig_P2+0x1>
     d26:	20 91 7d 04 	lds	r18, 0x047D	; 0x80047d <dig_P2>
     d2a:	93 2f       	mov	r25, r19
     d2c:	99 0f       	add	r25, r25
     d2e:	99 0b       	sbc	r25, r25
     d30:	e0 2e       	mov	r14, r16
     d32:	0f 2d       	mov	r16, r15
     d34:	49 2f       	mov	r20, r25
     d36:	59 2f       	mov	r21, r25
     d38:	69 2f       	mov	r22, r25
     d3a:	79 2f       	mov	r23, r25
     d3c:	89 2f       	mov	r24, r25
     d3e:	b0 d6       	rcall	.+3424   	; 0x1aa0 <__muldi3>
     d40:	0c e0       	ldi	r16, 0x0C	; 12
     d42:	cf d7       	rcall	.+3998   	; 0x1ce2 <__ashldi3>
     d44:	62 2e       	mov	r6, r18
     d46:	73 2e       	mov	r7, r19
     d48:	84 2e       	mov	r8, r20
     d4a:	95 2e       	mov	r9, r21
     d4c:	6e 8b       	std	Y+22, r22	; 0x16
     d4e:	7d 8b       	std	Y+21, r23	; 0x15
     d50:	58 2e       	mov	r5, r24
     d52:	49 2e       	mov	r4, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     d54:	30 91 b8 04 	lds	r19, 0x04B8	; 0x8004b8 <dig_P3+0x1>
     d58:	20 91 b7 04 	lds	r18, 0x04B7	; 0x8004b7 <dig_P3>
     d5c:	93 2f       	mov	r25, r19
     d5e:	99 0f       	add	r25, r25
     d60:	99 0b       	sbc	r25, r25
     d62:	a9 84       	ldd	r10, Y+9	; 0x09
     d64:	ba 84       	ldd	r11, Y+10	; 0x0a
     d66:	cb 84       	ldd	r12, Y+11	; 0x0b
     d68:	dc 84       	ldd	r13, Y+12	; 0x0c
     d6a:	ed 84       	ldd	r14, Y+13	; 0x0d
     d6c:	fe 84       	ldd	r15, Y+14	; 0x0e
     d6e:	0f 85       	ldd	r16, Y+15	; 0x0f
     d70:	18 89       	ldd	r17, Y+16	; 0x10
     d72:	49 2f       	mov	r20, r25
     d74:	59 2f       	mov	r21, r25
     d76:	69 2f       	mov	r22, r25
     d78:	79 2f       	mov	r23, r25
     d7a:	89 2f       	mov	r24, r25
     d7c:	91 d6       	rcall	.+3362   	; 0x1aa0 <__muldi3>
     d7e:	08 e0       	ldi	r16, 0x08	; 8
     d80:	c9 d7       	rcall	.+3986   	; 0x1d14 <__ashrdi3>
     d82:	a6 2c       	mov	r10, r6
     d84:	b7 2c       	mov	r11, r7
     d86:	c8 2c       	mov	r12, r8
     d88:	d9 2c       	mov	r13, r9
     d8a:	ee 88       	ldd	r14, Y+22	; 0x16
     d8c:	fd 88       	ldd	r15, Y+21	; 0x15
     d8e:	05 2d       	mov	r16, r5
     d90:	14 2d       	mov	r17, r4
     d92:	de d7       	rcall	.+4028   	; 0x1d50 <__adddi3>
     d94:	70 58       	subi	r23, 0x80	; 128
     d96:	8f 4f       	sbci	r24, 0xFF	; 255
     d98:	9f 4f       	sbci	r25, 0xFF	; 255
     d9a:	20 90 b5 04 	lds	r2, 0x04B5	; 0x8004b5 <dig_P1>
     d9e:	30 90 b6 04 	lds	r3, 0x04B6	; 0x8004b6 <dig_P1+0x1>
     da2:	a2 2c       	mov	r10, r2
     da4:	b3 2c       	mov	r11, r3
     da6:	c1 2c       	mov	r12, r1
     da8:	d1 2c       	mov	r13, r1
     daa:	e1 2c       	mov	r14, r1
     dac:	f1 2c       	mov	r15, r1
     dae:	00 e0       	ldi	r16, 0x00	; 0
     db0:	10 e0       	ldi	r17, 0x00	; 0
     db2:	76 d6       	rcall	.+3308   	; 0x1aa0 <__muldi3>
     db4:	01 e2       	ldi	r16, 0x21	; 33
     db6:	ae d7       	rcall	.+3932   	; 0x1d14 <__ashrdi3>
     db8:	32 2e       	mov	r3, r18
     dba:	23 2e       	mov	r2, r19
     dbc:	94 2e       	mov	r9, r20
     dbe:	5e 8b       	std	Y+22, r21	; 0x16
     dc0:	6d 8b       	std	Y+21, r22	; 0x15
     dc2:	47 2e       	mov	r4, r23
     dc4:	58 2e       	mov	r5, r24
	if (var1 == 0)
     dc6:	69 2e       	mov	r6, r25
     dc8:	a0 e0       	ldi	r26, 0x00	; 0
     dca:	d4 d7       	rcall	.+4008   	; 0x1d74 <__cmpdi2_s8>
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <BME280_compensate_P_int64+0x14e>
     dce:	37 c1       	rjmp	.+622    	; 0x103e <BME280_compensate_P_int64+0x3bc>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     dd0:	30 91 c4 04 	lds	r19, 0x04C4	; 0x8004c4 <dig_P6+0x1>
     dd4:	20 91 c3 04 	lds	r18, 0x04C3	; 0x8004c3 <dig_P6>
     dd8:	93 2f       	mov	r25, r19
     dda:	99 0f       	add	r25, r25
     ddc:	99 0b       	sbc	r25, r25
     dde:	a9 84       	ldd	r10, Y+9	; 0x09
     de0:	ba 84       	ldd	r11, Y+10	; 0x0a
     de2:	cb 84       	ldd	r12, Y+11	; 0x0b
     de4:	dc 84       	ldd	r13, Y+12	; 0x0c
     de6:	ed 84       	ldd	r14, Y+13	; 0x0d
     de8:	fe 84       	ldd	r15, Y+14	; 0x0e
     dea:	0f 85       	ldd	r16, Y+15	; 0x0f
     dec:	18 89       	ldd	r17, Y+16	; 0x10
     dee:	49 2f       	mov	r20, r25
     df0:	59 2f       	mov	r21, r25
     df2:	69 2f       	mov	r22, r25
     df4:	79 2f       	mov	r23, r25
     df6:	89 2f       	mov	r24, r25
     df8:	53 d6       	rcall	.+3238   	; 0x1aa0 <__muldi3>
     dfa:	29 87       	std	Y+9, r18	; 0x09
     dfc:	3a 87       	std	Y+10, r19	; 0x0a
     dfe:	4b 87       	std	Y+11, r20	; 0x0b
     e00:	75 2e       	mov	r7, r21
     e02:	86 2e       	mov	r8, r22
     e04:	7c 87       	std	Y+12, r23	; 0x0c
     e06:	8d 87       	std	Y+13, r24	; 0x0d
     e08:	9e 87       	std	Y+14, r25	; 0x0e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     e0a:	30 91 8f 04 	lds	r19, 0x048F	; 0x80048f <dig_P5+0x1>
     e0e:	20 91 8e 04 	lds	r18, 0x048E	; 0x80048e <dig_P5>
     e12:	93 2f       	mov	r25, r19
     e14:	99 0f       	add	r25, r25
     e16:	99 0b       	sbc	r25, r25
     e18:	a9 80       	ldd	r10, Y+1	; 0x01
     e1a:	ba 80       	ldd	r11, Y+2	; 0x02
     e1c:	cb 80       	ldd	r12, Y+3	; 0x03
     e1e:	dc 80       	ldd	r13, Y+4	; 0x04
     e20:	ed 80       	ldd	r14, Y+5	; 0x05
     e22:	fe 2c       	mov	r15, r14
     e24:	0e 2d       	mov	r16, r14
     e26:	1e 2d       	mov	r17, r14
     e28:	49 2f       	mov	r20, r25
     e2a:	59 2f       	mov	r21, r25
     e2c:	69 2f       	mov	r22, r25
     e2e:	79 2f       	mov	r23, r25
     e30:	89 2f       	mov	r24, r25
     e32:	36 d6       	rcall	.+3180   	; 0x1aa0 <__muldi3>
     e34:	01 e1       	ldi	r16, 0x11	; 17
     e36:	55 d7       	rcall	.+3754   	; 0x1ce2 <__ashldi3>
     e38:	a9 84       	ldd	r10, Y+9	; 0x09
     e3a:	ba 84       	ldd	r11, Y+10	; 0x0a
     e3c:	cb 84       	ldd	r12, Y+11	; 0x0b
     e3e:	d7 2c       	mov	r13, r7
     e40:	e8 2c       	mov	r14, r8
     e42:	fc 84       	ldd	r15, Y+12	; 0x0c
     e44:	0d 85       	ldd	r16, Y+13	; 0x0d
     e46:	1e 85       	ldd	r17, Y+14	; 0x0e
     e48:	83 d7       	rcall	.+3846   	; 0x1d50 <__adddi3>
     e4a:	a2 2e       	mov	r10, r18
     e4c:	b3 2e       	mov	r11, r19
     e4e:	c4 2e       	mov	r12, r20
     e50:	d5 2e       	mov	r13, r21
     e52:	e6 2e       	mov	r14, r22
     e54:	f7 2e       	mov	r15, r23
     e56:	78 2e       	mov	r7, r24
     e58:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	a0 e1       	ldi	r26, 0x10	; 16
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	29 89       	ldd	r18, Y+17	; 0x11
     e64:	3a 89       	ldd	r19, Y+18	; 0x12
     e66:	4b 89       	ldd	r20, Y+19	; 0x13
     e68:	5c 89       	ldd	r21, Y+20	; 0x14
     e6a:	82 1b       	sub	r24, r18
     e6c:	93 0b       	sbc	r25, r19
     e6e:	a4 0b       	sbc	r26, r20
     e70:	b5 0b       	sbc	r27, r21
     e72:	9c 01       	movw	r18, r24
     e74:	ad 01       	movw	r20, r26
     e76:	55 0f       	add	r21, r21
     e78:	22 0b       	sbc	r18, r18
     e7a:	32 2f       	mov	r19, r18
     e7c:	a9 01       	movw	r20, r18
     e7e:	29 83       	std	Y+1, r18	; 0x01
     e80:	3a 83       	std	Y+2, r19	; 0x02
     e82:	4b 83       	std	Y+3, r20	; 0x03
     e84:	5c 83       	std	Y+4, r21	; 0x04
     e86:	28 2f       	mov	r18, r24
     e88:	39 2f       	mov	r19, r25
     e8a:	4a 2f       	mov	r20, r26
     e8c:	5b 2f       	mov	r21, r27
     e8e:	69 81       	ldd	r22, Y+1	; 0x01
     e90:	76 2f       	mov	r23, r22
     e92:	86 2f       	mov	r24, r22
     e94:	96 2f       	mov	r25, r22
     e96:	0f e1       	ldi	r16, 0x1F	; 31
     e98:	24 d7       	rcall	.+3656   	; 0x1ce2 <__ashldi3>
     e9a:	82 2e       	mov	r8, r18
     e9c:	39 83       	std	Y+1, r19	; 0x01
     e9e:	4d 83       	std	Y+5, r20	; 0x05
     ea0:	59 87       	std	Y+9, r21	; 0x09
     ea2:	b6 2f       	mov	r27, r22
     ea4:	a7 2f       	mov	r26, r23
     ea6:	f8 2f       	mov	r31, r24
     ea8:	e9 2f       	mov	r30, r25
     eaa:	30 91 80 04 	lds	r19, 0x0480	; 0x800480 <dig_P4+0x1>
     eae:	20 91 7f 04 	lds	r18, 0x047F	; 0x80047f <dig_P4>
     eb2:	93 2f       	mov	r25, r19
     eb4:	99 0f       	add	r25, r25
     eb6:	99 0b       	sbc	r25, r25
     eb8:	49 2f       	mov	r20, r25
     eba:	59 2f       	mov	r21, r25
     ebc:	69 2f       	mov	r22, r25
     ebe:	79 2f       	mov	r23, r25
     ec0:	89 2f       	mov	r24, r25
     ec2:	03 e2       	ldi	r16, 0x23	; 35
     ec4:	0e d7       	rcall	.+3612   	; 0x1ce2 <__ashldi3>
     ec6:	07 2d       	mov	r16, r7
     ec8:	43 d7       	rcall	.+3718   	; 0x1d50 <__adddi3>
     eca:	a2 2e       	mov	r10, r18
     ecc:	b3 2e       	mov	r11, r19
     ece:	c4 2e       	mov	r12, r20
     ed0:	d5 2e       	mov	r13, r21
     ed2:	e6 2e       	mov	r14, r22
     ed4:	f7 2e       	mov	r15, r23
     ed6:	08 2f       	mov	r16, r24
     ed8:	19 2f       	mov	r17, r25
     eda:	28 2d       	mov	r18, r8
     edc:	39 81       	ldd	r19, Y+1	; 0x01
     ede:	4d 81       	ldd	r20, Y+5	; 0x05
     ee0:	59 85       	ldd	r21, Y+9	; 0x09
     ee2:	6b 2f       	mov	r22, r27
     ee4:	7a 2f       	mov	r23, r26
     ee6:	8f 2f       	mov	r24, r31
     ee8:	9e 2f       	mov	r25, r30
     eea:	3b d7       	rcall	.+3702   	; 0x1d62 <__subdi3>
     eec:	0f 2e       	mov	r0, r31
     eee:	f5 e3       	ldi	r31, 0x35	; 53
     ef0:	af 2e       	mov	r10, r31
     ef2:	f0 2d       	mov	r31, r0
     ef4:	0f 2e       	mov	r0, r31
     ef6:	fc e0       	ldi	r31, 0x0C	; 12
     ef8:	bf 2e       	mov	r11, r31
     efa:	f0 2d       	mov	r31, r0
     efc:	c1 2c       	mov	r12, r1
     efe:	d1 2c       	mov	r13, r1
     f00:	e1 2c       	mov	r14, r1
     f02:	f1 2c       	mov	r15, r1
     f04:	00 e0       	ldi	r16, 0x00	; 0
     f06:	10 e0       	ldi	r17, 0x00	; 0
     f08:	cb d5       	rcall	.+2966   	; 0x1aa0 <__muldi3>
     f0a:	a3 2c       	mov	r10, r3
     f0c:	b2 2c       	mov	r11, r2
     f0e:	c9 2c       	mov	r12, r9
     f10:	de 88       	ldd	r13, Y+22	; 0x16
     f12:	ed 88       	ldd	r14, Y+21	; 0x15
     f14:	f4 2c       	mov	r15, r4
     f16:	05 2d       	mov	r16, r5
     f18:	16 2d       	mov	r17, r6
     f1a:	15 d6       	rcall	.+3114   	; 0x1b46 <__divdi3>
     f1c:	2e 87       	std	Y+14, r18	; 0x0e
     f1e:	3d 87       	std	Y+13, r19	; 0x0d
     f20:	49 83       	std	Y+1, r20	; 0x01
     f22:	5d 83       	std	Y+5, r21	; 0x05
     f24:	69 87       	std	Y+9, r22	; 0x09
     f26:	7a 87       	std	Y+10, r23	; 0x0a
     f28:	8b 87       	std	Y+11, r24	; 0x0b
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     f2a:	9c 87       	std	Y+12, r25	; 0x0c
     f2c:	0d e0       	ldi	r16, 0x0D	; 13
     f2e:	f2 d6       	rcall	.+3556   	; 0x1d14 <__ashrdi3>
     f30:	92 2e       	mov	r9, r18
     f32:	83 2e       	mov	r8, r19
     f34:	74 2e       	mov	r7, r20
     f36:	65 2e       	mov	r6, r21
     f38:	56 2e       	mov	r5, r22
     f3a:	47 2e       	mov	r4, r23
     f3c:	38 2e       	mov	r3, r24
     f3e:	29 2e       	mov	r2, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     f40:	30 91 c0 04 	lds	r19, 0x04C0	; 0x8004c0 <dig_P9+0x1>
     f44:	20 91 bf 04 	lds	r18, 0x04BF	; 0x8004bf <dig_P9>
     f48:	93 2f       	mov	r25, r19
     f4a:	99 0f       	add	r25, r25
     f4c:	99 0b       	sbc	r25, r25
     f4e:	a9 2c       	mov	r10, r9
     f50:	b8 2c       	mov	r11, r8
     f52:	c7 2c       	mov	r12, r7
     f54:	d6 2c       	mov	r13, r6
     f56:	e5 2c       	mov	r14, r5
     f58:	f4 2c       	mov	r15, r4
     f5a:	03 2d       	mov	r16, r3
     f5c:	12 2d       	mov	r17, r2
     f5e:	49 2f       	mov	r20, r25
     f60:	59 2f       	mov	r21, r25
     f62:	69 2f       	mov	r22, r25
     f64:	79 2f       	mov	r23, r25
     f66:	89 2f       	mov	r24, r25
     f68:	9b d5       	rcall	.+2870   	; 0x1aa0 <__muldi3>
     f6a:	9a d5       	rcall	.+2868   	; 0x1aa0 <__muldi3>
     f6c:	09 e1       	ldi	r16, 0x19	; 25
     f6e:	d2 d6       	rcall	.+3492   	; 0x1d14 <__ashrdi3>
     f70:	ae 84       	ldd	r10, Y+14	; 0x0e
     f72:	bd 84       	ldd	r11, Y+13	; 0x0d
     f74:	c9 80       	ldd	r12, Y+1	; 0x01
     f76:	dd 80       	ldd	r13, Y+5	; 0x05
     f78:	e9 84       	ldd	r14, Y+9	; 0x09
     f7a:	fa 84       	ldd	r15, Y+10	; 0x0a
     f7c:	0b 85       	ldd	r16, Y+11	; 0x0b
     f7e:	1c 85       	ldd	r17, Y+12	; 0x0c
     f80:	e7 d6       	rcall	.+3534   	; 0x1d50 <__adddi3>
     f82:	22 2e       	mov	r2, r18
     f84:	33 2e       	mov	r3, r19
     f86:	44 2e       	mov	r4, r20
     f88:	55 2e       	mov	r5, r21
     f8a:	66 2e       	mov	r6, r22
     f8c:	77 2e       	mov	r7, r23
     f8e:	88 2e       	mov	r8, r24
     f90:	99 2e       	mov	r9, r25
     f92:	30 91 ba 04 	lds	r19, 0x04BA	; 0x8004ba <dig_P8+0x1>
     f96:	20 91 b9 04 	lds	r18, 0x04B9	; 0x8004b9 <dig_P8>
     f9a:	93 2f       	mov	r25, r19
     f9c:	99 0f       	add	r25, r25
     f9e:	99 0b       	sbc	r25, r25
     fa0:	49 2f       	mov	r20, r25
     fa2:	59 2f       	mov	r21, r25
     fa4:	69 2f       	mov	r22, r25
     fa6:	79 2f       	mov	r23, r25
     fa8:	89 2f       	mov	r24, r25
     faa:	7a d5       	rcall	.+2804   	; 0x1aa0 <__muldi3>
     fac:	03 e1       	ldi	r16, 0x13	; 19
     fae:	b2 d6       	rcall	.+3428   	; 0x1d14 <__ashrdi3>
     fb0:	a2 2e       	mov	r10, r18
     fb2:	b3 2e       	mov	r11, r19
     fb4:	c4 2e       	mov	r12, r20
     fb6:	d5 2e       	mov	r13, r21
     fb8:	e6 2e       	mov	r14, r22
     fba:	f7 2e       	mov	r15, r23
     fbc:	08 2f       	mov	r16, r24
     fbe:	19 2f       	mov	r17, r25
     fc0:	22 2d       	mov	r18, r2
     fc2:	33 2d       	mov	r19, r3
     fc4:	44 2d       	mov	r20, r4
     fc6:	55 2d       	mov	r21, r5
     fc8:	66 2d       	mov	r22, r6
     fca:	77 2d       	mov	r23, r7
     fcc:	88 2d       	mov	r24, r8
     fce:	99 2d       	mov	r25, r9
     fd0:	bf d6       	rcall	.+3454   	; 0x1d50 <__adddi3>
     fd2:	08 e0       	ldi	r16, 0x08	; 8
     fd4:	9f d6       	rcall	.+3390   	; 0x1d14 <__ashrdi3>
     fd6:	a2 2e       	mov	r10, r18
     fd8:	b3 2e       	mov	r11, r19
     fda:	c4 2e       	mov	r12, r20
     fdc:	d5 2e       	mov	r13, r21
     fde:	e6 2e       	mov	r14, r22
     fe0:	f7 2e       	mov	r15, r23
     fe2:	08 2f       	mov	r16, r24
     fe4:	19 2f       	mov	r17, r25
	return(long)p;
     fe6:	80 91 43 04 	lds	r24, 0x0443	; 0x800443 <dig_P7>
     fea:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <dig_P7+0x1>
     fee:	09 2e       	mov	r0, r25
     ff0:	00 0c       	add	r0, r0
     ff2:	aa 0b       	sbc	r26, r26
     ff4:	bb 0b       	sbc	r27, r27
     ff6:	88 0f       	add	r24, r24
     ff8:	99 1f       	adc	r25, r25
     ffa:	aa 1f       	adc	r26, r26
     ffc:	bb 1f       	adc	r27, r27
     ffe:	88 0f       	add	r24, r24
    1000:	99 1f       	adc	r25, r25
    1002:	aa 1f       	adc	r26, r26
    1004:	bb 1f       	adc	r27, r27
    1006:	88 0f       	add	r24, r24
    1008:	99 1f       	adc	r25, r25
    100a:	aa 1f       	adc	r26, r26
    100c:	bb 1f       	adc	r27, r27
    100e:	88 0f       	add	r24, r24
    1010:	99 1f       	adc	r25, r25
    1012:	aa 1f       	adc	r26, r26
    1014:	bb 1f       	adc	r27, r27
    1016:	2c 01       	movw	r4, r24
    1018:	3d 01       	movw	r6, r26
    101a:	77 0c       	add	r7, r7
    101c:	44 08       	sbc	r4, r4
    101e:	54 2c       	mov	r5, r4
    1020:	32 01       	movw	r6, r4
    1022:	28 2f       	mov	r18, r24
    1024:	39 2f       	mov	r19, r25
    1026:	4a 2f       	mov	r20, r26
    1028:	5b 2f       	mov	r21, r27
    102a:	64 2d       	mov	r22, r4
    102c:	74 2d       	mov	r23, r4
    102e:	84 2d       	mov	r24, r4
    1030:	94 2d       	mov	r25, r4
    1032:	8e d6       	rcall	.+3356   	; 0x1d50 <__adddi3>
    1034:	62 2f       	mov	r22, r18
    1036:	73 2f       	mov	r23, r19
    1038:	84 2f       	mov	r24, r20
    103a:	95 2f       	mov	r25, r21
    103c:	04 c0       	rjmp	.+8      	; 0x1046 <BME280_compensate_P_int64+0x3c4>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    103e:	60 e0       	ldi	r22, 0x00	; 0
    1040:	70 e0       	ldi	r23, 0x00	; 0
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    1046:	66 96       	adiw	r28, 0x16	; 22
    1048:	0f b6       	in	r0, 0x3f	; 63
    104a:	f8 94       	cli
    104c:	de bf       	out	0x3e, r29	; 62
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	cd bf       	out	0x3d, r28	; 61
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	1f 91       	pop	r17
    1058:	0f 91       	pop	r16
    105a:	ff 90       	pop	r15
    105c:	ef 90       	pop	r14
    105e:	df 90       	pop	r13
    1060:	cf 90       	pop	r12
    1062:	bf 90       	pop	r11
    1064:	af 90       	pop	r10
    1066:	9f 90       	pop	r9
    1068:	8f 90       	pop	r8
    106a:	7f 90       	pop	r7
    106c:	6f 90       	pop	r6
    106e:	5f 90       	pop	r5
    1070:	4f 90       	pop	r4
    1072:	3f 90       	pop	r3
    1074:	2f 90       	pop	r2
    1076:	08 95       	ret

00001078 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    1078:	2f 92       	push	r2
    107a:	3f 92       	push	r3
    107c:	4f 92       	push	r4
    107e:	5f 92       	push	r5
    1080:	6f 92       	push	r6
    1082:	7f 92       	push	r7
    1084:	8f 92       	push	r8
    1086:	9f 92       	push	r9
    1088:	af 92       	push	r10
    108a:	bf 92       	push	r11
    108c:	cf 92       	push	r12
    108e:	df 92       	push	r13
    1090:	ef 92       	push	r14
    1092:	ff 92       	push	r15
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	cd b7       	in	r28, 0x3d	; 61
    109e:	de b7       	in	r29, 0x3e	; 62
    10a0:	67 97       	sbiw	r28, 0x17	; 23
    10a2:	0f b6       	in	r0, 0x3f	; 63
    10a4:	f8 94       	cli
    10a6:	de bf       	out	0x3e, r29	; 62
    10a8:	0f be       	out	0x3f, r0	; 63
    10aa:	cd bf       	out	0x3d, r28	; 61
    10ac:	2b 01       	movw	r4, r22
    10ae:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    10b0:	80 91 c7 04 	lds	r24, 0x04C7	; 0x8004c7 <t_fine>
    10b4:	90 91 c8 04 	lds	r25, 0x04C8	; 0x8004c8 <t_fine+0x1>
    10b8:	a0 91 c9 04 	lds	r26, 0x04C9	; 0x8004c9 <t_fine+0x2>
    10bc:	b0 91 ca 04 	lds	r27, 0x04CA	; 0x8004ca <t_fine+0x3>
    10c0:	6c 01       	movw	r12, r24
    10c2:	7d 01       	movw	r14, r26
    10c4:	ff 0c       	add	r15, r15
    10c6:	cc 08       	sbc	r12, r12
    10c8:	dc 2c       	mov	r13, r12
    10ca:	76 01       	movw	r14, r12
    10cc:	28 2f       	mov	r18, r24
    10ce:	39 2f       	mov	r19, r25
    10d0:	4a 2f       	mov	r20, r26
    10d2:	5b 2f       	mov	r21, r27
    10d4:	6c 2d       	mov	r22, r12
    10d6:	7c 2d       	mov	r23, r12
    10d8:	8c 2d       	mov	r24, r12
    10da:	9c 2d       	mov	r25, r12
    10dc:	3c 52       	subi	r19, 0x2C	; 44
    10de:	41 40       	sbci	r20, 0x01	; 1
    10e0:	51 09       	sbc	r21, r1
    10e2:	61 09       	sbc	r22, r1
    10e4:	71 09       	sbc	r23, r1
    10e6:	81 09       	sbc	r24, r1
    10e8:	91 09       	sbc	r25, r1
    10ea:	2f 8b       	std	Y+23, r18	; 0x17
    10ec:	3e 8b       	std	Y+22, r19	; 0x16
    10ee:	49 83       	std	Y+1, r20	; 0x01
    10f0:	59 87       	std	Y+9, r21	; 0x09
    10f2:	6a 87       	std	Y+10, r22	; 0x0a
    10f4:	7b 87       	std	Y+11, r23	; 0x0b
    10f6:	8c 87       	std	Y+12, r24	; 0x0c
    10f8:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    10fa:	03 2e       	mov	r0, r19
    10fc:	3e e0       	ldi	r19, 0x0E	; 14
    10fe:	44 0c       	add	r4, r4
    1100:	55 1c       	adc	r5, r5
    1102:	66 1c       	adc	r6, r6
    1104:	77 1c       	adc	r7, r7
    1106:	3a 95       	dec	r19
    1108:	d1 f7       	brne	.-12     	; 0x10fe <bme280_compensate_H_int32+0x86>
    110a:	30 2d       	mov	r19, r0
    110c:	53 01       	movw	r10, r6
    110e:	42 01       	movw	r8, r4
    1110:	bb 0c       	add	r11, r11
    1112:	88 08       	sbc	r8, r8
    1114:	98 2c       	mov	r9, r8
    1116:	54 01       	movw	r10, r8
    1118:	30 91 48 04 	lds	r19, 0x0448	; 0x800448 <dig_H4+0x1>
    111c:	20 91 47 04 	lds	r18, 0x0447	; 0x800447 <dig_H4>
    1120:	93 2f       	mov	r25, r19
    1122:	99 0f       	add	r25, r25
    1124:	99 0b       	sbc	r25, r25
    1126:	49 2f       	mov	r20, r25
    1128:	59 2f       	mov	r21, r25
    112a:	69 2f       	mov	r22, r25
    112c:	79 2f       	mov	r23, r25
    112e:	89 2f       	mov	r24, r25
    1130:	04 e1       	ldi	r16, 0x14	; 20
    1132:	d7 d5       	rcall	.+2990   	; 0x1ce2 <__ashldi3>
    1134:	f2 2f       	mov	r31, r18
    1136:	e3 2f       	mov	r30, r19
    1138:	c4 2e       	mov	r12, r20
    113a:	d5 2e       	mov	r13, r21
    113c:	e6 2e       	mov	r14, r22
    113e:	f7 2e       	mov	r15, r23
    1140:	08 2f       	mov	r16, r24
    1142:	19 2f       	mov	r17, r25
    1144:	24 2d       	mov	r18, r4
    1146:	35 2d       	mov	r19, r5
    1148:	46 2d       	mov	r20, r6
    114a:	57 2d       	mov	r21, r7
    114c:	68 2d       	mov	r22, r8
    114e:	78 2d       	mov	r23, r8
    1150:	88 2d       	mov	r24, r8
    1152:	98 2d       	mov	r25, r8
    1154:	af 2e       	mov	r10, r31
    1156:	be 2e       	mov	r11, r30
    1158:	04 d6       	rcall	.+3080   	; 0x1d62 <__subdi3>
    115a:	22 2e       	mov	r2, r18
    115c:	33 2e       	mov	r3, r19
    115e:	44 2e       	mov	r4, r20
    1160:	55 2e       	mov	r5, r21
    1162:	66 2e       	mov	r6, r22
    1164:	77 2e       	mov	r7, r23
    1166:	88 2e       	mov	r8, r24
    1168:	99 2e       	mov	r9, r25
    116a:	30 91 bc 04 	lds	r19, 0x04BC	; 0x8004bc <dig_H5+0x1>
    116e:	20 91 bb 04 	lds	r18, 0x04BB	; 0x8004bb <dig_H5>
    1172:	93 2f       	mov	r25, r19
    1174:	99 0f       	add	r25, r25
    1176:	99 0b       	sbc	r25, r25
    1178:	af 88       	ldd	r10, Y+23	; 0x17
    117a:	be 88       	ldd	r11, Y+22	; 0x16
    117c:	c9 80       	ldd	r12, Y+1	; 0x01
    117e:	d9 84       	ldd	r13, Y+9	; 0x09
    1180:	ea 84       	ldd	r14, Y+10	; 0x0a
    1182:	fb 84       	ldd	r15, Y+11	; 0x0b
    1184:	0c 85       	ldd	r16, Y+12	; 0x0c
    1186:	1d 85       	ldd	r17, Y+13	; 0x0d
    1188:	49 2f       	mov	r20, r25
    118a:	59 2f       	mov	r21, r25
    118c:	69 2f       	mov	r22, r25
    118e:	79 2f       	mov	r23, r25
    1190:	89 2f       	mov	r24, r25
    1192:	86 d4       	rcall	.+2316   	; 0x1aa0 <__muldi3>
    1194:	a2 2e       	mov	r10, r18
    1196:	b3 2e       	mov	r11, r19
    1198:	c4 2e       	mov	r12, r20
    119a:	d5 2e       	mov	r13, r21
    119c:	e6 2e       	mov	r14, r22
    119e:	f7 2e       	mov	r15, r23
    11a0:	08 2f       	mov	r16, r24
    11a2:	19 2f       	mov	r17, r25
    11a4:	22 2d       	mov	r18, r2
    11a6:	33 2d       	mov	r19, r3
    11a8:	44 2d       	mov	r20, r4
    11aa:	55 2d       	mov	r21, r5
    11ac:	66 2d       	mov	r22, r6
    11ae:	77 2d       	mov	r23, r7
    11b0:	88 2d       	mov	r24, r8
    11b2:	99 2d       	mov	r25, r9
    11b4:	d6 d5       	rcall	.+2988   	; 0x1d62 <__subdi3>
    11b6:	30 5c       	subi	r19, 0xC0	; 192
    11b8:	4f 4f       	sbci	r20, 0xFF	; 255
    11ba:	5f 4f       	sbci	r21, 0xFF	; 255
    11bc:	6f 4f       	sbci	r22, 0xFF	; 255
    11be:	7f 4f       	sbci	r23, 0xFF	; 255
    11c0:	8f 4f       	sbci	r24, 0xFF	; 255
    11c2:	9f 4f       	sbci	r25, 0xFF	; 255
    11c4:	0f e0       	ldi	r16, 0x0F	; 15
    11c6:	a6 d5       	rcall	.+2892   	; 0x1d14 <__ashrdi3>
    11c8:	2e 87       	std	Y+14, r18	; 0x0e
    11ca:	3f 87       	std	Y+15, r19	; 0x0f
    11cc:	48 8b       	std	Y+16, r20	; 0x10
    11ce:	59 8b       	std	Y+17, r21	; 0x11
    11d0:	6a 8b       	std	Y+18, r22	; 0x12
    11d2:	7b 8b       	std	Y+19, r23	; 0x13
    11d4:	8c 8b       	std	Y+20, r24	; 0x14
    11d6:	9d 8b       	std	Y+21, r25	; 0x15
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
    11d8:	40 91 bd 04 	lds	r20, 0x04BD	; 0x8004bd <dig_H3>
    11dc:	50 91 be 04 	lds	r21, 0x04BE	; 0x8004be <dig_H3+0x1>
    11e0:	af 88       	ldd	r10, Y+23	; 0x17
    11e2:	be 88       	ldd	r11, Y+22	; 0x16
    11e4:	c9 80       	ldd	r12, Y+1	; 0x01
    11e6:	d9 84       	ldd	r13, Y+9	; 0x09
    11e8:	ea 84       	ldd	r14, Y+10	; 0x0a
    11ea:	fb 84       	ldd	r15, Y+11	; 0x0b
    11ec:	0c 85       	ldd	r16, Y+12	; 0x0c
    11ee:	1d 85       	ldd	r17, Y+13	; 0x0d
    11f0:	24 2f       	mov	r18, r20
    11f2:	35 2f       	mov	r19, r21
    11f4:	40 e0       	ldi	r20, 0x00	; 0
    11f6:	50 e0       	ldi	r21, 0x00	; 0
    11f8:	60 e0       	ldi	r22, 0x00	; 0
    11fa:	70 e0       	ldi	r23, 0x00	; 0
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	4f d4       	rcall	.+2206   	; 0x1aa0 <__muldi3>
    1202:	0b e0       	ldi	r16, 0x0B	; 11
    1204:	87 d5       	rcall	.+2830   	; 0x1d14 <__ashrdi3>
    1206:	30 58       	subi	r19, 0x80	; 128
    1208:	4f 4f       	sbci	r20, 0xFF	; 255
    120a:	5f 4f       	sbci	r21, 0xFF	; 255
    120c:	6f 4f       	sbci	r22, 0xFF	; 255
    120e:	7f 4f       	sbci	r23, 0xFF	; 255
    1210:	8f 4f       	sbci	r24, 0xFF	; 255
    1212:	9f 4f       	sbci	r25, 0xFF	; 255
    1214:	22 2e       	mov	r2, r18
    1216:	33 2e       	mov	r3, r19
    1218:	44 2e       	mov	r4, r20
    121a:	55 2e       	mov	r5, r21
    121c:	66 2e       	mov	r6, r22
    121e:	77 2e       	mov	r7, r23
    1220:	88 2e       	mov	r8, r24
    1222:	99 2e       	mov	r9, r25
    1224:	30 91 89 04 	lds	r19, 0x0489	; 0x800489 <dig_H6+0x1>
    1228:	20 91 88 04 	lds	r18, 0x0488	; 0x800488 <dig_H6>
    122c:	93 2f       	mov	r25, r19
    122e:	99 0f       	add	r25, r25
    1230:	99 0b       	sbc	r25, r25
    1232:	0c 85       	ldd	r16, Y+12	; 0x0c
    1234:	49 2f       	mov	r20, r25
    1236:	59 2f       	mov	r21, r25
    1238:	69 2f       	mov	r22, r25
    123a:	79 2f       	mov	r23, r25
    123c:	89 2f       	mov	r24, r25
    123e:	30 d4       	rcall	.+2144   	; 0x1aa0 <__muldi3>
    1240:	0a e0       	ldi	r16, 0x0A	; 10
    1242:	68 d5       	rcall	.+2768   	; 0x1d14 <__ashrdi3>
    1244:	a2 2e       	mov	r10, r18
    1246:	b3 2e       	mov	r11, r19
    1248:	c4 2e       	mov	r12, r20
    124a:	d5 2e       	mov	r13, r21
    124c:	e6 2e       	mov	r14, r22
    124e:	f7 2e       	mov	r15, r23
    1250:	08 2f       	mov	r16, r24
    1252:	19 2f       	mov	r17, r25
    1254:	22 2d       	mov	r18, r2
    1256:	33 2d       	mov	r19, r3
    1258:	44 2d       	mov	r20, r4
    125a:	55 2d       	mov	r21, r5
    125c:	66 2d       	mov	r22, r6
    125e:	77 2d       	mov	r23, r7
    1260:	88 2d       	mov	r24, r8
    1262:	99 2d       	mov	r25, r9
    1264:	1d d4       	rcall	.+2106   	; 0x1aa0 <__muldi3>
    1266:	0a e0       	ldi	r16, 0x0A	; 10
    1268:	55 d5       	rcall	.+2730   	; 0x1d14 <__ashrdi3>
    126a:	40 5e       	subi	r20, 0xE0	; 224
    126c:	5f 4f       	sbci	r21, 0xFF	; 255
    126e:	6f 4f       	sbci	r22, 0xFF	; 255
    1270:	7f 4f       	sbci	r23, 0xFF	; 255
    1272:	8f 4f       	sbci	r24, 0xFF	; 255
    1274:	9f 4f       	sbci	r25, 0xFF	; 255
    1276:	b0 90 c6 04 	lds	r11, 0x04C6	; 0x8004c6 <dig_H2+0x1>
    127a:	a0 90 c5 04 	lds	r10, 0x04C5	; 0x8004c5 <dig_H2>
    127e:	1b 2d       	mov	r17, r11
    1280:	11 0f       	add	r17, r17
    1282:	11 0b       	sbc	r17, r17
    1284:	c1 2e       	mov	r12, r17
    1286:	d1 2e       	mov	r13, r17
    1288:	e1 2e       	mov	r14, r17
    128a:	f1 2e       	mov	r15, r17
    128c:	01 2f       	mov	r16, r17
    128e:	08 d4       	rcall	.+2064   	; 0x1aa0 <__muldi3>
    1290:	30 5e       	subi	r19, 0xE0	; 224
    1292:	4f 4f       	sbci	r20, 0xFF	; 255
    1294:	5f 4f       	sbci	r21, 0xFF	; 255
    1296:	6f 4f       	sbci	r22, 0xFF	; 255
    1298:	7f 4f       	sbci	r23, 0xFF	; 255
    129a:	8f 4f       	sbci	r24, 0xFF	; 255
    129c:	9f 4f       	sbci	r25, 0xFF	; 255
    129e:	0e e0       	ldi	r16, 0x0E	; 14
    12a0:	39 d5       	rcall	.+2674   	; 0x1d14 <__ashrdi3>
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    12a2:	a2 2e       	mov	r10, r18
    12a4:	b3 2e       	mov	r11, r19
    12a6:	c4 2e       	mov	r12, r20
    12a8:	d5 2e       	mov	r13, r21
    12aa:	e6 2e       	mov	r14, r22
    12ac:	f7 2e       	mov	r15, r23
    12ae:	08 2f       	mov	r16, r24
    12b0:	19 2f       	mov	r17, r25
    12b2:	2e 85       	ldd	r18, Y+14	; 0x0e
    12b4:	3f 85       	ldd	r19, Y+15	; 0x0f
    12b6:	48 89       	ldd	r20, Y+16	; 0x10
    12b8:	59 89       	ldd	r21, Y+17	; 0x11
    12ba:	6a 89       	ldd	r22, Y+18	; 0x12
    12bc:	7b 89       	ldd	r23, Y+19	; 0x13
    12be:	8c 89       	ldd	r24, Y+20	; 0x14
    12c0:	9d 89       	ldd	r25, Y+21	; 0x15
    12c2:	ee d3       	rcall	.+2012   	; 0x1aa0 <__muldi3>
    12c4:	42 2e       	mov	r4, r18
    12c6:	53 2e       	mov	r5, r19
    12c8:	64 2e       	mov	r6, r20
    12ca:	75 2e       	mov	r7, r21
    12cc:	86 2e       	mov	r8, r22
    12ce:	97 2e       	mov	r9, r23
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    12d0:	8a 87       	std	Y+10, r24	; 0x0a
    12d2:	99 87       	std	Y+9, r25	; 0x09
    12d4:	0f e0       	ldi	r16, 0x0F	; 15
    12d6:	1e d5       	rcall	.+2620   	; 0x1d14 <__ashrdi3>
    12d8:	a2 2e       	mov	r10, r18
    12da:	b3 2e       	mov	r11, r19
    12dc:	c4 2e       	mov	r12, r20
    12de:	d5 2e       	mov	r13, r21
    12e0:	e6 2e       	mov	r14, r22
    12e2:	f7 2e       	mov	r15, r23
    12e4:	08 2f       	mov	r16, r24
    12e6:	19 2f       	mov	r17, r25
    12e8:	db d3       	rcall	.+1974   	; 0x1aa0 <__muldi3>
    12ea:	07 e0       	ldi	r16, 0x07	; 7
    12ec:	13 d5       	rcall	.+2598   	; 0x1d14 <__ashrdi3>
    12ee:	e0 91 77 04 	lds	r30, 0x0477	; 0x800477 <dig_H1>
    12f2:	f0 91 78 04 	lds	r31, 0x0478	; 0x800478 <dig_H1+0x1>
    12f6:	5f 01       	movw	r10, r30
    12f8:	c1 2c       	mov	r12, r1
    12fa:	d1 2c       	mov	r13, r1
    12fc:	e1 2c       	mov	r14, r1
    12fe:	f1 2c       	mov	r15, r1
    1300:	87 01       	movw	r16, r14
    1302:	e9 83       	std	Y+1, r30	; 0x01
    1304:	ba 82       	std	Y+2, r11	; 0x02
    1306:	cb 82       	std	Y+3, r12	; 0x03
    1308:	dc 82       	std	Y+4, r13	; 0x04
    130a:	ed 82       	std	Y+5, r14	; 0x05
    130c:	fe 82       	std	Y+6, r15	; 0x06
    130e:	0f 83       	std	Y+7, r16	; 0x07
    1310:	18 87       	std	Y+8, r17	; 0x08
    1312:	c1 2c       	mov	r12, r1
    1314:	d1 2c       	mov	r13, r1
    1316:	e1 2c       	mov	r14, r1
    1318:	f1 2c       	mov	r15, r1
    131a:	00 e0       	ldi	r16, 0x00	; 0
    131c:	10 e0       	ldi	r17, 0x00	; 0
    131e:	c0 d3       	rcall	.+1920   	; 0x1aa0 <__muldi3>
    1320:	04 e0       	ldi	r16, 0x04	; 4
    1322:	f8 d4       	rcall	.+2544   	; 0x1d14 <__ashrdi3>
    1324:	a2 2e       	mov	r10, r18
    1326:	b3 2e       	mov	r11, r19
    1328:	c4 2e       	mov	r12, r20
    132a:	d5 2e       	mov	r13, r21
    132c:	e6 2e       	mov	r14, r22
    132e:	f7 2e       	mov	r15, r23
    1330:	08 2f       	mov	r16, r24
    1332:	19 2f       	mov	r17, r25
    1334:	24 2d       	mov	r18, r4
    1336:	35 2d       	mov	r19, r5
    1338:	46 2d       	mov	r20, r6
    133a:	57 2d       	mov	r21, r7
    133c:	68 2d       	mov	r22, r8
    133e:	79 2d       	mov	r23, r9
    1340:	8a 85       	ldd	r24, Y+10	; 0x0a
    1342:	99 85       	ldd	r25, Y+9	; 0x09
    1344:	0e d5       	rcall	.+2588   	; 0x1d62 <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    1346:	f2 2e       	mov	r15, r18
    1348:	03 2f       	mov	r16, r19
    134a:	14 2f       	mov	r17, r20
    134c:	59 87       	std	Y+9, r21	; 0x09
    134e:	69 83       	std	Y+1, r22	; 0x01
    1350:	b7 2f       	mov	r27, r23
    1352:	f8 2f       	mov	r31, r24
    1354:	e9 2f       	mov	r30, r25
    1356:	a0 e0       	ldi	r26, 0x00	; 0
    1358:	0d d5       	rcall	.+2586   	; 0x1d74 <__cmpdi2_s8>
    135a:	44 f4       	brge	.+16     	; 0x136c <bme280_compensate_H_int32+0x2f4>
    135c:	f1 2c       	mov	r15, r1
    135e:	00 e0       	ldi	r16, 0x00	; 0
    1360:	10 e0       	ldi	r17, 0x00	; 0
    1362:	19 86       	std	Y+9, r1	; 0x09
    1364:	19 82       	std	Y+1, r1	; 0x01
    1366:	b0 e0       	ldi	r27, 0x00	; 0
    1368:	f0 e0       	ldi	r31, 0x00	; 0
    136a:	e0 e0       	ldi	r30, 0x00	; 0
    136c:	8f 2c       	mov	r8, r15
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
	return (long)(v_x1_u32r>>12);
    136e:	90 2e       	mov	r9, r16
    1370:	a1 2e       	mov	r10, r17
    1372:	b9 84       	ldd	r11, Y+9	; 0x09
    1374:	c9 80       	ldd	r12, Y+1	; 0x01
    1376:	db 2e       	mov	r13, r27
    1378:	ef 2e       	mov	r14, r31
    137a:	ae 2f       	mov	r26, r30
    137c:	2f 2d       	mov	r18, r15
    137e:	30 2f       	mov	r19, r16
    1380:	41 2f       	mov	r20, r17
    1382:	5b 2d       	mov	r21, r11
    1384:	6c 2d       	mov	r22, r12
    1386:	7b 2f       	mov	r23, r27
    1388:	8f 2f       	mov	r24, r31
    138a:	9e 2f       	mov	r25, r30
    138c:	21 15       	cp	r18, r1
    138e:	31 05       	cpc	r19, r1
    1390:	41 05       	cpc	r20, r1
    1392:	59 41       	sbci	r21, 0x19	; 25
    1394:	61 05       	cpc	r22, r1
    1396:	71 05       	cpc	r23, r1
    1398:	81 05       	cpc	r24, r1
    139a:	91 05       	cpc	r25, r1
    139c:	61 f0       	breq	.+24     	; 0x13b6 <bme280_compensate_H_int32+0x33e>
    139e:	5c f0       	brlt	.+22     	; 0x13b6 <bme280_compensate_H_int32+0x33e>
    13a0:	81 2c       	mov	r8, r1
    13a2:	91 2c       	mov	r9, r1
    13a4:	a1 2c       	mov	r10, r1
    13a6:	0f 2e       	mov	r0, r31
    13a8:	f9 e1       	ldi	r31, 0x19	; 25
    13aa:	bf 2e       	mov	r11, r31
    13ac:	f0 2d       	mov	r31, r0
    13ae:	c1 2c       	mov	r12, r1
    13b0:	d1 2c       	mov	r13, r1
    13b2:	e1 2c       	mov	r14, r1
    13b4:	a0 e0       	ldi	r26, 0x00	; 0
    13b6:	28 2d       	mov	r18, r8
    13b8:	39 2d       	mov	r19, r9
    13ba:	4a 2d       	mov	r20, r10
    13bc:	5b 2d       	mov	r21, r11
    13be:	6c 2d       	mov	r22, r12
    13c0:	7d 2d       	mov	r23, r13
    13c2:	8e 2d       	mov	r24, r14
    13c4:	9a 2f       	mov	r25, r26
    13c6:	0c e0       	ldi	r16, 0x0C	; 12
    13c8:	a5 d4       	rcall	.+2378   	; 0x1d14 <__ashrdi3>
    13ca:	62 2f       	mov	r22, r18
    13cc:	73 2f       	mov	r23, r19
    13ce:	84 2f       	mov	r24, r20
    13d0:	95 2f       	mov	r25, r21
    13d2:	67 96       	adiw	r28, 0x17	; 23
}
    13d4:	0f b6       	in	r0, 0x3f	; 63
    13d6:	f8 94       	cli
    13d8:	de bf       	out	0x3e, r29	; 62
    13da:	0f be       	out	0x3f, r0	; 63
    13dc:	cd bf       	out	0x3d, r28	; 61
    13de:	df 91       	pop	r29
    13e0:	cf 91       	pop	r28
    13e2:	1f 91       	pop	r17
    13e4:	0f 91       	pop	r16
    13e6:	ff 90       	pop	r15
    13e8:	ef 90       	pop	r14
    13ea:	df 90       	pop	r13
    13ec:	cf 90       	pop	r12
    13ee:	bf 90       	pop	r11
    13f0:	af 90       	pop	r10
    13f2:	9f 90       	pop	r9
    13f4:	8f 90       	pop	r8
    13f6:	7f 90       	pop	r7
    13f8:	6f 90       	pop	r6
    13fa:	5f 90       	pop	r5
    13fc:	4f 90       	pop	r4
    13fe:	3f 90       	pop	r3
    1400:	2f 90       	pop	r2
    1402:	08 95       	ret

00001404 <main>:
    1404:	0e 94 5f 01 	call	0x2be	; 0x2be <canary_io_pin_initialization>
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    1408:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <seconds+0x1>
    140c:	10 92 b3 04 	sts	0x04B3, r1	; 0x8004b3 <seconds>
	ItsTime=0;
    1410:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
    1414:	8b e2       	ldi	r24, 0x2B	; 43
    1416:	91 e0       	ldi	r25, 0x01	; 1
    1418:	90 93 ce 06 	sts	0x06CE, r25	; 0x8006ce <__iob+0x3>
    141c:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
    1420:	38 d1       	rcall	.+624    	; 0x1692 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    1422:	81 e8       	ldi	r24, 0x81	; 129
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	32 d2       	rcall	.+1124   	; 0x188c <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
    1428:	81 e8       	ldi	r24, 0x81	; 129
    142a:	90 e0       	ldi	r25, 0x00	; 0
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    142c:	a7 d2       	rcall	.+1358   	; 0x197c <USART1_init>
    142e:	51 d1       	rcall	.+674    	; 0x16d2 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    1430:	0e 94 c1 00 	call	0x182	; 0x182 <ADC_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
    1434:	0e 94 ac 01 	call	0x358	; 0x358 <gas_sensors_init>
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
    1438:	2a 9a       	sbi	0x05, 2	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    143a:	2f e7       	ldi	r18, 0x7F	; 127
    143c:	84 e8       	ldi	r24, 0x84	; 132
    143e:	9e e1       	ldi	r25, 0x1E	; 30
    1440:	21 50       	subi	r18, 0x01	; 1
    1442:	80 40       	sbci	r24, 0x00	; 0
    1444:	90 40       	sbci	r25, 0x00	; 0
    1446:	e1 f7       	brne	.-8      	; 0x1440 <main+0x3c>
    1448:	00 c0       	rjmp	.+0      	; 0x144a <main+0x46>
    144a:	00 00       	nop
	_delay_ms(500);
	ClearBit(PORTB, PORTB2);
    144c:	2a 98       	cbi	0x05, 2	; 5
    144e:	2f e7       	ldi	r18, 0x7F	; 127
    1450:	84 e8       	ldi	r24, 0x84	; 132
    1452:	9e e1       	ldi	r25, 0x1E	; 30
    1454:	21 50       	subi	r18, 0x01	; 1
    1456:	80 40       	sbci	r24, 0x00	; 0
    1458:	90 40       	sbci	r25, 0x00	; 0
    145a:	e1 f7       	brne	.-8      	; 0x1454 <main+0x50>
    145c:	00 c0       	rjmp	.+0      	; 0x145e <main+0x5a>
	// 
	// Start all interrupts
	sei();
	//
	// Initialize and check the BME interface...
	bme280basic_init();
    145e:	00 00       	nop
    1460:	78 94       	sei
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    1462:	3f da       	rcall	.-2946   	; 0x8e2 <bme280basic_init>
    1464:	81 e0       	ldi	r24, 0x01	; 1
    1466:	91 e0       	ldi	r25, 0x01	; 1
    1468:	4e d2       	rcall	.+1180   	; 0x1906 <USART0_putstring>
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
    146a:	0f 2e       	mov	r0, r31
    146c:	fa e3       	ldi	r31, 0x3A	; 58
    146e:	af 2e       	mov	r10, r31
    1470:	f1 e0       	ldi	r31, 0x01	; 1
    1472:	bf 2e       	mov	r11, r31
    1474:	f0 2d       	mov	r31, r0
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    1476:	0f 2e       	mov	r0, r31
    1478:	fb ec       	ldi	r31, 0xCB	; 203
    147a:	cf 2e       	mov	r12, r31
    147c:	f5 e0       	ldi	r31, 0x05	; 5
    147e:	df 2e       	mov	r13, r31
    1480:	f0 2d       	mov	r31, r0
    1482:	0f 2e       	mov	r0, r31
    1484:	f8 e4       	ldi	r31, 0x48	; 72
    1486:	ef 2e       	mov	r14, r31
    1488:	f1 e0       	ldi	r31, 0x01	; 1
    148a:	ff 2e       	mov	r15, r31
    148c:	f0 2d       	mov	r31, r0
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
 			printf("LIDAR distance = %u", distance);
    148e:	0c e4       	ldi	r16, 0x4C	; 76
    1490:	11 e0       	ldi	r17, 0x01	; 1
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1492:	ce e1       	ldi	r28, 0x1E	; 30
    1494:	d3 e0       	ldi	r29, 0x03	; 3
    1496:	0f 2e       	mov	r0, r31
    1498:	f0 e6       	ldi	r31, 0x60	; 96
    149a:	8f 2e       	mov	r8, r31
    149c:	f1 e0       	ldi	r31, 0x01	; 1
    149e:	9f 2e       	mov	r9, r31
    14a0:	f0 2d       	mov	r31, r0
 			printf("\nH = %u", raw_gas_vector[1]);
    14a2:	0f 2e       	mov	r0, r31
    14a4:	f9 e6       	ldi	r31, 0x69	; 105
    14a6:	2f 2e       	mov	r2, r31
    14a8:	f1 e0       	ldi	r31, 0x01	; 1
    14aa:	3f 2e       	mov	r3, r31
    14ac:	f0 2d       	mov	r31, r0
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
    14ae:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <ItsTime>
    14b2:	81 30       	cpi	r24, 0x01	; 1
    14b4:	e1 f7       	brne	.-8      	; 0x14ae <main+0xaa>
			ItsTime = 0; 
    14b6:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <ItsTime>
			seconds++;
    14ba:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <seconds>
    14be:	90 91 b4 04 	lds	r25, 0x04B4	; 0x8004b4 <seconds+0x1>
    14c2:	01 96       	adiw	r24, 0x01	; 1
    14c4:	90 93 b4 04 	sts	0x04B4, r25	; 0x8004b4 <seconds+0x1>
    14c8:	80 93 b3 04 	sts	0x04B3, r24	; 0x8004b3 <seconds>
			printf("\nSeconds = %u", seconds);
    14cc:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <seconds>
    14d0:	90 91 b4 04 	lds	r25, 0x04B4	; 0x8004b4 <seconds+0x1>
    14d4:	9f 93       	push	r25
    14d6:	8f 93       	push	r24
    14d8:	bf 92       	push	r11
    14da:	af 92       	push	r10
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    14dc:	66 d4       	rcall	.+2252   	; 0x1daa <printf>
    14de:	df 92       	push	r13
    14e0:	cf 92       	push	r12
    14e2:	ff 92       	push	r15
    14e4:	ef 92       	push	r14
    14e6:	61 d4       	rcall	.+2242   	; 0x1daa <printf>
    14e8:	2f ef       	ldi	r18, 0xFF	; 255
    14ea:	84 e3       	ldi	r24, 0x34	; 52
    14ec:	9c e0       	ldi	r25, 0x0C	; 12
    14ee:	21 50       	subi	r18, 0x01	; 1
    14f0:	80 40       	sbci	r24, 0x00	; 0
    14f2:	90 40       	sbci	r25, 0x00	; 0
    14f4:	e1 f7       	brne	.-8      	; 0x14ee <main+0xea>
    14f6:	00 c0       	rjmp	.+0      	; 0x14f8 <main+0xf4>
			// Now we want to read each sensor - and send out the data,
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
    14f8:	00 00       	nop
    14fa:	46 d8       	rcall	.-3956   	; 0x588 <LIDAR_distance>
    14fc:	80 93 19 03 	sts	0x0319, r24	; 0x800319 <distance>
    1500:	90 93 1a 03 	sts	0x031A, r25	; 0x80031a <distance+0x1>
 			printf("LIDAR distance = %u", distance);
    1504:	9f 93       	push	r25
    1506:	8f 93       	push	r24
    1508:	1f 93       	push	r17
    150a:	0f 93       	push	r16
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    150c:	4e d4       	rcall	.+2204   	; 0x1daa <printf>
    150e:	0e 94 2b 02 	call	0x456	; 0x456 <start_gas_sensor_read>
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1512:	89 81       	ldd	r24, Y+1	; 0x01
    1514:	8f 93       	push	r24
    1516:	88 81       	ld	r24, Y
    1518:	8f 93       	push	r24
    151a:	9f 92       	push	r9
    151c:	8f 92       	push	r8
 			printf("\nH = %u", raw_gas_vector[1]);
    151e:	45 d4       	rcall	.+2186   	; 0x1daa <printf>
    1520:	8b 81       	ldd	r24, Y+3	; 0x03
    1522:	8f 93       	push	r24
    1524:	8a 81       	ldd	r24, Y+2	; 0x02
    1526:	8f 93       	push	r24
    1528:	3f 92       	push	r3
    152a:	2f 92       	push	r2
 			printf("\nNA = %u", raw_gas_vector[2]);
    152c:	3e d4       	rcall	.+2172   	; 0x1daa <printf>
    152e:	8d 81       	ldd	r24, Y+5	; 0x05
    1530:	8f 93       	push	r24
    1532:	8c 81       	ldd	r24, Y+4	; 0x04
    1534:	8f 93       	push	r24
    1536:	81 e7       	ldi	r24, 0x71	; 113
    1538:	91 e0       	ldi	r25, 0x01	; 1
    153a:	9f 93       	push	r25
    153c:	8f 93       	push	r24
 			printf("\nCH4 = %u", raw_gas_vector[3]);
    153e:	35 d4       	rcall	.+2154   	; 0x1daa <printf>
    1540:	8f 81       	ldd	r24, Y+7	; 0x07
    1542:	8f 93       	push	r24
    1544:	8e 81       	ldd	r24, Y+6	; 0x06
    1546:	8f 93       	push	r24
    1548:	8a e7       	ldi	r24, 0x7A	; 122
    154a:	91 e0       	ldi	r25, 0x01	; 1
    154c:	9f 93       	push	r25
    154e:	8f 93       	push	r24
 			printf("\nO3 = %u", raw_gas_vector[4]);
    1550:	2c d4       	rcall	.+2136   	; 0x1daa <printf>
    1552:	89 85       	ldd	r24, Y+9	; 0x09
    1554:	8f 93       	push	r24
    1556:	88 85       	ldd	r24, Y+8	; 0x08
    1558:	8f 93       	push	r24
    155a:	84 e8       	ldi	r24, 0x84	; 132
    155c:	91 e0       	ldi	r25, 0x01	; 1
    155e:	9f 93       	push	r25
    1560:	8f 93       	push	r24
			//
			//============================
			// Now read the BME interface...
 			bme280basic_bulk_data_read();
    1562:	23 d4       	rcall	.+2118   	; 0x1daa <printf>
    1564:	8d b7       	in	r24, 0x3d	; 61
    1566:	9e b7       	in	r25, 0x3e	; 62
    1568:	80 96       	adiw	r24, 0x20	; 32
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	9e bf       	out	0x3e, r25	; 62
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	8d bf       	out	0x3d, r24	; 61
 			tempCelsius = BME280_compensate_T_int32(rawTemp);
    1574:	12 da       	rcall	.-3036   	; 0x99a <bme280basic_bulk_data_read>
    1576:	60 91 79 04 	lds	r22, 0x0479	; 0x800479 <rawTemp>
    157a:	70 91 7a 04 	lds	r23, 0x047A	; 0x80047a <rawTemp+0x1>
    157e:	80 91 7b 04 	lds	r24, 0x047B	; 0x80047b <rawTemp+0x2>
    1582:	90 91 7c 04 	lds	r25, 0x047C	; 0x80047c <rawTemp+0x3>
    1586:	f2 da       	rcall	.-2588   	; 0xb6c <BME280_compensate_T_int32>
    1588:	60 93 73 04 	sts	0x0473, r22	; 0x800473 <tempCelsius>
    158c:	70 93 74 04 	sts	0x0474, r23	; 0x800474 <tempCelsius+0x1>
    1590:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <tempCelsius+0x2>
    1594:	90 93 76 04 	sts	0x0476, r25	; 0x800476 <tempCelsius+0x3>
// 			sprintf(temperatureBuf, "%lu", tempCelsius);
  			printf("\nCelsius = %lu", tempCelsius);
    1598:	9f 93       	push	r25
    159a:	8f 93       	push	r24
    159c:	7f 93       	push	r23
    159e:	6f 93       	push	r22
    15a0:	8d e8       	ldi	r24, 0x8D	; 141
    15a2:	91 e0       	ldi	r25, 0x01	; 1
    15a4:	9f 93       	push	r25
    15a6:	8f 93       	push	r24
 			pressure = BME280_compensate_P_int64(rawPress);
    15a8:	00 d4       	rcall	.+2048   	; 0x1daa <printf>
    15aa:	60 91 91 04 	lds	r22, 0x0491	; 0x800491 <rawPress>
    15ae:	70 91 92 04 	lds	r23, 0x0492	; 0x800492 <rawPress+0x1>
    15b2:	80 91 93 04 	lds	r24, 0x0493	; 0x800493 <rawPress+0x2>
    15b6:	90 91 94 04 	lds	r25, 0x0494	; 0x800494 <rawPress+0x3>
    15ba:	63 db       	rcall	.-2362   	; 0xc82 <BME280_compensate_P_int64>
    15bc:	60 93 82 04 	sts	0x0482, r22	; 0x800482 <pressure>
    15c0:	70 93 83 04 	sts	0x0483, r23	; 0x800483 <pressure+0x1>
    15c4:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <pressure+0x2>
    15c8:	90 93 85 04 	sts	0x0485, r25	; 0x800485 <pressure+0x3>
 			printf("\nPressure in Pa = %lu", pressure>>8);
    15cc:	bb 27       	eor	r27, r27
    15ce:	97 fd       	sbrc	r25, 7
    15d0:	ba 95       	dec	r27
    15d2:	a9 2f       	mov	r26, r25
    15d4:	98 2f       	mov	r25, r24
    15d6:	87 2f       	mov	r24, r23
    15d8:	bf 93       	push	r27
    15da:	af 93       	push	r26
    15dc:	9f 93       	push	r25
    15de:	8f 93       	push	r24
    15e0:	8c e9       	ldi	r24, 0x9C	; 156
    15e2:	91 e0       	ldi	r25, 0x01	; 1
    15e4:	9f 93       	push	r25
    15e6:	8f 93       	push	r24
 			humidity = bme280_compensate_H_int32(rawHum);
    15e8:	e0 d3       	rcall	.+1984   	; 0x1daa <printf>
    15ea:	60 91 95 04 	lds	r22, 0x0495	; 0x800495 <rawHum>
    15ee:	70 91 96 04 	lds	r23, 0x0496	; 0x800496 <rawHum+0x1>
    15f2:	80 91 97 04 	lds	r24, 0x0497	; 0x800497 <rawHum+0x2>
    15f6:	90 91 98 04 	lds	r25, 0x0498	; 0x800498 <rawHum+0x3>
    15fa:	3e dd       	rcall	.-1412   	; 0x1078 <bme280_compensate_H_int32>
    15fc:	2b 01       	movw	r4, r22
    15fe:	3c 01       	movw	r6, r24
    1600:	60 93 8a 04 	sts	0x048A, r22	; 0x80048a <humidity>
    1604:	70 93 8b 04 	sts	0x048B, r23	; 0x80048b <humidity+0x1>
    1608:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <humidity+0x2>
    160c:	90 93 8d 04 	sts	0x048D, r25	; 0x80048d <humidity+0x3>
 			printf("\nHumidity%% = %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    1610:	a8 ee       	ldi	r26, 0xE8	; 232
    1612:	b3 e0       	ldi	r27, 0x03	; 3
    1614:	9b 01       	movw	r18, r22
    1616:	ac 01       	movw	r20, r24
    1618:	33 d2       	rcall	.+1126   	; 0x1a80 <__muluhisi3>
    161a:	dc 01       	movw	r26, r24
    161c:	cb 01       	movw	r24, r22
    161e:	07 2e       	mov	r0, r23
    1620:	7a e0       	ldi	r23, 0x0A	; 10
    1622:	b5 95       	asr	r27
    1624:	a7 95       	ror	r26
    1626:	97 95       	ror	r25
    1628:	87 95       	ror	r24
    162a:	7a 95       	dec	r23
    162c:	d1 f7       	brne	.-12     	; 0x1622 <main+0x21e>
    162e:	70 2d       	mov	r23, r0
    1630:	bf 93       	push	r27
    1632:	af 93       	push	r26
    1634:	9f 93       	push	r25
    1636:	8f 93       	push	r24
    1638:	d3 01       	movw	r26, r6
    163a:	c2 01       	movw	r24, r4
    163c:	07 2e       	mov	r0, r23
    163e:	7a e0       	ldi	r23, 0x0A	; 10
    1640:	b5 95       	asr	r27
    1642:	a7 95       	ror	r26
    1644:	97 95       	ror	r25
    1646:	87 95       	ror	r24
    1648:	7a 95       	dec	r23
    164a:	d1 f7       	brne	.-12     	; 0x1640 <main+0x23c>
    164c:	70 2d       	mov	r23, r0
    164e:	bf 93       	push	r27
    1650:	af 93       	push	r26
    1652:	9f 93       	push	r25
    1654:	8f 93       	push	r24
    1656:	82 eb       	ldi	r24, 0xB2	; 178
    1658:	91 e0       	ldi	r25, 0x01	; 1
    165a:	9f 93       	push	r25
    165c:	8f 93       	push	r24
    165e:	a5 d3       	rcall	.+1866   	; 0x1daa <printf>
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
    1660:	e9 ec       	ldi	r30, 0xC9	; 201
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	80 81       	ld	r24, Z
    1666:	80 69       	ori	r24, 0x90	; 144
    1668:	80 83       	st	Z, r24
    166a:	8d b7       	in	r24, 0x3d	; 61
    166c:	9e b7       	in	r25, 0x3e	; 62
    166e:	46 96       	adiw	r24, 0x16	; 22
    1670:	0f b6       	in	r0, 0x3f	; 63
    1672:	f8 94       	cli
    1674:	9e bf       	out	0x3e, r25	; 62
    1676:	0f be       	out	0x3f, r0	; 63
    1678:	8d bf       	out	0x3d, r24	; 61
    167a:	19 cf       	rjmp	.-462    	; 0x14ae <main+0xaa>

0000167c <__vector_default>:
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
    167c:	1f 92       	push	r1
    167e:	0f 92       	push	r0
    1680:	0f b6       	in	r0, 0x3f	; 63
    1682:	0f 92       	push	r0
    1684:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
    1686:	2a 9a       	sbi	0x05, 2	; 5
    1688:	0f 90       	pop	r0
    168a:	0f be       	out	0x3f, r0	; 63
    168c:	0f 90       	pop	r0
    168e:	1f 90       	pop	r1
    1690:	18 95       	reti

00001692 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    1692:	8d e0       	ldi	r24, 0x0D	; 13
    1694:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    1698:	8a e4       	ldi	r24, 0x4A	; 74
    169a:	9c e4       	ldi	r25, 0x4C	; 76
    169c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    16a0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    16a4:	08 95       	ret

000016a6 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    16a6:	18 95       	reti

000016a8 <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
    16a8:	1f 92       	push	r1
    16aa:	0f 92       	push	r0
    16ac:	0f b6       	in	r0, 0x3f	; 63
    16ae:	0f 92       	push	r0
    16b0:	11 24       	eor	r1, r1
    16b2:	8f 93       	push	r24
    16b4:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    16b6:	95 b1       	in	r25, 0x05	; 5
    16b8:	82 e0       	ldi	r24, 0x02	; 2
    16ba:	89 27       	eor	r24, r25
    16bc:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	80 93 fe 02 	sts	0x02FE, r24	; 0x8002fe <ItsTime>
}
    16c4:	9f 91       	pop	r25
    16c6:	8f 91       	pop	r24
    16c8:	0f 90       	pop	r0
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	0f 90       	pop	r0
    16ce:	1f 90       	pop	r1
    16d0:	18 95       	reti

000016d2 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    16d2:	81 e1       	ldi	r24, 0x11	; 17
    16d4:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    16d8:	8f ef       	ldi	r24, 0xFF	; 255
    16da:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    16de:	84 e0       	ldi	r24, 0x04	; 4
    16e0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    16e4:	08 95       	ret

000016e6 <TWI_Transceiver_Busy>:
    16e6:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    16ea:	81 78       	andi	r24, 0x81	; 129
    16ec:	08 95       	ret

000016ee <TWI_Start_Transceiver_With_Data>:
    16ee:	cf 93       	push	r28
    16f0:	df 93       	push	r29
    16f2:	ec 01       	movw	r28, r24
    16f4:	ec eb       	ldi	r30, 0xBC	; 188
    16f6:	f0 e0       	ldi	r31, 0x00	; 0
    16f8:	90 81       	ld	r25, Z
    16fa:	91 78       	andi	r25, 0x81	; 129
    16fc:	e9 f7       	brne	.-6      	; 0x16f8 <TWI_Start_Transceiver_With_Data+0xa>
    16fe:	60 93 d0 01 	sts	0x01D0, r22	; 0x8001d0 <TWI_msgSize>
    1702:	88 81       	ld	r24, Y
    1704:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <TWI_buf>
    1708:	80 fd       	sbrc	r24, 0
    170a:	12 c0       	rjmp	.+36     	; 0x1730 <TWI_Start_Transceiver_With_Data+0x42>
    170c:	62 30       	cpi	r22, 0x02	; 2
    170e:	80 f0       	brcs	.+32     	; 0x1730 <TWI_Start_Transceiver_With_Data+0x42>
    1710:	fe 01       	movw	r30, r28
    1712:	31 96       	adiw	r30, 0x01	; 1
    1714:	a2 ed       	ldi	r26, 0xD2	; 210
    1716:	b1 e0       	ldi	r27, 0x01	; 1
    1718:	62 50       	subi	r22, 0x02	; 2
    171a:	26 2f       	mov	r18, r22
    171c:	30 e0       	ldi	r19, 0x00	; 0
    171e:	2e 5f       	subi	r18, 0xFE	; 254
    1720:	3f 4f       	sbci	r19, 0xFF	; 255
    1722:	2c 0f       	add	r18, r28
    1724:	3d 1f       	adc	r19, r29
    1726:	91 91       	ld	r25, Z+
    1728:	9d 93       	st	X+, r25
    172a:	e2 17       	cp	r30, r18
    172c:	f3 07       	cpc	r31, r19
    172e:	d9 f7       	brne	.-10     	; 0x1726 <TWI_Start_Transceiver_With_Data+0x38>
    1730:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <TWI_statusReg>
    1734:	88 ef       	ldi	r24, 0xF8	; 248
    1736:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    173a:	85 ea       	ldi	r24, 0xA5	; 165
    173c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	08 95       	ret

00001746 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1746:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1748:	ec eb       	ldi	r30, 0xBC	; 188
    174a:	f0 e0       	ldi	r31, 0x00	; 0
    174c:	90 81       	ld	r25, Z
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    174e:	91 78       	andi	r25, 0x81	; 129
    1750:	e9 f7       	brne	.-6      	; 0x174c <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1752:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    1756:	80 ff       	sbrs	r24, 0
    1758:	11 c0       	rjmp	.+34     	; 0x177c <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    175a:	66 23       	and	r22, r22
    175c:	79 f0       	breq	.+30     	; 0x177c <TWI_Get_Data_From_Transceiver+0x36>
    175e:	a1 ed       	ldi	r26, 0xD1	; 209
    1760:	b1 e0       	ldi	r27, 0x01	; 1
    1762:	fa 01       	movw	r30, r20
    1764:	61 50       	subi	r22, 0x01	; 1
    1766:	26 2f       	mov	r18, r22
    1768:	30 e0       	ldi	r19, 0x00	; 0
    176a:	2f 5f       	subi	r18, 0xFF	; 255
    176c:	3f 4f       	sbci	r19, 0xFF	; 255
    176e:	24 0f       	add	r18, r20
    1770:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    1772:	9d 91       	ld	r25, X+
    1774:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1776:	e2 17       	cp	r30, r18
    1778:	f3 07       	cpc	r31, r19
    177a:	d9 f7       	brne	.-10     	; 0x1772 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    177c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
}
    1780:	81 70       	andi	r24, 0x01	; 1
    1782:	08 95       	ret

00001784 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    1784:	1f 92       	push	r1
    1786:	0f 92       	push	r0
    1788:	0f b6       	in	r0, 0x3f	; 63
    178a:	0f 92       	push	r0
    178c:	11 24       	eor	r1, r1
    178e:	0b b6       	in	r0, 0x3b	; 59
    1790:	0f 92       	push	r0
    1792:	2f 93       	push	r18
    1794:	3f 93       	push	r19
    1796:	8f 93       	push	r24
    1798:	9f 93       	push	r25
    179a:	af 93       	push	r26
    179c:	bf 93       	push	r27
    179e:	ef 93       	push	r30
    17a0:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    17a2:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    17a6:	8e 2f       	mov	r24, r30
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	fc 01       	movw	r30, r24
    17ac:	38 97       	sbiw	r30, 0x08	; 8
    17ae:	e1 35       	cpi	r30, 0x51	; 81
    17b0:	f1 05       	cpc	r31, r1
    17b2:	08 f0       	brcs	.+2      	; 0x17b6 <__vector_26+0x32>
    17b4:	55 c0       	rjmp	.+170    	; 0x1860 <__vector_26+0xdc>
    17b6:	ea 5b       	subi	r30, 0xBA	; 186
    17b8:	ff 4f       	sbci	r31, 0xFF	; 255
    17ba:	59 c1       	rjmp	.+690    	; 0x1a6e <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    17bc:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <TWI_bufPtr.1674>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    17c0:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    17c4:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    17c8:	e8 17       	cp	r30, r24
    17ca:	70 f4       	brcc	.+28     	; 0x17e8 <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	8e 0f       	add	r24, r30
    17d0:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1674>
    17d4:	f0 e0       	ldi	r31, 0x00	; 0
    17d6:	ef 52       	subi	r30, 0x2F	; 47
    17d8:	fe 4f       	sbci	r31, 0xFE	; 254
    17da:	80 81       	ld	r24, Z
    17dc:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    17e0:	85 e8       	ldi	r24, 0x85	; 133
    17e2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17e6:	43 c0       	rjmp	.+134    	; 0x186e <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    17e8:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    17ec:	81 60       	ori	r24, 0x01	; 1
    17ee:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    17f2:	84 e9       	ldi	r24, 0x94	; 148
    17f4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17f8:	3a c0       	rjmp	.+116    	; 0x186e <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    17fa:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	8e 0f       	add	r24, r30
    1802:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1674>
    1806:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    180a:	f0 e0       	ldi	r31, 0x00	; 0
    180c:	ef 52       	subi	r30, 0x2F	; 47
    180e:	fe 4f       	sbci	r31, 0xFE	; 254
    1810:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1812:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    1816:	30 e0       	ldi	r19, 0x00	; 0
    1818:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	28 17       	cp	r18, r24
    1822:	39 07       	cpc	r19, r25
    1824:	24 f4       	brge	.+8      	; 0x182e <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1826:	85 ec       	ldi	r24, 0xC5	; 197
    1828:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    182c:	20 c0       	rjmp	.+64     	; 0x186e <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    182e:	85 e8       	ldi	r24, 0x85	; 133
    1830:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1834:	1c c0       	rjmp	.+56     	; 0x186e <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    1836:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    183a:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1674>
    183e:	f0 e0       	ldi	r31, 0x00	; 0
    1840:	ef 52       	subi	r30, 0x2F	; 47
    1842:	fe 4f       	sbci	r31, 0xFE	; 254
    1844:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1846:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    184a:	81 60       	ori	r24, 0x01	; 1
    184c:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1850:	84 e9       	ldi	r24, 0x94	; 148
    1852:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    1856:	0b c0       	rjmp	.+22     	; 0x186e <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1858:	85 ea       	ldi	r24, 0xA5	; 165
    185a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    185e:	07 c0       	rjmp	.+14     	; 0x186e <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    1860:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1864:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1868:	84 e0       	ldi	r24, 0x04	; 4
    186a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    186e:	ff 91       	pop	r31
    1870:	ef 91       	pop	r30
    1872:	bf 91       	pop	r27
    1874:	af 91       	pop	r26
    1876:	9f 91       	pop	r25
    1878:	8f 91       	pop	r24
    187a:	3f 91       	pop	r19
    187c:	2f 91       	pop	r18
    187e:	0f 90       	pop	r0
    1880:	0b be       	out	0x3b, r0	; 59
    1882:	0f 90       	pop	r0
    1884:	0f be       	out	0x3f, r0	; 63
    1886:	0f 90       	pop	r0
    1888:	1f 90       	pop	r1
    188a:	18 95       	reti

0000188c <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    188c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    1890:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    1894:	88 e0       	ldi	r24, 0x08	; 8
    1896:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    189a:	86 e0       	ldi	r24, 0x06	; 6
    189c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    18a0:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <UART0_RxTail>
    18a4:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <UART0_RxHead>
    18a8:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <UART0_TxTail>
    18ac:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <UART0_TxHead>
    18b0:	08 95       	ret

000018b2 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    18b2:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    18b6:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    18b8:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    18bc:	29 17       	cp	r18, r25
    18be:	e1 f3       	breq	.-8      	; 0x18b8 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    18c0:	e2 2f       	mov	r30, r18
    18c2:	f0 e0       	ldi	r31, 0x00	; 0
    18c4:	ed 51       	subi	r30, 0x1D	; 29
    18c6:	fe 4f       	sbci	r31, 0xFE	; 254
    18c8:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    18ca:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    18ce:	e1 ec       	ldi	r30, 0xC1	; 193
    18d0:	f0 e0       	ldi	r31, 0x00	; 0
    18d2:	80 81       	ld	r24, Z
    18d4:	80 62       	ori	r24, 0x20	; 32
    18d6:	80 83       	st	Z, r24
    18d8:	08 95       	ret

000018da <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    18da:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    18de:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    18e0:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    18e4:	29 17       	cp	r18, r25
    18e6:	e1 f3       	breq	.-8      	; 0x18e0 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    18e8:	e2 2f       	mov	r30, r18
    18ea:	f0 e0       	ldi	r31, 0x00	; 0
    18ec:	ed 51       	subi	r30, 0x1D	; 29
    18ee:	fe 4f       	sbci	r31, 0xFE	; 254
    18f0:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    18f2:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    18f6:	e1 ec       	ldi	r30, 0xC1	; 193
    18f8:	f0 e0       	ldi	r31, 0x00	; 0
    18fa:	80 81       	ld	r24, Z
    18fc:	80 62       	ori	r24, 0x20	; 32
    18fe:	80 83       	st	Z, r24
	return(0);
}
    1900:	80 e0       	ldi	r24, 0x00	; 0
    1902:	90 e0       	ldi	r25, 0x00	; 0
    1904:	08 95       	ret

00001906 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    1906:	cf 93       	push	r28
    1908:	df 93       	push	r29
    190a:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    190c:	88 81       	ld	r24, Y
    190e:	88 23       	and	r24, r24
    1910:	29 f0       	breq	.+10     	; 0x191c <USART0_putstring+0x16>
    1912:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    1914:	ce df       	rcall	.-100    	; 0x18b2 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    1916:	89 91       	ld	r24, Y+
    1918:	81 11       	cpse	r24, r1
    191a:	fc cf       	rjmp	.-8      	; 0x1914 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    191c:	df 91       	pop	r29
    191e:	cf 91       	pop	r28
    1920:	08 95       	ret

00001922 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1922:	1f 92       	push	r1
    1924:	0f 92       	push	r0
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	0f 92       	push	r0
    192a:	11 24       	eor	r1, r1
    192c:	0b b6       	in	r0, 0x3b	; 59
    192e:	0f 92       	push	r0
    1930:	8f 93       	push	r24
    1932:	9f 93       	push	r25
    1934:	ef 93       	push	r30
    1936:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1938:	90 91 e2 01 	lds	r25, 0x01E2	; 0x8001e2 <UART0_TxHead>
    193c:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1940:	98 17       	cp	r25, r24
    1942:	61 f0       	breq	.+24     	; 0x195c <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1944:	e0 91 e1 01 	lds	r30, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1948:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    194a:	e0 93 e1 01 	sts	0x01E1, r30	; 0x8001e1 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    194e:	f0 e0       	ldi	r31, 0x00	; 0
    1950:	ed 51       	subi	r30, 0x1D	; 29
    1952:	fe 4f       	sbci	r31, 0xFE	; 254
    1954:	80 81       	ld	r24, Z
    1956:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    195a:	05 c0       	rjmp	.+10     	; 0x1966 <__vector_21+0x44>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    195c:	e1 ec       	ldi	r30, 0xC1	; 193
    195e:	f0 e0       	ldi	r31, 0x00	; 0
    1960:	80 81       	ld	r24, Z
    1962:	8f 7d       	andi	r24, 0xDF	; 223
    1964:	80 83       	st	Z, r24
	}
    1966:	ff 91       	pop	r31
    1968:	ef 91       	pop	r30
    196a:	9f 91       	pop	r25
    196c:	8f 91       	pop	r24
    196e:	0f 90       	pop	r0
    1970:	0b be       	out	0x3b, r0	; 59
    1972:	0f 90       	pop	r0
    1974:	0f be       	out	0x3f, r0	; 63
    1976:	0f 90       	pop	r0
    1978:	1f 90       	pop	r1
    197a:	18 95       	reti

0000197c <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    197c:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1980:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1984:	80 e9       	ldi	r24, 0x90	; 144
    1986:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    198a:	86 e0       	ldi	r24, 0x06	; 6
    198c:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1990:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_RxTail>
    1994:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxHead>
    1998:	10 92 e5 02 	sts	0x02E5, r1	; 0x8002e5 <UART1_TxTail>
    199c:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <UART1_TxHead>
    19a0:	08 95       	ret

000019a2 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    19a2:	1f 92       	push	r1
    19a4:	0f 92       	push	r0
    19a6:	0f b6       	in	r0, 0x3f	; 63
    19a8:	0f 92       	push	r0
    19aa:	11 24       	eor	r1, r1
    19ac:	0b b6       	in	r0, 0x3b	; 59
    19ae:	0f 92       	push	r0
    19b0:	2f 93       	push	r18
    19b2:	3f 93       	push	r19
    19b4:	8f 93       	push	r24
    19b6:	9f 93       	push	r25
    19b8:	af 93       	push	r26
    19ba:	bf 93       	push	r27
    19bc:	cf 93       	push	r28
    19be:	df 93       	push	r29
    19c0:	ef 93       	push	r30
    19c2:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    19c4:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    19c8:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <UART1_RxHead>
    19cc:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    19ce:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    19d2:	20 91 e7 02 	lds	r18, 0x02E7	; 0x8002e7 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    19d6:	e8 2f       	mov	r30, r24
    19d8:	f0 e0       	ldi	r31, 0x00	; 0
    19da:	e5 53       	subi	r30, 0x35	; 53
    19dc:	fb 4f       	sbci	r31, 0xFB	; 251
    19de:	90 83       	st	Z, r25
	
	if (data == 10)
    19e0:	9a 30       	cpi	r25, 0x0A	; 10
    19e2:	29 f5       	brne	.+74     	; 0x1a2e <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    19e4:	90 91 d0 04 	lds	r25, 0x04D0	; 0x8004d0 <UART1_RxBuf+0x5>
    19e8:	97 34       	cpi	r25, 0x47	; 71
    19ea:	e9 f4       	brne	.+58     	; 0x1a26 <__vector_28+0x84>
    19ec:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
    19ee:	2e 2f       	mov	r18, r30
    19f0:	30 e0       	ldi	r19, 0x00	; 0
    19f2:	d9 01       	movw	r26, r18
    19f4:	a5 53       	subi	r26, 0x35	; 53
    19f6:	ba 4f       	sbci	r27, 0xFA	; 250
    19f8:	e9 01       	movw	r28, r18
    19fa:	c5 53       	subi	r28, 0x35	; 53
    19fc:	db 4f       	sbci	r29, 0xFB	; 251
    19fe:	99 81       	ldd	r25, Y+1	; 0x01
    1a00:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1a02:	ef 5f       	subi	r30, 0xFF	; 255
    1a04:	8e 17       	cp	r24, r30
    1a06:	98 f7       	brcc	.-26     	; 0x19ee <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i]=0x00; //messageWant[i+1]=0x00;
    1a08:	f0 e0       	ldi	r31, 0x00	; 0
    1a0a:	e5 53       	subi	r30, 0x35	; 53
    1a0c:	fa 4f       	sbci	r31, 0xFA	; 250
    1a0e:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1a10:	e9 ec       	ldi	r30, 0xC9	; 201
    1a12:	f0 e0       	ldi	r31, 0x00	; 0
    1a14:	80 81       	ld	r24, Z
    1a16:	10 82       	st	Z, r1
 			ItsTime = 1;
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	80 93 fe 02 	sts	0x02FE, r24	; 0x8002fe <ItsTime>
 			ToggleBit(PORTB, PORTB1);
    1a1e:	95 b1       	in	r25, 0x05	; 5
    1a20:	82 e0       	ldi	r24, 0x02	; 2
    1a22:	89 27       	eor	r24, r25
    1a24:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1a26:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_RxTail>
		UART1_RxHead = 0;
    1a2a:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxHead>
	}
}
    1a2e:	ff 91       	pop	r31
    1a30:	ef 91       	pop	r30
    1a32:	df 91       	pop	r29
    1a34:	cf 91       	pop	r28
    1a36:	bf 91       	pop	r27
    1a38:	af 91       	pop	r26
    1a3a:	9f 91       	pop	r25
    1a3c:	8f 91       	pop	r24
    1a3e:	3f 91       	pop	r19
    1a40:	2f 91       	pop	r18
    1a42:	0f 90       	pop	r0
    1a44:	0b be       	out	0x3b, r0	; 59
    1a46:	0f 90       	pop	r0
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	0f 90       	pop	r0
    1a4c:	1f 90       	pop	r1
    1a4e:	18 95       	reti

00001a50 <__mulsi3>:
    1a50:	db 01       	movw	r26, r22
    1a52:	8f 93       	push	r24
    1a54:	9f 93       	push	r25
    1a56:	14 d0       	rcall	.+40     	; 0x1a80 <__muluhisi3>
    1a58:	bf 91       	pop	r27
    1a5a:	af 91       	pop	r26
    1a5c:	a2 9f       	mul	r26, r18
    1a5e:	80 0d       	add	r24, r0
    1a60:	91 1d       	adc	r25, r1
    1a62:	a3 9f       	mul	r26, r19
    1a64:	90 0d       	add	r25, r0
    1a66:	b2 9f       	mul	r27, r18
    1a68:	90 0d       	add	r25, r0
    1a6a:	11 24       	eor	r1, r1
    1a6c:	08 95       	ret

00001a6e <__tablejump2__>:
    1a6e:	ee 0f       	add	r30, r30
    1a70:	ff 1f       	adc	r31, r31
    1a72:	00 24       	eor	r0, r0
    1a74:	00 1c       	adc	r0, r0
    1a76:	0b be       	out	0x3b, r0	; 59
    1a78:	07 90       	elpm	r0, Z+
    1a7a:	f6 91       	elpm	r31, Z
    1a7c:	e0 2d       	mov	r30, r0
    1a7e:	09 94       	ijmp

00001a80 <__muluhisi3>:
    1a80:	85 d1       	rcall	.+778    	; 0x1d8c <__umulhisi3>
    1a82:	a5 9f       	mul	r26, r21
    1a84:	90 0d       	add	r25, r0
    1a86:	b4 9f       	mul	r27, r20
    1a88:	90 0d       	add	r25, r0
    1a8a:	a4 9f       	mul	r26, r20
    1a8c:	80 0d       	add	r24, r0
    1a8e:	91 1d       	adc	r25, r1
    1a90:	11 24       	eor	r1, r1
    1a92:	08 95       	ret

00001a94 <__mulshisi3>:
    1a94:	b7 ff       	sbrs	r27, 7
    1a96:	f4 cf       	rjmp	.-24     	; 0x1a80 <__muluhisi3>

00001a98 <__mulohisi3>:
    1a98:	f3 df       	rcall	.-26     	; 0x1a80 <__muluhisi3>
    1a9a:	82 1b       	sub	r24, r18
    1a9c:	93 0b       	sbc	r25, r19
    1a9e:	08 95       	ret

00001aa0 <__muldi3>:
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	1f 93       	push	r17
    1aa6:	0f 93       	push	r16
    1aa8:	9a 9d       	mul	r25, r10
    1aaa:	f0 2d       	mov	r31, r0
    1aac:	21 9f       	mul	r18, r17
    1aae:	f0 0d       	add	r31, r0
    1ab0:	8b 9d       	mul	r24, r11
    1ab2:	f0 0d       	add	r31, r0
    1ab4:	8a 9d       	mul	r24, r10
    1ab6:	e0 2d       	mov	r30, r0
    1ab8:	f1 0d       	add	r31, r1
    1aba:	03 9f       	mul	r16, r19
    1abc:	f0 0d       	add	r31, r0
    1abe:	02 9f       	mul	r16, r18
    1ac0:	e0 0d       	add	r30, r0
    1ac2:	f1 1d       	adc	r31, r1
    1ac4:	4e 9d       	mul	r20, r14
    1ac6:	e0 0d       	add	r30, r0
    1ac8:	f1 1d       	adc	r31, r1
    1aca:	5e 9d       	mul	r21, r14
    1acc:	f0 0d       	add	r31, r0
    1ace:	4f 9d       	mul	r20, r15
    1ad0:	f0 0d       	add	r31, r0
    1ad2:	7f 93       	push	r23
    1ad4:	6f 93       	push	r22
    1ad6:	bf 92       	push	r11
    1ad8:	af 92       	push	r10
    1ada:	5f 93       	push	r21
    1adc:	4f 93       	push	r20
    1ade:	d5 01       	movw	r26, r10
    1ae0:	55 d1       	rcall	.+682    	; 0x1d8c <__umulhisi3>
    1ae2:	8b 01       	movw	r16, r22
    1ae4:	ac 01       	movw	r20, r24
    1ae6:	d7 01       	movw	r26, r14
    1ae8:	51 d1       	rcall	.+674    	; 0x1d8c <__umulhisi3>
    1aea:	eb 01       	movw	r28, r22
    1aec:	e8 0f       	add	r30, r24
    1aee:	f9 1f       	adc	r31, r25
    1af0:	d6 01       	movw	r26, r12
    1af2:	1f d0       	rcall	.+62     	; 0x1b32 <__muldi3_6>
    1af4:	2f 91       	pop	r18
    1af6:	3f 91       	pop	r19
    1af8:	d6 01       	movw	r26, r12
    1afa:	48 d1       	rcall	.+656    	; 0x1d8c <__umulhisi3>
    1afc:	c6 0f       	add	r28, r22
    1afe:	d7 1f       	adc	r29, r23
    1b00:	e8 1f       	adc	r30, r24
    1b02:	f9 1f       	adc	r31, r25
    1b04:	af 91       	pop	r26
    1b06:	bf 91       	pop	r27
    1b08:	14 d0       	rcall	.+40     	; 0x1b32 <__muldi3_6>
    1b0a:	2f 91       	pop	r18
    1b0c:	3f 91       	pop	r19
    1b0e:	3e d1       	rcall	.+636    	; 0x1d8c <__umulhisi3>
    1b10:	c6 0f       	add	r28, r22
    1b12:	d7 1f       	adc	r29, r23
    1b14:	e8 1f       	adc	r30, r24
    1b16:	f9 1f       	adc	r31, r25
    1b18:	d6 01       	movw	r26, r12
    1b1a:	38 d1       	rcall	.+624    	; 0x1d8c <__umulhisi3>
    1b1c:	e6 0f       	add	r30, r22
    1b1e:	f7 1f       	adc	r31, r23
    1b20:	98 01       	movw	r18, r16
    1b22:	be 01       	movw	r22, r28
    1b24:	cf 01       	movw	r24, r30
    1b26:	11 24       	eor	r1, r1
    1b28:	0f 91       	pop	r16
    1b2a:	1f 91       	pop	r17
    1b2c:	cf 91       	pop	r28
    1b2e:	df 91       	pop	r29
    1b30:	08 95       	ret

00001b32 <__muldi3_6>:
    1b32:	2c d1       	rcall	.+600    	; 0x1d8c <__umulhisi3>
    1b34:	46 0f       	add	r20, r22
    1b36:	57 1f       	adc	r21, r23
    1b38:	c8 1f       	adc	r28, r24
    1b3a:	d9 1f       	adc	r29, r25
    1b3c:	08 f4       	brcc	.+2      	; 0x1b40 <__muldi3_6+0xe>
    1b3e:	31 96       	adiw	r30, 0x01	; 1
    1b40:	08 95       	ret

00001b42 <__moddi3>:
    1b42:	68 94       	set
    1b44:	01 c0       	rjmp	.+2      	; 0x1b48 <__divdi3_moddi3>

00001b46 <__divdi3>:
    1b46:	e8 94       	clt

00001b48 <__divdi3_moddi3>:
    1b48:	f9 2f       	mov	r31, r25
    1b4a:	f1 2b       	or	r31, r17
    1b4c:	0a f0       	brmi	.+2      	; 0x1b50 <__divdi3_moddi3+0x8>
    1b4e:	27 c0       	rjmp	.+78     	; 0x1b9e <__udivdi3_umoddi3>
    1b50:	a0 e0       	ldi	r26, 0x00	; 0
    1b52:	b0 e0       	ldi	r27, 0x00	; 0
    1b54:	ed ea       	ldi	r30, 0xAD	; 173
    1b56:	fd e0       	ldi	r31, 0x0D	; 13
    1b58:	93 c0       	rjmp	.+294    	; 0x1c80 <__prologue_saves__+0xc>
    1b5a:	09 2e       	mov	r0, r25
    1b5c:	05 94       	asr	r0
    1b5e:	1a f4       	brpl	.+6      	; 0x1b66 <__divdi3_moddi3+0x1e>
    1b60:	79 d0       	rcall	.+242    	; 0x1c54 <__negdi2>
    1b62:	11 23       	and	r17, r17
    1b64:	92 f4       	brpl	.+36     	; 0x1b8a <__divdi3_moddi3+0x42>
    1b66:	f0 e8       	ldi	r31, 0x80	; 128
    1b68:	0f 26       	eor	r0, r31
    1b6a:	ff ef       	ldi	r31, 0xFF	; 255
    1b6c:	e0 94       	com	r14
    1b6e:	f0 94       	com	r15
    1b70:	00 95       	com	r16
    1b72:	10 95       	com	r17
    1b74:	b0 94       	com	r11
    1b76:	c0 94       	com	r12
    1b78:	d0 94       	com	r13
    1b7a:	a1 94       	neg	r10
    1b7c:	bf 0a       	sbc	r11, r31
    1b7e:	cf 0a       	sbc	r12, r31
    1b80:	df 0a       	sbc	r13, r31
    1b82:	ef 0a       	sbc	r14, r31
    1b84:	ff 0a       	sbc	r15, r31
    1b86:	0f 0b       	sbc	r16, r31
    1b88:	1f 0b       	sbc	r17, r31
    1b8a:	13 d0       	rcall	.+38     	; 0x1bb2 <__udivmod64>
    1b8c:	07 fc       	sbrc	r0, 7
    1b8e:	62 d0       	rcall	.+196    	; 0x1c54 <__negdi2>
    1b90:	cd b7       	in	r28, 0x3d	; 61
    1b92:	de b7       	in	r29, 0x3e	; 62
    1b94:	ec e0       	ldi	r30, 0x0C	; 12
    1b96:	90 c0       	rjmp	.+288    	; 0x1cb8 <__epilogue_restores__+0xc>

00001b98 <__umoddi3>:
    1b98:	68 94       	set
    1b9a:	01 c0       	rjmp	.+2      	; 0x1b9e <__udivdi3_umoddi3>

00001b9c <__udivdi3>:
    1b9c:	e8 94       	clt

00001b9e <__udivdi3_umoddi3>:
    1b9e:	8f 92       	push	r8
    1ba0:	9f 92       	push	r9
    1ba2:	cf 93       	push	r28
    1ba4:	df 93       	push	r29
    1ba6:	05 d0       	rcall	.+10     	; 0x1bb2 <__udivmod64>
    1ba8:	df 91       	pop	r29
    1baa:	cf 91       	pop	r28
    1bac:	9f 90       	pop	r9
    1bae:	8f 90       	pop	r8
    1bb0:	08 95       	ret

00001bb2 <__udivmod64>:
    1bb2:	88 24       	eor	r8, r8
    1bb4:	99 24       	eor	r9, r9
    1bb6:	f4 01       	movw	r30, r8
    1bb8:	e4 01       	movw	r28, r8
    1bba:	b0 e4       	ldi	r27, 0x40	; 64
    1bbc:	9f 93       	push	r25
    1bbe:	aa 27       	eor	r26, r26
    1bc0:	9a 15       	cp	r25, r10
    1bc2:	8b 04       	cpc	r8, r11
    1bc4:	9c 04       	cpc	r9, r12
    1bc6:	ed 05       	cpc	r30, r13
    1bc8:	fe 05       	cpc	r31, r14
    1bca:	cf 05       	cpc	r28, r15
    1bcc:	d0 07       	cpc	r29, r16
    1bce:	a1 07       	cpc	r26, r17
    1bd0:	98 f4       	brcc	.+38     	; 0x1bf8 <__udivmod64+0x46>
    1bd2:	ad 2f       	mov	r26, r29
    1bd4:	dc 2f       	mov	r29, r28
    1bd6:	cf 2f       	mov	r28, r31
    1bd8:	fe 2f       	mov	r31, r30
    1bda:	e9 2d       	mov	r30, r9
    1bdc:	98 2c       	mov	r9, r8
    1bde:	89 2e       	mov	r8, r25
    1be0:	98 2f       	mov	r25, r24
    1be2:	87 2f       	mov	r24, r23
    1be4:	76 2f       	mov	r23, r22
    1be6:	65 2f       	mov	r22, r21
    1be8:	54 2f       	mov	r21, r20
    1bea:	43 2f       	mov	r20, r19
    1bec:	32 2f       	mov	r19, r18
    1bee:	22 27       	eor	r18, r18
    1bf0:	b8 50       	subi	r27, 0x08	; 8
    1bf2:	31 f7       	brne	.-52     	; 0x1bc0 <__udivmod64+0xe>
    1bf4:	bf 91       	pop	r27
    1bf6:	27 c0       	rjmp	.+78     	; 0x1c46 <__udivmod64+0x94>
    1bf8:	1b 2e       	mov	r1, r27
    1bfa:	bf 91       	pop	r27
    1bfc:	bb 27       	eor	r27, r27
    1bfe:	22 0f       	add	r18, r18
    1c00:	33 1f       	adc	r19, r19
    1c02:	44 1f       	adc	r20, r20
    1c04:	55 1f       	adc	r21, r21
    1c06:	66 1f       	adc	r22, r22
    1c08:	77 1f       	adc	r23, r23
    1c0a:	88 1f       	adc	r24, r24
    1c0c:	99 1f       	adc	r25, r25
    1c0e:	88 1c       	adc	r8, r8
    1c10:	99 1c       	adc	r9, r9
    1c12:	ee 1f       	adc	r30, r30
    1c14:	ff 1f       	adc	r31, r31
    1c16:	cc 1f       	adc	r28, r28
    1c18:	dd 1f       	adc	r29, r29
    1c1a:	aa 1f       	adc	r26, r26
    1c1c:	bb 1f       	adc	r27, r27
    1c1e:	8a 14       	cp	r8, r10
    1c20:	9b 04       	cpc	r9, r11
    1c22:	ec 05       	cpc	r30, r12
    1c24:	fd 05       	cpc	r31, r13
    1c26:	ce 05       	cpc	r28, r14
    1c28:	df 05       	cpc	r29, r15
    1c2a:	a0 07       	cpc	r26, r16
    1c2c:	b1 07       	cpc	r27, r17
    1c2e:	48 f0       	brcs	.+18     	; 0x1c42 <__udivmod64+0x90>
    1c30:	8a 18       	sub	r8, r10
    1c32:	9b 08       	sbc	r9, r11
    1c34:	ec 09       	sbc	r30, r12
    1c36:	fd 09       	sbc	r31, r13
    1c38:	ce 09       	sbc	r28, r14
    1c3a:	df 09       	sbc	r29, r15
    1c3c:	a0 0b       	sbc	r26, r16
    1c3e:	b1 0b       	sbc	r27, r17
    1c40:	21 60       	ori	r18, 0x01	; 1
    1c42:	1a 94       	dec	r1
    1c44:	e1 f6       	brne	.-72     	; 0x1bfe <__udivmod64+0x4c>
    1c46:	2e f4       	brtc	.+10     	; 0x1c52 <__udivmod64+0xa0>
    1c48:	94 01       	movw	r18, r8
    1c4a:	af 01       	movw	r20, r30
    1c4c:	be 01       	movw	r22, r28
    1c4e:	cd 01       	movw	r24, r26
    1c50:	00 0c       	add	r0, r0
    1c52:	08 95       	ret

00001c54 <__negdi2>:
    1c54:	60 95       	com	r22
    1c56:	70 95       	com	r23
    1c58:	80 95       	com	r24
    1c5a:	90 95       	com	r25
    1c5c:	30 95       	com	r19
    1c5e:	40 95       	com	r20
    1c60:	50 95       	com	r21
    1c62:	21 95       	neg	r18
    1c64:	3f 4f       	sbci	r19, 0xFF	; 255
    1c66:	4f 4f       	sbci	r20, 0xFF	; 255
    1c68:	5f 4f       	sbci	r21, 0xFF	; 255
    1c6a:	6f 4f       	sbci	r22, 0xFF	; 255
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	8f 4f       	sbci	r24, 0xFF	; 255
    1c70:	9f 4f       	sbci	r25, 0xFF	; 255
    1c72:	08 95       	ret

00001c74 <__prologue_saves__>:
    1c74:	2f 92       	push	r2
    1c76:	3f 92       	push	r3
    1c78:	4f 92       	push	r4
    1c7a:	5f 92       	push	r5
    1c7c:	6f 92       	push	r6
    1c7e:	7f 92       	push	r7
    1c80:	8f 92       	push	r8
    1c82:	9f 92       	push	r9
    1c84:	af 92       	push	r10
    1c86:	bf 92       	push	r11
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	cd b7       	in	r28, 0x3d	; 61
    1c9a:	de b7       	in	r29, 0x3e	; 62
    1c9c:	ca 1b       	sub	r28, r26
    1c9e:	db 0b       	sbc	r29, r27
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	de bf       	out	0x3e, r29	; 62
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	cd bf       	out	0x3d, r28	; 61
    1caa:	09 94       	ijmp

00001cac <__epilogue_restores__>:
    1cac:	2a 88       	ldd	r2, Y+18	; 0x12
    1cae:	39 88       	ldd	r3, Y+17	; 0x11
    1cb0:	48 88       	ldd	r4, Y+16	; 0x10
    1cb2:	5f 84       	ldd	r5, Y+15	; 0x0f
    1cb4:	6e 84       	ldd	r6, Y+14	; 0x0e
    1cb6:	7d 84       	ldd	r7, Y+13	; 0x0d
    1cb8:	8c 84       	ldd	r8, Y+12	; 0x0c
    1cba:	9b 84       	ldd	r9, Y+11	; 0x0b
    1cbc:	aa 84       	ldd	r10, Y+10	; 0x0a
    1cbe:	b9 84       	ldd	r11, Y+9	; 0x09
    1cc0:	c8 84       	ldd	r12, Y+8	; 0x08
    1cc2:	df 80       	ldd	r13, Y+7	; 0x07
    1cc4:	ee 80       	ldd	r14, Y+6	; 0x06
    1cc6:	fd 80       	ldd	r15, Y+5	; 0x05
    1cc8:	0c 81       	ldd	r16, Y+4	; 0x04
    1cca:	1b 81       	ldd	r17, Y+3	; 0x03
    1ccc:	aa 81       	ldd	r26, Y+2	; 0x02
    1cce:	b9 81       	ldd	r27, Y+1	; 0x01
    1cd0:	ce 0f       	add	r28, r30
    1cd2:	d1 1d       	adc	r29, r1
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	de bf       	out	0x3e, r29	; 62
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	cd bf       	out	0x3d, r28	; 61
    1cde:	ed 01       	movw	r28, r26
    1ce0:	08 95       	ret

00001ce2 <__ashldi3>:
    1ce2:	0f 93       	push	r16
    1ce4:	08 30       	cpi	r16, 0x08	; 8
    1ce6:	90 f0       	brcs	.+36     	; 0x1d0c <__ashldi3+0x2a>
    1ce8:	98 2f       	mov	r25, r24
    1cea:	87 2f       	mov	r24, r23
    1cec:	76 2f       	mov	r23, r22
    1cee:	65 2f       	mov	r22, r21
    1cf0:	54 2f       	mov	r21, r20
    1cf2:	43 2f       	mov	r20, r19
    1cf4:	32 2f       	mov	r19, r18
    1cf6:	22 27       	eor	r18, r18
    1cf8:	08 50       	subi	r16, 0x08	; 8
    1cfa:	f4 cf       	rjmp	.-24     	; 0x1ce4 <__ashldi3+0x2>
    1cfc:	22 0f       	add	r18, r18
    1cfe:	33 1f       	adc	r19, r19
    1d00:	44 1f       	adc	r20, r20
    1d02:	55 1f       	adc	r21, r21
    1d04:	66 1f       	adc	r22, r22
    1d06:	77 1f       	adc	r23, r23
    1d08:	88 1f       	adc	r24, r24
    1d0a:	99 1f       	adc	r25, r25
    1d0c:	0a 95       	dec	r16
    1d0e:	b2 f7       	brpl	.-20     	; 0x1cfc <__ashldi3+0x1a>
    1d10:	0f 91       	pop	r16
    1d12:	08 95       	ret

00001d14 <__ashrdi3>:
    1d14:	97 fb       	bst	r25, 7
    1d16:	10 f8       	bld	r1, 0

00001d18 <__lshrdi3>:
    1d18:	16 94       	lsr	r1
    1d1a:	00 08       	sbc	r0, r0
    1d1c:	0f 93       	push	r16
    1d1e:	08 30       	cpi	r16, 0x08	; 8
    1d20:	98 f0       	brcs	.+38     	; 0x1d48 <__lshrdi3+0x30>
    1d22:	08 50       	subi	r16, 0x08	; 8
    1d24:	23 2f       	mov	r18, r19
    1d26:	34 2f       	mov	r19, r20
    1d28:	45 2f       	mov	r20, r21
    1d2a:	56 2f       	mov	r21, r22
    1d2c:	67 2f       	mov	r22, r23
    1d2e:	78 2f       	mov	r23, r24
    1d30:	89 2f       	mov	r24, r25
    1d32:	90 2d       	mov	r25, r0
    1d34:	f4 cf       	rjmp	.-24     	; 0x1d1e <__lshrdi3+0x6>
    1d36:	05 94       	asr	r0
    1d38:	97 95       	ror	r25
    1d3a:	87 95       	ror	r24
    1d3c:	77 95       	ror	r23
    1d3e:	67 95       	ror	r22
    1d40:	57 95       	ror	r21
    1d42:	47 95       	ror	r20
    1d44:	37 95       	ror	r19
    1d46:	27 95       	ror	r18
    1d48:	0a 95       	dec	r16
    1d4a:	aa f7       	brpl	.-22     	; 0x1d36 <__lshrdi3+0x1e>
    1d4c:	0f 91       	pop	r16
    1d4e:	08 95       	ret

00001d50 <__adddi3>:
    1d50:	2a 0d       	add	r18, r10
    1d52:	3b 1d       	adc	r19, r11
    1d54:	4c 1d       	adc	r20, r12
    1d56:	5d 1d       	adc	r21, r13
    1d58:	6e 1d       	adc	r22, r14
    1d5a:	7f 1d       	adc	r23, r15
    1d5c:	80 1f       	adc	r24, r16
    1d5e:	91 1f       	adc	r25, r17
    1d60:	08 95       	ret

00001d62 <__subdi3>:
    1d62:	2a 19       	sub	r18, r10
    1d64:	3b 09       	sbc	r19, r11
    1d66:	4c 09       	sbc	r20, r12
    1d68:	5d 09       	sbc	r21, r13
    1d6a:	6e 09       	sbc	r22, r14
    1d6c:	7f 09       	sbc	r23, r15
    1d6e:	80 0b       	sbc	r24, r16
    1d70:	91 0b       	sbc	r25, r17
    1d72:	08 95       	ret

00001d74 <__cmpdi2_s8>:
    1d74:	00 24       	eor	r0, r0
    1d76:	a7 fd       	sbrc	r26, 7
    1d78:	00 94       	com	r0
    1d7a:	2a 17       	cp	r18, r26
    1d7c:	30 05       	cpc	r19, r0
    1d7e:	40 05       	cpc	r20, r0
    1d80:	50 05       	cpc	r21, r0
    1d82:	60 05       	cpc	r22, r0
    1d84:	70 05       	cpc	r23, r0
    1d86:	80 05       	cpc	r24, r0
    1d88:	90 05       	cpc	r25, r0
    1d8a:	08 95       	ret

00001d8c <__umulhisi3>:
    1d8c:	a2 9f       	mul	r26, r18
    1d8e:	b0 01       	movw	r22, r0
    1d90:	b3 9f       	mul	r27, r19
    1d92:	c0 01       	movw	r24, r0
    1d94:	a3 9f       	mul	r26, r19
    1d96:	70 0d       	add	r23, r0
    1d98:	81 1d       	adc	r24, r1
    1d9a:	11 24       	eor	r1, r1
    1d9c:	91 1d       	adc	r25, r1
    1d9e:	b2 9f       	mul	r27, r18
    1da0:	70 0d       	add	r23, r0
    1da2:	81 1d       	adc	r24, r1
    1da4:	11 24       	eor	r1, r1
    1da6:	91 1d       	adc	r25, r1
    1da8:	08 95       	ret

00001daa <printf>:
    1daa:	cf 93       	push	r28
    1dac:	df 93       	push	r29
    1dae:	cd b7       	in	r28, 0x3d	; 61
    1db0:	de b7       	in	r29, 0x3e	; 62
    1db2:	ae 01       	movw	r20, r28
    1db4:	4b 5f       	subi	r20, 0xFB	; 251
    1db6:	5f 4f       	sbci	r21, 0xFF	; 255
    1db8:	fa 01       	movw	r30, r20
    1dba:	61 91       	ld	r22, Z+
    1dbc:	71 91       	ld	r23, Z+
    1dbe:	af 01       	movw	r20, r30
    1dc0:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <__iob+0x2>
    1dc4:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <__iob+0x3>
    1dc8:	03 d0       	rcall	.+6      	; 0x1dd0 <vfprintf>
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	08 95       	ret

00001dd0 <vfprintf>:
    1dd0:	2f 92       	push	r2
    1dd2:	3f 92       	push	r3
    1dd4:	4f 92       	push	r4
    1dd6:	5f 92       	push	r5
    1dd8:	6f 92       	push	r6
    1dda:	7f 92       	push	r7
    1ddc:	8f 92       	push	r8
    1dde:	9f 92       	push	r9
    1de0:	af 92       	push	r10
    1de2:	bf 92       	push	r11
    1de4:	cf 92       	push	r12
    1de6:	df 92       	push	r13
    1de8:	ef 92       	push	r14
    1dea:	ff 92       	push	r15
    1dec:	0f 93       	push	r16
    1dee:	1f 93       	push	r17
    1df0:	cf 93       	push	r28
    1df2:	df 93       	push	r29
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
    1df8:	2b 97       	sbiw	r28, 0x0b	; 11
    1dfa:	0f b6       	in	r0, 0x3f	; 63
    1dfc:	f8 94       	cli
    1dfe:	de bf       	out	0x3e, r29	; 62
    1e00:	0f be       	out	0x3f, r0	; 63
    1e02:	cd bf       	out	0x3d, r28	; 61
    1e04:	6c 01       	movw	r12, r24
    1e06:	7b 01       	movw	r14, r22
    1e08:	8a 01       	movw	r16, r20
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	17 82       	std	Z+7, r1	; 0x07
    1e0e:	16 82       	std	Z+6, r1	; 0x06
    1e10:	83 81       	ldd	r24, Z+3	; 0x03
    1e12:	81 ff       	sbrs	r24, 1
    1e14:	bf c1       	rjmp	.+894    	; 0x2194 <vfprintf+0x3c4>
    1e16:	ce 01       	movw	r24, r28
    1e18:	01 96       	adiw	r24, 0x01	; 1
    1e1a:	3c 01       	movw	r6, r24
    1e1c:	f6 01       	movw	r30, r12
    1e1e:	93 81       	ldd	r25, Z+3	; 0x03
    1e20:	f7 01       	movw	r30, r14
    1e22:	93 fd       	sbrc	r25, 3
    1e24:	85 91       	lpm	r24, Z+
    1e26:	93 ff       	sbrs	r25, 3
    1e28:	81 91       	ld	r24, Z+
    1e2a:	7f 01       	movw	r14, r30
    1e2c:	88 23       	and	r24, r24
    1e2e:	09 f4       	brne	.+2      	; 0x1e32 <vfprintf+0x62>
    1e30:	ad c1       	rjmp	.+858    	; 0x218c <vfprintf+0x3bc>
    1e32:	85 32       	cpi	r24, 0x25	; 37
    1e34:	39 f4       	brne	.+14     	; 0x1e44 <vfprintf+0x74>
    1e36:	93 fd       	sbrc	r25, 3
    1e38:	85 91       	lpm	r24, Z+
    1e3a:	93 ff       	sbrs	r25, 3
    1e3c:	81 91       	ld	r24, Z+
    1e3e:	7f 01       	movw	r14, r30
    1e40:	85 32       	cpi	r24, 0x25	; 37
    1e42:	21 f4       	brne	.+8      	; 0x1e4c <vfprintf+0x7c>
    1e44:	b6 01       	movw	r22, r12
    1e46:	90 e0       	ldi	r25, 0x00	; 0
    1e48:	d6 d1       	rcall	.+940    	; 0x21f6 <fputc>
    1e4a:	e8 cf       	rjmp	.-48     	; 0x1e1c <vfprintf+0x4c>
    1e4c:	91 2c       	mov	r9, r1
    1e4e:	21 2c       	mov	r2, r1
    1e50:	31 2c       	mov	r3, r1
    1e52:	ff e1       	ldi	r31, 0x1F	; 31
    1e54:	f3 15       	cp	r31, r3
    1e56:	d8 f0       	brcs	.+54     	; 0x1e8e <vfprintf+0xbe>
    1e58:	8b 32       	cpi	r24, 0x2B	; 43
    1e5a:	79 f0       	breq	.+30     	; 0x1e7a <vfprintf+0xaa>
    1e5c:	38 f4       	brcc	.+14     	; 0x1e6c <vfprintf+0x9c>
    1e5e:	80 32       	cpi	r24, 0x20	; 32
    1e60:	79 f0       	breq	.+30     	; 0x1e80 <vfprintf+0xb0>
    1e62:	83 32       	cpi	r24, 0x23	; 35
    1e64:	a1 f4       	brne	.+40     	; 0x1e8e <vfprintf+0xbe>
    1e66:	23 2d       	mov	r18, r3
    1e68:	20 61       	ori	r18, 0x10	; 16
    1e6a:	1d c0       	rjmp	.+58     	; 0x1ea6 <vfprintf+0xd6>
    1e6c:	8d 32       	cpi	r24, 0x2D	; 45
    1e6e:	61 f0       	breq	.+24     	; 0x1e88 <vfprintf+0xb8>
    1e70:	80 33       	cpi	r24, 0x30	; 48
    1e72:	69 f4       	brne	.+26     	; 0x1e8e <vfprintf+0xbe>
    1e74:	23 2d       	mov	r18, r3
    1e76:	21 60       	ori	r18, 0x01	; 1
    1e78:	16 c0       	rjmp	.+44     	; 0x1ea6 <vfprintf+0xd6>
    1e7a:	83 2d       	mov	r24, r3
    1e7c:	82 60       	ori	r24, 0x02	; 2
    1e7e:	38 2e       	mov	r3, r24
    1e80:	e3 2d       	mov	r30, r3
    1e82:	e4 60       	ori	r30, 0x04	; 4
    1e84:	3e 2e       	mov	r3, r30
    1e86:	2a c0       	rjmp	.+84     	; 0x1edc <vfprintf+0x10c>
    1e88:	f3 2d       	mov	r31, r3
    1e8a:	f8 60       	ori	r31, 0x08	; 8
    1e8c:	1d c0       	rjmp	.+58     	; 0x1ec8 <vfprintf+0xf8>
    1e8e:	37 fc       	sbrc	r3, 7
    1e90:	2d c0       	rjmp	.+90     	; 0x1eec <vfprintf+0x11c>
    1e92:	20 ed       	ldi	r18, 0xD0	; 208
    1e94:	28 0f       	add	r18, r24
    1e96:	2a 30       	cpi	r18, 0x0A	; 10
    1e98:	40 f0       	brcs	.+16     	; 0x1eaa <vfprintf+0xda>
    1e9a:	8e 32       	cpi	r24, 0x2E	; 46
    1e9c:	b9 f4       	brne	.+46     	; 0x1ecc <vfprintf+0xfc>
    1e9e:	36 fc       	sbrc	r3, 6
    1ea0:	75 c1       	rjmp	.+746    	; 0x218c <vfprintf+0x3bc>
    1ea2:	23 2d       	mov	r18, r3
    1ea4:	20 64       	ori	r18, 0x40	; 64
    1ea6:	32 2e       	mov	r3, r18
    1ea8:	19 c0       	rjmp	.+50     	; 0x1edc <vfprintf+0x10c>
    1eaa:	36 fe       	sbrs	r3, 6
    1eac:	06 c0       	rjmp	.+12     	; 0x1eba <vfprintf+0xea>
    1eae:	8a e0       	ldi	r24, 0x0A	; 10
    1eb0:	98 9e       	mul	r9, r24
    1eb2:	20 0d       	add	r18, r0
    1eb4:	11 24       	eor	r1, r1
    1eb6:	92 2e       	mov	r9, r18
    1eb8:	11 c0       	rjmp	.+34     	; 0x1edc <vfprintf+0x10c>
    1eba:	ea e0       	ldi	r30, 0x0A	; 10
    1ebc:	2e 9e       	mul	r2, r30
    1ebe:	20 0d       	add	r18, r0
    1ec0:	11 24       	eor	r1, r1
    1ec2:	22 2e       	mov	r2, r18
    1ec4:	f3 2d       	mov	r31, r3
    1ec6:	f0 62       	ori	r31, 0x20	; 32
    1ec8:	3f 2e       	mov	r3, r31
    1eca:	08 c0       	rjmp	.+16     	; 0x1edc <vfprintf+0x10c>
    1ecc:	8c 36       	cpi	r24, 0x6C	; 108
    1ece:	21 f4       	brne	.+8      	; 0x1ed8 <vfprintf+0x108>
    1ed0:	83 2d       	mov	r24, r3
    1ed2:	80 68       	ori	r24, 0x80	; 128
    1ed4:	38 2e       	mov	r3, r24
    1ed6:	02 c0       	rjmp	.+4      	; 0x1edc <vfprintf+0x10c>
    1ed8:	88 36       	cpi	r24, 0x68	; 104
    1eda:	41 f4       	brne	.+16     	; 0x1eec <vfprintf+0x11c>
    1edc:	f7 01       	movw	r30, r14
    1ede:	93 fd       	sbrc	r25, 3
    1ee0:	85 91       	lpm	r24, Z+
    1ee2:	93 ff       	sbrs	r25, 3
    1ee4:	81 91       	ld	r24, Z+
    1ee6:	7f 01       	movw	r14, r30
    1ee8:	81 11       	cpse	r24, r1
    1eea:	b3 cf       	rjmp	.-154    	; 0x1e52 <vfprintf+0x82>
    1eec:	98 2f       	mov	r25, r24
    1eee:	9f 7d       	andi	r25, 0xDF	; 223
    1ef0:	95 54       	subi	r25, 0x45	; 69
    1ef2:	93 30       	cpi	r25, 0x03	; 3
    1ef4:	28 f4       	brcc	.+10     	; 0x1f00 <vfprintf+0x130>
    1ef6:	0c 5f       	subi	r16, 0xFC	; 252
    1ef8:	1f 4f       	sbci	r17, 0xFF	; 255
    1efa:	9f e3       	ldi	r25, 0x3F	; 63
    1efc:	99 83       	std	Y+1, r25	; 0x01
    1efe:	0d c0       	rjmp	.+26     	; 0x1f1a <vfprintf+0x14a>
    1f00:	83 36       	cpi	r24, 0x63	; 99
    1f02:	31 f0       	breq	.+12     	; 0x1f10 <vfprintf+0x140>
    1f04:	83 37       	cpi	r24, 0x73	; 115
    1f06:	71 f0       	breq	.+28     	; 0x1f24 <vfprintf+0x154>
    1f08:	83 35       	cpi	r24, 0x53	; 83
    1f0a:	09 f0       	breq	.+2      	; 0x1f0e <vfprintf+0x13e>
    1f0c:	55 c0       	rjmp	.+170    	; 0x1fb8 <vfprintf+0x1e8>
    1f0e:	20 c0       	rjmp	.+64     	; 0x1f50 <vfprintf+0x180>
    1f10:	f8 01       	movw	r30, r16
    1f12:	80 81       	ld	r24, Z
    1f14:	89 83       	std	Y+1, r24	; 0x01
    1f16:	0e 5f       	subi	r16, 0xFE	; 254
    1f18:	1f 4f       	sbci	r17, 0xFF	; 255
    1f1a:	88 24       	eor	r8, r8
    1f1c:	83 94       	inc	r8
    1f1e:	91 2c       	mov	r9, r1
    1f20:	53 01       	movw	r10, r6
    1f22:	12 c0       	rjmp	.+36     	; 0x1f48 <vfprintf+0x178>
    1f24:	28 01       	movw	r4, r16
    1f26:	f2 e0       	ldi	r31, 0x02	; 2
    1f28:	4f 0e       	add	r4, r31
    1f2a:	51 1c       	adc	r5, r1
    1f2c:	f8 01       	movw	r30, r16
    1f2e:	a0 80       	ld	r10, Z
    1f30:	b1 80       	ldd	r11, Z+1	; 0x01
    1f32:	36 fe       	sbrs	r3, 6
    1f34:	03 c0       	rjmp	.+6      	; 0x1f3c <vfprintf+0x16c>
    1f36:	69 2d       	mov	r22, r9
    1f38:	70 e0       	ldi	r23, 0x00	; 0
    1f3a:	02 c0       	rjmp	.+4      	; 0x1f40 <vfprintf+0x170>
    1f3c:	6f ef       	ldi	r22, 0xFF	; 255
    1f3e:	7f ef       	ldi	r23, 0xFF	; 255
    1f40:	c5 01       	movw	r24, r10
    1f42:	4e d1       	rcall	.+668    	; 0x21e0 <strnlen>
    1f44:	4c 01       	movw	r8, r24
    1f46:	82 01       	movw	r16, r4
    1f48:	f3 2d       	mov	r31, r3
    1f4a:	ff 77       	andi	r31, 0x7F	; 127
    1f4c:	3f 2e       	mov	r3, r31
    1f4e:	15 c0       	rjmp	.+42     	; 0x1f7a <vfprintf+0x1aa>
    1f50:	28 01       	movw	r4, r16
    1f52:	22 e0       	ldi	r18, 0x02	; 2
    1f54:	42 0e       	add	r4, r18
    1f56:	51 1c       	adc	r5, r1
    1f58:	f8 01       	movw	r30, r16
    1f5a:	a0 80       	ld	r10, Z
    1f5c:	b1 80       	ldd	r11, Z+1	; 0x01
    1f5e:	36 fe       	sbrs	r3, 6
    1f60:	03 c0       	rjmp	.+6      	; 0x1f68 <vfprintf+0x198>
    1f62:	69 2d       	mov	r22, r9
    1f64:	70 e0       	ldi	r23, 0x00	; 0
    1f66:	02 c0       	rjmp	.+4      	; 0x1f6c <vfprintf+0x19c>
    1f68:	6f ef       	ldi	r22, 0xFF	; 255
    1f6a:	7f ef       	ldi	r23, 0xFF	; 255
    1f6c:	c5 01       	movw	r24, r10
    1f6e:	2d d1       	rcall	.+602    	; 0x21ca <strnlen_P>
    1f70:	4c 01       	movw	r8, r24
    1f72:	f3 2d       	mov	r31, r3
    1f74:	f0 68       	ori	r31, 0x80	; 128
    1f76:	3f 2e       	mov	r3, r31
    1f78:	82 01       	movw	r16, r4
    1f7a:	33 fc       	sbrc	r3, 3
    1f7c:	19 c0       	rjmp	.+50     	; 0x1fb0 <vfprintf+0x1e0>
    1f7e:	82 2d       	mov	r24, r2
    1f80:	90 e0       	ldi	r25, 0x00	; 0
    1f82:	88 16       	cp	r8, r24
    1f84:	99 06       	cpc	r9, r25
    1f86:	a0 f4       	brcc	.+40     	; 0x1fb0 <vfprintf+0x1e0>
    1f88:	b6 01       	movw	r22, r12
    1f8a:	80 e2       	ldi	r24, 0x20	; 32
    1f8c:	90 e0       	ldi	r25, 0x00	; 0
    1f8e:	33 d1       	rcall	.+614    	; 0x21f6 <fputc>
    1f90:	2a 94       	dec	r2
    1f92:	f5 cf       	rjmp	.-22     	; 0x1f7e <vfprintf+0x1ae>
    1f94:	f5 01       	movw	r30, r10
    1f96:	37 fc       	sbrc	r3, 7
    1f98:	85 91       	lpm	r24, Z+
    1f9a:	37 fe       	sbrs	r3, 7
    1f9c:	81 91       	ld	r24, Z+
    1f9e:	5f 01       	movw	r10, r30
    1fa0:	b6 01       	movw	r22, r12
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	28 d1       	rcall	.+592    	; 0x21f6 <fputc>
    1fa6:	21 10       	cpse	r2, r1
    1fa8:	2a 94       	dec	r2
    1faa:	21 e0       	ldi	r18, 0x01	; 1
    1fac:	82 1a       	sub	r8, r18
    1fae:	91 08       	sbc	r9, r1
    1fb0:	81 14       	cp	r8, r1
    1fb2:	91 04       	cpc	r9, r1
    1fb4:	79 f7       	brne	.-34     	; 0x1f94 <vfprintf+0x1c4>
    1fb6:	e1 c0       	rjmp	.+450    	; 0x217a <vfprintf+0x3aa>
    1fb8:	84 36       	cpi	r24, 0x64	; 100
    1fba:	11 f0       	breq	.+4      	; 0x1fc0 <vfprintf+0x1f0>
    1fbc:	89 36       	cpi	r24, 0x69	; 105
    1fbe:	39 f5       	brne	.+78     	; 0x200e <vfprintf+0x23e>
    1fc0:	f8 01       	movw	r30, r16
    1fc2:	37 fe       	sbrs	r3, 7
    1fc4:	07 c0       	rjmp	.+14     	; 0x1fd4 <vfprintf+0x204>
    1fc6:	60 81       	ld	r22, Z
    1fc8:	71 81       	ldd	r23, Z+1	; 0x01
    1fca:	82 81       	ldd	r24, Z+2	; 0x02
    1fcc:	93 81       	ldd	r25, Z+3	; 0x03
    1fce:	0c 5f       	subi	r16, 0xFC	; 252
    1fd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd2:	08 c0       	rjmp	.+16     	; 0x1fe4 <vfprintf+0x214>
    1fd4:	60 81       	ld	r22, Z
    1fd6:	71 81       	ldd	r23, Z+1	; 0x01
    1fd8:	07 2e       	mov	r0, r23
    1fda:	00 0c       	add	r0, r0
    1fdc:	88 0b       	sbc	r24, r24
    1fde:	99 0b       	sbc	r25, r25
    1fe0:	0e 5f       	subi	r16, 0xFE	; 254
    1fe2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fe4:	f3 2d       	mov	r31, r3
    1fe6:	ff 76       	andi	r31, 0x6F	; 111
    1fe8:	3f 2e       	mov	r3, r31
    1fea:	97 ff       	sbrs	r25, 7
    1fec:	09 c0       	rjmp	.+18     	; 0x2000 <vfprintf+0x230>
    1fee:	90 95       	com	r25
    1ff0:	80 95       	com	r24
    1ff2:	70 95       	com	r23
    1ff4:	61 95       	neg	r22
    1ff6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff8:	8f 4f       	sbci	r24, 0xFF	; 255
    1ffa:	9f 4f       	sbci	r25, 0xFF	; 255
    1ffc:	f0 68       	ori	r31, 0x80	; 128
    1ffe:	3f 2e       	mov	r3, r31
    2000:	2a e0       	ldi	r18, 0x0A	; 10
    2002:	30 e0       	ldi	r19, 0x00	; 0
    2004:	a3 01       	movw	r20, r6
    2006:	33 d1       	rcall	.+614    	; 0x226e <__ultoa_invert>
    2008:	88 2e       	mov	r8, r24
    200a:	86 18       	sub	r8, r6
    200c:	44 c0       	rjmp	.+136    	; 0x2096 <vfprintf+0x2c6>
    200e:	85 37       	cpi	r24, 0x75	; 117
    2010:	31 f4       	brne	.+12     	; 0x201e <vfprintf+0x24e>
    2012:	23 2d       	mov	r18, r3
    2014:	2f 7e       	andi	r18, 0xEF	; 239
    2016:	b2 2e       	mov	r11, r18
    2018:	2a e0       	ldi	r18, 0x0A	; 10
    201a:	30 e0       	ldi	r19, 0x00	; 0
    201c:	25 c0       	rjmp	.+74     	; 0x2068 <vfprintf+0x298>
    201e:	93 2d       	mov	r25, r3
    2020:	99 7f       	andi	r25, 0xF9	; 249
    2022:	b9 2e       	mov	r11, r25
    2024:	8f 36       	cpi	r24, 0x6F	; 111
    2026:	c1 f0       	breq	.+48     	; 0x2058 <vfprintf+0x288>
    2028:	18 f4       	brcc	.+6      	; 0x2030 <vfprintf+0x260>
    202a:	88 35       	cpi	r24, 0x58	; 88
    202c:	79 f0       	breq	.+30     	; 0x204c <vfprintf+0x27c>
    202e:	ae c0       	rjmp	.+348    	; 0x218c <vfprintf+0x3bc>
    2030:	80 37       	cpi	r24, 0x70	; 112
    2032:	19 f0       	breq	.+6      	; 0x203a <vfprintf+0x26a>
    2034:	88 37       	cpi	r24, 0x78	; 120
    2036:	21 f0       	breq	.+8      	; 0x2040 <vfprintf+0x270>
    2038:	a9 c0       	rjmp	.+338    	; 0x218c <vfprintf+0x3bc>
    203a:	e9 2f       	mov	r30, r25
    203c:	e0 61       	ori	r30, 0x10	; 16
    203e:	be 2e       	mov	r11, r30
    2040:	b4 fe       	sbrs	r11, 4
    2042:	0d c0       	rjmp	.+26     	; 0x205e <vfprintf+0x28e>
    2044:	fb 2d       	mov	r31, r11
    2046:	f4 60       	ori	r31, 0x04	; 4
    2048:	bf 2e       	mov	r11, r31
    204a:	09 c0       	rjmp	.+18     	; 0x205e <vfprintf+0x28e>
    204c:	34 fe       	sbrs	r3, 4
    204e:	0a c0       	rjmp	.+20     	; 0x2064 <vfprintf+0x294>
    2050:	29 2f       	mov	r18, r25
    2052:	26 60       	ori	r18, 0x06	; 6
    2054:	b2 2e       	mov	r11, r18
    2056:	06 c0       	rjmp	.+12     	; 0x2064 <vfprintf+0x294>
    2058:	28 e0       	ldi	r18, 0x08	; 8
    205a:	30 e0       	ldi	r19, 0x00	; 0
    205c:	05 c0       	rjmp	.+10     	; 0x2068 <vfprintf+0x298>
    205e:	20 e1       	ldi	r18, 0x10	; 16
    2060:	30 e0       	ldi	r19, 0x00	; 0
    2062:	02 c0       	rjmp	.+4      	; 0x2068 <vfprintf+0x298>
    2064:	20 e1       	ldi	r18, 0x10	; 16
    2066:	32 e0       	ldi	r19, 0x02	; 2
    2068:	f8 01       	movw	r30, r16
    206a:	b7 fe       	sbrs	r11, 7
    206c:	07 c0       	rjmp	.+14     	; 0x207c <vfprintf+0x2ac>
    206e:	60 81       	ld	r22, Z
    2070:	71 81       	ldd	r23, Z+1	; 0x01
    2072:	82 81       	ldd	r24, Z+2	; 0x02
    2074:	93 81       	ldd	r25, Z+3	; 0x03
    2076:	0c 5f       	subi	r16, 0xFC	; 252
    2078:	1f 4f       	sbci	r17, 0xFF	; 255
    207a:	06 c0       	rjmp	.+12     	; 0x2088 <vfprintf+0x2b8>
    207c:	60 81       	ld	r22, Z
    207e:	71 81       	ldd	r23, Z+1	; 0x01
    2080:	80 e0       	ldi	r24, 0x00	; 0
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	0e 5f       	subi	r16, 0xFE	; 254
    2086:	1f 4f       	sbci	r17, 0xFF	; 255
    2088:	a3 01       	movw	r20, r6
    208a:	f1 d0       	rcall	.+482    	; 0x226e <__ultoa_invert>
    208c:	88 2e       	mov	r8, r24
    208e:	86 18       	sub	r8, r6
    2090:	fb 2d       	mov	r31, r11
    2092:	ff 77       	andi	r31, 0x7F	; 127
    2094:	3f 2e       	mov	r3, r31
    2096:	36 fe       	sbrs	r3, 6
    2098:	0d c0       	rjmp	.+26     	; 0x20b4 <vfprintf+0x2e4>
    209a:	23 2d       	mov	r18, r3
    209c:	2e 7f       	andi	r18, 0xFE	; 254
    209e:	a2 2e       	mov	r10, r18
    20a0:	89 14       	cp	r8, r9
    20a2:	58 f4       	brcc	.+22     	; 0x20ba <vfprintf+0x2ea>
    20a4:	34 fe       	sbrs	r3, 4
    20a6:	0b c0       	rjmp	.+22     	; 0x20be <vfprintf+0x2ee>
    20a8:	32 fc       	sbrc	r3, 2
    20aa:	09 c0       	rjmp	.+18     	; 0x20be <vfprintf+0x2ee>
    20ac:	83 2d       	mov	r24, r3
    20ae:	8e 7e       	andi	r24, 0xEE	; 238
    20b0:	a8 2e       	mov	r10, r24
    20b2:	05 c0       	rjmp	.+10     	; 0x20be <vfprintf+0x2ee>
    20b4:	b8 2c       	mov	r11, r8
    20b6:	a3 2c       	mov	r10, r3
    20b8:	03 c0       	rjmp	.+6      	; 0x20c0 <vfprintf+0x2f0>
    20ba:	b8 2c       	mov	r11, r8
    20bc:	01 c0       	rjmp	.+2      	; 0x20c0 <vfprintf+0x2f0>
    20be:	b9 2c       	mov	r11, r9
    20c0:	a4 fe       	sbrs	r10, 4
    20c2:	0f c0       	rjmp	.+30     	; 0x20e2 <vfprintf+0x312>
    20c4:	fe 01       	movw	r30, r28
    20c6:	e8 0d       	add	r30, r8
    20c8:	f1 1d       	adc	r31, r1
    20ca:	80 81       	ld	r24, Z
    20cc:	80 33       	cpi	r24, 0x30	; 48
    20ce:	21 f4       	brne	.+8      	; 0x20d8 <vfprintf+0x308>
    20d0:	9a 2d       	mov	r25, r10
    20d2:	99 7e       	andi	r25, 0xE9	; 233
    20d4:	a9 2e       	mov	r10, r25
    20d6:	09 c0       	rjmp	.+18     	; 0x20ea <vfprintf+0x31a>
    20d8:	a2 fe       	sbrs	r10, 2
    20da:	06 c0       	rjmp	.+12     	; 0x20e8 <vfprintf+0x318>
    20dc:	b3 94       	inc	r11
    20de:	b3 94       	inc	r11
    20e0:	04 c0       	rjmp	.+8      	; 0x20ea <vfprintf+0x31a>
    20e2:	8a 2d       	mov	r24, r10
    20e4:	86 78       	andi	r24, 0x86	; 134
    20e6:	09 f0       	breq	.+2      	; 0x20ea <vfprintf+0x31a>
    20e8:	b3 94       	inc	r11
    20ea:	a3 fc       	sbrc	r10, 3
    20ec:	10 c0       	rjmp	.+32     	; 0x210e <vfprintf+0x33e>
    20ee:	a0 fe       	sbrs	r10, 0
    20f0:	06 c0       	rjmp	.+12     	; 0x20fe <vfprintf+0x32e>
    20f2:	b2 14       	cp	r11, r2
    20f4:	80 f4       	brcc	.+32     	; 0x2116 <vfprintf+0x346>
    20f6:	28 0c       	add	r2, r8
    20f8:	92 2c       	mov	r9, r2
    20fa:	9b 18       	sub	r9, r11
    20fc:	0d c0       	rjmp	.+26     	; 0x2118 <vfprintf+0x348>
    20fe:	b2 14       	cp	r11, r2
    2100:	58 f4       	brcc	.+22     	; 0x2118 <vfprintf+0x348>
    2102:	b6 01       	movw	r22, r12
    2104:	80 e2       	ldi	r24, 0x20	; 32
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	76 d0       	rcall	.+236    	; 0x21f6 <fputc>
    210a:	b3 94       	inc	r11
    210c:	f8 cf       	rjmp	.-16     	; 0x20fe <vfprintf+0x32e>
    210e:	b2 14       	cp	r11, r2
    2110:	18 f4       	brcc	.+6      	; 0x2118 <vfprintf+0x348>
    2112:	2b 18       	sub	r2, r11
    2114:	02 c0       	rjmp	.+4      	; 0x211a <vfprintf+0x34a>
    2116:	98 2c       	mov	r9, r8
    2118:	21 2c       	mov	r2, r1
    211a:	a4 fe       	sbrs	r10, 4
    211c:	0f c0       	rjmp	.+30     	; 0x213c <vfprintf+0x36c>
    211e:	b6 01       	movw	r22, r12
    2120:	80 e3       	ldi	r24, 0x30	; 48
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	68 d0       	rcall	.+208    	; 0x21f6 <fputc>
    2126:	a2 fe       	sbrs	r10, 2
    2128:	16 c0       	rjmp	.+44     	; 0x2156 <vfprintf+0x386>
    212a:	a1 fc       	sbrc	r10, 1
    212c:	03 c0       	rjmp	.+6      	; 0x2134 <vfprintf+0x364>
    212e:	88 e7       	ldi	r24, 0x78	; 120
    2130:	90 e0       	ldi	r25, 0x00	; 0
    2132:	02 c0       	rjmp	.+4      	; 0x2138 <vfprintf+0x368>
    2134:	88 e5       	ldi	r24, 0x58	; 88
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	b6 01       	movw	r22, r12
    213a:	0c c0       	rjmp	.+24     	; 0x2154 <vfprintf+0x384>
    213c:	8a 2d       	mov	r24, r10
    213e:	86 78       	andi	r24, 0x86	; 134
    2140:	51 f0       	breq	.+20     	; 0x2156 <vfprintf+0x386>
    2142:	a1 fe       	sbrs	r10, 1
    2144:	02 c0       	rjmp	.+4      	; 0x214a <vfprintf+0x37a>
    2146:	8b e2       	ldi	r24, 0x2B	; 43
    2148:	01 c0       	rjmp	.+2      	; 0x214c <vfprintf+0x37c>
    214a:	80 e2       	ldi	r24, 0x20	; 32
    214c:	a7 fc       	sbrc	r10, 7
    214e:	8d e2       	ldi	r24, 0x2D	; 45
    2150:	b6 01       	movw	r22, r12
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	50 d0       	rcall	.+160    	; 0x21f6 <fputc>
    2156:	89 14       	cp	r8, r9
    2158:	30 f4       	brcc	.+12     	; 0x2166 <vfprintf+0x396>
    215a:	b6 01       	movw	r22, r12
    215c:	80 e3       	ldi	r24, 0x30	; 48
    215e:	90 e0       	ldi	r25, 0x00	; 0
    2160:	4a d0       	rcall	.+148    	; 0x21f6 <fputc>
    2162:	9a 94       	dec	r9
    2164:	f8 cf       	rjmp	.-16     	; 0x2156 <vfprintf+0x386>
    2166:	8a 94       	dec	r8
    2168:	f3 01       	movw	r30, r6
    216a:	e8 0d       	add	r30, r8
    216c:	f1 1d       	adc	r31, r1
    216e:	80 81       	ld	r24, Z
    2170:	b6 01       	movw	r22, r12
    2172:	90 e0       	ldi	r25, 0x00	; 0
    2174:	40 d0       	rcall	.+128    	; 0x21f6 <fputc>
    2176:	81 10       	cpse	r8, r1
    2178:	f6 cf       	rjmp	.-20     	; 0x2166 <vfprintf+0x396>
    217a:	22 20       	and	r2, r2
    217c:	09 f4       	brne	.+2      	; 0x2180 <vfprintf+0x3b0>
    217e:	4e ce       	rjmp	.-868    	; 0x1e1c <vfprintf+0x4c>
    2180:	b6 01       	movw	r22, r12
    2182:	80 e2       	ldi	r24, 0x20	; 32
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	37 d0       	rcall	.+110    	; 0x21f6 <fputc>
    2188:	2a 94       	dec	r2
    218a:	f7 cf       	rjmp	.-18     	; 0x217a <vfprintf+0x3aa>
    218c:	f6 01       	movw	r30, r12
    218e:	86 81       	ldd	r24, Z+6	; 0x06
    2190:	97 81       	ldd	r25, Z+7	; 0x07
    2192:	02 c0       	rjmp	.+4      	; 0x2198 <vfprintf+0x3c8>
    2194:	8f ef       	ldi	r24, 0xFF	; 255
    2196:	9f ef       	ldi	r25, 0xFF	; 255
    2198:	2b 96       	adiw	r28, 0x0b	; 11
    219a:	0f b6       	in	r0, 0x3f	; 63
    219c:	f8 94       	cli
    219e:	de bf       	out	0x3e, r29	; 62
    21a0:	0f be       	out	0x3f, r0	; 63
    21a2:	cd bf       	out	0x3d, r28	; 61
    21a4:	df 91       	pop	r29
    21a6:	cf 91       	pop	r28
    21a8:	1f 91       	pop	r17
    21aa:	0f 91       	pop	r16
    21ac:	ff 90       	pop	r15
    21ae:	ef 90       	pop	r14
    21b0:	df 90       	pop	r13
    21b2:	cf 90       	pop	r12
    21b4:	bf 90       	pop	r11
    21b6:	af 90       	pop	r10
    21b8:	9f 90       	pop	r9
    21ba:	8f 90       	pop	r8
    21bc:	7f 90       	pop	r7
    21be:	6f 90       	pop	r6
    21c0:	5f 90       	pop	r5
    21c2:	4f 90       	pop	r4
    21c4:	3f 90       	pop	r3
    21c6:	2f 90       	pop	r2
    21c8:	08 95       	ret

000021ca <strnlen_P>:
    21ca:	fc 01       	movw	r30, r24
    21cc:	05 90       	lpm	r0, Z+
    21ce:	61 50       	subi	r22, 0x01	; 1
    21d0:	70 40       	sbci	r23, 0x00	; 0
    21d2:	01 10       	cpse	r0, r1
    21d4:	d8 f7       	brcc	.-10     	; 0x21cc <strnlen_P+0x2>
    21d6:	80 95       	com	r24
    21d8:	90 95       	com	r25
    21da:	8e 0f       	add	r24, r30
    21dc:	9f 1f       	adc	r25, r31
    21de:	08 95       	ret

000021e0 <strnlen>:
    21e0:	fc 01       	movw	r30, r24
    21e2:	61 50       	subi	r22, 0x01	; 1
    21e4:	70 40       	sbci	r23, 0x00	; 0
    21e6:	01 90       	ld	r0, Z+
    21e8:	01 10       	cpse	r0, r1
    21ea:	d8 f7       	brcc	.-10     	; 0x21e2 <strnlen+0x2>
    21ec:	80 95       	com	r24
    21ee:	90 95       	com	r25
    21f0:	8e 0f       	add	r24, r30
    21f2:	9f 1f       	adc	r25, r31
    21f4:	08 95       	ret

000021f6 <fputc>:
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	fb 01       	movw	r30, r22
    2200:	23 81       	ldd	r18, Z+3	; 0x03
    2202:	21 fd       	sbrc	r18, 1
    2204:	03 c0       	rjmp	.+6      	; 0x220c <fputc+0x16>
    2206:	8f ef       	ldi	r24, 0xFF	; 255
    2208:	9f ef       	ldi	r25, 0xFF	; 255
    220a:	2c c0       	rjmp	.+88     	; 0x2264 <fputc+0x6e>
    220c:	22 ff       	sbrs	r18, 2
    220e:	16 c0       	rjmp	.+44     	; 0x223c <fputc+0x46>
    2210:	46 81       	ldd	r20, Z+6	; 0x06
    2212:	57 81       	ldd	r21, Z+7	; 0x07
    2214:	24 81       	ldd	r18, Z+4	; 0x04
    2216:	35 81       	ldd	r19, Z+5	; 0x05
    2218:	42 17       	cp	r20, r18
    221a:	53 07       	cpc	r21, r19
    221c:	44 f4       	brge	.+16     	; 0x222e <fputc+0x38>
    221e:	a0 81       	ld	r26, Z
    2220:	b1 81       	ldd	r27, Z+1	; 0x01
    2222:	9d 01       	movw	r18, r26
    2224:	2f 5f       	subi	r18, 0xFF	; 255
    2226:	3f 4f       	sbci	r19, 0xFF	; 255
    2228:	31 83       	std	Z+1, r19	; 0x01
    222a:	20 83       	st	Z, r18
    222c:	8c 93       	st	X, r24
    222e:	26 81       	ldd	r18, Z+6	; 0x06
    2230:	37 81       	ldd	r19, Z+7	; 0x07
    2232:	2f 5f       	subi	r18, 0xFF	; 255
    2234:	3f 4f       	sbci	r19, 0xFF	; 255
    2236:	37 83       	std	Z+7, r19	; 0x07
    2238:	26 83       	std	Z+6, r18	; 0x06
    223a:	14 c0       	rjmp	.+40     	; 0x2264 <fputc+0x6e>
    223c:	8b 01       	movw	r16, r22
    223e:	ec 01       	movw	r28, r24
    2240:	fb 01       	movw	r30, r22
    2242:	00 84       	ldd	r0, Z+8	; 0x08
    2244:	f1 85       	ldd	r31, Z+9	; 0x09
    2246:	e0 2d       	mov	r30, r0
    2248:	09 95       	icall
    224a:	89 2b       	or	r24, r25
    224c:	e1 f6       	brne	.-72     	; 0x2206 <fputc+0x10>
    224e:	d8 01       	movw	r26, r16
    2250:	16 96       	adiw	r26, 0x06	; 6
    2252:	8d 91       	ld	r24, X+
    2254:	9c 91       	ld	r25, X
    2256:	17 97       	sbiw	r26, 0x07	; 7
    2258:	01 96       	adiw	r24, 0x01	; 1
    225a:	17 96       	adiw	r26, 0x07	; 7
    225c:	9c 93       	st	X, r25
    225e:	8e 93       	st	-X, r24
    2260:	16 97       	sbiw	r26, 0x06	; 6
    2262:	ce 01       	movw	r24, r28
    2264:	df 91       	pop	r29
    2266:	cf 91       	pop	r28
    2268:	1f 91       	pop	r17
    226a:	0f 91       	pop	r16
    226c:	08 95       	ret

0000226e <__ultoa_invert>:
    226e:	fa 01       	movw	r30, r20
    2270:	aa 27       	eor	r26, r26
    2272:	28 30       	cpi	r18, 0x08	; 8
    2274:	51 f1       	breq	.+84     	; 0x22ca <__ultoa_invert+0x5c>
    2276:	20 31       	cpi	r18, 0x10	; 16
    2278:	81 f1       	breq	.+96     	; 0x22da <__ultoa_invert+0x6c>
    227a:	e8 94       	clt
    227c:	6f 93       	push	r22
    227e:	6e 7f       	andi	r22, 0xFE	; 254
    2280:	6e 5f       	subi	r22, 0xFE	; 254
    2282:	7f 4f       	sbci	r23, 0xFF	; 255
    2284:	8f 4f       	sbci	r24, 0xFF	; 255
    2286:	9f 4f       	sbci	r25, 0xFF	; 255
    2288:	af 4f       	sbci	r26, 0xFF	; 255
    228a:	b1 e0       	ldi	r27, 0x01	; 1
    228c:	3e d0       	rcall	.+124    	; 0x230a <__ultoa_invert+0x9c>
    228e:	b4 e0       	ldi	r27, 0x04	; 4
    2290:	3c d0       	rcall	.+120    	; 0x230a <__ultoa_invert+0x9c>
    2292:	67 0f       	add	r22, r23
    2294:	78 1f       	adc	r23, r24
    2296:	89 1f       	adc	r24, r25
    2298:	9a 1f       	adc	r25, r26
    229a:	a1 1d       	adc	r26, r1
    229c:	68 0f       	add	r22, r24
    229e:	79 1f       	adc	r23, r25
    22a0:	8a 1f       	adc	r24, r26
    22a2:	91 1d       	adc	r25, r1
    22a4:	a1 1d       	adc	r26, r1
    22a6:	6a 0f       	add	r22, r26
    22a8:	71 1d       	adc	r23, r1
    22aa:	81 1d       	adc	r24, r1
    22ac:	91 1d       	adc	r25, r1
    22ae:	a1 1d       	adc	r26, r1
    22b0:	20 d0       	rcall	.+64     	; 0x22f2 <__ultoa_invert+0x84>
    22b2:	09 f4       	brne	.+2      	; 0x22b6 <__ultoa_invert+0x48>
    22b4:	68 94       	set
    22b6:	3f 91       	pop	r19
    22b8:	2a e0       	ldi	r18, 0x0A	; 10
    22ba:	26 9f       	mul	r18, r22
    22bc:	11 24       	eor	r1, r1
    22be:	30 19       	sub	r19, r0
    22c0:	30 5d       	subi	r19, 0xD0	; 208
    22c2:	31 93       	st	Z+, r19
    22c4:	de f6       	brtc	.-74     	; 0x227c <__ultoa_invert+0xe>
    22c6:	cf 01       	movw	r24, r30
    22c8:	08 95       	ret
    22ca:	46 2f       	mov	r20, r22
    22cc:	47 70       	andi	r20, 0x07	; 7
    22ce:	40 5d       	subi	r20, 0xD0	; 208
    22d0:	41 93       	st	Z+, r20
    22d2:	b3 e0       	ldi	r27, 0x03	; 3
    22d4:	0f d0       	rcall	.+30     	; 0x22f4 <__ultoa_invert+0x86>
    22d6:	c9 f7       	brne	.-14     	; 0x22ca <__ultoa_invert+0x5c>
    22d8:	f6 cf       	rjmp	.-20     	; 0x22c6 <__ultoa_invert+0x58>
    22da:	46 2f       	mov	r20, r22
    22dc:	4f 70       	andi	r20, 0x0F	; 15
    22de:	40 5d       	subi	r20, 0xD0	; 208
    22e0:	4a 33       	cpi	r20, 0x3A	; 58
    22e2:	18 f0       	brcs	.+6      	; 0x22ea <__ultoa_invert+0x7c>
    22e4:	49 5d       	subi	r20, 0xD9	; 217
    22e6:	31 fd       	sbrc	r19, 1
    22e8:	40 52       	subi	r20, 0x20	; 32
    22ea:	41 93       	st	Z+, r20
    22ec:	02 d0       	rcall	.+4      	; 0x22f2 <__ultoa_invert+0x84>
    22ee:	a9 f7       	brne	.-22     	; 0x22da <__ultoa_invert+0x6c>
    22f0:	ea cf       	rjmp	.-44     	; 0x22c6 <__ultoa_invert+0x58>
    22f2:	b4 e0       	ldi	r27, 0x04	; 4
    22f4:	a6 95       	lsr	r26
    22f6:	97 95       	ror	r25
    22f8:	87 95       	ror	r24
    22fa:	77 95       	ror	r23
    22fc:	67 95       	ror	r22
    22fe:	ba 95       	dec	r27
    2300:	c9 f7       	brne	.-14     	; 0x22f4 <__ultoa_invert+0x86>
    2302:	00 97       	sbiw	r24, 0x00	; 0
    2304:	61 05       	cpc	r22, r1
    2306:	71 05       	cpc	r23, r1
    2308:	08 95       	ret
    230a:	9b 01       	movw	r18, r22
    230c:	ac 01       	movw	r20, r24
    230e:	0a 2e       	mov	r0, r26
    2310:	06 94       	lsr	r0
    2312:	57 95       	ror	r21
    2314:	47 95       	ror	r20
    2316:	37 95       	ror	r19
    2318:	27 95       	ror	r18
    231a:	ba 95       	dec	r27
    231c:	c9 f7       	brne	.-14     	; 0x2310 <__ultoa_invert+0xa2>
    231e:	62 0f       	add	r22, r18
    2320:	73 1f       	adc	r23, r19
    2322:	84 1f       	adc	r24, r20
    2324:	95 1f       	adc	r25, r21
    2326:	a0 1d       	adc	r26, r0
    2328:	08 95       	ret

0000232a <eeprom_read_word>:
    232a:	a8 e1       	ldi	r26, 0x18	; 24
    232c:	b0 e0       	ldi	r27, 0x00	; 0
    232e:	42 e0       	ldi	r20, 0x02	; 2
    2330:	50 e0       	ldi	r21, 0x00	; 0
    2332:	02 c0       	rjmp	.+4      	; 0x2338 <eeprom_read_blraw>

00002334 <eeprom_read_block>:
    2334:	dc 01       	movw	r26, r24
    2336:	cb 01       	movw	r24, r22

00002338 <eeprom_read_blraw>:
    2338:	fc 01       	movw	r30, r24
    233a:	f9 99       	sbic	0x1f, 1	; 31
    233c:	fe cf       	rjmp	.-4      	; 0x233a <eeprom_read_blraw+0x2>
    233e:	06 c0       	rjmp	.+12     	; 0x234c <eeprom_read_blraw+0x14>
    2340:	f2 bd       	out	0x22, r31	; 34
    2342:	e1 bd       	out	0x21, r30	; 33
    2344:	f8 9a       	sbi	0x1f, 0	; 31
    2346:	31 96       	adiw	r30, 0x01	; 1
    2348:	00 b4       	in	r0, 0x20	; 32
    234a:	0d 92       	st	X+, r0
    234c:	41 50       	subi	r20, 0x01	; 1
    234e:	50 40       	sbci	r21, 0x00	; 0
    2350:	b8 f7       	brcc	.-18     	; 0x2340 <eeprom_read_blraw+0x8>
    2352:	08 95       	ret

00002354 <_exit>:
    2354:	f8 94       	cli

00002356 <__stop_program>:
    2356:	ff cf       	rjmp	.-2      	; 0x2356 <__stop_program>
