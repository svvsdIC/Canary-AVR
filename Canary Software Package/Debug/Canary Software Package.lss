
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000188  00800100  000023e6  0000247a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005ec  00800288  00800288  00002602  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00002602  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002660  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000300  00000000  00000000  000026a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004f0f  00000000  00000000  000029a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000187d  00000000  00000000  000078af  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002401  00000000  00000000  0000912c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a14  00000000  00000000  0000b530  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001090  00000000  00000000  0000bf44  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003ae2  00000000  00000000  0000cfd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000238  00000000  00000000  00010ab6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	8e c0       	rjmp	.+284    	; 0x11e <__ctors_end>
       2:	00 00       	nop
       4:	a9 c0       	rjmp	.+338    	; 0x158 <__bad_interrupt>
       6:	00 00       	nop
       8:	a7 c0       	rjmp	.+334    	; 0x158 <__bad_interrupt>
       a:	00 00       	nop
       c:	a5 c0       	rjmp	.+330    	; 0x158 <__bad_interrupt>
       e:	00 00       	nop
      10:	a3 c0       	rjmp	.+326    	; 0x158 <__bad_interrupt>
      12:	00 00       	nop
      14:	a1 c0       	rjmp	.+322    	; 0x158 <__bad_interrupt>
      16:	00 00       	nop
      18:	9f c0       	rjmp	.+318    	; 0x158 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	9d c0       	rjmp	.+314    	; 0x158 <__bad_interrupt>
      1e:	00 00       	nop
      20:	9b c0       	rjmp	.+310    	; 0x158 <__bad_interrupt>
      22:	00 00       	nop
      24:	99 c0       	rjmp	.+306    	; 0x158 <__bad_interrupt>
      26:	00 00       	nop
      28:	97 c0       	rjmp	.+302    	; 0x158 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	95 c0       	rjmp	.+298    	; 0x158 <__bad_interrupt>
      2e:	00 00       	nop
      30:	93 c0       	rjmp	.+294    	; 0x158 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 c5 0b 	jmp	0x178a	; 0x178a <__vector_13>
      38:	8f c0       	rjmp	.+286    	; 0x158 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	8d c0       	rjmp	.+282    	; 0x158 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__vector_16>
      44:	89 c0       	rjmp	.+274    	; 0x158 <__bad_interrupt>
      46:	00 00       	nop
      48:	87 c0       	rjmp	.+270    	; 0x158 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	85 c0       	rjmp	.+266    	; 0x158 <__bad_interrupt>
      4e:	00 00       	nop
      50:	83 c0       	rjmp	.+262    	; 0x158 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 fe 0c 	jmp	0x19fc	; 0x19fc <__vector_21>
      58:	7f c0       	rjmp	.+254    	; 0x158 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	7d c0       	rjmp	.+250    	; 0x158 <__bad_interrupt>
      5e:	00 00       	nop
      60:	7b c0       	rjmp	.+246    	; 0x158 <__bad_interrupt>
      62:	00 00       	nop
      64:	79 c0       	rjmp	.+242    	; 0x158 <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 33 0c 	jmp	0x1866	; 0x1866 <__vector_26>
      6c:	75 c0       	rjmp	.+234    	; 0x158 <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 3a 0d 	jmp	0x1a74	; 0x1a74 <__vector_28>
      74:	0c 94 82 0d 	jmp	0x1b04	; 0x1b04 <__vector_29>
      78:	6f c0       	rjmp	.+222    	; 0x158 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	4d 0c       	add	r4, r13
      7e:	9f 0c       	add	r9, r15
      80:	9f 0c       	add	r9, r15
      82:	9f 0c       	add	r9, r15
      84:	9f 0c       	add	r9, r15
      86:	9f 0c       	add	r9, r15
      88:	9f 0c       	add	r9, r15
      8a:	9f 0c       	add	r9, r15
      8c:	4d 0c       	add	r4, r13
      8e:	9f 0c       	add	r9, r15
      90:	9f 0c       	add	r9, r15
      92:	9f 0c       	add	r9, r15
      94:	9f 0c       	add	r9, r15
      96:	9f 0c       	add	r9, r15
      98:	9f 0c       	add	r9, r15
      9a:	9f 0c       	add	r9, r15
      9c:	4f 0c       	add	r4, r15
      9e:	9f 0c       	add	r9, r15
      a0:	9f 0c       	add	r9, r15
      a2:	9f 0c       	add	r9, r15
      a4:	9f 0c       	add	r9, r15
      a6:	9f 0c       	add	r9, r15
      a8:	9f 0c       	add	r9, r15
      aa:	9f 0c       	add	r9, r15
      ac:	9f 0c       	add	r9, r15
      ae:	9f 0c       	add	r9, r15
      b0:	9f 0c       	add	r9, r15
      b2:	9f 0c       	add	r9, r15
      b4:	9f 0c       	add	r9, r15
      b6:	9f 0c       	add	r9, r15
      b8:	9f 0c       	add	r9, r15
      ba:	9f 0c       	add	r9, r15
      bc:	4f 0c       	add	r4, r15
      be:	9f 0c       	add	r9, r15
      c0:	9f 0c       	add	r9, r15
      c2:	9f 0c       	add	r9, r15
      c4:	9f 0c       	add	r9, r15
      c6:	9f 0c       	add	r9, r15
      c8:	9f 0c       	add	r9, r15
      ca:	9f 0c       	add	r9, r15
      cc:	9f 0c       	add	r9, r15
      ce:	9f 0c       	add	r9, r15
      d0:	9f 0c       	add	r9, r15
      d2:	9f 0c       	add	r9, r15
      d4:	9f 0c       	add	r9, r15
      d6:	9f 0c       	add	r9, r15
      d8:	9f 0c       	add	r9, r15
      da:	9f 0c       	add	r9, r15
      dc:	9b 0c       	add	r9, r11
      de:	9f 0c       	add	r9, r15
      e0:	9f 0c       	add	r9, r15
      e2:	9f 0c       	add	r9, r15
      e4:	9f 0c       	add	r9, r15
      e6:	9f 0c       	add	r9, r15
      e8:	9f 0c       	add	r9, r15
      ea:	9f 0c       	add	r9, r15
      ec:	78 0c       	add	r7, r8
      ee:	9f 0c       	add	r9, r15
      f0:	9f 0c       	add	r9, r15
      f2:	9f 0c       	add	r9, r15
      f4:	9f 0c       	add	r9, r15
      f6:	9f 0c       	add	r9, r15
      f8:	9f 0c       	add	r9, r15
      fa:	9f 0c       	add	r9, r15
      fc:	9f 0c       	add	r9, r15
      fe:	9f 0c       	add	r9, r15
     100:	9f 0c       	add	r9, r15
     102:	9f 0c       	add	r9, r15
     104:	9f 0c       	add	r9, r15
     106:	9f 0c       	add	r9, r15
     108:	9f 0c       	add	r9, r15
     10a:	9f 0c       	add	r9, r15
     10c:	6c 0c       	add	r6, r12
     10e:	9f 0c       	add	r9, r15
     110:	9f 0c       	add	r9, r15
     112:	9f 0c       	add	r9, r15
     114:	9f 0c       	add	r9, r15
     116:	9f 0c       	add	r9, r15
     118:	9f 0c       	add	r9, r15
     11a:	9f 0c       	add	r9, r15
     11c:	8a 0c       	add	r8, r10

0000011e <__ctors_end>:
     11e:	11 24       	eor	r1, r1
     120:	1f be       	out	0x3f, r1	; 63
     122:	cf ef       	ldi	r28, 0xFF	; 255
     124:	d8 e0       	ldi	r29, 0x08	; 8
     126:	de bf       	out	0x3e, r29	; 62
     128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
     12a:	12 e0       	ldi	r17, 0x02	; 2
     12c:	a0 e0       	ldi	r26, 0x00	; 0
     12e:	b1 e0       	ldi	r27, 0x01	; 1
     130:	e6 ee       	ldi	r30, 0xE6	; 230
     132:	f3 e2       	ldi	r31, 0x23	; 35
     134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
     136:	05 90       	lpm	r0, Z+
     138:	0d 92       	st	X+, r0
     13a:	a8 38       	cpi	r26, 0x88	; 136
     13c:	b1 07       	cpc	r27, r17
     13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
     140:	28 e0       	ldi	r18, 0x08	; 8
     142:	a8 e8       	ldi	r26, 0x88	; 136
     144:	b2 e0       	ldi	r27, 0x02	; 2
     146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
     148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
     14a:	a4 37       	cpi	r26, 0x74	; 116
     14c:	b2 07       	cpc	r27, r18
     14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>
     150:	0e 94 49 0a 	call	0x1492	; 0x1492 <main>
     154:	0c 94 f1 11 	jmp	0x23e2	; 0x23e2 <_exit>

00000158 <__bad_interrupt>:
     158:	53 cf       	rjmp	.-346    	; 0x0 <__vectors>

0000015a <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     15a:	ec e7       	ldi	r30, 0x7C	; 124
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	90 81       	ld	r25, Z
     160:	90 7e       	andi	r25, 0xE0	; 224
     162:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     164:	90 81       	ld	r25, Z
     166:	89 2b       	or	r24, r25
     168:	80 83       	st	Z, r24
     16a:	08 95       	ret

0000016c <ADC_init>:
}

void ADC_init(void)
{
     16c:	cf 93       	push	r28
     16e:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	80 81       	ld	r24, Z
     176:	80 64       	ori	r24, 0x40	; 64
     178:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     17a:	ca e7       	ldi	r28, 0x7A	; 122
     17c:	d0 e0       	ldi	r29, 0x00	; 0
     17e:	88 81       	ld	r24, Y
     180:	81 60       	ori	r24, 0x01	; 1
     182:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     184:	88 81       	ld	r24, Y
     186:	82 60       	ori	r24, 0x02	; 2
     188:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     18a:	88 81       	ld	r24, Y
     18c:	84 60       	ori	r24, 0x04	; 4
     18e:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     190:	a4 e6       	ldi	r26, 0x64	; 100
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	8c 91       	ld	r24, X
     196:	8e 7f       	andi	r24, 0xFE	; 254
     198:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     19a:	80 81       	ld	r24, Z
     19c:	8f 7d       	andi	r24, 0xDF	; 223
     19e:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1a0:	8f e3       	ldi	r24, 0x3F	; 63
     1a2:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1a6:	88 81       	ld	r24, Y
     1a8:	80 68       	ori	r24, 0x80	; 128
     1aa:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1ac:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1b0:	8f e1       	ldi	r24, 0x1F	; 31
     1b2:	d3 df       	rcall	.-90     	; 0x15a <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1b4:	88 81       	ld	r24, Y
     1b6:	80 64       	ori	r24, 0x40	; 64
     1b8:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ba:	ea e7       	ldi	r30, 0x7A	; 122
     1bc:	f0 e0       	ldi	r31, 0x00	; 0
     1be:	80 81       	ld	r24, Z
     1c0:	84 ff       	sbrs	r24, 4
     1c2:	fd cf       	rjmp	.-6      	; 0x1be <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1c4:	ea e7       	ldi	r30, 0x7A	; 122
     1c6:	f0 e0       	ldi	r31, 0x00	; 0
     1c8:	80 81       	ld	r24, Z
     1ca:	80 64       	ori	r24, 0x40	; 64
     1cc:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1ce:	80 81       	ld	r24, Z
     1d0:	84 ff       	sbrs	r24, 4
     1d2:	fd cf       	rjmp	.-6      	; 0x1ce <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1d4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <__data_end+0x1>
     1de:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1e2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1e6:	20 91 88 02 	lds	r18, 0x0288	; 0x800288 <__data_end>
     1ea:	30 91 89 02 	lds	r19, 0x0289	; 0x800289 <__data_end+0x1>
     1ee:	89 2f       	mov	r24, r25
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	98 2f       	mov	r25, r24
     1f4:	88 27       	eor	r24, r24
     1f6:	82 0f       	add	r24, r18
     1f8:	93 1f       	adc	r25, r19
     1fa:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <__data_end+0x1>
     1fe:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     202:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <__data_end>
     206:	90 91 89 02 	lds	r25, 0x0289	; 0x800289 <__data_end+0x1>
     20a:	99 23       	and	r25, r25
     20c:	1c f4       	brge	.+6      	; 0x214 <ADC_init+0xa8>
     20e:	91 95       	neg	r25
     210:	81 95       	neg	r24
     212:	91 09       	sbc	r25, r1
     214:	05 97       	sbiw	r24, 0x05	; 5
     216:	2c f0       	brlt	.+10     	; 0x222 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     218:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <gas_sensor_initialization_errors>
     21c:	81 60       	ori	r24, 0x01	; 1
     21e:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     222:	8e e1       	ldi	r24, 0x1E	; 30
     224:	9a df       	rcall	.-204    	; 0x15a <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     226:	ea e7       	ldi	r30, 0x7A	; 122
     228:	f0 e0       	ldi	r31, 0x00	; 0
     22a:	80 81       	ld	r24, Z
     22c:	80 64       	ori	r24, 0x40	; 64
     22e:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     230:	80 81       	ld	r24, Z
     232:	84 ff       	sbrs	r24, 4
     234:	fd cf       	rjmp	.-6      	; 0x230 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     236:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <__data_end+0x1>
     240:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     244:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     248:	20 91 88 02 	lds	r18, 0x0288	; 0x800288 <__data_end>
     24c:	30 91 89 02 	lds	r19, 0x0289	; 0x800289 <__data_end+0x1>
     250:	89 2f       	mov	r24, r25
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	98 2f       	mov	r25, r24
     256:	88 27       	eor	r24, r24
     258:	82 0f       	add	r24, r18
     25a:	93 1f       	adc	r25, r19
     25c:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <__data_end+0x1>
     260:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     264:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <__data_end>
     268:	90 91 89 02 	lds	r25, 0x0289	; 0x800289 <__data_end+0x1>
     26c:	81 5e       	subi	r24, 0xE1	; 225
     26e:	91 09       	sbc	r25, r1
     270:	90 93 89 02 	sts	0x0289, r25	; 0x800289 <__data_end+0x1>
     274:	80 93 88 02 	sts	0x0288, r24	; 0x800288 <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     278:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <__data_end>
     27c:	90 91 89 02 	lds	r25, 0x0289	; 0x800289 <__data_end+0x1>
     280:	99 23       	and	r25, r25
     282:	1c f4       	brge	.+6      	; 0x28a <ADC_init+0x11e>
     284:	91 95       	neg	r25
     286:	81 95       	neg	r24
     288:	91 09       	sbc	r25, r1
     28a:	05 97       	sbiw	r24, 0x05	; 5
     28c:	2c f0       	brlt	.+10     	; 0x298 <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     28e:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <gas_sensor_initialization_errors>
     292:	82 60       	ori	r24, 0x02	; 2
     294:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     298:	ea e7       	ldi	r30, 0x7A	; 122
     29a:	f0 e0       	ldi	r31, 0x00	; 0
     29c:	80 81       	ld	r24, Z
     29e:	8f 77       	andi	r24, 0x7F	; 127
     2a0:	80 83       	st	Z, r24
     2a2:	df 91       	pop	r29
     2a4:	cf 91       	pop	r28
     2a6:	08 95       	ret

000002a8 <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2a8:	87 e0       	ldi	r24, 0x07	; 7
     2aa:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2ac:	85 b1       	in	r24, 0x05	; 5
     2ae:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2b0:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2b2:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2b4:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2b6:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2b8:	41 9a       	sbi	0x08, 1	; 8
     2ba:	08 95       	ret

000002bc <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2c0:	2f ef       	ldi	r18, 0xFF	; 255
     2c2:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2c4:	fc 01       	movw	r30, r24
     2c6:	ee 0f       	add	r30, r30
     2c8:	ff 1f       	adc	r31, r31
     2ca:	ee 0f       	add	r30, r30
     2cc:	ff 1f       	adc	r31, r31
     2ce:	e3 54       	subi	r30, 0x43	; 67
     2d0:	fb 4f       	sbci	r31, 0xFB	; 251
     2d2:	11 82       	std	Z+1, r1	; 0x01
     2d4:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2d6:	33 83       	std	Z+3, r19	; 0x03
     2d8:	22 83       	std	Z+2, r18	; 0x02
     2da:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2dc:	85 30       	cpi	r24, 0x05	; 5
     2de:	91 05       	cpc	r25, r1
     2e0:	89 f7       	brne	.-30     	; 0x2c4 <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2e2:	08 95       	ret

000002e4 <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2e4:	ef 92       	push	r14
     2e6:	ff 92       	push	r15
     2e8:	0f 93       	push	r16
     2ea:	1f 93       	push	r17
     2ec:	cf 93       	push	r28
     2ee:	df 93       	push	r29
     2f0:	0f 2e       	mov	r0, r31
     2f2:	f7 ea       	ldi	r31, 0xA7	; 167
     2f4:	ef 2e       	mov	r14, r31
     2f6:	f4 e0       	ldi	r31, 0x04	; 4
     2f8:	ff 2e       	mov	r15, r31
     2fa:	f0 2d       	mov	r31, r0
     2fc:	00 e0       	ldi	r16, 0x00	; 0
     2fe:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     300:	c7 01       	movw	r24, r14
     302:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <eeprom_read_word>
     306:	e8 01       	movw	r28, r16
     308:	cc 0f       	add	r28, r28
     30a:	dd 1f       	adc	r29, r29
     30c:	cc 0f       	add	r28, r28
     30e:	dd 1f       	adc	r29, r29
     310:	c3 54       	subi	r28, 0x43	; 67
     312:	db 4f       	sbci	r29, 0xFB	; 251
     314:	99 83       	std	Y+1, r25	; 0x01
     316:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     318:	c7 01       	movw	r24, r14
     31a:	02 96       	adiw	r24, 0x02	; 2
     31c:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <eeprom_read_word>
     320:	9b 83       	std	Y+3, r25	; 0x03
     322:	8a 83       	std	Y+2, r24	; 0x02
     324:	0f 5f       	subi	r16, 0xFF	; 255
     326:	1f 4f       	sbci	r17, 0xFF	; 255
     328:	84 e0       	ldi	r24, 0x04	; 4
     32a:	e8 0e       	add	r14, r24
     32c:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     32e:	05 30       	cpi	r16, 0x05	; 5
     330:	11 05       	cpc	r17, r1
     332:	31 f7       	brne	.-52     	; 0x300 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     334:	df 91       	pop	r29
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	08 95       	ret

00000342 <gas_sensors_init>:

void gas_sensors_init(void)
{
     342:	af 92       	push	r10
     344:	bf 92       	push	r11
     346:	cf 92       	push	r12
     348:	df 92       	push	r13
     34a:	ef 92       	push	r14
     34c:	ff 92       	push	r15
     34e:	0f 93       	push	r16
     350:	1f 93       	push	r17
     352:	cf 93       	push	r28
     354:	df 93       	push	r29
     356:	1f 92       	push	r1
     358:	cd b7       	in	r28, 0x3d	; 61
     35a:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     35c:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     360:	10 92 da 04 	sts	0x04DA, r1	; 0x8004da <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     364:	bf df       	rcall	.-130    	; 0x2e4 <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     366:	aa df       	rcall	.-172    	; 0x2bc <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     368:	ea e7       	ldi	r30, 0x7A	; 122
     36a:	f0 e0       	ldi	r31, 0x00	; 0
     36c:	80 81       	ld	r24, Z
     36e:	80 68       	ori	r24, 0x80	; 128
     370:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     372:	19 82       	std	Y+1, r1	; 0x01
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	85 30       	cpi	r24, 0x05	; 5
     378:	08 f0       	brcs	.+2      	; 0x37c <gas_sensors_init+0x3a>
     37a:	51 c0       	rjmp	.+162    	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     37c:	0a e7       	ldi	r16, 0x7A	; 122
     37e:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     380:	0f 2e       	mov	r0, r31
     382:	f8 e7       	ldi	r31, 0x78	; 120
     384:	ef 2e       	mov	r14, r31
     386:	f1 2c       	mov	r15, r1
     388:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     38a:	bb 24       	eor	r11, r11
     38c:	b3 94       	inc	r11
     38e:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     390:	cc 24       	eor	r12, r12
     392:	c3 94       	inc	r12
     394:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     396:	89 81       	ldd	r24, Y+1	; 0x01
     398:	e0 de       	rcall	.-576    	; 0x15a <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
     39a:	f8 01       	movw	r30, r16
     39c:	80 81       	ld	r24, Z
     39e:	80 64       	ori	r24, 0x40	; 64
     3a0:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
     3a2:	f8 01       	movw	r30, r16
     3a4:	80 81       	ld	r24, Z
     3a6:	84 ff       	sbrs	r24, 4
     3a8:	fc cf       	rjmp	.-8      	; 0x3a2 <gas_sensors_init+0x60>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3aa:	f7 01       	movw	r30, r14
     3ac:	80 81       	ld	r24, Z
     3ae:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3b0:	e9 81       	ldd	r30, Y+1	; 0x01
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	ee 0f       	add	r30, r30
     3b6:	ff 1f       	adc	r31, r31
     3b8:	ee 0f       	add	r30, r30
     3ba:	ff 1f       	adc	r31, r31
     3bc:	e3 54       	subi	r30, 0x43	; 67
     3be:	fb 4f       	sbci	r31, 0xFB	; 251
     3c0:	20 81       	ld	r18, Z
     3c2:	31 81       	ldd	r19, Z+1	; 0x01
     3c4:	e9 81       	ldd	r30, Y+1	; 0x01
     3c6:	f0 e0       	ldi	r31, 0x00	; 0
     3c8:	ee 0f       	add	r30, r30
     3ca:	ff 1f       	adc	r31, r31
     3cc:	ee 0f       	add	r30, r30
     3ce:	ff 1f       	adc	r31, r31
     3d0:	e3 54       	subi	r30, 0x43	; 67
     3d2:	fb 4f       	sbci	r31, 0xFB	; 251
     3d4:	62 81       	ldd	r22, Z+2	; 0x02
     3d6:	73 81       	ldd	r23, Z+3	; 0x03
     3d8:	4b 2d       	mov	r20, r11
     3da:	68 17       	cp	r22, r24
     3dc:	79 07       	cpc	r23, r25
     3de:	08 f0       	brcs	.+2      	; 0x3e2 <gas_sensors_init+0xa0>
     3e0:	4a 2d       	mov	r20, r10
     3e2:	41 11       	cpse	r20, r1
     3e4:	07 c0       	rjmp	.+14     	; 0x3f4 <gas_sensors_init+0xb2>
     3e6:	4b 2d       	mov	r20, r11
     3e8:	82 17       	cp	r24, r18
     3ea:	93 07       	cpc	r25, r19
     3ec:	08 f0       	brcs	.+2      	; 0x3f0 <gas_sensors_init+0xae>
     3ee:	4a 2d       	mov	r20, r10
     3f0:	44 23       	and	r20, r20
     3f2:	71 f0       	breq	.+28     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3f4:	99 81       	ldd	r25, Y+1	; 0x01
     3f6:	20 91 e7 04 	lds	r18, 0x04E7	; 0x8004e7 <gas_sensor_initialization_errors>
     3fa:	9d 5f       	subi	r25, 0xFD	; 253
     3fc:	a6 01       	movw	r20, r12
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
     400:	44 0f       	add	r20, r20
     402:	55 1f       	adc	r21, r21
     404:	9a 95       	dec	r25
     406:	e2 f7       	brpl	.-8      	; 0x400 <__LOCK_REGION_LENGTH__>
     408:	ca 01       	movw	r24, r20
     40a:	82 2b       	or	r24, r18
     40c:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     410:	89 81       	ldd	r24, Y+1	; 0x01
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	89 83       	std	Y+1, r24	; 0x01
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	85 30       	cpi	r24, 0x05	; 5
     41a:	08 f4       	brcc	.+2      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     41c:	bc cf       	rjmp	.-136    	; 0x396 <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     41e:	ea e7       	ldi	r30, 0x7A	; 122
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	80 81       	ld	r24, Z
     424:	8f 77       	andi	r24, 0x7F	; 127
     426:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     428:	0f 90       	pop	r0
     42a:	df 91       	pop	r29
     42c:	cf 91       	pop	r28
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	08 95       	ret

00000440 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
     440:	8f 92       	push	r8
     442:	9f 92       	push	r9
     444:	af 92       	push	r10
     446:	bf 92       	push	r11
     448:	cf 92       	push	r12
     44a:	df 92       	push	r13
     44c:	ef 92       	push	r14
     44e:	ff 92       	push	r15
     450:	0f 93       	push	r16
     452:	1f 93       	push	r17
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	00 d0       	rcall	.+0      	; 0x45a <start_gas_sensor_read+0x1a>
     45a:	1f 92       	push	r1
     45c:	cd b7       	in	r28, 0x3d	; 61
     45e:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     460:	ea e7       	ldi	r30, 0x7A	; 122
     462:	f0 e0       	ldi	r31, 0x00	; 0
     464:	80 81       	ld	r24, Z
     466:	80 68       	ori	r24, 0x80	; 128
     468:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     46a:	19 82       	std	Y+1, r1	; 0x01
     46c:	89 81       	ldd	r24, Y+1	; 0x01
     46e:	85 30       	cpi	r24, 0x05	; 5
     470:	08 f0       	brcs	.+2      	; 0x474 <start_gas_sensor_read+0x34>
     472:	76 c0       	rjmp	.+236    	; 0x560 <start_gas_sensor_read+0x120>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
     474:	68 94       	set
     476:	88 24       	eor	r8, r8
     478:	82 f8       	bld	r8, 2
     47a:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     47c:	0a e7       	ldi	r16, 0x7A	; 122
     47e:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     480:	0f 2e       	mov	r0, r31
     482:	f8 e7       	ldi	r31, 0x78	; 120
     484:	ef 2e       	mov	r14, r31
     486:	f1 2c       	mov	r15, r1
     488:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     48a:	cc 24       	eor	r12, r12
     48c:	c3 94       	inc	r12
     48e:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     490:	bb 24       	eor	r11, r11
     492:	b3 94       	inc	r11
     494:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     496:	89 81       	ldd	r24, Y+1	; 0x01
     498:	60 de       	rcall	.-832    	; 0x15a <ADC_SetMux>
		total = 0;	// re-zero the average
     49a:	1b 82       	std	Y+3, r1	; 0x03
     49c:	1a 82       	std	Y+2, r1	; 0x02
     49e:	28 2d       	mov	r18, r8
     4a0:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i ++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4a2:	f8 01       	movw	r30, r16
     4a4:	80 81       	ld	r24, Z
     4a6:	80 64       	ori	r24, 0x40	; 64
     4a8:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4aa:	f8 01       	movw	r30, r16
     4ac:	80 81       	ld	r24, Z
     4ae:	84 ff       	sbrs	r24, 4
     4b0:	fc cf       	rjmp	.-8      	; 0x4aa <start_gas_sensor_read+0x6a>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4b2:	f7 01       	movw	r30, r14
     4b4:	80 81       	ld	r24, Z
     4b6:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4b8:	e9 81       	ldd	r30, Y+1	; 0x01
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	ee 0f       	add	r30, r30
     4c2:	ff 1f       	adc	r31, r31
     4c4:	e3 54       	subi	r30, 0x43	; 67
     4c6:	fb 4f       	sbci	r31, 0xFB	; 251
     4c8:	40 81       	ld	r20, Z
     4ca:	51 81       	ldd	r21, Z+1	; 0x01
     4cc:	e9 81       	ldd	r30, Y+1	; 0x01
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	e3 54       	subi	r30, 0x43	; 67
     4da:	fb 4f       	sbci	r31, 0xFB	; 251
     4dc:	62 81       	ldd	r22, Z+2	; 0x02
     4de:	73 81       	ldd	r23, Z+3	; 0x03
     4e0:	eb 2d       	mov	r30, r11
     4e2:	68 17       	cp	r22, r24
     4e4:	79 07       	cpc	r23, r25
     4e6:	08 f0       	brcs	.+2      	; 0x4ea <start_gas_sensor_read+0xaa>
     4e8:	ea 2d       	mov	r30, r10
     4ea:	e1 11       	cpse	r30, r1
     4ec:	07 c0       	rjmp	.+14     	; 0x4fc <start_gas_sensor_read+0xbc>
     4ee:	6b 2d       	mov	r22, r11
     4f0:	84 17       	cp	r24, r20
     4f2:	95 07       	cpc	r25, r21
     4f4:	08 f0       	brcs	.+2      	; 0x4f8 <start_gas_sensor_read+0xb8>
     4f6:	6a 2d       	mov	r22, r10
     4f8:	66 23       	and	r22, r22
     4fa:	71 f0       	breq	.+28     	; 0x518 <start_gas_sensor_read+0xd8>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     4fc:	59 81       	ldd	r21, Y+1	; 0x01
     4fe:	60 91 e7 04 	lds	r22, 0x04E7	; 0x8004e7 <gas_sensor_initialization_errors>
     502:	5d 5f       	subi	r21, 0xFD	; 253
     504:	f6 01       	movw	r30, r12
     506:	02 c0       	rjmp	.+4      	; 0x50c <start_gas_sensor_read+0xcc>
     508:	ee 0f       	add	r30, r30
     50a:	ff 1f       	adc	r31, r31
     50c:	5a 95       	dec	r21
     50e:	e2 f7       	brpl	.-8      	; 0x508 <start_gas_sensor_read+0xc8>
     510:	af 01       	movw	r20, r30
     512:	46 2b       	or	r20, r22
     514:	40 93 e7 04 	sts	0x04E7, r20	; 0x8004e7 <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     518:	4a 81       	ldd	r20, Y+2	; 0x02
     51a:	5b 81       	ldd	r21, Y+3	; 0x03
     51c:	84 0f       	add	r24, r20
     51e:	95 1f       	adc	r25, r21
     520:	9b 83       	std	Y+3, r25	; 0x03
     522:	8a 83       	std	Y+2, r24	; 0x02
     524:	21 50       	subi	r18, 0x01	; 1
     526:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i ++)
     528:	09 f0       	breq	.+2      	; 0x52c <start_gas_sensor_read+0xec>
     52a:	bb cf       	rjmp	.-138    	; 0x4a2 <start_gas_sensor_read+0x62>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     52c:	8a 81       	ldd	r24, Y+2	; 0x02
     52e:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     530:	e9 81       	ldd	r30, Y+1	; 0x01
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	e5 52       	subi	r30, 0x25	; 37
     53a:	fb 4f       	sbci	r31, 0xFB	; 251
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     53c:	9c 01       	movw	r18, r24
     53e:	99 23       	and	r25, r25
     540:	14 f4       	brge	.+4      	; 0x546 <start_gas_sensor_read+0x106>
     542:	2d 5f       	subi	r18, 0xFD	; 253
     544:	3f 4f       	sbci	r19, 0xFF	; 255
     546:	35 95       	asr	r19
     548:	27 95       	ror	r18
     54a:	35 95       	asr	r19
     54c:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
     54e:	31 83       	std	Z+1, r19	; 0x01
     550:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     552:	89 81       	ldd	r24, Y+1	; 0x01
     554:	8f 5f       	subi	r24, 0xFF	; 255
     556:	89 83       	std	Y+1, r24	; 0x01
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	85 30       	cpi	r24, 0x05	; 5
     55c:	08 f4       	brcc	.+2      	; 0x560 <start_gas_sensor_read+0x120>
     55e:	9b cf       	rjmp	.-202    	; 0x496 <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	df 91       	pop	r29
     568:	cf 91       	pop	r28
     56a:	1f 91       	pop	r17
     56c:	0f 91       	pop	r16
     56e:	ff 90       	pop	r15
     570:	ef 90       	pop	r14
     572:	df 90       	pop	r13
     574:	cf 90       	pop	r12
     576:	bf 90       	pop	r11
     578:	af 90       	pop	r10
     57a:	9f 90       	pop	r9
     57c:	8f 90       	pop	r8
     57e:	08 95       	ret

00000580 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     580:	1f 93       	push	r17
     582:	cf 93       	push	r28
     584:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     586:	ee ee       	ldi	r30, 0xEE	; 238
     588:	f4 e0       	ldi	r31, 0x04	; 4
     58a:	84 ec       	ldi	r24, 0xC4	; 196
     58c:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     58e:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     590:	84 e0       	ldi	r24, 0x04	; 4
     592:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     594:	63 e0       	ldi	r22, 0x03	; 3
     596:	cf 01       	movw	r24, r30
     598:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     59c:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     5a0:	81 11       	cpse	r24, r1
     5a2:	fc cf       	rjmp	.-8      	; 0x59c <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5a4:	ee ee       	ldi	r30, 0xEE	; 238
     5a6:	f4 e0       	ldi	r31, 0x04	; 4
     5a8:	84 ec       	ldi	r24, 0xC4	; 196
     5aa:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5b0:	62 e0       	ldi	r22, 0x02	; 2
     5b2:	cf 01       	movw	r24, r30
     5b4:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5b8:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     5bc:	81 11       	cpse	r24, r1
     5be:	fc cf       	rjmp	.-8      	; 0x5b8 <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5c0:	ce ee       	ldi	r28, 0xEE	; 238
     5c2:	d4 e0       	ldi	r29, 0x04	; 4
     5c4:	15 ec       	ldi	r17, 0xC5	; 197
     5c6:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5c8:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5ca:	62 e0       	ldi	r22, 0x02	; 2
     5cc:	ce 01       	movw	r24, r28
     5ce:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5d2:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     5d6:	81 11       	cpse	r24, r1
     5d8:	fc cf       	rjmp	.-8      	; 0x5d2 <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5da:	62 e0       	ldi	r22, 0x02	; 2
     5dc:	ce 01       	movw	r24, r28
     5de:	0e 94 14 0c 	call	0x1828	; 0x1828 <TWI_Get_Data_From_Transceiver>
     5e2:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5e6:	89 81       	ldd	r24, Y+1	; 0x01
     5e8:	80 93 ff 05 	sts	0x05FF, r24	; 0x8005ff <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     5ec:	80 fd       	sbrc	r24, 0
     5ee:	eb cf       	rjmp	.-42     	; 0x5c6 <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5f0:	ee ee       	ldi	r30, 0xEE	; 238
     5f2:	f4 e0       	ldi	r31, 0x04	; 4
     5f4:	84 ec       	ldi	r24, 0xC4	; 196
     5f6:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     5f8:	8f e8       	ldi	r24, 0x8F	; 143
     5fa:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5fc:	62 e0       	ldi	r22, 0x02	; 2
     5fe:	cf 01       	movw	r24, r30
     600:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     604:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     608:	81 11       	cpse	r24, r1
     60a:	fc cf       	rjmp	.-8      	; 0x604 <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     60c:	ee ee       	ldi	r30, 0xEE	; 238
     60e:	f4 e0       	ldi	r31, 0x04	; 4
     610:	85 ec       	ldi	r24, 0xC5	; 197
     612:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     614:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     616:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     618:	63 e0       	ldi	r22, 0x03	; 3
     61a:	cf 01       	movw	r24, r30
     61c:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     620:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     624:	81 11       	cpse	r24, r1
     626:	fc cf       	rjmp	.-8      	; 0x620 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     628:	63 e0       	ldi	r22, 0x03	; 3
     62a:	8e ee       	ldi	r24, 0xEE	; 238
     62c:	94 e0       	ldi	r25, 0x04	; 4
     62e:	0e 94 14 0c 	call	0x1828	; 0x1828 <TWI_Get_Data_From_Transceiver>
     632:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     636:	ee ee       	ldi	r30, 0xEE	; 238
     638:	f4 e0       	ldi	r31, 0x04	; 4
     63a:	81 81       	ldd	r24, Z+1	; 0x01
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	98 2f       	mov	r25, r24
     640:	88 27       	eor	r24, r24
     642:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
     644:	82 0f       	add	r24, r18
     646:	91 1d       	adc	r25, r1
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret

00000650 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     650:	ff 92       	push	r15
     652:	0f 93       	push	r16
     654:	1f 93       	push	r17
     656:	cf 93       	push	r28
     658:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     65a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     65e:	88 23       	and	r24, r24
     660:	59 f1       	breq	.+86     	; 0x6b8 <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     662:	cf ef       	ldi	r28, 0xFF	; 255
     664:	d4 e0       	ldi	r29, 0x04	; 4
     666:	0f 2e       	mov	r0, r31
     668:	fc ee       	ldi	r31, 0xEC	; 236
     66a:	ff 2e       	mov	r15, r31
     66c:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     66e:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     670:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     672:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     674:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     676:	62 e0       	ldi	r22, 0x02	; 2
     678:	ce 01       	movw	r24, r28
     67a:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     67e:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     682:	81 11       	cpse	r24, r1
     684:	fc cf       	rjmp	.-8      	; 0x67e <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     686:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     688:	6a e1       	ldi	r22, 0x1A	; 26
     68a:	ce 01       	movw	r24, r28
     68c:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     690:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     694:	81 11       	cpse	r24, r1
     696:	fc cf       	rjmp	.-8      	; 0x690 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     698:	6a e1       	ldi	r22, 0x1A	; 26
     69a:	ce 01       	movw	r24, r28
     69c:	0e 94 14 0c 	call	0x1828	; 0x1828 <TWI_Get_Data_From_Transceiver>
     6a0:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6a4:	89 81       	ldd	r24, Y+1	; 0x01
     6a6:	83 fb       	bst	r24, 3
     6a8:	88 27       	eor	r24, r24
     6aa:	80 f9       	bld	r24, 0
     6ac:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6b0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6b4:	81 11       	cpse	r24, r1
     6b6:	dd cf       	rjmp	.-70     	; 0x672 <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6b8:	ef ef       	ldi	r30, 0xFF	; 255
     6ba:	f4 e0       	ldi	r31, 0x04	; 4
     6bc:	8c ee       	ldi	r24, 0xEC	; 236
     6be:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6c0:	88 e8       	ldi	r24, 0x88	; 136
     6c2:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6c4:	62 e0       	ldi	r22, 0x02	; 2
     6c6:	cf 01       	movw	r24, r30
     6c8:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6cc:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     6d0:	81 11       	cpse	r24, r1
     6d2:	fc cf       	rjmp	.-8      	; 0x6cc <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6d4:	8d ee       	ldi	r24, 0xED	; 237
     6d6:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6da:	6b e1       	ldi	r22, 0x1B	; 27
     6dc:	8f ef       	ldi	r24, 0xFF	; 255
     6de:	94 e0       	ldi	r25, 0x04	; 4
     6e0:	0e 94 e8 0b 	call	0x17d0	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6e4:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <TWI_Transceiver_Busy>
     6e8:	81 11       	cpse	r24, r1
     6ea:	fc cf       	rjmp	.-8      	; 0x6e4 <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     6ec:	6b e1       	ldi	r22, 0x1B	; 27
     6ee:	8f ef       	ldi	r24, 0xFF	; 255
     6f0:	94 e0       	ldi	r25, 0x04	; 4
     6f2:	0e 94 14 0c 	call	0x1828	; 0x1828 <TWI_Get_Data_From_Transceiver>
     6f6:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
     6fa:	c0 e0       	ldi	r28, 0x00	; 0
     6fc:	d5 e0       	ldi	r29, 0x05	; 5
     6fe:	08 e0       	ldi	r16, 0x08	; 8
     700:	16 e0       	ldi	r17, 0x06	; 6
     702:	2b e1       	ldi	r18, 0x1B	; 27
     704:	35 e0       	ldi	r19, 0x05	; 5
     706:	d8 01       	movw	r26, r16
     708:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     70a:	81 91       	ld	r24, Z+
     70c:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     70e:	e2 17       	cp	r30, r18
     710:	f3 07       	cpc	r31, r19
     712:	d9 f7       	brne	.-10     	; 0x70a <BME_read_correction_coefficients+0xba>
     714:	8b e1       	ldi	r24, 0x1B	; 27
     716:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <i.2287>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     71a:	e8 e0       	ldi	r30, 0x08	; 8
     71c:	f6 e0       	ldi	r31, 0x06	; 6
     71e:	81 81       	ldd	r24, Z+1	; 0x01
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	98 2f       	mov	r25, r24
     724:	88 27       	eor	r24, r24
     726:	20 81       	ld	r18, Z
     728:	82 2b       	or	r24, r18
     72a:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <dig_T1+0x1>
     72e:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     732:	83 81       	ldd	r24, Z+3	; 0x03
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	98 2f       	mov	r25, r24
     738:	88 27       	eor	r24, r24
     73a:	22 81       	ldd	r18, Z+2	; 0x02
     73c:	82 2b       	or	r24, r18
     73e:	90 93 07 06 	sts	0x0607, r25	; 0x800607 <dig_T2+0x1>
     742:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     746:	85 81       	ldd	r24, Z+5	; 0x05
     748:	90 e0       	ldi	r25, 0x00	; 0
     74a:	98 2f       	mov	r25, r24
     74c:	88 27       	eor	r24, r24
     74e:	24 81       	ldd	r18, Z+4	; 0x04
     750:	82 2b       	or	r24, r18
     752:	90 93 65 06 	sts	0x0665, r25	; 0x800665 <dig_T3+0x1>
     756:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     75a:	87 81       	ldd	r24, Z+7	; 0x07
     75c:	90 e0       	ldi	r25, 0x00	; 0
     75e:	98 2f       	mov	r25, r24
     760:	88 27       	eor	r24, r24
     762:	26 81       	ldd	r18, Z+6	; 0x06
     764:	82 2b       	or	r24, r18
     766:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <dig_P1+0x1>
     76a:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     76e:	81 85       	ldd	r24, Z+9	; 0x09
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	98 2f       	mov	r25, r24
     774:	88 27       	eor	r24, r24
     776:	20 85       	ldd	r18, Z+8	; 0x08
     778:	82 2b       	or	r24, r18
     77a:	90 93 3b 06 	sts	0x063B, r25	; 0x80063b <dig_P2+0x1>
     77e:	80 93 3a 06 	sts	0x063A, r24	; 0x80063a <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     782:	83 85       	ldd	r24, Z+11	; 0x0b
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	98 2f       	mov	r25, r24
     788:	88 27       	eor	r24, r24
     78a:	22 85       	ldd	r18, Z+10	; 0x0a
     78c:	82 2b       	or	r24, r18
     78e:	90 93 5b 06 	sts	0x065B, r25	; 0x80065b <dig_P3+0x1>
     792:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     796:	85 85       	ldd	r24, Z+13	; 0x0d
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	98 2f       	mov	r25, r24
     79c:	88 27       	eor	r24, r24
     79e:	24 85       	ldd	r18, Z+12	; 0x0c
     7a0:	82 2b       	or	r24, r18
     7a2:	90 93 3d 06 	sts	0x063D, r25	; 0x80063d <dig_P4+0x1>
     7a6:	80 93 3c 06 	sts	0x063C, r24	; 0x80063c <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7aa:	87 85       	ldd	r24, Z+15	; 0x0f
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	98 2f       	mov	r25, r24
     7b0:	88 27       	eor	r24, r24
     7b2:	26 85       	ldd	r18, Z+14	; 0x0e
     7b4:	82 2b       	or	r24, r18
     7b6:	90 93 4c 06 	sts	0x064C, r25	; 0x80064c <dig_P5+0x1>
     7ba:	80 93 4b 06 	sts	0x064B, r24	; 0x80064b <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7be:	81 89       	ldd	r24, Z+17	; 0x11
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	98 2f       	mov	r25, r24
     7c4:	88 27       	eor	r24, r24
     7c6:	20 89       	ldd	r18, Z+16	; 0x10
     7c8:	82 2b       	or	r24, r18
     7ca:	90 93 67 06 	sts	0x0667, r25	; 0x800667 <dig_P6+0x1>
     7ce:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7d2:	83 89       	ldd	r24, Z+19	; 0x13
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	98 2f       	mov	r25, r24
     7d8:	88 27       	eor	r24, r24
     7da:	22 89       	ldd	r18, Z+18	; 0x12
     7dc:	82 2b       	or	r24, r18
     7de:	90 93 01 06 	sts	0x0601, r25	; 0x800601 <dig_P7+0x1>
     7e2:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7e6:	85 89       	ldd	r24, Z+21	; 0x15
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	98 2f       	mov	r25, r24
     7ec:	88 27       	eor	r24, r24
     7ee:	24 89       	ldd	r18, Z+20	; 0x14
     7f0:	82 2b       	or	r24, r18
     7f2:	90 93 5d 06 	sts	0x065D, r25	; 0x80065d <dig_P8+0x1>
     7f6:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     7fa:	87 89       	ldd	r24, Z+23	; 0x17
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	98 2f       	mov	r25, r24
     800:	88 27       	eor	r24, r24
     802:	26 89       	ldd	r18, Z+22	; 0x16
     804:	82 2b       	or	r24, r18
     806:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <dig_P9+0x1>
     80a:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <dig_P9>
	dig_H1 = RawBMEdata[25];
     80e:	81 8d       	ldd	r24, Z+25	; 0x19
     810:	90 e0       	ldi	r25, 0x00	; 0
     812:	90 93 35 06 	sts	0x0635, r25	; 0x800635 <dig_H1+0x1>
     816:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     81a:	ef ef       	ldi	r30, 0xFF	; 255
     81c:	f4 e0       	ldi	r31, 0x04	; 4
     81e:	8c ee       	ldi	r24, 0xEC	; 236
     820:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     822:	81 ee       	ldi	r24, 0xE1	; 225
     824:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     826:	62 e0       	ldi	r22, 0x02	; 2
     828:	cf 01       	movw	r24, r30
     82a:	d2 d7       	rcall	.+4004   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     82c:	cd d7       	rcall	.+3994   	; 0x17c8 <TWI_Transceiver_Busy>
     82e:	81 11       	cpse	r24, r1
     830:	fd cf       	rjmp	.-6      	; 0x82c <BME_read_correction_coefficients+0x1dc>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     832:	8d ee       	ldi	r24, 0xED	; 237
     834:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     838:	68 e0       	ldi	r22, 0x08	; 8
     83a:	8f ef       	ldi	r24, 0xFF	; 255
     83c:	94 e0       	ldi	r25, 0x04	; 4
     83e:	c8 d7       	rcall	.+3984   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     840:	c3 d7       	rcall	.+3974   	; 0x17c8 <TWI_Transceiver_Busy>
     842:	81 11       	cpse	r24, r1
     844:	fd cf       	rjmp	.-6      	; 0x840 <BME_read_correction_coefficients+0x1f0>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     846:	68 e0       	ldi	r22, 0x08	; 8
     848:	8f ef       	ldi	r24, 0xFF	; 255
     84a:	94 e0       	ldi	r25, 0x04	; 4
     84c:	ed d7       	rcall	.+4058   	; 0x1828 <TWI_Get_Data_From_Transceiver>
     84e:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
     852:	27 e0       	ldi	r18, 0x07	; 7
     854:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     856:	89 91       	ld	r24, Y+
     858:	f8 01       	movw	r30, r16
     85a:	81 93       	st	Z+, r24
     85c:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     85e:	c2 17       	cp	r28, r18
     860:	d3 07       	cpc	r29, r19
     862:	c9 f7       	brne	.-14     	; 0x856 <BME_read_correction_coefficients+0x206>
     864:	87 e0       	ldi	r24, 0x07	; 7
     866:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <i.2287>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8); 
     86a:	e8 e0       	ldi	r30, 0x08	; 8
     86c:	f6 e0       	ldi	r31, 0x06	; 6
     86e:	82 81       	ldd	r24, Z+2	; 0x02
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	98 2f       	mov	r25, r24
     874:	88 27       	eor	r24, r24
     876:	21 81       	ldd	r18, Z+1	; 0x01
     878:	82 2b       	or	r24, r18
     87a:	90 93 69 06 	sts	0x0669, r25	; 0x800669 <dig_H2+0x1>
     87e:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <dig_H2>
	dig_H3 = RawBMEdata[3]; 
     882:	83 81       	ldd	r24, Z+3	; 0x03
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	90 93 61 06 	sts	0x0661, r25	; 0x800661 <dig_H3+0x1>
     88a:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     88e:	85 81       	ldd	r24, Z+5	; 0x05
     890:	82 95       	swap	r24
     892:	86 95       	lsr	r24
     894:	87 70       	andi	r24, 0x07	; 7
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	24 81       	ldd	r18, Z+4	; 0x04
     89a:	40 e1       	ldi	r20, 0x10	; 16
     89c:	24 9f       	mul	r18, r20
     89e:	90 01       	movw	r18, r0
     8a0:	11 24       	eor	r1, r1
     8a2:	28 2b       	or	r18, r24
     8a4:	39 2b       	or	r19, r25
     8a6:	30 93 05 06 	sts	0x0605, r19	; 0x800605 <dig_H4+0x1>
     8aa:	20 93 04 06 	sts	0x0604, r18	; 0x800604 <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     8ae:	26 81       	ldd	r18, Z+6	; 0x06
     8b0:	40 e1       	ldi	r20, 0x10	; 16
     8b2:	24 9f       	mul	r18, r20
     8b4:	90 01       	movw	r18, r0
     8b6:	11 24       	eor	r1, r1
     8b8:	82 2b       	or	r24, r18
     8ba:	93 2b       	or	r25, r19
     8bc:	90 93 5f 06 	sts	0x065F, r25	; 0x80065f <dig_H5+0x1>
     8c0:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <dig_H5>
	dig_H6 = RawBMEdata[7];
     8c4:	87 81       	ldd	r24, Z+7	; 0x07
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	90 93 46 06 	sts	0x0646, r25	; 0x800646 <dig_H6+0x1>
     8cc:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <dig_H6>
}
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	1f 91       	pop	r17
     8d6:	0f 91       	pop	r16
     8d8:	ff 90       	pop	r15
     8da:	08 95       	ret

000008dc <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8dc:	ef ef       	ldi	r30, 0xFF	; 255
     8de:	f4 e0       	ldi	r31, 0x04	; 4
     8e0:	8c ee       	ldi	r24, 0xEC	; 236
     8e2:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     8e4:	80 ee       	ldi	r24, 0xE0	; 224
     8e6:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     8e8:	86 eb       	ldi	r24, 0xB6	; 182
     8ea:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     8ec:	63 e0       	ldi	r22, 0x03	; 3
     8ee:	cf 01       	movw	r24, r30
     8f0:	6f d7       	rcall	.+3806   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     8f2:	6a d7       	rcall	.+3796   	; 0x17c8 <TWI_Transceiver_Busy>
     8f4:	81 11       	cpse	r24, r1
     8f6:	fd cf       	rjmp	.-6      	; 0x8f2 <bme280basic_init+0x16>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8f8:	ef ef       	ldi	r30, 0xFF	; 255
     8fa:	f4 e0       	ldi	r31, 0x04	; 4
     8fc:	8c ee       	ldi	r24, 0xEC	; 236
     8fe:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     900:	80 ed       	ldi	r24, 0xD0	; 208
     902:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     904:	62 e0       	ldi	r22, 0x02	; 2
     906:	cf 01       	movw	r24, r30
     908:	63 d7       	rcall	.+3782   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     90a:	5e d7       	rcall	.+3772   	; 0x17c8 <TWI_Transceiver_Busy>
     90c:	81 11       	cpse	r24, r1
     90e:	fd cf       	rjmp	.-6      	; 0x90a <__stack+0xb>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     910:	8d ee       	ldi	r24, 0xED	; 237
     912:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     916:	62 e0       	ldi	r22, 0x02	; 2
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	94 e0       	ldi	r25, 0x04	; 4
     91c:	59 d7       	rcall	.+3762   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     91e:	54 d7       	rcall	.+3752   	; 0x17c8 <TWI_Transceiver_Busy>
     920:	81 11       	cpse	r24, r1
     922:	fd cf       	rjmp	.-6      	; 0x91e <__stack+0x1f>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     924:	62 e0       	ldi	r22, 0x02	; 2
     926:	8f ef       	ldi	r24, 0xFF	; 255
     928:	94 e0       	ldi	r25, 0x04	; 4
     92a:	7e d7       	rcall	.+3836   	; 0x1828 <TWI_Get_Data_From_Transceiver>
     92c:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     930:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <BMEmessageBuf+0x1>
     934:	80 36       	cpi	r24, 0x60	; 96
     936:	69 f5       	brne	.+90     	; 0x992 <__stack+0x93>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     938:	ef ef       	ldi	r30, 0xFF	; 255
     93a:	f4 e0       	ldi	r31, 0x04	; 4
     93c:	8c ee       	ldi	r24, 0xEC	; 236
     93e:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     940:	82 ef       	ldi	r24, 0xF2	; 242
     942:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     948:	63 e0       	ldi	r22, 0x03	; 3
     94a:	cf 01       	movw	r24, r30
     94c:	41 d7       	rcall	.+3714   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     94e:	3c d7       	rcall	.+3704   	; 0x17c8 <TWI_Transceiver_Busy>
     950:	81 11       	cpse	r24, r1
     952:	fd cf       	rjmp	.-6      	; 0x94e <__stack+0x4f>
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     954:	ef ef       	ldi	r30, 0xFF	; 255
     956:	f4 e0       	ldi	r31, 0x04	; 4
     958:	8c ee       	ldi	r24, 0xEC	; 236
     95a:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     95c:	85 ef       	ldi	r24, 0xF5	; 245
     95e:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     960:	80 e1       	ldi	r24, 0x10	; 16
     962:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     964:	63 e0       	ldi	r22, 0x03	; 3
     966:	cf 01       	movw	r24, r30
     968:	33 d7       	rcall	.+3686   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     96a:	2e d7       	rcall	.+3676   	; 0x17c8 <TWI_Transceiver_Busy>
     96c:	81 11       	cpse	r24, r1
     96e:	fd cf       	rjmp	.-6      	; 0x96a <__stack+0x6b>
		//
		BME_read_correction_coefficients();
     970:	6f de       	rcall	.-802    	; 0x650 <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     972:	81 e3       	ldi	r24, 0x31	; 49
     974:	80 93 3e 06 	sts	0x063E, r24	; 0x80063e <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     978:	ef ef       	ldi	r30, 0xFF	; 255
     97a:	f4 e0       	ldi	r31, 0x04	; 4
     97c:	9c ee       	ldi	r25, 0xEC	; 236
     97e:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     980:	94 ef       	ldi	r25, 0xF4	; 244
     982:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     984:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     986:	63 e0       	ldi	r22, 0x03	; 3
     988:	cf 01       	movw	r24, r30
     98a:	22 d7       	rcall	.+3652   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     98c:	1d d7       	rcall	.+3642   	; 0x17c8 <TWI_Transceiver_Busy>
     98e:	81 11       	cpse	r24, r1
     990:	fd cf       	rjmp	.-6      	; 0x98c <__stack+0x8d>
     992:	08 95       	ret

00000994 <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     994:	ff 92       	push	r15
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	80 93 8a 02 	sts	0x028A, r24	; 0x80028a <BMEbusy.2341>
	while (BMEbusy) {
     9a4:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <BMEbusy.2341>
     9a8:	88 23       	and	r24, r24
     9aa:	31 f1       	breq	.+76     	; 0x9f8 <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9ac:	cf ef       	ldi	r28, 0xFF	; 255
     9ae:	d4 e0       	ldi	r29, 0x04	; 4
     9b0:	0f 2e       	mov	r0, r31
     9b2:	fc ee       	ldi	r31, 0xEC	; 236
     9b4:	ff 2e       	mov	r15, r31
     9b6:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9b8:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9ba:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9bc:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9be:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9c0:	62 e0       	ldi	r22, 0x02	; 2
     9c2:	ce 01       	movw	r24, r28
     9c4:	05 d7       	rcall	.+3594   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9c6:	00 d7       	rcall	.+3584   	; 0x17c8 <TWI_Transceiver_Busy>
     9c8:	81 11       	cpse	r24, r1
     9ca:	fd cf       	rjmp	.-6      	; 0x9c6 <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9cc:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     9ce:	62 e0       	ldi	r22, 0x02	; 2
     9d0:	ce 01       	movw	r24, r28
     9d2:	fe d6       	rcall	.+3580   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9d4:	f9 d6       	rcall	.+3570   	; 0x17c8 <TWI_Transceiver_Busy>
     9d6:	81 11       	cpse	r24, r1
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9da:	62 e0       	ldi	r22, 0x02	; 2
     9dc:	ce 01       	movw	r24, r28
     9de:	24 d7       	rcall	.+3656   	; 0x1828 <TWI_Get_Data_From_Transceiver>
     9e0:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     9e4:	89 81       	ldd	r24, Y+1	; 0x01
     9e6:	83 fb       	bst	r24, 3
     9e8:	88 27       	eor	r24, r24
     9ea:	80 f9       	bld	r24, 0
     9ec:	80 93 8a 02 	sts	0x028A, r24	; 0x80028a <BMEbusy.2341>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     9f0:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <BMEbusy.2341>
     9f4:	81 11       	cpse	r24, r1
     9f6:	e2 cf       	rjmp	.-60     	; 0x9bc <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9f8:	ef ef       	ldi	r30, 0xFF	; 255
     9fa:	f4 e0       	ldi	r31, 0x04	; 4
     9fc:	8c ee       	ldi	r24, 0xEC	; 236
     9fe:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     a00:	87 ef       	ldi	r24, 0xF7	; 247
     a02:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     a04:	62 e0       	ldi	r22, 0x02	; 2
     a06:	cf 01       	movw	r24, r30
     a08:	e3 d6       	rcall	.+3526   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a0a:	de d6       	rcall	.+3516   	; 0x17c8 <TWI_Transceiver_Busy>
     a0c:	81 11       	cpse	r24, r1
     a0e:	fd cf       	rjmp	.-6      	; 0xa0a <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     a10:	8d ee       	ldi	r24, 0xED	; 237
     a12:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     a16:	69 e0       	ldi	r22, 0x09	; 9
     a18:	8f ef       	ldi	r24, 0xFF	; 255
     a1a:	94 e0       	ldi	r25, 0x04	; 4
     a1c:	d9 d6       	rcall	.+3506   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a1e:	d4 d6       	rcall	.+3496   	; 0x17c8 <TWI_Transceiver_Busy>
     a20:	81 11       	cpse	r24, r1
     a22:	fd cf       	rjmp	.-6      	; 0xa1e <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     a24:	69 e0       	ldi	r22, 0x09	; 9
     a26:	8f ef       	ldi	r24, 0xFF	; 255
     a28:	94 e0       	ldi	r25, 0x04	; 4
     a2a:	fe d6       	rcall	.+3580   	; 0x1828 <TWI_Get_Data_From_Transceiver>
     a2c:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <TWI_XFER_STATUS>
     a30:	e0 e0       	ldi	r30, 0x00	; 0
     a32:	f5 e0       	ldi	r31, 0x05	; 5
     a34:	a8 e0       	ldi	r26, 0x08	; 8
     a36:	b6 e0       	ldi	r27, 0x06	; 6
     a38:	28 e0       	ldi	r18, 0x08	; 8
     a3a:	35 e0       	ldi	r19, 0x05	; 5
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a3c:	81 91       	ld	r24, Z+
     a3e:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a40:	e2 17       	cp	r30, r18
     a42:	f3 07       	cpc	r31, r19
     a44:	d9 f7       	brne	.-10     	; 0xa3c <bme280basic_bulk_data_read+0xa8>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a46:	e8 e0       	ldi	r30, 0x08	; 8
     a48:	f6 e0       	ldi	r31, 0x06	; 6
     a4a:	81 81       	ldd	r24, Z+1	; 0x01
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	b0 e0       	ldi	r27, 0x00	; 0
     a52:	88 0f       	add	r24, r24
     a54:	99 1f       	adc	r25, r25
     a56:	aa 1f       	adc	r26, r26
     a58:	bb 1f       	adc	r27, r27
     a5a:	88 0f       	add	r24, r24
     a5c:	99 1f       	adc	r25, r25
     a5e:	aa 1f       	adc	r26, r26
     a60:	bb 1f       	adc	r27, r27
     a62:	88 0f       	add	r24, r24
     a64:	99 1f       	adc	r25, r25
     a66:	aa 1f       	adc	r26, r26
     a68:	bb 1f       	adc	r27, r27
     a6a:	88 0f       	add	r24, r24
     a6c:	99 1f       	adc	r25, r25
     a6e:	aa 1f       	adc	r26, r26
     a70:	bb 1f       	adc	r27, r27
     a72:	40 81       	ld	r20, Z
     a74:	50 e0       	ldi	r21, 0x00	; 0
     a76:	60 e0       	ldi	r22, 0x00	; 0
     a78:	70 e0       	ldi	r23, 0x00	; 0
     a7a:	03 2e       	mov	r0, r19
     a7c:	3c e0       	ldi	r19, 0x0C	; 12
     a7e:	44 0f       	add	r20, r20
     a80:	55 1f       	adc	r21, r21
     a82:	66 1f       	adc	r22, r22
     a84:	77 1f       	adc	r23, r23
     a86:	3a 95       	dec	r19
     a88:	d1 f7       	brne	.-12     	; 0xa7e <bme280basic_bulk_data_read+0xea>
     a8a:	30 2d       	mov	r19, r0
     a8c:	84 2b       	or	r24, r20
     a8e:	95 2b       	or	r25, r21
     a90:	a6 2b       	or	r26, r22
     a92:	b7 2b       	or	r27, r23
     a94:	22 81       	ldd	r18, Z+2	; 0x02
     a96:	22 95       	swap	r18
     a98:	2f 70       	andi	r18, 0x0F	; 15
     a9a:	82 2b       	or	r24, r18
     a9c:	80 93 4e 06 	sts	0x064E, r24	; 0x80064e <rawPress>
     aa0:	90 93 4f 06 	sts	0x064F, r25	; 0x80064f <rawPress+0x1>
     aa4:	a0 93 50 06 	sts	0x0650, r26	; 0x800650 <rawPress+0x2>
     aa8:	b0 93 51 06 	sts	0x0651, r27	; 0x800651 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     aac:	84 81       	ldd	r24, Z+4	; 0x04
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	a0 e0       	ldi	r26, 0x00	; 0
     ab2:	b0 e0       	ldi	r27, 0x00	; 0
     ab4:	88 0f       	add	r24, r24
     ab6:	99 1f       	adc	r25, r25
     ab8:	aa 1f       	adc	r26, r26
     aba:	bb 1f       	adc	r27, r27
     abc:	88 0f       	add	r24, r24
     abe:	99 1f       	adc	r25, r25
     ac0:	aa 1f       	adc	r26, r26
     ac2:	bb 1f       	adc	r27, r27
     ac4:	88 0f       	add	r24, r24
     ac6:	99 1f       	adc	r25, r25
     ac8:	aa 1f       	adc	r26, r26
     aca:	bb 1f       	adc	r27, r27
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	aa 1f       	adc	r26, r26
     ad2:	bb 1f       	adc	r27, r27
     ad4:	43 81       	ldd	r20, Z+3	; 0x03
     ad6:	50 e0       	ldi	r21, 0x00	; 0
     ad8:	60 e0       	ldi	r22, 0x00	; 0
     ada:	70 e0       	ldi	r23, 0x00	; 0
     adc:	03 2e       	mov	r0, r19
     ade:	3c e0       	ldi	r19, 0x0C	; 12
     ae0:	44 0f       	add	r20, r20
     ae2:	55 1f       	adc	r21, r21
     ae4:	66 1f       	adc	r22, r22
     ae6:	77 1f       	adc	r23, r23
     ae8:	3a 95       	dec	r19
     aea:	d1 f7       	brne	.-12     	; 0xae0 <bme280basic_bulk_data_read+0x14c>
     aec:	30 2d       	mov	r19, r0
     aee:	84 2b       	or	r24, r20
     af0:	95 2b       	or	r25, r21
     af2:	a6 2b       	or	r26, r22
     af4:	b7 2b       	or	r27, r23
     af6:	25 81       	ldd	r18, Z+5	; 0x05
     af8:	22 95       	swap	r18
     afa:	2f 70       	andi	r18, 0x0F	; 15
     afc:	82 2b       	or	r24, r18
     afe:	80 93 36 06 	sts	0x0636, r24	; 0x800636 <rawTemp>
     b02:	90 93 37 06 	sts	0x0637, r25	; 0x800637 <rawTemp+0x1>
     b06:	a0 93 38 06 	sts	0x0638, r26	; 0x800638 <rawTemp+0x2>
     b0a:	b0 93 39 06 	sts	0x0639, r27	; 0x800639 <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     b0e:	86 81       	ldd	r24, Z+6	; 0x06
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	a0 e0       	ldi	r26, 0x00	; 0
     b14:	b0 e0       	ldi	r27, 0x00	; 0
     b16:	ba 2f       	mov	r27, r26
     b18:	a9 2f       	mov	r26, r25
     b1a:	98 2f       	mov	r25, r24
     b1c:	88 27       	eor	r24, r24
     b1e:	27 81       	ldd	r18, Z+7	; 0x07
     b20:	82 2b       	or	r24, r18
     b22:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <rawHum>
     b26:	90 93 53 06 	sts	0x0653, r25	; 0x800653 <rawHum+0x1>
     b2a:	a0 93 54 06 	sts	0x0654, r26	; 0x800654 <rawHum+0x2>
     b2e:	b0 93 55 06 	sts	0x0655, r27	; 0x800655 <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     b32:	ef ef       	ldi	r30, 0xFF	; 255
     b34:	f4 e0       	ldi	r31, 0x04	; 4
     b36:	8c ee       	ldi	r24, 0xEC	; 236
     b38:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b3a:	84 ef       	ldi	r24, 0xF4	; 244
     b3c:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b3e:	81 e3       	ldi	r24, 0x31	; 49
     b40:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b42:	63 e0       	ldi	r22, 0x03	; 3
     b44:	cf 01       	movw	r24, r30
     b46:	44 d6       	rcall	.+3208   	; 0x17d0 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b48:	3f d6       	rcall	.+3198   	; 0x17c8 <TWI_Transceiver_Busy>
     b4a:	81 11       	cpse	r24, r1
     b4c:	fd cf       	rjmp	.-6      	; 0xb48 <bme280basic_bulk_data_read+0x1b4>
	//  All done - and the next measurement cycle has  been kicked off!
}
     b4e:	df 91       	pop	r29
     b50:	cf 91       	pop	r28
     b52:	1f 91       	pop	r17
     b54:	0f 91       	pop	r16
     b56:	ff 90       	pop	r15
     b58:	08 95       	ret

00000b5a <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b5a:	8f 92       	push	r8
     b5c:	9f 92       	push	r9
     b5e:	af 92       	push	r10
     b60:	bf 92       	push	r11
     b62:	cf 92       	push	r12
     b64:	df 92       	push	r13
     b66:	ef 92       	push	r14
     b68:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b6a:	20 91 02 06 	lds	r18, 0x0602	; 0x800602 <dig_T1>
     b6e:	30 91 03 06 	lds	r19, 0x0603	; 0x800603 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b72:	6b 01       	movw	r12, r22
     b74:	7c 01       	movw	r14, r24
     b76:	68 94       	set
     b78:	13 f8       	bld	r1, 3
     b7a:	f5 94       	asr	r15
     b7c:	e7 94       	ror	r14
     b7e:	d7 94       	ror	r13
     b80:	c7 94       	ror	r12
     b82:	16 94       	lsr	r1
     b84:	d1 f7       	brne	.-12     	; 0xb7a <BME280_compensate_T_int32+0x20>
     b86:	c2 1a       	sub	r12, r18
     b88:	d3 0a       	sbc	r13, r19
     b8a:	e1 08       	sbc	r14, r1
     b8c:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of 5123 equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b8e:	dc 01       	movw	r26, r24
     b90:	cb 01       	movw	r24, r22
     b92:	68 94       	set
     b94:	12 f8       	bld	r1, 2
     b96:	b5 95       	asr	r27
     b98:	a7 95       	ror	r26
     b9a:	97 95       	ror	r25
     b9c:	87 95       	ror	r24
     b9e:	16 94       	lsr	r1
     ba0:	d1 f7       	brne	.-12     	; 0xb96 <BME280_compensate_T_int32+0x3c>
     ba2:	22 0f       	add	r18, r18
     ba4:	33 1f       	adc	r19, r19
     ba6:	4c 01       	movw	r8, r24
     ba8:	5d 01       	movw	r10, r26
     baa:	82 1a       	sub	r8, r18
     bac:	93 0a       	sbc	r9, r19
     bae:	a1 08       	sbc	r10, r1
     bb0:	b1 08       	sbc	r11, r1
     bb2:	a5 01       	movw	r20, r10
     bb4:	94 01       	movw	r18, r8
     bb6:	a0 91 06 06 	lds	r26, 0x0606	; 0x800606 <dig_T2>
     bba:	b0 91 07 06 	lds	r27, 0x0607	; 0x800607 <dig_T2+0x1>
     bbe:	ea d7       	rcall	.+4052   	; 0x1b94 <__mulshisi3>
     bc0:	4b 01       	movw	r8, r22
     bc2:	5c 01       	movw	r10, r24
     bc4:	07 2e       	mov	r0, r23
     bc6:	7b e0       	ldi	r23, 0x0B	; 11
     bc8:	b5 94       	asr	r11
     bca:	a7 94       	ror	r10
     bcc:	97 94       	ror	r9
     bce:	87 94       	ror	r8
     bd0:	7a 95       	dec	r23
     bd2:	d1 f7       	brne	.-12     	; 0xbc8 <BME280_compensate_T_int32+0x6e>
     bd4:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     bd6:	a7 01       	movw	r20, r14
     bd8:	96 01       	movw	r18, r12
     bda:	c7 01       	movw	r24, r14
     bdc:	b6 01       	movw	r22, r12
     bde:	bb d7       	rcall	.+3958   	; 0x1b56 <__mulsi3>
     be0:	9b 01       	movw	r18, r22
     be2:	ac 01       	movw	r20, r24
     be4:	01 2e       	mov	r0, r17
     be6:	1c e0       	ldi	r17, 0x0C	; 12
     be8:	55 95       	asr	r21
     bea:	47 95       	ror	r20
     bec:	37 95       	ror	r19
     bee:	27 95       	ror	r18
     bf0:	1a 95       	dec	r17
     bf2:	d1 f7       	brne	.-12     	; 0xbe8 <BME280_compensate_T_int32+0x8e>
     bf4:	10 2d       	mov	r17, r0
     bf6:	a0 91 64 06 	lds	r26, 0x0664	; 0x800664 <dig_T3>
     bfa:	b0 91 65 06 	lds	r27, 0x0665	; 0x800665 <dig_T3+0x1>
     bfe:	ca d7       	rcall	.+3988   	; 0x1b94 <__mulshisi3>
     c00:	dc 01       	movw	r26, r24
     c02:	cb 01       	movw	r24, r22
     c04:	07 2e       	mov	r0, r23
     c06:	7e e0       	ldi	r23, 0x0E	; 14
     c08:	b5 95       	asr	r27
     c0a:	a7 95       	ror	r26
     c0c:	97 95       	ror	r25
     c0e:	87 95       	ror	r24
     c10:	7a 95       	dec	r23
     c12:	d1 f7       	brne	.-12     	; 0xc08 <BME280_compensate_T_int32+0xae>
     c14:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     c16:	88 0d       	add	r24, r8
     c18:	99 1d       	adc	r25, r9
     c1a:	aa 1d       	adc	r26, r10
     c1c:	bb 1d       	adc	r27, r11
     c1e:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <t_fine>
     c22:	90 93 6b 06 	sts	0x066B, r25	; 0x80066b <t_fine+0x1>
     c26:	a0 93 6c 06 	sts	0x066C, r26	; 0x80066c <t_fine+0x2>
     c2a:	b0 93 6d 06 	sts	0x066D, r27	; 0x80066d <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     c2e:	6c 01       	movw	r12, r24
     c30:	7d 01       	movw	r14, r26
     c32:	cc 0c       	add	r12, r12
     c34:	dd 1c       	adc	r13, r13
     c36:	ee 1c       	adc	r14, r14
     c38:	ff 1c       	adc	r15, r15
     c3a:	cc 0c       	add	r12, r12
     c3c:	dd 1c       	adc	r13, r13
     c3e:	ee 1c       	adc	r14, r14
     c40:	ff 1c       	adc	r15, r15
     c42:	8c 0d       	add	r24, r12
     c44:	9d 1d       	adc	r25, r13
     c46:	ae 1d       	adc	r26, r14
     c48:	bf 1d       	adc	r27, r15
     c4a:	80 58       	subi	r24, 0x80	; 128
     c4c:	9f 4f       	sbci	r25, 0xFF	; 255
     c4e:	af 4f       	sbci	r26, 0xFF	; 255
     c50:	bf 4f       	sbci	r27, 0xFF	; 255
     c52:	69 2f       	mov	r22, r25
     c54:	7a 2f       	mov	r23, r26
     c56:	8b 2f       	mov	r24, r27
     c58:	99 27       	eor	r25, r25
     c5a:	87 fd       	sbrc	r24, 7
     c5c:	9a 95       	dec	r25
	return T;
}
     c5e:	ff 90       	pop	r15
     c60:	ef 90       	pop	r14
     c62:	df 90       	pop	r13
     c64:	cf 90       	pop	r12
     c66:	bf 90       	pop	r11
     c68:	af 90       	pop	r10
     c6a:	9f 90       	pop	r9
     c6c:	8f 90       	pop	r8
     c6e:	08 95       	ret

00000c70 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c70:	2f 92       	push	r2
     c72:	3f 92       	push	r3
     c74:	4f 92       	push	r4
     c76:	5f 92       	push	r5
     c78:	6f 92       	push	r6
     c7a:	7f 92       	push	r7
     c7c:	8f 92       	push	r8
     c7e:	9f 92       	push	r9
     c80:	af 92       	push	r10
     c82:	bf 92       	push	r11
     c84:	cf 92       	push	r12
     c86:	df 92       	push	r13
     c88:	ef 92       	push	r14
     c8a:	ff 92       	push	r15
     c8c:	0f 93       	push	r16
     c8e:	1f 93       	push	r17
     c90:	cf 93       	push	r28
     c92:	df 93       	push	r29
     c94:	cd b7       	in	r28, 0x3d	; 61
     c96:	de b7       	in	r29, 0x3e	; 62
     c98:	6e 97       	sbiw	r28, 0x1e	; 30
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	de bf       	out	0x3e, r29	; 62
     ca0:	0f be       	out	0x3f, r0	; 63
     ca2:	cd bf       	out	0x3d, r28	; 61
     ca4:	6e 8b       	std	Y+22, r22	; 0x16
     ca6:	7f 8b       	std	Y+23, r23	; 0x17
     ca8:	88 8f       	std	Y+24, r24	; 0x18
     caa:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     cac:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <t_fine>
     cb0:	90 91 6b 06 	lds	r25, 0x066B	; 0x80066b <t_fine+0x1>
     cb4:	a0 91 6c 06 	lds	r26, 0x066C	; 0x80066c <t_fine+0x2>
     cb8:	b0 91 6d 06 	lds	r27, 0x066D	; 0x80066d <t_fine+0x3>
     cbc:	8c 01       	movw	r16, r24
     cbe:	9d 01       	movw	r18, r26
     cc0:	14 5f       	subi	r17, 0xF4	; 244
     cc2:	21 40       	sbci	r18, 0x01	; 1
     cc4:	31 09       	sbc	r19, r1
     cc6:	09 83       	std	Y+1, r16	; 0x01
     cc8:	1a 83       	std	Y+2, r17	; 0x02
     cca:	2b 83       	std	Y+3, r18	; 0x03
     ccc:	3c 83       	std	Y+4, r19	; 0x04
     cce:	33 0f       	add	r19, r19
     cd0:	00 0b       	sbc	r16, r16
     cd2:	10 2f       	mov	r17, r16
     cd4:	98 01       	movw	r18, r16
     cd6:	0d 83       	std	Y+5, r16	; 0x05
     cd8:	1e 83       	std	Y+6, r17	; 0x06
     cda:	2f 83       	std	Y+7, r18	; 0x07
     cdc:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     cde:	a9 80       	ldd	r10, Y+1	; 0x01
     ce0:	ba 80       	ldd	r11, Y+2	; 0x02
     ce2:	cb 80       	ldd	r12, Y+3	; 0x03
     ce4:	dc 80       	ldd	r13, Y+4	; 0x04
     ce6:	ed 80       	ldd	r14, Y+5	; 0x05
     ce8:	fe 2c       	mov	r15, r14
     cea:	0e 2d       	mov	r16, r14
     cec:	1e 2d       	mov	r17, r14
     cee:	2a 2d       	mov	r18, r10
     cf0:	3b 2d       	mov	r19, r11
     cf2:	4c 2d       	mov	r20, r12
     cf4:	5d 2d       	mov	r21, r13
     cf6:	60 2f       	mov	r22, r16
     cf8:	70 2f       	mov	r23, r16
     cfa:	80 2f       	mov	r24, r16
     cfc:	9e 2d       	mov	r25, r14
     cfe:	50 d7       	rcall	.+3744   	; 0x1ba0 <__muldi3>
     d00:	2d 87       	std	Y+13, r18	; 0x0d
     d02:	3e 87       	std	Y+14, r19	; 0x0e
     d04:	4f 87       	std	Y+15, r20	; 0x0f
     d06:	58 8b       	std	Y+16, r21	; 0x10
     d08:	69 8b       	std	Y+17, r22	; 0x11
     d0a:	7a 8b       	std	Y+18, r23	; 0x12
     d0c:	8b 8b       	std	Y+19, r24	; 0x13
     d0e:	9c 8b       	std	Y+20, r25	; 0x14
     d10:	10 91 66 06 	lds	r17, 0x0666	; 0x800666 <dig_P6>
     d14:	1a 8f       	std	Y+26, r17	; 0x1a
     d16:	20 91 67 06 	lds	r18, 0x0667	; 0x800667 <dig_P6+0x1>
     d1a:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     d1c:	30 91 4b 06 	lds	r19, 0x064B	; 0x80064b <dig_P5>
     d20:	3b 8f       	std	Y+27, r19	; 0x1b
     d22:	40 91 4c 06 	lds	r20, 0x064C	; 0x80064c <dig_P5+0x1>
     d26:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     d28:	50 91 3c 06 	lds	r21, 0x063C	; 0x80063c <dig_P4>
     d2c:	5c 8f       	std	Y+28, r21	; 0x1c
     d2e:	80 91 3d 06 	lds	r24, 0x063D	; 0x80063d <dig_P4+0x1>
     d32:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     d34:	30 91 3b 06 	lds	r19, 0x063B	; 0x80063b <dig_P2+0x1>
     d38:	20 91 3a 06 	lds	r18, 0x063A	; 0x80063a <dig_P2>
     d3c:	93 2f       	mov	r25, r19
     d3e:	99 0f       	add	r25, r25
     d40:	99 0b       	sbc	r25, r25
     d42:	fe 2c       	mov	r15, r14
     d44:	0e 2d       	mov	r16, r14
     d46:	1e 2d       	mov	r17, r14
     d48:	49 2f       	mov	r20, r25
     d4a:	59 2f       	mov	r21, r25
     d4c:	69 2f       	mov	r22, r25
     d4e:	79 2f       	mov	r23, r25
     d50:	89 2f       	mov	r24, r25
     d52:	26 d7       	rcall	.+3660   	; 0x1ba0 <__muldi3>
     d54:	0c e0       	ldi	r16, 0x0C	; 12
     d56:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <__ashldi3>
     d5a:	42 2e       	mov	r4, r18
     d5c:	53 2e       	mov	r5, r19
     d5e:	64 2e       	mov	r6, r20
     d60:	75 2e       	mov	r7, r21
     d62:	86 2e       	mov	r8, r22
     d64:	97 2e       	mov	r9, r23
     d66:	28 2e       	mov	r2, r24
     d68:	39 2e       	mov	r3, r25
     d6a:	b0 90 5b 06 	lds	r11, 0x065B	; 0x80065b <dig_P3+0x1>
     d6e:	a0 90 5a 06 	lds	r10, 0x065A	; 0x80065a <dig_P3>
     d72:	1b 2d       	mov	r17, r11
     d74:	11 0f       	add	r17, r17
     d76:	11 0b       	sbc	r17, r17
     d78:	c1 2e       	mov	r12, r17
     d7a:	d1 2e       	mov	r13, r17
     d7c:	e1 2e       	mov	r14, r17
     d7e:	f1 2e       	mov	r15, r17
     d80:	01 2f       	mov	r16, r17
     d82:	2d 85       	ldd	r18, Y+13	; 0x0d
     d84:	3e 85       	ldd	r19, Y+14	; 0x0e
     d86:	4f 85       	ldd	r20, Y+15	; 0x0f
     d88:	58 89       	ldd	r21, Y+16	; 0x10
     d8a:	69 89       	ldd	r22, Y+17	; 0x11
     d8c:	7a 89       	ldd	r23, Y+18	; 0x12
     d8e:	8b 89       	ldd	r24, Y+19	; 0x13
     d90:	9c 89       	ldd	r25, Y+20	; 0x14
     d92:	06 d7       	rcall	.+3596   	; 0x1ba0 <__muldi3>
     d94:	08 e0       	ldi	r16, 0x08	; 8
     d96:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <__ashrdi3>
     d9a:	a4 2c       	mov	r10, r4
     d9c:	b5 2c       	mov	r11, r5
     d9e:	c6 2c       	mov	r12, r6
     da0:	d7 2c       	mov	r13, r7
     da2:	e8 2c       	mov	r14, r8
     da4:	f9 2c       	mov	r15, r9
     da6:	02 2d       	mov	r16, r2
     da8:	13 2d       	mov	r17, r3
     daa:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     dae:	70 58       	subi	r23, 0x80	; 128
     db0:	8f 4f       	sbci	r24, 0xFF	; 255
     db2:	9f 4f       	sbci	r25, 0xFF	; 255
     db4:	20 90 58 06 	lds	r2, 0x0658	; 0x800658 <dig_P1>
     db8:	30 90 59 06 	lds	r3, 0x0659	; 0x800659 <dig_P1+0x1>
     dbc:	a2 2c       	mov	r10, r2
     dbe:	b3 2c       	mov	r11, r3
     dc0:	c1 2c       	mov	r12, r1
     dc2:	d1 2c       	mov	r13, r1
     dc4:	e1 2c       	mov	r14, r1
     dc6:	f1 2c       	mov	r15, r1
     dc8:	00 e0       	ldi	r16, 0x00	; 0
     dca:	10 e0       	ldi	r17, 0x00	; 0
     dcc:	e9 d6       	rcall	.+3538   	; 0x1ba0 <__muldi3>
     dce:	01 e2       	ldi	r16, 0x21	; 33
     dd0:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <__ashrdi3>
     dd4:	29 87       	std	Y+9, r18	; 0x09
     dd6:	3a 87       	std	Y+10, r19	; 0x0a
     dd8:	4b 87       	std	Y+11, r20	; 0x0b
     dda:	45 2e       	mov	r4, r21
     ddc:	56 2e       	mov	r5, r22
     dde:	7c 87       	std	Y+12, r23	; 0x0c
     de0:	38 2e       	mov	r3, r24
     de2:	29 2e       	mov	r2, r25
	if (var1 == 0)
     de4:	65 2d       	mov	r22, r5
     de6:	83 2d       	mov	r24, r3
     de8:	92 2d       	mov	r25, r2
     dea:	a0 e0       	ldi	r26, 0x00	; 0
     dec:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <__cmpdi2_s8>
     df0:	09 f4       	brne	.+2      	; 0xdf4 <BME280_compensate_P_int64+0x184>
     df2:	6c c1       	rjmp	.+728    	; 0x10cc <BME280_compensate_P_int64+0x45c>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     df4:	aa 8c       	ldd	r10, Y+26	; 0x1a
     df6:	1e 8d       	ldd	r17, Y+30	; 0x1e
     df8:	11 0f       	add	r17, r17
     dfa:	11 0b       	sbc	r17, r17
     dfc:	be 8c       	ldd	r11, Y+30	; 0x1e
     dfe:	c1 2e       	mov	r12, r17
     e00:	d1 2e       	mov	r13, r17
     e02:	e1 2e       	mov	r14, r17
     e04:	f1 2e       	mov	r15, r17
     e06:	01 2f       	mov	r16, r17
     e08:	2d 85       	ldd	r18, Y+13	; 0x0d
     e0a:	3e 85       	ldd	r19, Y+14	; 0x0e
     e0c:	4f 85       	ldd	r20, Y+15	; 0x0f
     e0e:	58 89       	ldd	r21, Y+16	; 0x10
     e10:	69 89       	ldd	r22, Y+17	; 0x11
     e12:	7a 89       	ldd	r23, Y+18	; 0x12
     e14:	8b 89       	ldd	r24, Y+19	; 0x13
     e16:	9c 89       	ldd	r25, Y+20	; 0x14
     e18:	c3 d6       	rcall	.+3462   	; 0x1ba0 <__muldi3>
     e1a:	2d 87       	std	Y+13, r18	; 0x0d
     e1c:	3e 87       	std	Y+14, r19	; 0x0e
     e1e:	64 2e       	mov	r6, r20
     e20:	75 2e       	mov	r7, r21
     e22:	86 2e       	mov	r8, r22
     e24:	97 2e       	mov	r9, r23
     e26:	88 8b       	std	Y+16, r24	; 0x10
     e28:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     e2a:	2b 8d       	ldd	r18, Y+27	; 0x1b
     e2c:	9d 8d       	ldd	r25, Y+29	; 0x1d
     e2e:	99 0f       	add	r25, r25
     e30:	99 0b       	sbc	r25, r25
     e32:	a9 80       	ldd	r10, Y+1	; 0x01
     e34:	ba 80       	ldd	r11, Y+2	; 0x02
     e36:	cb 80       	ldd	r12, Y+3	; 0x03
     e38:	dc 80       	ldd	r13, Y+4	; 0x04
     e3a:	ed 80       	ldd	r14, Y+5	; 0x05
     e3c:	fe 2c       	mov	r15, r14
     e3e:	0e 2d       	mov	r16, r14
     e40:	1e 2d       	mov	r17, r14
     e42:	3d 8d       	ldd	r19, Y+29	; 0x1d
     e44:	49 2f       	mov	r20, r25
     e46:	59 2f       	mov	r21, r25
     e48:	69 2f       	mov	r22, r25
     e4a:	79 2f       	mov	r23, r25
     e4c:	89 2f       	mov	r24, r25
     e4e:	a8 d6       	rcall	.+3408   	; 0x1ba0 <__muldi3>
     e50:	01 e1       	ldi	r16, 0x11	; 17
     e52:	c7 d7       	rcall	.+3982   	; 0x1de2 <__ashldi3>
     e54:	ad 84       	ldd	r10, Y+13	; 0x0d
     e56:	be 84       	ldd	r11, Y+14	; 0x0e
     e58:	c6 2c       	mov	r12, r6
     e5a:	d7 2c       	mov	r13, r7
     e5c:	e8 2c       	mov	r14, r8
     e5e:	f9 2c       	mov	r15, r9
     e60:	08 89       	ldd	r16, Y+16	; 0x10
     e62:	1f 85       	ldd	r17, Y+15	; 0x0f
     e64:	f5 d7       	rcall	.+4074   	; 0x1e50 <__adddi3>
     e66:	a2 2e       	mov	r10, r18
     e68:	b3 2e       	mov	r11, r19
     e6a:	c4 2e       	mov	r12, r20
     e6c:	d5 2e       	mov	r13, r21
     e6e:	e6 2e       	mov	r14, r22
     e70:	f7 2e       	mov	r15, r23
     e72:	e8 2f       	mov	r30, r24
     e74:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	a0 e1       	ldi	r26, 0x10	; 16
     e7c:	b0 e0       	ldi	r27, 0x00	; 0
     e7e:	2e 89       	ldd	r18, Y+22	; 0x16
     e80:	3f 89       	ldd	r19, Y+23	; 0x17
     e82:	48 8d       	ldd	r20, Y+24	; 0x18
     e84:	59 8d       	ldd	r21, Y+25	; 0x19
     e86:	82 1b       	sub	r24, r18
     e88:	93 0b       	sbc	r25, r19
     e8a:	a4 0b       	sbc	r26, r20
     e8c:	b5 0b       	sbc	r27, r21
     e8e:	3c 01       	movw	r6, r24
     e90:	4d 01       	movw	r8, r26
     e92:	99 0c       	add	r9, r9
     e94:	66 08       	sbc	r6, r6
     e96:	76 2c       	mov	r7, r6
     e98:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     e9a:	28 2f       	mov	r18, r24
     e9c:	39 2f       	mov	r19, r25
     e9e:	4a 2f       	mov	r20, r26
     ea0:	5b 2f       	mov	r21, r27
     ea2:	66 2d       	mov	r22, r6
     ea4:	76 2d       	mov	r23, r6
     ea6:	86 2d       	mov	r24, r6
     ea8:	96 2d       	mov	r25, r6
     eaa:	0f e1       	ldi	r16, 0x1F	; 31
     eac:	9a d7       	rcall	.+3892   	; 0x1de2 <__ashldi3>
     eae:	82 2e       	mov	r8, r18
     eb0:	93 2e       	mov	r9, r19
     eb2:	f4 2f       	mov	r31, r20
     eb4:	75 2e       	mov	r7, r21
     eb6:	b6 2f       	mov	r27, r22
     eb8:	a7 2f       	mov	r26, r23
     eba:	68 2e       	mov	r6, r24
     ebc:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     ebe:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ec0:	9d 89       	ldd	r25, Y+21	; 0x15
     ec2:	99 0f       	add	r25, r25
     ec4:	99 0b       	sbc	r25, r25
     ec6:	3d 89       	ldd	r19, Y+21	; 0x15
     ec8:	49 2f       	mov	r20, r25
     eca:	59 2f       	mov	r21, r25
     ecc:	69 2f       	mov	r22, r25
     ece:	79 2f       	mov	r23, r25
     ed0:	89 2f       	mov	r24, r25
     ed2:	03 e2       	ldi	r16, 0x23	; 35
     ed4:	86 d7       	rcall	.+3852   	; 0x1de2 <__ashldi3>
     ed6:	0e 2f       	mov	r16, r30
     ed8:	bb d7       	rcall	.+3958   	; 0x1e50 <__adddi3>
     eda:	a2 2e       	mov	r10, r18
     edc:	b3 2e       	mov	r11, r19
     ede:	c4 2e       	mov	r12, r20
     ee0:	d5 2e       	mov	r13, r21
     ee2:	e6 2e       	mov	r14, r22
     ee4:	f7 2e       	mov	r15, r23
     ee6:	08 2f       	mov	r16, r24
     ee8:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     eea:	28 2d       	mov	r18, r8
     eec:	39 2d       	mov	r19, r9
     eee:	4f 2f       	mov	r20, r31
     ef0:	57 2d       	mov	r21, r7
     ef2:	6b 2f       	mov	r22, r27
     ef4:	7a 2f       	mov	r23, r26
     ef6:	86 2d       	mov	r24, r6
     ef8:	9d 81       	ldd	r25, Y+5	; 0x05
     efa:	b3 d7       	rcall	.+3942   	; 0x1e62 <__subdi3>
     efc:	82 2e       	mov	r8, r18
     efe:	93 2e       	mov	r9, r19
     f00:	49 83       	std	Y+1, r20	; 0x01
     f02:	65 2e       	mov	r6, r21
     f04:	b6 2f       	mov	r27, r22
     f06:	a7 2f       	mov	r26, r23
     f08:	f8 2f       	mov	r31, r24
     f0a:	e9 2f       	mov	r30, r25
     f0c:	03 e0       	ldi	r16, 0x03	; 3
     f0e:	69 d7       	rcall	.+3794   	; 0x1de2 <__ashldi3>
     f10:	a8 2c       	mov	r10, r8
     f12:	b9 2c       	mov	r11, r9
     f14:	c9 80       	ldd	r12, Y+1	; 0x01
     f16:	d6 2c       	mov	r13, r6
     f18:	eb 2e       	mov	r14, r27
     f1a:	fa 2e       	mov	r15, r26
     f1c:	0f 2f       	mov	r16, r31
     f1e:	1e 2f       	mov	r17, r30
     f20:	a0 d7       	rcall	.+3904   	; 0x1e62 <__subdi3>
     f22:	a2 2e       	mov	r10, r18
     f24:	b3 2e       	mov	r11, r19
     f26:	c4 2e       	mov	r12, r20
     f28:	d5 2e       	mov	r13, r21
     f2a:	e6 2e       	mov	r14, r22
     f2c:	f7 2e       	mov	r15, r23
     f2e:	78 2e       	mov	r7, r24
     f30:	19 2f       	mov	r17, r25
     f32:	03 e0       	ldi	r16, 0x03	; 3
     f34:	56 d7       	rcall	.+3756   	; 0x1de2 <__ashldi3>
     f36:	07 2d       	mov	r16, r7
     f38:	94 d7       	rcall	.+3880   	; 0x1e62 <__subdi3>
     f3a:	03 e0       	ldi	r16, 0x03	; 3
     f3c:	52 d7       	rcall	.+3748   	; 0x1de2 <__ashldi3>
     f3e:	a8 2c       	mov	r10, r8
     f40:	b9 2c       	mov	r11, r9
     f42:	c9 80       	ldd	r12, Y+1	; 0x01
     f44:	d6 2c       	mov	r13, r6
     f46:	eb 2e       	mov	r14, r27
     f48:	fa 2e       	mov	r15, r26
     f4a:	0f 2f       	mov	r16, r31
     f4c:	1e 2f       	mov	r17, r30
     f4e:	89 d7       	rcall	.+3858   	; 0x1e62 <__subdi3>
     f50:	02 e0       	ldi	r16, 0x02	; 2
     f52:	47 d7       	rcall	.+3726   	; 0x1de2 <__ashldi3>
     f54:	0f 2f       	mov	r16, r31
     f56:	85 d7       	rcall	.+3850   	; 0x1e62 <__subdi3>
     f58:	01 e0       	ldi	r16, 0x01	; 1
     f5a:	43 d7       	rcall	.+3718   	; 0x1de2 <__ashldi3>
     f5c:	0f 2f       	mov	r16, r31
     f5e:	81 d7       	rcall	.+3842   	; 0x1e62 <__subdi3>
     f60:	a9 84       	ldd	r10, Y+9	; 0x09
     f62:	ba 84       	ldd	r11, Y+10	; 0x0a
     f64:	cb 84       	ldd	r12, Y+11	; 0x0b
     f66:	d4 2c       	mov	r13, r4
     f68:	e5 2c       	mov	r14, r5
     f6a:	fc 84       	ldd	r15, Y+12	; 0x0c
     f6c:	03 2d       	mov	r16, r3
     f6e:	12 2d       	mov	r17, r2
     f70:	6a d6       	rcall	.+3284   	; 0x1c46 <__divdi3>
     f72:	2e 87       	std	Y+14, r18	; 0x0e
     f74:	3d 87       	std	Y+13, r19	; 0x0d
     f76:	49 83       	std	Y+1, r20	; 0x01
     f78:	5d 83       	std	Y+5, r21	; 0x05
     f7a:	69 87       	std	Y+9, r22	; 0x09
     f7c:	7a 87       	std	Y+10, r23	; 0x0a
     f7e:	8b 87       	std	Y+11, r24	; 0x0b
     f80:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     f82:	0d e0       	ldi	r16, 0x0D	; 13
     f84:	47 d7       	rcall	.+3726   	; 0x1e14 <__ashrdi3>
     f86:	82 2e       	mov	r8, r18
     f88:	93 2e       	mov	r9, r19
     f8a:	74 2e       	mov	r7, r20
     f8c:	65 2e       	mov	r6, r21
     f8e:	56 2e       	mov	r5, r22
     f90:	47 2e       	mov	r4, r23
     f92:	38 2e       	mov	r3, r24
     f94:	29 2e       	mov	r2, r25
     f96:	30 91 63 06 	lds	r19, 0x0663	; 0x800663 <dig_P9+0x1>
     f9a:	20 91 62 06 	lds	r18, 0x0662	; 0x800662 <dig_P9>
     f9e:	93 2f       	mov	r25, r19
     fa0:	99 0f       	add	r25, r25
     fa2:	99 0b       	sbc	r25, r25
     fa4:	a8 2c       	mov	r10, r8
     fa6:	b9 2c       	mov	r11, r9
     fa8:	c7 2c       	mov	r12, r7
     faa:	d6 2c       	mov	r13, r6
     fac:	e5 2c       	mov	r14, r5
     fae:	f4 2c       	mov	r15, r4
     fb0:	03 2d       	mov	r16, r3
     fb2:	12 2d       	mov	r17, r2
     fb4:	49 2f       	mov	r20, r25
     fb6:	59 2f       	mov	r21, r25
     fb8:	69 2f       	mov	r22, r25
     fba:	79 2f       	mov	r23, r25
     fbc:	89 2f       	mov	r24, r25
     fbe:	f0 d5       	rcall	.+3040   	; 0x1ba0 <__muldi3>
     fc0:	a2 2e       	mov	r10, r18
     fc2:	b3 2e       	mov	r11, r19
     fc4:	c4 2e       	mov	r12, r20
     fc6:	d5 2e       	mov	r13, r21
     fc8:	e6 2e       	mov	r14, r22
     fca:	f7 2e       	mov	r15, r23
     fcc:	08 2f       	mov	r16, r24
     fce:	19 2f       	mov	r17, r25
     fd0:	28 2d       	mov	r18, r8
     fd2:	39 2d       	mov	r19, r9
     fd4:	47 2d       	mov	r20, r7
     fd6:	56 2d       	mov	r21, r6
     fd8:	65 2d       	mov	r22, r5
     fda:	74 2d       	mov	r23, r4
     fdc:	83 2d       	mov	r24, r3
     fde:	92 2d       	mov	r25, r2
     fe0:	df d5       	rcall	.+3006   	; 0x1ba0 <__muldi3>
     fe2:	09 e1       	ldi	r16, 0x19	; 25
     fe4:	17 d7       	rcall	.+3630   	; 0x1e14 <__ashrdi3>
     fe6:	a2 2e       	mov	r10, r18
     fe8:	b3 2e       	mov	r11, r19
     fea:	c4 2e       	mov	r12, r20
     fec:	d5 2e       	mov	r13, r21
     fee:	e6 2e       	mov	r14, r22
     ff0:	f7 2e       	mov	r15, r23
     ff2:	08 2f       	mov	r16, r24
     ff4:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
     ff6:	2e 85       	ldd	r18, Y+14	; 0x0e
     ff8:	3d 85       	ldd	r19, Y+13	; 0x0d
     ffa:	49 81       	ldd	r20, Y+1	; 0x01
     ffc:	5d 81       	ldd	r21, Y+5	; 0x05
     ffe:	69 85       	ldd	r22, Y+9	; 0x09
    1000:	7a 85       	ldd	r23, Y+10	; 0x0a
    1002:	8b 85       	ldd	r24, Y+11	; 0x0b
    1004:	9c 85       	ldd	r25, Y+12	; 0x0c
    1006:	24 d7       	rcall	.+3656   	; 0x1e50 <__adddi3>
    1008:	22 2e       	mov	r2, r18
    100a:	33 2e       	mov	r3, r19
    100c:	44 2e       	mov	r4, r20
    100e:	55 2e       	mov	r5, r21
    1010:	66 2e       	mov	r6, r22
    1012:	77 2e       	mov	r7, r23
    1014:	88 2e       	mov	r8, r24
    1016:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
    1018:	30 91 5d 06 	lds	r19, 0x065D	; 0x80065d <dig_P8+0x1>
    101c:	20 91 5c 06 	lds	r18, 0x065C	; 0x80065c <dig_P8>
    1020:	93 2f       	mov	r25, r19
    1022:	99 0f       	add	r25, r25
    1024:	99 0b       	sbc	r25, r25
    1026:	ae 84       	ldd	r10, Y+14	; 0x0e
    1028:	bd 84       	ldd	r11, Y+13	; 0x0d
    102a:	c9 80       	ldd	r12, Y+1	; 0x01
    102c:	dd 80       	ldd	r13, Y+5	; 0x05
    102e:	e9 84       	ldd	r14, Y+9	; 0x09
    1030:	fa 84       	ldd	r15, Y+10	; 0x0a
    1032:	0b 85       	ldd	r16, Y+11	; 0x0b
    1034:	1c 85       	ldd	r17, Y+12	; 0x0c
    1036:	49 2f       	mov	r20, r25
    1038:	59 2f       	mov	r21, r25
    103a:	69 2f       	mov	r22, r25
    103c:	79 2f       	mov	r23, r25
    103e:	89 2f       	mov	r24, r25
    1040:	af d5       	rcall	.+2910   	; 0x1ba0 <__muldi3>
    1042:	03 e1       	ldi	r16, 0x13	; 19
    1044:	e7 d6       	rcall	.+3534   	; 0x1e14 <__ashrdi3>
    1046:	a2 2e       	mov	r10, r18
    1048:	b3 2e       	mov	r11, r19
    104a:	c4 2e       	mov	r12, r20
    104c:	d5 2e       	mov	r13, r21
    104e:	e6 2e       	mov	r14, r22
    1050:	f7 2e       	mov	r15, r23
    1052:	08 2f       	mov	r16, r24
    1054:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1056:	22 2d       	mov	r18, r2
    1058:	33 2d       	mov	r19, r3
    105a:	44 2d       	mov	r20, r4
    105c:	55 2d       	mov	r21, r5
    105e:	66 2d       	mov	r22, r6
    1060:	77 2d       	mov	r23, r7
    1062:	88 2d       	mov	r24, r8
    1064:	99 2d       	mov	r25, r9
    1066:	f4 d6       	rcall	.+3560   	; 0x1e50 <__adddi3>
    1068:	08 e0       	ldi	r16, 0x08	; 8
    106a:	d4 d6       	rcall	.+3496   	; 0x1e14 <__ashrdi3>
    106c:	40 90 00 06 	lds	r4, 0x0600	; 0x800600 <dig_P7>
    1070:	50 90 01 06 	lds	r5, 0x0601	; 0x800601 <dig_P7+0x1>
    1074:	05 2c       	mov	r0, r5
    1076:	00 0c       	add	r0, r0
    1078:	66 08       	sbc	r6, r6
    107a:	77 08       	sbc	r7, r7
    107c:	44 0c       	add	r4, r4
    107e:	55 1c       	adc	r5, r5
    1080:	66 1c       	adc	r6, r6
    1082:	77 1c       	adc	r7, r7
    1084:	44 0c       	add	r4, r4
    1086:	55 1c       	adc	r5, r5
    1088:	66 1c       	adc	r6, r6
    108a:	77 1c       	adc	r7, r7
    108c:	44 0c       	add	r4, r4
    108e:	55 1c       	adc	r5, r5
    1090:	66 1c       	adc	r6, r6
    1092:	77 1c       	adc	r7, r7
    1094:	44 0c       	add	r4, r4
    1096:	55 1c       	adc	r5, r5
    1098:	66 1c       	adc	r6, r6
    109a:	77 1c       	adc	r7, r7
    109c:	83 01       	movw	r16, r6
    109e:	72 01       	movw	r14, r4
    10a0:	11 0f       	add	r17, r17
    10a2:	ee 08       	sbc	r14, r14
    10a4:	fe 2c       	mov	r15, r14
    10a6:	87 01       	movw	r16, r14
    10a8:	e9 82       	std	Y+1, r14	; 0x01
    10aa:	fa 82       	std	Y+2, r15	; 0x02
    10ac:	0b 83       	std	Y+3, r16	; 0x03
    10ae:	1c 83       	std	Y+4, r17	; 0x04
    10b0:	a4 2c       	mov	r10, r4
    10b2:	b5 2c       	mov	r11, r5
    10b4:	c6 2c       	mov	r12, r6
    10b6:	d7 2c       	mov	r13, r7
    10b8:	e9 80       	ldd	r14, Y+1	; 0x01
    10ba:	fe 2c       	mov	r15, r14
    10bc:	0e 2d       	mov	r16, r14
    10be:	1e 2d       	mov	r17, r14
    10c0:	c7 d6       	rcall	.+3470   	; 0x1e50 <__adddi3>
	return(long)p;
    10c2:	62 2f       	mov	r22, r18
    10c4:	73 2f       	mov	r23, r19
    10c6:	84 2f       	mov	r24, r20
    10c8:	95 2f       	mov	r25, r21
    10ca:	04 c0       	rjmp	.+8      	; 0x10d4 <BME280_compensate_P_int64+0x464>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    10cc:	60 e0       	ldi	r22, 0x00	; 0
    10ce:	70 e0       	ldi	r23, 0x00	; 0
    10d0:	80 e0       	ldi	r24, 0x00	; 0
    10d2:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    10d4:	6e 96       	adiw	r28, 0x1e	; 30
    10d6:	0f b6       	in	r0, 0x3f	; 63
    10d8:	f8 94       	cli
    10da:	de bf       	out	0x3e, r29	; 62
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	cd bf       	out	0x3d, r28	; 61
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	df 90       	pop	r13
    10ee:	cf 90       	pop	r12
    10f0:	bf 90       	pop	r11
    10f2:	af 90       	pop	r10
    10f4:	9f 90       	pop	r9
    10f6:	8f 90       	pop	r8
    10f8:	7f 90       	pop	r7
    10fa:	6f 90       	pop	r6
    10fc:	5f 90       	pop	r5
    10fe:	4f 90       	pop	r4
    1100:	3f 90       	pop	r3
    1102:	2f 90       	pop	r2
    1104:	08 95       	ret

00001106 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    1106:	2f 92       	push	r2
    1108:	3f 92       	push	r3
    110a:	4f 92       	push	r4
    110c:	5f 92       	push	r5
    110e:	6f 92       	push	r6
    1110:	7f 92       	push	r7
    1112:	8f 92       	push	r8
    1114:	9f 92       	push	r9
    1116:	af 92       	push	r10
    1118:	bf 92       	push	r11
    111a:	cf 92       	push	r12
    111c:	df 92       	push	r13
    111e:	ef 92       	push	r14
    1120:	ff 92       	push	r15
    1122:	0f 93       	push	r16
    1124:	1f 93       	push	r17
    1126:	cf 93       	push	r28
    1128:	df 93       	push	r29
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    112e:	67 97       	sbiw	r28, 0x17	; 23
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	de bf       	out	0x3e, r29	; 62
    1136:	0f be       	out	0x3f, r0	; 63
    1138:	cd bf       	out	0x3d, r28	; 61
    113a:	2b 01       	movw	r4, r22
    113c:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    113e:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <t_fine>
    1142:	90 91 6b 06 	lds	r25, 0x066B	; 0x80066b <t_fine+0x1>
    1146:	a0 91 6c 06 	lds	r26, 0x066C	; 0x80066c <t_fine+0x2>
    114a:	b0 91 6d 06 	lds	r27, 0x066D	; 0x80066d <t_fine+0x3>
    114e:	6c 01       	movw	r12, r24
    1150:	7d 01       	movw	r14, r26
    1152:	ff 0c       	add	r15, r15
    1154:	cc 08       	sbc	r12, r12
    1156:	dc 2c       	mov	r13, r12
    1158:	76 01       	movw	r14, r12
    115a:	28 2f       	mov	r18, r24
    115c:	39 2f       	mov	r19, r25
    115e:	4a 2f       	mov	r20, r26
    1160:	5b 2f       	mov	r21, r27
    1162:	6c 2d       	mov	r22, r12
    1164:	7c 2d       	mov	r23, r12
    1166:	8c 2d       	mov	r24, r12
    1168:	9c 2d       	mov	r25, r12
    116a:	3c 52       	subi	r19, 0x2C	; 44
    116c:	41 40       	sbci	r20, 0x01	; 1
    116e:	51 09       	sbc	r21, r1
    1170:	61 09       	sbc	r22, r1
    1172:	71 09       	sbc	r23, r1
    1174:	81 09       	sbc	r24, r1
    1176:	91 09       	sbc	r25, r1
    1178:	2f 8b       	std	Y+23, r18	; 0x17
    117a:	3e 8b       	std	Y+22, r19	; 0x16
    117c:	49 83       	std	Y+1, r20	; 0x01
    117e:	59 87       	std	Y+9, r21	; 0x09
    1180:	6a 87       	std	Y+10, r22	; 0x0a
    1182:	7b 87       	std	Y+11, r23	; 0x0b
    1184:	8c 87       	std	Y+12, r24	; 0x0c
    1186:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1188:	03 2e       	mov	r0, r19
    118a:	3e e0       	ldi	r19, 0x0E	; 14
    118c:	44 0c       	add	r4, r4
    118e:	55 1c       	adc	r5, r5
    1190:	66 1c       	adc	r6, r6
    1192:	77 1c       	adc	r7, r7
    1194:	3a 95       	dec	r19
    1196:	d1 f7       	brne	.-12     	; 0x118c <bme280_compensate_H_int32+0x86>
    1198:	30 2d       	mov	r19, r0
    119a:	53 01       	movw	r10, r6
    119c:	42 01       	movw	r8, r4
    119e:	bb 0c       	add	r11, r11
    11a0:	88 08       	sbc	r8, r8
    11a2:	98 2c       	mov	r9, r8
    11a4:	54 01       	movw	r10, r8
    11a6:	30 91 05 06 	lds	r19, 0x0605	; 0x800605 <dig_H4+0x1>
    11aa:	20 91 04 06 	lds	r18, 0x0604	; 0x800604 <dig_H4>
    11ae:	93 2f       	mov	r25, r19
    11b0:	99 0f       	add	r25, r25
    11b2:	99 0b       	sbc	r25, r25
    11b4:	49 2f       	mov	r20, r25
    11b6:	59 2f       	mov	r21, r25
    11b8:	69 2f       	mov	r22, r25
    11ba:	79 2f       	mov	r23, r25
    11bc:	89 2f       	mov	r24, r25
    11be:	04 e1       	ldi	r16, 0x14	; 20
    11c0:	10 d6       	rcall	.+3104   	; 0x1de2 <__ashldi3>
    11c2:	f2 2f       	mov	r31, r18
    11c4:	e3 2f       	mov	r30, r19
    11c6:	c4 2e       	mov	r12, r20
    11c8:	d5 2e       	mov	r13, r21
    11ca:	e6 2e       	mov	r14, r22
    11cc:	f7 2e       	mov	r15, r23
    11ce:	08 2f       	mov	r16, r24
    11d0:	19 2f       	mov	r17, r25
    11d2:	24 2d       	mov	r18, r4
    11d4:	35 2d       	mov	r19, r5
    11d6:	46 2d       	mov	r20, r6
    11d8:	57 2d       	mov	r21, r7
    11da:	68 2d       	mov	r22, r8
    11dc:	78 2d       	mov	r23, r8
    11de:	88 2d       	mov	r24, r8
    11e0:	98 2d       	mov	r25, r8
    11e2:	af 2e       	mov	r10, r31
    11e4:	be 2e       	mov	r11, r30
    11e6:	3d d6       	rcall	.+3194   	; 0x1e62 <__subdi3>
    11e8:	22 2e       	mov	r2, r18
    11ea:	33 2e       	mov	r3, r19
    11ec:	44 2e       	mov	r4, r20
    11ee:	55 2e       	mov	r5, r21
    11f0:	66 2e       	mov	r6, r22
    11f2:	77 2e       	mov	r7, r23
    11f4:	88 2e       	mov	r8, r24
    11f6:	99 2e       	mov	r9, r25
    11f8:	30 91 5f 06 	lds	r19, 0x065F	; 0x80065f <dig_H5+0x1>
    11fc:	20 91 5e 06 	lds	r18, 0x065E	; 0x80065e <dig_H5>
    1200:	93 2f       	mov	r25, r19
    1202:	99 0f       	add	r25, r25
    1204:	99 0b       	sbc	r25, r25
    1206:	af 88       	ldd	r10, Y+23	; 0x17
    1208:	be 88       	ldd	r11, Y+22	; 0x16
    120a:	c9 80       	ldd	r12, Y+1	; 0x01
    120c:	d9 84       	ldd	r13, Y+9	; 0x09
    120e:	ea 84       	ldd	r14, Y+10	; 0x0a
    1210:	fb 84       	ldd	r15, Y+11	; 0x0b
    1212:	0c 85       	ldd	r16, Y+12	; 0x0c
    1214:	1d 85       	ldd	r17, Y+13	; 0x0d
    1216:	49 2f       	mov	r20, r25
    1218:	59 2f       	mov	r21, r25
    121a:	69 2f       	mov	r22, r25
    121c:	79 2f       	mov	r23, r25
    121e:	89 2f       	mov	r24, r25
    1220:	bf d4       	rcall	.+2430   	; 0x1ba0 <__muldi3>
    1222:	a2 2e       	mov	r10, r18
    1224:	b3 2e       	mov	r11, r19
    1226:	c4 2e       	mov	r12, r20
    1228:	d5 2e       	mov	r13, r21
    122a:	e6 2e       	mov	r14, r22
    122c:	f7 2e       	mov	r15, r23
    122e:	08 2f       	mov	r16, r24
    1230:	19 2f       	mov	r17, r25
    1232:	22 2d       	mov	r18, r2
    1234:	33 2d       	mov	r19, r3
    1236:	44 2d       	mov	r20, r4
    1238:	55 2d       	mov	r21, r5
    123a:	66 2d       	mov	r22, r6
    123c:	77 2d       	mov	r23, r7
    123e:	88 2d       	mov	r24, r8
    1240:	99 2d       	mov	r25, r9
    1242:	0f d6       	rcall	.+3102   	; 0x1e62 <__subdi3>
    1244:	30 5c       	subi	r19, 0xC0	; 192
    1246:	4f 4f       	sbci	r20, 0xFF	; 255
    1248:	5f 4f       	sbci	r21, 0xFF	; 255
    124a:	6f 4f       	sbci	r22, 0xFF	; 255
    124c:	7f 4f       	sbci	r23, 0xFF	; 255
    124e:	8f 4f       	sbci	r24, 0xFF	; 255
    1250:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    1252:	0f e0       	ldi	r16, 0x0F	; 15
    1254:	df d5       	rcall	.+3006   	; 0x1e14 <__ashrdi3>
    1256:	2e 87       	std	Y+14, r18	; 0x0e
    1258:	3f 87       	std	Y+15, r19	; 0x0f
    125a:	48 8b       	std	Y+16, r20	; 0x10
    125c:	59 8b       	std	Y+17, r21	; 0x11
    125e:	6a 8b       	std	Y+18, r22	; 0x12
    1260:	7b 8b       	std	Y+19, r23	; 0x13
    1262:	8c 8b       	std	Y+20, r24	; 0x14
    1264:	9d 8b       	std	Y+21, r25	; 0x15
    1266:	30 91 46 06 	lds	r19, 0x0646	; 0x800646 <dig_H6+0x1>
    126a:	20 91 45 06 	lds	r18, 0x0645	; 0x800645 <dig_H6>
    126e:	93 2f       	mov	r25, r19
    1270:	99 0f       	add	r25, r25
    1272:	99 0b       	sbc	r25, r25
    1274:	af 88       	ldd	r10, Y+23	; 0x17
    1276:	be 88       	ldd	r11, Y+22	; 0x16
    1278:	c9 80       	ldd	r12, Y+1	; 0x01
    127a:	d9 84       	ldd	r13, Y+9	; 0x09
    127c:	ea 84       	ldd	r14, Y+10	; 0x0a
    127e:	fb 84       	ldd	r15, Y+11	; 0x0b
    1280:	0c 85       	ldd	r16, Y+12	; 0x0c
    1282:	1d 85       	ldd	r17, Y+13	; 0x0d
    1284:	49 2f       	mov	r20, r25
    1286:	59 2f       	mov	r21, r25
    1288:	69 2f       	mov	r22, r25
    128a:	79 2f       	mov	r23, r25
    128c:	89 2f       	mov	r24, r25
    128e:	88 d4       	rcall	.+2320   	; 0x1ba0 <__muldi3>
    1290:	0a e0       	ldi	r16, 0x0A	; 10
    1292:	c0 d5       	rcall	.+2944   	; 0x1e14 <__ashrdi3>
    1294:	82 2e       	mov	r8, r18
    1296:	93 2e       	mov	r9, r19
    1298:	74 2e       	mov	r7, r20
    129a:	65 2e       	mov	r6, r21
    129c:	56 2e       	mov	r5, r22
    129e:	47 2e       	mov	r4, r23
    12a0:	38 2e       	mov	r3, r24
    12a2:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12a4:	40 91 60 06 	lds	r20, 0x0660	; 0x800660 <dig_H3>
    12a8:	50 91 61 06 	lds	r21, 0x0661	; 0x800661 <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12ac:	0c 85       	ldd	r16, Y+12	; 0x0c
    12ae:	24 2f       	mov	r18, r20
    12b0:	35 2f       	mov	r19, r21
    12b2:	40 e0       	ldi	r20, 0x00	; 0
    12b4:	50 e0       	ldi	r21, 0x00	; 0
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	70 e0       	ldi	r23, 0x00	; 0
    12ba:	80 e0       	ldi	r24, 0x00	; 0
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	70 d4       	rcall	.+2272   	; 0x1ba0 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12c0:	0b e0       	ldi	r16, 0x0B	; 11
    12c2:	a8 d5       	rcall	.+2896   	; 0x1e14 <__ashrdi3>
    12c4:	30 58       	subi	r19, 0x80	; 128
    12c6:	4f 4f       	sbci	r20, 0xFF	; 255
    12c8:	5f 4f       	sbci	r21, 0xFF	; 255
    12ca:	6f 4f       	sbci	r22, 0xFF	; 255
    12cc:	7f 4f       	sbci	r23, 0xFF	; 255
    12ce:	8f 4f       	sbci	r24, 0xFF	; 255
    12d0:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12d2:	a2 2e       	mov	r10, r18
    12d4:	b3 2e       	mov	r11, r19
    12d6:	c4 2e       	mov	r12, r20
    12d8:	d5 2e       	mov	r13, r21
    12da:	e6 2e       	mov	r14, r22
    12dc:	f7 2e       	mov	r15, r23
    12de:	08 2f       	mov	r16, r24
    12e0:	19 2f       	mov	r17, r25
    12e2:	28 2d       	mov	r18, r8
    12e4:	39 2d       	mov	r19, r9
    12e6:	47 2d       	mov	r20, r7
    12e8:	56 2d       	mov	r21, r6
    12ea:	65 2d       	mov	r22, r5
    12ec:	74 2d       	mov	r23, r4
    12ee:	83 2d       	mov	r24, r3
    12f0:	92 2d       	mov	r25, r2
    12f2:	56 d4       	rcall	.+2220   	; 0x1ba0 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12f4:	0a e0       	ldi	r16, 0x0A	; 10
    12f6:	8e d5       	rcall	.+2844   	; 0x1e14 <__ashrdi3>
    12f8:	40 5e       	subi	r20, 0xE0	; 224
    12fa:	5f 4f       	sbci	r21, 0xFF	; 255
    12fc:	6f 4f       	sbci	r22, 0xFF	; 255
    12fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1300:	8f 4f       	sbci	r24, 0xFF	; 255
    1302:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
    1304:	b0 90 69 06 	lds	r11, 0x0669	; 0x800669 <dig_H2+0x1>
    1308:	a0 90 68 06 	lds	r10, 0x0668	; 0x800668 <dig_H2>
    130c:	1b 2d       	mov	r17, r11
    130e:	11 0f       	add	r17, r17
    1310:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1312:	c1 2e       	mov	r12, r17
    1314:	d1 2e       	mov	r13, r17
    1316:	e1 2e       	mov	r14, r17
    1318:	f1 2e       	mov	r15, r17
    131a:	01 2f       	mov	r16, r17
    131c:	41 d4       	rcall	.+2178   	; 0x1ba0 <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    131e:	30 5e       	subi	r19, 0xE0	; 224
    1320:	4f 4f       	sbci	r20, 0xFF	; 255
    1322:	5f 4f       	sbci	r21, 0xFF	; 255
    1324:	6f 4f       	sbci	r22, 0xFF	; 255
    1326:	7f 4f       	sbci	r23, 0xFF	; 255
    1328:	8f 4f       	sbci	r24, 0xFF	; 255
    132a:	9f 4f       	sbci	r25, 0xFF	; 255
    132c:	0e e0       	ldi	r16, 0x0E	; 14
    132e:	72 d5       	rcall	.+2788   	; 0x1e14 <__ashrdi3>
// Output value of 47445 represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1330:	a2 2e       	mov	r10, r18
    1332:	b3 2e       	mov	r11, r19
    1334:	c4 2e       	mov	r12, r20
    1336:	d5 2e       	mov	r13, r21
    1338:	e6 2e       	mov	r14, r22
    133a:	f7 2e       	mov	r15, r23
    133c:	08 2f       	mov	r16, r24
    133e:	19 2f       	mov	r17, r25
    1340:	2e 85       	ldd	r18, Y+14	; 0x0e
    1342:	3f 85       	ldd	r19, Y+15	; 0x0f
    1344:	48 89       	ldd	r20, Y+16	; 0x10
    1346:	59 89       	ldd	r21, Y+17	; 0x11
    1348:	6a 89       	ldd	r22, Y+18	; 0x12
    134a:	7b 89       	ldd	r23, Y+19	; 0x13
    134c:	8c 89       	ldd	r24, Y+20	; 0x14
    134e:	9d 89       	ldd	r25, Y+21	; 0x15
    1350:	27 d4       	rcall	.+2126   	; 0x1ba0 <__muldi3>
    1352:	42 2e       	mov	r4, r18
    1354:	53 2e       	mov	r5, r19
    1356:	64 2e       	mov	r6, r20
    1358:	75 2e       	mov	r7, r21
    135a:	86 2e       	mov	r8, r22
    135c:	97 2e       	mov	r9, r23
    135e:	28 2e       	mov	r2, r24
    1360:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    1362:	0f e0       	ldi	r16, 0x0F	; 15
    1364:	57 d5       	rcall	.+2734   	; 0x1e14 <__ashrdi3>
    1366:	a2 2e       	mov	r10, r18
    1368:	b3 2e       	mov	r11, r19
    136a:	c4 2e       	mov	r12, r20
    136c:	d5 2e       	mov	r13, r21
    136e:	e6 2e       	mov	r14, r22
    1370:	f7 2e       	mov	r15, r23
    1372:	08 2f       	mov	r16, r24
    1374:	19 2f       	mov	r17, r25
    1376:	14 d4       	rcall	.+2088   	; 0x1ba0 <__muldi3>
    1378:	07 e0       	ldi	r16, 0x07	; 7
    137a:	4c d5       	rcall	.+2712   	; 0x1e14 <__ashrdi3>
    137c:	e0 91 34 06 	lds	r30, 0x0634	; 0x800634 <dig_H1>
    1380:	f0 91 35 06 	lds	r31, 0x0635	; 0x800635 <dig_H1+0x1>
    1384:	5f 01       	movw	r10, r30
    1386:	c1 2c       	mov	r12, r1
    1388:	d1 2c       	mov	r13, r1
    138a:	e1 2c       	mov	r14, r1
    138c:	f1 2c       	mov	r15, r1
    138e:	87 01       	movw	r16, r14
    1390:	e9 83       	std	Y+1, r30	; 0x01
    1392:	ba 82       	std	Y+2, r11	; 0x02
    1394:	cb 82       	std	Y+3, r12	; 0x03
    1396:	dc 82       	std	Y+4, r13	; 0x04
    1398:	ed 82       	std	Y+5, r14	; 0x05
    139a:	fe 82       	std	Y+6, r15	; 0x06
    139c:	0f 83       	std	Y+7, r16	; 0x07
    139e:	18 87       	std	Y+8, r17	; 0x08
    13a0:	c1 2c       	mov	r12, r1
    13a2:	d1 2c       	mov	r13, r1
    13a4:	e1 2c       	mov	r14, r1
    13a6:	f1 2c       	mov	r15, r1
    13a8:	00 e0       	ldi	r16, 0x00	; 0
    13aa:	10 e0       	ldi	r17, 0x00	; 0
    13ac:	f9 d3       	rcall	.+2034   	; 0x1ba0 <__muldi3>
    13ae:	04 e0       	ldi	r16, 0x04	; 4
    13b0:	31 d5       	rcall	.+2658   	; 0x1e14 <__ashrdi3>
    13b2:	a2 2e       	mov	r10, r18
    13b4:	b3 2e       	mov	r11, r19
    13b6:	c4 2e       	mov	r12, r20
    13b8:	d5 2e       	mov	r13, r21
    13ba:	e6 2e       	mov	r14, r22
    13bc:	f7 2e       	mov	r15, r23
    13be:	08 2f       	mov	r16, r24
    13c0:	19 2f       	mov	r17, r25
    13c2:	24 2d       	mov	r18, r4
    13c4:	35 2d       	mov	r19, r5
    13c6:	46 2d       	mov	r20, r6
    13c8:	57 2d       	mov	r21, r7
    13ca:	68 2d       	mov	r22, r8
    13cc:	79 2d       	mov	r23, r9
    13ce:	82 2d       	mov	r24, r2
    13d0:	93 2d       	mov	r25, r3
    13d2:	47 d5       	rcall	.+2702   	; 0x1e62 <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    13d4:	f2 2e       	mov	r15, r18
    13d6:	03 2f       	mov	r16, r19
    13d8:	14 2f       	mov	r17, r20
    13da:	65 2e       	mov	r6, r21
    13dc:	76 2e       	mov	r7, r22
    13de:	b7 2f       	mov	r27, r23
    13e0:	f8 2f       	mov	r31, r24
    13e2:	e9 2f       	mov	r30, r25
    13e4:	a0 e0       	ldi	r26, 0x00	; 0
    13e6:	46 d5       	rcall	.+2700   	; 0x1e74 <__cmpdi2_s8>
    13e8:	44 f4       	brge	.+16     	; 0x13fa <bme280_compensate_H_int32+0x2f4>
    13ea:	f1 2c       	mov	r15, r1
    13ec:	00 e0       	ldi	r16, 0x00	; 0
    13ee:	10 e0       	ldi	r17, 0x00	; 0
    13f0:	61 2c       	mov	r6, r1
    13f2:	71 2c       	mov	r7, r1
    13f4:	b0 e0       	ldi	r27, 0x00	; 0
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    13fa:	8f 2c       	mov	r8, r15
    13fc:	90 2e       	mov	r9, r16
    13fe:	a1 2e       	mov	r10, r17
    1400:	b6 2c       	mov	r11, r6
    1402:	c7 2c       	mov	r12, r7
    1404:	db 2e       	mov	r13, r27
    1406:	ef 2e       	mov	r14, r31
    1408:	ae 2f       	mov	r26, r30
    140a:	2f 2d       	mov	r18, r15
    140c:	30 2f       	mov	r19, r16
    140e:	41 2f       	mov	r20, r17
    1410:	56 2d       	mov	r21, r6
    1412:	67 2d       	mov	r22, r7
    1414:	7b 2f       	mov	r23, r27
    1416:	8f 2f       	mov	r24, r31
    1418:	9e 2f       	mov	r25, r30
    141a:	21 15       	cp	r18, r1
    141c:	31 05       	cpc	r19, r1
    141e:	41 05       	cpc	r20, r1
    1420:	59 41       	sbci	r21, 0x19	; 25
    1422:	61 05       	cpc	r22, r1
    1424:	71 05       	cpc	r23, r1
    1426:	81 05       	cpc	r24, r1
    1428:	91 05       	cpc	r25, r1
    142a:	61 f0       	breq	.+24     	; 0x1444 <bme280_compensate_H_int32+0x33e>
    142c:	5c f0       	brlt	.+22     	; 0x1444 <bme280_compensate_H_int32+0x33e>
    142e:	81 2c       	mov	r8, r1
    1430:	91 2c       	mov	r9, r1
    1432:	a1 2c       	mov	r10, r1
    1434:	0f 2e       	mov	r0, r31
    1436:	f9 e1       	ldi	r31, 0x19	; 25
    1438:	bf 2e       	mov	r11, r31
    143a:	f0 2d       	mov	r31, r0
    143c:	c1 2c       	mov	r12, r1
    143e:	d1 2c       	mov	r13, r1
    1440:	e1 2c       	mov	r14, r1
    1442:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    1444:	28 2d       	mov	r18, r8
    1446:	39 2d       	mov	r19, r9
    1448:	4a 2d       	mov	r20, r10
    144a:	5b 2d       	mov	r21, r11
    144c:	6c 2d       	mov	r22, r12
    144e:	7d 2d       	mov	r23, r13
    1450:	8e 2d       	mov	r24, r14
    1452:	9a 2f       	mov	r25, r26
    1454:	0c e0       	ldi	r16, 0x0C	; 12
    1456:	de d4       	rcall	.+2492   	; 0x1e14 <__ashrdi3>
    1458:	62 2f       	mov	r22, r18
    145a:	73 2f       	mov	r23, r19
    145c:	84 2f       	mov	r24, r20
    145e:	95 2f       	mov	r25, r21
}
    1460:	67 96       	adiw	r28, 0x17	; 23
    1462:	0f b6       	in	r0, 0x3f	; 63
    1464:	f8 94       	cli
    1466:	de bf       	out	0x3e, r29	; 62
    1468:	0f be       	out	0x3f, r0	; 63
    146a:	cd bf       	out	0x3d, r28	; 61
    146c:	df 91       	pop	r29
    146e:	cf 91       	pop	r28
    1470:	1f 91       	pop	r17
    1472:	0f 91       	pop	r16
    1474:	ff 90       	pop	r15
    1476:	ef 90       	pop	r14
    1478:	df 90       	pop	r13
    147a:	cf 90       	pop	r12
    147c:	bf 90       	pop	r11
    147e:	af 90       	pop	r10
    1480:	9f 90       	pop	r9
    1482:	8f 90       	pop	r8
    1484:	7f 90       	pop	r7
    1486:	6f 90       	pop	r6
    1488:	5f 90       	pop	r5
    148a:	4f 90       	pop	r4
    148c:	3f 90       	pop	r3
    148e:	2f 90       	pop	r2
    1490:	08 95       	ret

00001492 <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    1492:	0e 94 54 01 	call	0x2a8	; 0x2a8 <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    1496:	10 92 57 06 	sts	0x0657, r1	; 0x800657 <seconds+0x1>
    149a:	10 92 56 06 	sts	0x0656, r1	; 0x800656 <seconds>
	ItsTime=0;
    149e:	10 92 bc 04 	sts	0x04BC, r1	; 0x8004bc <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout0;
    14a2:	8b e2       	ldi	r24, 0x2B	; 43
    14a4:	91 e0       	ldi	r25, 0x01	; 1
    14a6:	90 93 71 08 	sts	0x0871, r25	; 0x800871 <__iob+0x3>
    14aa:	80 93 70 08 	sts	0x0870, r24	; 0x800870 <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	initialize_timer_counter_1();
    14ae:	5f d1       	rcall	.+702    	; 0x176e <initialize_timer_counter_1>
	//
	// Initialize timer counter 0 for 100Hz interrupt (used for SD card debug only)
	// initialize_timer_counter_0();  // ONLY ENABLE if using SD card
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    14b0:	81 e8       	ldi	r24, 0x81	; 129
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	58 d2       	rcall	.+1200   	; 0x1966 <USART0_init>
	USART1_init(MYUBRR1);
    14b6:	81 e8       	ldi	r24, 0x81	; 129
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	c9 d2       	rcall	.+1426   	; 0x1a4e <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    14bc:	7b d1       	rcall	.+758    	; 0x17b4 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    14be:	0e 94 b6 00 	call	0x16c	; 0x16c <ADC_init>
	//
	// FOR DEBUG ONLY: Initialize the RGB sensor - Craig uses this to ensure I2C is working
//	RGBsensor_init();
	//
 	// initialize the gas sensors
	gas_sensors_init();
    14c2:	0e 94 a1 01 	call	0x342	; 0x342 <gas_sensors_init>
	// 
	// Start all interrupts
	sei();
    14c6:	78 94       	sei
	//
	// Initialize the pressure / temperature /  humidity sensor
	// BME280_init(); 
	//
	// Check the BME interface...
	bme280basic_init();
    14c8:	09 da       	rcall	.-3054   	; 0x8dc <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	91 e0       	ldi	r25, 0x01	; 1
    14ce:	88 d2       	rcall	.+1296   	; 0x19e0 <USART0_putstring>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14d0:	2f e7       	ldi	r18, 0x7F	; 127
    14d2:	84 e8       	ldi	r24, 0x84	; 132
    14d4:	9e e1       	ldi	r25, 0x1E	; 30
    14d6:	21 50       	subi	r18, 0x01	; 1
    14d8:	80 40       	sbci	r24, 0x00	; 0
    14da:	90 40       	sbci	r25, 0x00	; 0
    14dc:	e1 f7       	brne	.-8      	; 0x14d6 <main+0x44>
    14de:	00 c0       	rjmp	.+0      	; 0x14e0 <main+0x4e>
    14e0:	00 00       	nop
	// ====================================================
	////////////////////////////////////////////////////////////////////////////
 	// *************************************************************************
 	// main loop
 	// *************************************************************************
    printf("hi ");
    14e2:	8a e3       	ldi	r24, 0x3A	; 58
    14e4:	91 e0       	ldi	r25, 0x01	; 1
    14e6:	9f 93       	push	r25
    14e8:	8f 93       	push	r24
    14ea:	df d4       	rcall	.+2494   	; 0x1eaa <printf>
    14ec:	0f 90       	pop	r0
    14ee:	0f 90       	pop	r0
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u \n", seconds);
    14f0:	0f 2e       	mov	r0, r31
    14f2:	fe e3       	ldi	r31, 0x3E	; 62
    14f4:	af 2e       	mov	r10, r31
    14f6:	f1 e0       	ldi	r31, 0x01	; 1
    14f8:	bf 2e       	mov	r11, r31
    14fa:	f0 2d       	mov	r31, r0
    14fc:	c6 eb       	ldi	r28, 0xB6	; 182
    14fe:	d7 e0       	ldi	r29, 0x07	; 7
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
    1500:	0f 2e       	mov	r0, r31
    1502:	fe e4       	ldi	r31, 0x4E	; 78
    1504:	8f 2e       	mov	r8, r31
    1506:	f1 e0       	ldi	r31, 0x01	; 1
    1508:	9f 2e       	mov	r9, r31
    150a:	f0 2d       	mov	r31, r0
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
    150c:	0f 2e       	mov	r0, r31
    150e:	f3 e6       	ldi	r31, 0x63	; 99
    1510:	6f 2e       	mov	r6, r31
    1512:	f1 e0       	ldi	r31, 0x01	; 1
    1514:	7f 2e       	mov	r7, r31
    1516:	f0 2d       	mov	r31, r0
			// Now test the gas sensor interface...
			start_gas_sensor_read();
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    1518:	0f 2e       	mov	r0, r31
    151a:	fb ed       	ldi	r31, 0xDB	; 219
    151c:	ef 2e       	mov	r14, r31
    151e:	f4 e0       	ldi	r31, 0x04	; 4
    1520:	ff 2e       	mov	r15, r31
    1522:	f0 2d       	mov	r31, r0
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
			tempCelsius = BME280_compensate_T_int32(rawTemp);
 			printf("\nCelsius = %lu\n", tempCelsius);
    1524:	0f 2e       	mov	r0, r31
    1526:	fe e2       	ldi	r31, 0x2E	; 46
    1528:	cf 2e       	mov	r12, r31
    152a:	f2 e0       	ldi	r31, 0x02	; 2
    152c:	df 2e       	mov	r13, r31
    152e:	f0 2d       	mov	r31, r0
		// USART0_TransmitByte(USART0_ReceiveByte());
		//////////////////////////////////////////////////////////
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second...
		
		if (ItsTime == 1){ //wait for our 1Hz flag
    1530:	80 91 bc 04 	lds	r24, 0x04BC	; 0x8004bc <ItsTime>
    1534:	81 30       	cpi	r24, 0x01	; 1
    1536:	e1 f7       	brne	.-8      	; 0x1530 <main+0x9e>
			ItsTime = 0; 
    1538:	10 92 bc 04 	sts	0x04BC, r1	; 0x8004bc <ItsTime>
			seconds++;
    153c:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <seconds>
    1540:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <seconds+0x1>
    1544:	01 96       	adiw	r24, 0x01	; 1
    1546:	90 93 57 06 	sts	0x0657, r25	; 0x800657 <seconds+0x1>
    154a:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <seconds>
			printf("\nSeconds = %u \n", seconds);
    154e:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <seconds>
    1552:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <seconds+0x1>
    1556:	9f 93       	push	r25
    1558:	8f 93       	push	r24
    155a:	bf 92       	push	r11
    155c:	af 92       	push	r10
    155e:	a5 d4       	rcall	.+2378   	; 0x1eaa <printf>
    1560:	0e e6       	ldi	r16, 0x6E	; 110
    1562:	17 e0       	ldi	r17, 0x07	; 7
    1564:	0f 90       	pop	r0
    1566:	0f 90       	pop	r0
    1568:	0f 90       	pop	r0
    156a:	0f 90       	pop	r0
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
			{
				USART0_TransmitByte(messageWant[i]);
    156c:	d8 01       	movw	r26, r16
    156e:	8d 91       	ld	r24, X+
    1570:	8d 01       	movw	r16, r26
    1572:	0c d2       	rcall	.+1048   	; 0x198c <USART0_TransmitByte>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//USART0_putstring(&messageWant[0]);
			
			for (uint8_t i = 0; i<= 71; i++)
    1574:	0c 17       	cp	r16, r28
    1576:	1d 07       	cpc	r17, r29
    1578:	c9 f7       	brne	.-14     	; 0x156c <main+0xda>
			printf("\n=================");
			//============================
	*/		//
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
    157a:	02 d8       	rcall	.-4092   	; 0x580 <LIDAR_distance>
    157c:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <distance>
    1580:	90 93 d7 04 	sts	0x04D7, r25	; 0x8004d7 <distance+0x1>
			printf("\nLIDAR distance = %u", distance);
    1584:	9f 93       	push	r25
    1586:	8f 93       	push	r24
    1588:	9f 92       	push	r9
    158a:	8f 92       	push	r8
    158c:	8e d4       	rcall	.+2332   	; 0x1eaa <printf>
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
    158e:	80 91 d7 04 	lds	r24, 0x04D7	; 0x8004d7 <distance+0x1>
    1592:	8f 93       	push	r24
    1594:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <distance>
    1598:	8f 93       	push	r24
    159a:	7f 92       	push	r7
    159c:	6f 92       	push	r6
    159e:	85 d4       	rcall	.+2314   	; 0x1eaa <printf>
			for (uint8_t i = 8; i<= 13; i++)//adds in time
			{
				USART0_TransmitByte(messageWant[i]);
    15a0:	80 91 76 07 	lds	r24, 0x0776	; 0x800776 <messageWant+0x8>
    15a4:	f3 d1       	rcall	.+998    	; 0x198c <USART0_TransmitByte>
    15a6:	0f 2e       	mov	r0, r31
    15a8:	f7 e7       	ldi	r31, 0x77	; 119
    15aa:	4f 2e       	mov	r4, r31
    15ac:	f7 e0       	ldi	r31, 0x07	; 7
    15ae:	5f 2e       	mov	r5, r31
    15b0:	f0 2d       	mov	r31, r0
    15b2:	ed b7       	in	r30, 0x3d	; 61
    15b4:	fe b7       	in	r31, 0x3e	; 62
    15b6:	38 96       	adiw	r30, 0x08	; 8
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	fe bf       	out	0x3e, r31	; 62
    15be:	0f be       	out	0x3f, r0	; 63
    15c0:	ed bf       	out	0x3d, r30	; 61
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    15c2:	18 e0       	ldi	r17, 0x08	; 8
    15c4:	09 c0       	rjmp	.+18     	; 0x15d8 <main+0x146>
			{
				USART0_TransmitByte(messageWant[i]);
    15c6:	d2 01       	movw	r26, r4
    15c8:	8d 91       	ld	r24, X+
    15ca:	2d 01       	movw	r4, r26
    15cc:	df d1       	rcall	.+958    	; 0x198c <USART0_TransmitByte>
				if (i%2 ==1)
    15ce:	10 ff       	sbrs	r17, 0
    15d0:	03 c0       	rjmp	.+6      	; 0x15d8 <main+0x146>
				{
					printf(":");
    15d2:	8a e3       	ldi	r24, 0x3A	; 58
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    15d6:	7c d4       	rcall	.+2296   	; 0x1ed0 <putchar>
			//============================
			 //Now test reading the LIDAR interface
			distance = LIDAR_distance();
			printf("\nLIDAR distance = %u", distance);
			printf("\n LiDAR message = http://canary.chordsrt.com/measurements/url_create?instrument_id=3&dist=%u&key=4e6fba7420ec9e881f510bcddb&", distance); //need key
			for (uint8_t i = 8; i<= 13; i++)//adds in time
    15d8:	1f 5f       	subi	r17, 0xFF	; 255
    15da:	1e 30       	cpi	r17, 0x0E	; 14
    15dc:	a1 f7       	brne	.-24     	; 0x15c6 <main+0x134>
				if (i%2 ==1)
				{
					printf(":");
				}
			}
			printf("Z");
    15de:	8a e5       	ldi	r24, 0x5A	; 90
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	76 d4       	rcall	.+2284   	; 0x1ed0 <putchar>
			// Davita has this routine specified in the notebook.
			//============================
			//
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    15e4:	0e 94 20 02 	call	0x440	; 0x440 <start_gas_sensor_read>
			// Note that this is a blocking read (stops all other activity)
			// At present, the print statements are in that routine....
			//...but the routine needs to be redesigned to operate in the background
 			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
    15e8:	f7 01       	movw	r30, r14
    15ea:	81 81       	ldd	r24, Z+1	; 0x01
    15ec:	8f 93       	push	r24
    15ee:	80 81       	ld	r24, Z
    15f0:	8f 93       	push	r24
    15f2:	a0 ee       	ldi	r26, 0xE0	; 224
    15f4:	b1 e0       	ldi	r27, 0x01	; 1
    15f6:	bf 93       	push	r27
    15f8:	af 93       	push	r26
    15fa:	57 d4       	rcall	.+2222   	; 0x1eaa <printf>
 			printf("\nHydrogen = %u", raw_gas_vector[1]);
    15fc:	d7 01       	movw	r26, r14
    15fe:	13 96       	adiw	r26, 0x03	; 3
    1600:	8c 91       	ld	r24, X
    1602:	13 97       	sbiw	r26, 0x03	; 3
    1604:	8f 93       	push	r24
    1606:	12 96       	adiw	r26, 0x02	; 2
    1608:	8c 91       	ld	r24, X
    160a:	8f 93       	push	r24
    160c:	a6 ef       	ldi	r26, 0xF6	; 246
    160e:	b1 e0       	ldi	r27, 0x01	; 1
    1610:	bf 93       	push	r27
    1612:	af 93       	push	r26
    1614:	4a d4       	rcall	.+2196   	; 0x1eaa <printf>
 			printf("\nAmmonia = %u", raw_gas_vector[2]);
    1616:	d7 01       	movw	r26, r14
    1618:	15 96       	adiw	r26, 0x05	; 5
    161a:	8c 91       	ld	r24, X
    161c:	15 97       	sbiw	r26, 0x05	; 5
    161e:	8f 93       	push	r24
    1620:	14 96       	adiw	r26, 0x04	; 4
    1622:	8c 91       	ld	r24, X
    1624:	8f 93       	push	r24
    1626:	a5 e0       	ldi	r26, 0x05	; 5
    1628:	b2 e0       	ldi	r27, 0x02	; 2
    162a:	bf 93       	push	r27
    162c:	af 93       	push	r26
    162e:	3d d4       	rcall	.+2170   	; 0x1eaa <printf>
 			printf("\nMethane = %u", raw_gas_vector[3]);
    1630:	d7 01       	movw	r26, r14
    1632:	17 96       	adiw	r26, 0x07	; 7
    1634:	8c 91       	ld	r24, X
    1636:	17 97       	sbiw	r26, 0x07	; 7
    1638:	8f 93       	push	r24
    163a:	16 96       	adiw	r26, 0x06	; 6
    163c:	8c 91       	ld	r24, X
    163e:	8f 93       	push	r24
    1640:	a3 e1       	ldi	r26, 0x13	; 19
    1642:	b2 e0       	ldi	r27, 0x02	; 2
    1644:	bf 93       	push	r27
    1646:	af 93       	push	r26
    1648:	30 d4       	rcall	.+2144   	; 0x1eaa <printf>
 			printf("\nOzone = %u\n", raw_gas_vector[4]);
    164a:	d7 01       	movw	r26, r14
    164c:	19 96       	adiw	r26, 0x09	; 9
    164e:	8c 91       	ld	r24, X
    1650:	19 97       	sbiw	r26, 0x09	; 9
    1652:	8f 93       	push	r24
    1654:	18 96       	adiw	r26, 0x08	; 8
    1656:	8c 91       	ld	r24, X
    1658:	8f 93       	push	r24
    165a:	a1 e2       	ldi	r26, 0x21	; 33
    165c:	b2 e0       	ldi	r27, 0x02	; 2
    165e:	bf 93       	push	r27
    1660:	af 93       	push	r26
    1662:	23 d4       	rcall	.+2118   	; 0x1eaa <printf>
			// Now test the BME interface...
			// THIS ROUTINE NOT YET WRITTEN
			//============================
			//
			// That completes the sensor sweep
			bme280basic_bulk_data_read();
    1664:	97 d9       	rcall	.-3282   	; 0x994 <bme280basic_bulk_data_read>
			tempCelsius = BME280_compensate_T_int32(rawTemp);
    1666:	60 91 36 06 	lds	r22, 0x0636	; 0x800636 <rawTemp>
    166a:	70 91 37 06 	lds	r23, 0x0637	; 0x800637 <rawTemp+0x1>
    166e:	80 91 38 06 	lds	r24, 0x0638	; 0x800638 <rawTemp+0x2>
    1672:	90 91 39 06 	lds	r25, 0x0639	; 0x800639 <rawTemp+0x3>
    1676:	71 da       	rcall	.-2846   	; 0xb5a <BME280_compensate_T_int32>
    1678:	60 93 30 06 	sts	0x0630, r22	; 0x800630 <tempCelsius>
    167c:	70 93 31 06 	sts	0x0631, r23	; 0x800631 <tempCelsius+0x1>
    1680:	80 93 32 06 	sts	0x0632, r24	; 0x800632 <tempCelsius+0x2>
    1684:	90 93 33 06 	sts	0x0633, r25	; 0x800633 <tempCelsius+0x3>
 			printf("\nCelsius = %lu\n", tempCelsius);
    1688:	9f 93       	push	r25
    168a:	8f 93       	push	r24
    168c:	7f 93       	push	r23
    168e:	6f 93       	push	r22
    1690:	df 92       	push	r13
    1692:	cf 92       	push	r12
    1694:	0a d4       	rcall	.+2068   	; 0x1eaa <printf>
			pressure = BME280_compensate_P_int64(rawPress);
    1696:	60 91 4e 06 	lds	r22, 0x064E	; 0x80064e <rawPress>
    169a:	70 91 4f 06 	lds	r23, 0x064F	; 0x80064f <rawPress+0x1>
    169e:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <rawPress+0x2>
    16a2:	90 91 51 06 	lds	r25, 0x0651	; 0x800651 <rawPress+0x3>
    16a6:	e4 da       	rcall	.-2616   	; 0xc70 <BME280_compensate_P_int64>
    16a8:	60 93 3f 06 	sts	0x063F, r22	; 0x80063f <pressure>
    16ac:	70 93 40 06 	sts	0x0640, r23	; 0x800640 <pressure+0x1>
    16b0:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <pressure+0x2>
    16b4:	90 93 42 06 	sts	0x0642, r25	; 0x800642 <pressure+0x3>
			printf("\nPressure in Pa = %lu\n", pressure>>8);
    16b8:	bb 27       	eor	r27, r27
    16ba:	97 fd       	sbrc	r25, 7
    16bc:	ba 95       	dec	r27
    16be:	a9 2f       	mov	r26, r25
    16c0:	98 2f       	mov	r25, r24
    16c2:	87 2f       	mov	r24, r23
    16c4:	bf 93       	push	r27
    16c6:	af 93       	push	r26
    16c8:	9f 93       	push	r25
    16ca:	8f 93       	push	r24
    16cc:	8e e3       	ldi	r24, 0x3E	; 62
    16ce:	92 e0       	ldi	r25, 0x02	; 2
    16d0:	9f 93       	push	r25
    16d2:	8f 93       	push	r24
    16d4:	ea d3       	rcall	.+2004   	; 0x1eaa <printf>
			humidity = bme280_compensate_H_int32(rawHum);
    16d6:	8d b7       	in	r24, 0x3d	; 61
    16d8:	9e b7       	in	r25, 0x3e	; 62
    16da:	80 96       	adiw	r24, 0x20	; 32
    16dc:	0f b6       	in	r0, 0x3f	; 63
    16de:	f8 94       	cli
    16e0:	9e bf       	out	0x3e, r25	; 62
    16e2:	0f be       	out	0x3f, r0	; 63
    16e4:	8d bf       	out	0x3d, r24	; 61
    16e6:	60 91 52 06 	lds	r22, 0x0652	; 0x800652 <rawHum>
    16ea:	70 91 53 06 	lds	r23, 0x0653	; 0x800653 <rawHum+0x1>
    16ee:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <rawHum+0x2>
    16f2:	90 91 55 06 	lds	r25, 0x0655	; 0x800655 <rawHum+0x3>
    16f6:	07 dd       	rcall	.-1522   	; 0x1106 <bme280_compensate_H_int32>
    16f8:	1b 01       	movw	r2, r22
    16fa:	2c 01       	movw	r4, r24
    16fc:	60 93 47 06 	sts	0x0647, r22	; 0x800647 <humidity>
    1700:	70 93 48 06 	sts	0x0648, r23	; 0x800648 <humidity+0x1>
    1704:	80 93 49 06 	sts	0x0649, r24	; 0x800649 <humidity+0x2>
    1708:	90 93 4a 06 	sts	0x064A, r25	; 0x80064a <humidity+0x3>
			printf("\n Humidity in percent relative humidity= %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    170c:	a8 ee       	ldi	r26, 0xE8	; 232
    170e:	b3 e0       	ldi	r27, 0x03	; 3
    1710:	9b 01       	movw	r18, r22
    1712:	ac 01       	movw	r20, r24
    1714:	35 d2       	rcall	.+1130   	; 0x1b80 <__muluhisi3>
    1716:	dc 01       	movw	r26, r24
    1718:	cb 01       	movw	r24, r22
    171a:	07 2e       	mov	r0, r23
    171c:	7a e0       	ldi	r23, 0x0A	; 10
    171e:	b5 95       	asr	r27
    1720:	a7 95       	ror	r26
    1722:	97 95       	ror	r25
    1724:	87 95       	ror	r24
    1726:	7a 95       	dec	r23
    1728:	d1 f7       	brne	.-12     	; 0x171e <main+0x28c>
    172a:	70 2d       	mov	r23, r0
    172c:	bf 93       	push	r27
    172e:	af 93       	push	r26
    1730:	9f 93       	push	r25
    1732:	8f 93       	push	r24
    1734:	d2 01       	movw	r26, r4
    1736:	c1 01       	movw	r24, r2
    1738:	07 2e       	mov	r0, r23
    173a:	7a e0       	ldi	r23, 0x0A	; 10
    173c:	b5 95       	asr	r27
    173e:	a7 95       	ror	r26
    1740:	97 95       	ror	r25
    1742:	87 95       	ror	r24
    1744:	7a 95       	dec	r23
    1746:	d1 f7       	brne	.-12     	; 0x173c <main+0x2aa>
    1748:	70 2d       	mov	r23, r0
    174a:	bf 93       	push	r27
    174c:	af 93       	push	r26
    174e:	9f 93       	push	r25
    1750:	8f 93       	push	r24
    1752:	85 e5       	ldi	r24, 0x55	; 85
    1754:	92 e0       	ldi	r25, 0x02	; 2
    1756:	9f 93       	push	r25
    1758:	8f 93       	push	r24
    175a:	a7 d3       	rcall	.+1870   	; 0x1eaa <printf>
    175c:	ad b7       	in	r26, 0x3d	; 61
    175e:	be b7       	in	r27, 0x3e	; 62
    1760:	1a 96       	adiw	r26, 0x0a	; 10
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	be bf       	out	0x3e, r27	; 62
    1768:	0f be       	out	0x3f, r0	; 63
    176a:	ad bf       	out	0x3d, r26	; 61
    176c:	e1 ce       	rjmp	.-574    	; 0x1530 <main+0x9e>

0000176e <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    176e:	8d e0       	ldi	r24, 0x0D	; 13
    1770:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    1774:	8a e4       	ldi	r24, 0x4A	; 74
    1776:	9c e4       	ldi	r25, 0x4C	; 76
    1778:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    177c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
	// Now enable the interrupt on the compare register A
	TIMSK1 = (1<<OCIE1A);
    1780:	82 e0       	ldi	r24, 0x02	; 2
    1782:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
    1786:	08 95       	ret

00001788 <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    1788:	18 95       	reti

0000178a <__vector_13>:
}
*/


ISR(TIMER1_COMPA_vect)
{
    178a:	1f 92       	push	r1
    178c:	0f 92       	push	r0
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	0f 92       	push	r0
    1792:	11 24       	eor	r1, r1
    1794:	8f 93       	push	r24
    1796:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    1798:	95 b1       	in	r25, 0x05	; 5
    179a:	82 e0       	ldi	r24, 0x02	; 2
    179c:	89 27       	eor	r24, r25
    179e:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <ItsTime>
}
    17a6:	9f 91       	pop	r25
    17a8:	8f 91       	pop	r24
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
    17ae:	0f 90       	pop	r0
    17b0:	1f 90       	pop	r1
    17b2:	18 95       	reti

000017b4 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    17b4:	81 e1       	ldi	r24, 0x11	; 17
    17b6:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    17ba:	8f ef       	ldi	r24, 0xFF	; 255
    17bc:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    17c0:	84 e0       	ldi	r24, 0x04	; 4
    17c2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17c6:	08 95       	ret

000017c8 <TWI_Transceiver_Busy>:
    17c8:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17cc:	81 78       	andi	r24, 0x81	; 129
    17ce:	08 95       	ret

000017d0 <TWI_Start_Transceiver_With_Data>:
    17d0:	cf 93       	push	r28
    17d2:	df 93       	push	r29
    17d4:	ec 01       	movw	r28, r24
    17d6:	ec eb       	ldi	r30, 0xBC	; 188
    17d8:	f0 e0       	ldi	r31, 0x00	; 0
    17da:	90 81       	ld	r25, Z
    17dc:	91 78       	andi	r25, 0x81	; 129
    17de:	e9 f7       	brne	.-6      	; 0x17da <TWI_Start_Transceiver_With_Data+0xa>
    17e0:	60 93 8e 02 	sts	0x028E, r22	; 0x80028e <TWI_msgSize>
    17e4:	88 81       	ld	r24, Y
    17e6:	80 93 8f 02 	sts	0x028F, r24	; 0x80028f <TWI_buf>
    17ea:	80 fd       	sbrc	r24, 0
    17ec:	12 c0       	rjmp	.+36     	; 0x1812 <TWI_Start_Transceiver_With_Data+0x42>
    17ee:	62 30       	cpi	r22, 0x02	; 2
    17f0:	80 f0       	brcs	.+32     	; 0x1812 <TWI_Start_Transceiver_With_Data+0x42>
    17f2:	fe 01       	movw	r30, r28
    17f4:	31 96       	adiw	r30, 0x01	; 1
    17f6:	a0 e9       	ldi	r26, 0x90	; 144
    17f8:	b2 e0       	ldi	r27, 0x02	; 2
    17fa:	62 50       	subi	r22, 0x02	; 2
    17fc:	26 2f       	mov	r18, r22
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	2e 5f       	subi	r18, 0xFE	; 254
    1802:	3f 4f       	sbci	r19, 0xFF	; 255
    1804:	2c 0f       	add	r18, r28
    1806:	3d 1f       	adc	r19, r29
    1808:	91 91       	ld	r25, Z+
    180a:	9d 93       	st	X+, r25
    180c:	e2 17       	cp	r30, r18
    180e:	f3 07       	cpc	r31, r19
    1810:	d9 f7       	brne	.-10     	; 0x1808 <TWI_Start_Transceiver_With_Data+0x38>
    1812:	10 92 8d 02 	sts	0x028D, r1	; 0x80028d <TWI_statusReg>
    1816:	88 ef       	ldi	r24, 0xF8	; 248
    1818:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    181c:	85 ea       	ldi	r24, 0xA5	; 165
    181e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1822:	df 91       	pop	r29
    1824:	cf 91       	pop	r28
    1826:	08 95       	ret

00001828 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1828:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    182a:	ec eb       	ldi	r30, 0xBC	; 188
    182c:	f0 e0       	ldi	r31, 0x00	; 0
    182e:	90 81       	ld	r25, Z
    1830:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1832:	e9 f7       	brne	.-6      	; 0x182e <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1834:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <TWI_statusReg>
    1838:	80 ff       	sbrs	r24, 0
    183a:	11 c0       	rjmp	.+34     	; 0x185e <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    183c:	66 23       	and	r22, r22
    183e:	79 f0       	breq	.+30     	; 0x185e <TWI_Get_Data_From_Transceiver+0x36>
    1840:	af e8       	ldi	r26, 0x8F	; 143
    1842:	b2 e0       	ldi	r27, 0x02	; 2
    1844:	fa 01       	movw	r30, r20
    1846:	61 50       	subi	r22, 0x01	; 1
    1848:	26 2f       	mov	r18, r22
    184a:	30 e0       	ldi	r19, 0x00	; 0
    184c:	2f 5f       	subi	r18, 0xFF	; 255
    184e:	3f 4f       	sbci	r19, 0xFF	; 255
    1850:	24 0f       	add	r18, r20
    1852:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    1854:	9d 91       	ld	r25, X+
    1856:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1858:	e2 17       	cp	r30, r18
    185a:	f3 07       	cpc	r31, r19
    185c:	d9 f7       	brne	.-10     	; 0x1854 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    185e:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <TWI_statusReg>
}
    1862:	81 70       	andi	r24, 0x01	; 1
    1864:	08 95       	ret

00001866 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    1866:	1f 92       	push	r1
    1868:	0f 92       	push	r0
    186a:	0f b6       	in	r0, 0x3f	; 63
    186c:	0f 92       	push	r0
    186e:	11 24       	eor	r1, r1
    1870:	2f 93       	push	r18
    1872:	3f 93       	push	r19
    1874:	8f 93       	push	r24
    1876:	9f 93       	push	r25
    1878:	af 93       	push	r26
    187a:	bf 93       	push	r27
    187c:	ef 93       	push	r30
    187e:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1880:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1884:	8e 2f       	mov	r24, r30
    1886:	90 e0       	ldi	r25, 0x00	; 0
    1888:	fc 01       	movw	r30, r24
    188a:	38 97       	sbiw	r30, 0x08	; 8
    188c:	e1 35       	cpi	r30, 0x51	; 81
    188e:	f1 05       	cpc	r31, r1
    1890:	08 f0       	brcs	.+2      	; 0x1894 <__vector_26+0x2e>
    1892:	55 c0       	rjmp	.+170    	; 0x193e <__vector_26+0xd8>
    1894:	e2 5c       	subi	r30, 0xC2	; 194
    1896:	ff 4f       	sbci	r31, 0xFF	; 255
    1898:	6d c1       	rjmp	.+730    	; 0x1b74 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    189a:	10 92 8c 02 	sts	0x028C, r1	; 0x80028c <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    189e:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <TWI_bufPtr.1555>
    18a2:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <TWI_msgSize>
    18a6:	e8 17       	cp	r30, r24
    18a8:	70 f4       	brcc	.+28     	; 0x18c6 <__vector_26+0x60>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	8e 0f       	add	r24, r30
    18ae:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <TWI_bufPtr.1555>
    18b2:	f0 e0       	ldi	r31, 0x00	; 0
    18b4:	e1 57       	subi	r30, 0x71	; 113
    18b6:	fd 4f       	sbci	r31, 0xFD	; 253
    18b8:	80 81       	ld	r24, Z
    18ba:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18be:	85 e8       	ldi	r24, 0x85	; 133
    18c0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18c4:	43 c0       	rjmp	.+134    	; 0x194c <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    18c6:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <TWI_statusReg>
    18ca:	81 60       	ori	r24, 0x01	; 1
    18cc:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18d0:	84 e9       	ldi	r24, 0x94	; 148
    18d2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    18d6:	3a c0       	rjmp	.+116    	; 0x194c <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    18d8:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <TWI_bufPtr.1555>
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	8e 0f       	add	r24, r30
    18e0:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <TWI_bufPtr.1555>
    18e4:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    18e8:	f0 e0       	ldi	r31, 0x00	; 0
    18ea:	e1 57       	subi	r30, 0x71	; 113
    18ec:	fd 4f       	sbci	r31, 0xFD	; 253
    18ee:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    18f0:	20 91 8c 02 	lds	r18, 0x028C	; 0x80028c <TWI_bufPtr.1555>
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <TWI_msgSize>
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	01 97       	sbiw	r24, 0x01	; 1
    18fe:	28 17       	cp	r18, r24
    1900:	39 07       	cpc	r19, r25
    1902:	24 f4       	brge	.+8      	; 0x190c <__vector_26+0xa6>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1904:	85 ec       	ldi	r24, 0xC5	; 197
    1906:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    190a:	20 c0       	rjmp	.+64     	; 0x194c <__vector_26+0xe6>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    190c:	85 e8       	ldi	r24, 0x85	; 133
    190e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1912:	1c c0       	rjmp	.+56     	; 0x194c <__vector_26+0xe6>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    1914:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1918:	e0 91 8c 02 	lds	r30, 0x028C	; 0x80028c <TWI_bufPtr.1555>
    191c:	f0 e0       	ldi	r31, 0x00	; 0
    191e:	e1 57       	subi	r30, 0x71	; 113
    1920:	fd 4f       	sbci	r31, 0xFD	; 253
    1922:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1924:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <TWI_statusReg>
    1928:	81 60       	ori	r24, 0x01	; 1
    192a:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    192e:	84 e9       	ldi	r24, 0x94	; 148
    1930:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    1934:	0b c0       	rjmp	.+22     	; 0x194c <__vector_26+0xe6>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1936:	85 ea       	ldi	r24, 0xA5	; 165
    1938:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    193c:	07 c0       	rjmp	.+14     	; 0x194c <__vector_26+0xe6>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    193e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    1942:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1946:	84 e0       	ldi	r24, 0x04	; 4
    1948:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    194c:	ff 91       	pop	r31
    194e:	ef 91       	pop	r30
    1950:	bf 91       	pop	r27
    1952:	af 91       	pop	r26
    1954:	9f 91       	pop	r25
    1956:	8f 91       	pop	r24
    1958:	3f 91       	pop	r19
    195a:	2f 91       	pop	r18
    195c:	0f 90       	pop	r0
    195e:	0f be       	out	0x3f, r0	; 63
    1960:	0f 90       	pop	r0
    1962:	1f 90       	pop	r1
    1964:	18 95       	reti

00001966 <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    1966:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    196a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    196e:	88 e9       	ldi	r24, 0x98	; 152
    1970:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1974:	8e e0       	ldi	r24, 0x0E	; 14
    1976:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    197a:	10 92 a1 03 	sts	0x03A1, r1	; 0x8003a1 <UART0_RxTail>
    197e:	10 92 a2 03 	sts	0x03A2, r1	; 0x8003a2 <UART0_RxHead>
    1982:	10 92 9f 02 	sts	0x029F, r1	; 0x80029f <UART0_TxTail>
    1986:	10 92 a0 02 	sts	0x02A0, r1	; 0x8002a0 <UART0_TxHead>
    198a:	08 95       	ret

0000198c <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    198c:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <UART0_TxHead>
    1990:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1992:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <UART0_TxTail>
    1996:	29 17       	cp	r18, r25
    1998:	e1 f3       	breq	.-8      	; 0x1992 <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    199a:	e2 2f       	mov	r30, r18
    199c:	f0 e0       	ldi	r31, 0x00	; 0
    199e:	ef 55       	subi	r30, 0x5F	; 95
    19a0:	fd 4f       	sbci	r31, 0xFD	; 253
    19a2:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    19a4:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    19a8:	e1 ec       	ldi	r30, 0xC1	; 193
    19aa:	f0 e0       	ldi	r31, 0x00	; 0
    19ac:	80 81       	ld	r24, Z
    19ae:	80 62       	ori	r24, 0x20	; 32
    19b0:	80 83       	st	Z, r24
    19b2:	08 95       	ret

000019b4 <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    19b4:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <UART0_TxHead>
    19b8:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    19ba:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <UART0_TxTail>
    19be:	29 17       	cp	r18, r25
    19c0:	e1 f3       	breq	.-8      	; 0x19ba <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    19c2:	e2 2f       	mov	r30, r18
    19c4:	f0 e0       	ldi	r31, 0x00	; 0
    19c6:	ef 55       	subi	r30, 0x5F	; 95
    19c8:	fd 4f       	sbci	r31, 0xFD	; 253
    19ca:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    19cc:	20 93 a0 02 	sts	0x02A0, r18	; 0x8002a0 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    19d0:	e1 ec       	ldi	r30, 0xC1	; 193
    19d2:	f0 e0       	ldi	r31, 0x00	; 0
    19d4:	80 81       	ld	r24, Z
    19d6:	80 62       	ori	r24, 0x20	; 32
    19d8:	80 83       	st	Z, r24
	return(0);
}
    19da:	80 e0       	ldi	r24, 0x00	; 0
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	08 95       	ret

000019e0 <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    19e0:	cf 93       	push	r28
    19e2:	df 93       	push	r29
    19e4:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    19e6:	88 81       	ld	r24, Y
    19e8:	88 23       	and	r24, r24
    19ea:	29 f0       	breq	.+10     	; 0x19f6 <USART0_putstring+0x16>
    19ec:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    19ee:	ce df       	rcall	.-100    	; 0x198c <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    19f0:	89 91       	ld	r24, Y+
    19f2:	81 11       	cpse	r24, r1
    19f4:	fc cf       	rjmp	.-8      	; 0x19ee <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	08 95       	ret

000019fc <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    19fc:	1f 92       	push	r1
    19fe:	0f 92       	push	r0
    1a00:	0f b6       	in	r0, 0x3f	; 63
    1a02:	0f 92       	push	r0
    1a04:	11 24       	eor	r1, r1
    1a06:	8f 93       	push	r24
    1a08:	9f 93       	push	r25
    1a0a:	ef 93       	push	r30
    1a0c:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    1a0e:	90 91 a0 02 	lds	r25, 0x02A0	; 0x8002a0 <UART0_TxHead>
    1a12:	80 91 9f 02 	lds	r24, 0x029F	; 0x80029f <UART0_TxTail>
    1a16:	98 17       	cp	r25, r24
    1a18:	61 f0       	breq	.+24     	; 0x1a32 <__vector_21+0x36>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    1a1a:	e0 91 9f 02 	lds	r30, 0x029F	; 0x80029f <UART0_TxTail>
    1a1e:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    1a20:	e0 93 9f 02 	sts	0x029F, r30	; 0x80029f <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    1a24:	f0 e0       	ldi	r31, 0x00	; 0
    1a26:	ef 55       	subi	r30, 0x5F	; 95
    1a28:	fd 4f       	sbci	r31, 0xFD	; 253
    1a2a:	80 81       	ld	r24, Z
    1a2c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1a30:	05 c0       	rjmp	.+10     	; 0x1a3c <__vector_21+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    1a32:	e1 ec       	ldi	r30, 0xC1	; 193
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	80 81       	ld	r24, Z
    1a38:	8f 7d       	andi	r24, 0xDF	; 223
    1a3a:	80 83       	st	Z, r24
	}
    1a3c:	ff 91       	pop	r31
    1a3e:	ef 91       	pop	r30
    1a40:	9f 91       	pop	r25
    1a42:	8f 91       	pop	r24
    1a44:	0f 90       	pop	r0
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	0f 90       	pop	r0
    1a4a:	1f 90       	pop	r1
    1a4c:	18 95       	reti

00001a4e <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1a4e:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1a52:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    1a56:	88 e9       	ldi	r24, 0x98	; 152
    1a58:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    1a5c:	86 e0       	ldi	r24, 0x06	; 6
    1a5e:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    1a62:	10 92 a5 04 	sts	0x04A5, r1	; 0x8004a5 <UART1_RxTail>
    1a66:	10 92 a6 04 	sts	0x04A6, r1	; 0x8004a6 <UART1_RxHead>
    1a6a:	10 92 a3 03 	sts	0x03A3, r1	; 0x8003a3 <UART1_TxTail>
    1a6e:	10 92 a4 03 	sts	0x03A4, r1	; 0x8003a4 <UART1_TxHead>
    1a72:	08 95       	ret

00001a74 <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1a74:	1f 92       	push	r1
    1a76:	0f 92       	push	r0
    1a78:	0f b6       	in	r0, 0x3f	; 63
    1a7a:	0f 92       	push	r0
    1a7c:	11 24       	eor	r1, r1
    1a7e:	2f 93       	push	r18
    1a80:	3f 93       	push	r19
    1a82:	8f 93       	push	r24
    1a84:	9f 93       	push	r25
    1a86:	af 93       	push	r26
    1a88:	bf 93       	push	r27
    1a8a:	cf 93       	push	r28
    1a8c:	df 93       	push	r29
    1a8e:	ef 93       	push	r30
    1a90:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1a92:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1a96:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <UART1_RxHead>
    1a9a:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1a9c:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1aa0:	20 91 a5 04 	lds	r18, 0x04A5	; 0x8004a5 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1aa4:	e8 2f       	mov	r30, r24
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	e2 59       	subi	r30, 0x92	; 146
    1aaa:	f9 4f       	sbci	r31, 0xF9	; 249
    1aac:	90 83       	st	Z, r25
	
	if (data == 10)
    1aae:	9a 30       	cpi	r25, 0x0A	; 10
    1ab0:	d1 f4       	brne	.+52     	; 0x1ae6 <__vector_28+0x72>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1ab2:	90 91 73 06 	lds	r25, 0x0673	; 0x800673 <UART1_RxBuf+0x5>
    1ab6:	97 34       	cpi	r25, 0x47	; 71
    1ab8:	91 f4       	brne	.+36     	; 0x1ade <__vector_28+0x6a>
    1aba:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i];
    1abc:	2e 2f       	mov	r18, r30
    1abe:	30 e0       	ldi	r19, 0x00	; 0
    1ac0:	d9 01       	movw	r26, r18
    1ac2:	a2 59       	subi	r26, 0x92	; 146
    1ac4:	b8 4f       	sbci	r27, 0xF8	; 248
    1ac6:	e9 01       	movw	r28, r18
    1ac8:	c2 59       	subi	r28, 0x92	; 146
    1aca:	d9 4f       	sbci	r29, 0xF9	; 249
    1acc:	98 81       	ld	r25, Y
    1ace:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1ad0:	ef 5f       	subi	r30, 0xFF	; 255
    1ad2:	8e 17       	cp	r24, r30
    1ad4:	98 f7       	brcc	.-26     	; 0x1abc <__vector_28+0x48>
			{
				messageWant[i] = UART1_RxBuf[i];

			}
			messageWant[i+1]=0x00;
    1ad6:	f0 e0       	ldi	r31, 0x00	; 0
    1ad8:	e2 59       	subi	r30, 0x92	; 146
    1ada:	f8 4f       	sbci	r31, 0xF8	; 248
    1adc:	11 82       	std	Z+1, r1	; 0x01
		}
		UART1_RxTail = 0;
    1ade:	10 92 a5 04 	sts	0x04A5, r1	; 0x8004a5 <UART1_RxTail>
		UART1_RxHead = 0;
    1ae2:	10 92 a6 04 	sts	0x04A6, r1	; 0x8004a6 <UART1_RxHead>
	}
}
    1ae6:	ff 91       	pop	r31
    1ae8:	ef 91       	pop	r30
    1aea:	df 91       	pop	r29
    1aec:	cf 91       	pop	r28
    1aee:	bf 91       	pop	r27
    1af0:	af 91       	pop	r26
    1af2:	9f 91       	pop	r25
    1af4:	8f 91       	pop	r24
    1af6:	3f 91       	pop	r19
    1af8:	2f 91       	pop	r18
    1afa:	0f 90       	pop	r0
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	0f 90       	pop	r0
    1b00:	1f 90       	pop	r1
    1b02:	18 95       	reti

00001b04 <__vector_29>:

ISR(USART1_UDRE_vect)
{
    1b04:	1f 92       	push	r1
    1b06:	0f 92       	push	r0
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	0f 92       	push	r0
    1b0c:	11 24       	eor	r1, r1
    1b0e:	8f 93       	push	r24
    1b10:	9f 93       	push	r25
    1b12:	ef 93       	push	r30
    1b14:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART1_TxHead != UART1_TxTail) {
    1b16:	90 91 a4 03 	lds	r25, 0x03A4	; 0x8003a4 <UART1_TxHead>
    1b1a:	80 91 a3 03 	lds	r24, 0x03A3	; 0x8003a3 <UART1_TxTail>
    1b1e:	98 17       	cp	r25, r24
    1b20:	61 f0       	breq	.+24     	; 0x1b3a <__vector_29+0x36>
		// Calculate buffer index
		tmptail = ( UART1_TxTail + 1 ) & UART1_TX_BUFFER_MASK;
    1b22:	e0 91 a3 03 	lds	r30, 0x03A3	; 0x8003a3 <UART1_TxTail>
    1b26:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART1_TxTail = tmptail;
    1b28:	e0 93 a3 03 	sts	0x03A3, r30	; 0x8003a3 <UART1_TxTail>
		// Start transmission 
		UDR1 = UART1_TxBuf[tmptail];
    1b2c:	f0 e0       	ldi	r31, 0x00	; 0
    1b2e:	eb 55       	subi	r30, 0x5B	; 91
    1b30:	fc 4f       	sbci	r31, 0xFC	; 252
    1b32:	80 81       	ld	r24, Z
    1b34:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1b38:	05 c0       	rjmp	.+10     	; 0x1b44 <__vector_29+0x40>
		} else {
		// Disable UDRE interrupt 
		UCSR1B &= ~(1<<UDRIE1);
    1b3a:	e9 ec       	ldi	r30, 0xC9	; 201
    1b3c:	f0 e0       	ldi	r31, 0x00	; 0
    1b3e:	80 81       	ld	r24, Z
    1b40:	8f 7d       	andi	r24, 0xDF	; 223
    1b42:	80 83       	st	Z, r24
	}
    1b44:	ff 91       	pop	r31
    1b46:	ef 91       	pop	r30
    1b48:	9f 91       	pop	r25
    1b4a:	8f 91       	pop	r24
    1b4c:	0f 90       	pop	r0
    1b4e:	0f be       	out	0x3f, r0	; 63
    1b50:	0f 90       	pop	r0
    1b52:	1f 90       	pop	r1
    1b54:	18 95       	reti

00001b56 <__mulsi3>:
    1b56:	db 01       	movw	r26, r22
    1b58:	8f 93       	push	r24
    1b5a:	9f 93       	push	r25
    1b5c:	11 d0       	rcall	.+34     	; 0x1b80 <__muluhisi3>
    1b5e:	bf 91       	pop	r27
    1b60:	af 91       	pop	r26
    1b62:	a2 9f       	mul	r26, r18
    1b64:	80 0d       	add	r24, r0
    1b66:	91 1d       	adc	r25, r1
    1b68:	a3 9f       	mul	r26, r19
    1b6a:	90 0d       	add	r25, r0
    1b6c:	b2 9f       	mul	r27, r18
    1b6e:	90 0d       	add	r25, r0
    1b70:	11 24       	eor	r1, r1
    1b72:	08 95       	ret

00001b74 <__tablejump2__>:
    1b74:	ee 0f       	add	r30, r30
    1b76:	ff 1f       	adc	r31, r31
    1b78:	05 90       	lpm	r0, Z+
    1b7a:	f4 91       	lpm	r31, Z
    1b7c:	e0 2d       	mov	r30, r0
    1b7e:	09 94       	ijmp

00001b80 <__muluhisi3>:
    1b80:	85 d1       	rcall	.+778    	; 0x1e8c <__umulhisi3>
    1b82:	a5 9f       	mul	r26, r21
    1b84:	90 0d       	add	r25, r0
    1b86:	b4 9f       	mul	r27, r20
    1b88:	90 0d       	add	r25, r0
    1b8a:	a4 9f       	mul	r26, r20
    1b8c:	80 0d       	add	r24, r0
    1b8e:	91 1d       	adc	r25, r1
    1b90:	11 24       	eor	r1, r1
    1b92:	08 95       	ret

00001b94 <__mulshisi3>:
    1b94:	b7 ff       	sbrs	r27, 7
    1b96:	f4 cf       	rjmp	.-24     	; 0x1b80 <__muluhisi3>

00001b98 <__mulohisi3>:
    1b98:	f3 df       	rcall	.-26     	; 0x1b80 <__muluhisi3>
    1b9a:	82 1b       	sub	r24, r18
    1b9c:	93 0b       	sbc	r25, r19
    1b9e:	08 95       	ret

00001ba0 <__muldi3>:
    1ba0:	df 93       	push	r29
    1ba2:	cf 93       	push	r28
    1ba4:	1f 93       	push	r17
    1ba6:	0f 93       	push	r16
    1ba8:	9a 9d       	mul	r25, r10
    1baa:	f0 2d       	mov	r31, r0
    1bac:	21 9f       	mul	r18, r17
    1bae:	f0 0d       	add	r31, r0
    1bb0:	8b 9d       	mul	r24, r11
    1bb2:	f0 0d       	add	r31, r0
    1bb4:	8a 9d       	mul	r24, r10
    1bb6:	e0 2d       	mov	r30, r0
    1bb8:	f1 0d       	add	r31, r1
    1bba:	03 9f       	mul	r16, r19
    1bbc:	f0 0d       	add	r31, r0
    1bbe:	02 9f       	mul	r16, r18
    1bc0:	e0 0d       	add	r30, r0
    1bc2:	f1 1d       	adc	r31, r1
    1bc4:	4e 9d       	mul	r20, r14
    1bc6:	e0 0d       	add	r30, r0
    1bc8:	f1 1d       	adc	r31, r1
    1bca:	5e 9d       	mul	r21, r14
    1bcc:	f0 0d       	add	r31, r0
    1bce:	4f 9d       	mul	r20, r15
    1bd0:	f0 0d       	add	r31, r0
    1bd2:	7f 93       	push	r23
    1bd4:	6f 93       	push	r22
    1bd6:	bf 92       	push	r11
    1bd8:	af 92       	push	r10
    1bda:	5f 93       	push	r21
    1bdc:	4f 93       	push	r20
    1bde:	d5 01       	movw	r26, r10
    1be0:	55 d1       	rcall	.+682    	; 0x1e8c <__umulhisi3>
    1be2:	8b 01       	movw	r16, r22
    1be4:	ac 01       	movw	r20, r24
    1be6:	d7 01       	movw	r26, r14
    1be8:	51 d1       	rcall	.+674    	; 0x1e8c <__umulhisi3>
    1bea:	eb 01       	movw	r28, r22
    1bec:	e8 0f       	add	r30, r24
    1bee:	f9 1f       	adc	r31, r25
    1bf0:	d6 01       	movw	r26, r12
    1bf2:	1f d0       	rcall	.+62     	; 0x1c32 <__muldi3_6>
    1bf4:	2f 91       	pop	r18
    1bf6:	3f 91       	pop	r19
    1bf8:	d6 01       	movw	r26, r12
    1bfa:	48 d1       	rcall	.+656    	; 0x1e8c <__umulhisi3>
    1bfc:	c6 0f       	add	r28, r22
    1bfe:	d7 1f       	adc	r29, r23
    1c00:	e8 1f       	adc	r30, r24
    1c02:	f9 1f       	adc	r31, r25
    1c04:	af 91       	pop	r26
    1c06:	bf 91       	pop	r27
    1c08:	14 d0       	rcall	.+40     	; 0x1c32 <__muldi3_6>
    1c0a:	2f 91       	pop	r18
    1c0c:	3f 91       	pop	r19
    1c0e:	3e d1       	rcall	.+636    	; 0x1e8c <__umulhisi3>
    1c10:	c6 0f       	add	r28, r22
    1c12:	d7 1f       	adc	r29, r23
    1c14:	e8 1f       	adc	r30, r24
    1c16:	f9 1f       	adc	r31, r25
    1c18:	d6 01       	movw	r26, r12
    1c1a:	38 d1       	rcall	.+624    	; 0x1e8c <__umulhisi3>
    1c1c:	e6 0f       	add	r30, r22
    1c1e:	f7 1f       	adc	r31, r23
    1c20:	98 01       	movw	r18, r16
    1c22:	be 01       	movw	r22, r28
    1c24:	cf 01       	movw	r24, r30
    1c26:	11 24       	eor	r1, r1
    1c28:	0f 91       	pop	r16
    1c2a:	1f 91       	pop	r17
    1c2c:	cf 91       	pop	r28
    1c2e:	df 91       	pop	r29
    1c30:	08 95       	ret

00001c32 <__muldi3_6>:
    1c32:	2c d1       	rcall	.+600    	; 0x1e8c <__umulhisi3>
    1c34:	46 0f       	add	r20, r22
    1c36:	57 1f       	adc	r21, r23
    1c38:	c8 1f       	adc	r28, r24
    1c3a:	d9 1f       	adc	r29, r25
    1c3c:	08 f4       	brcc	.+2      	; 0x1c40 <__muldi3_6+0xe>
    1c3e:	31 96       	adiw	r30, 0x01	; 1
    1c40:	08 95       	ret

00001c42 <__moddi3>:
    1c42:	68 94       	set
    1c44:	01 c0       	rjmp	.+2      	; 0x1c48 <__divdi3_moddi3>

00001c46 <__divdi3>:
    1c46:	e8 94       	clt

00001c48 <__divdi3_moddi3>:
    1c48:	f9 2f       	mov	r31, r25
    1c4a:	f1 2b       	or	r31, r17
    1c4c:	0a f0       	brmi	.+2      	; 0x1c50 <__divdi3_moddi3+0x8>
    1c4e:	27 c0       	rjmp	.+78     	; 0x1c9e <__udivdi3_umoddi3>
    1c50:	a0 e0       	ldi	r26, 0x00	; 0
    1c52:	b0 e0       	ldi	r27, 0x00	; 0
    1c54:	ed e2       	ldi	r30, 0x2D	; 45
    1c56:	fe e0       	ldi	r31, 0x0E	; 14
    1c58:	93 c0       	rjmp	.+294    	; 0x1d80 <__prologue_saves__+0xc>
    1c5a:	09 2e       	mov	r0, r25
    1c5c:	05 94       	asr	r0
    1c5e:	1a f4       	brpl	.+6      	; 0x1c66 <__divdi3_moddi3+0x1e>
    1c60:	79 d0       	rcall	.+242    	; 0x1d54 <__negdi2>
    1c62:	11 23       	and	r17, r17
    1c64:	92 f4       	brpl	.+36     	; 0x1c8a <__divdi3_moddi3+0x42>
    1c66:	f0 e8       	ldi	r31, 0x80	; 128
    1c68:	0f 26       	eor	r0, r31
    1c6a:	ff ef       	ldi	r31, 0xFF	; 255
    1c6c:	e0 94       	com	r14
    1c6e:	f0 94       	com	r15
    1c70:	00 95       	com	r16
    1c72:	10 95       	com	r17
    1c74:	b0 94       	com	r11
    1c76:	c0 94       	com	r12
    1c78:	d0 94       	com	r13
    1c7a:	a1 94       	neg	r10
    1c7c:	bf 0a       	sbc	r11, r31
    1c7e:	cf 0a       	sbc	r12, r31
    1c80:	df 0a       	sbc	r13, r31
    1c82:	ef 0a       	sbc	r14, r31
    1c84:	ff 0a       	sbc	r15, r31
    1c86:	0f 0b       	sbc	r16, r31
    1c88:	1f 0b       	sbc	r17, r31
    1c8a:	13 d0       	rcall	.+38     	; 0x1cb2 <__udivmod64>
    1c8c:	07 fc       	sbrc	r0, 7
    1c8e:	62 d0       	rcall	.+196    	; 0x1d54 <__negdi2>
    1c90:	cd b7       	in	r28, 0x3d	; 61
    1c92:	de b7       	in	r29, 0x3e	; 62
    1c94:	ec e0       	ldi	r30, 0x0C	; 12
    1c96:	90 c0       	rjmp	.+288    	; 0x1db8 <__epilogue_restores__+0xc>

00001c98 <__umoddi3>:
    1c98:	68 94       	set
    1c9a:	01 c0       	rjmp	.+2      	; 0x1c9e <__udivdi3_umoddi3>

00001c9c <__udivdi3>:
    1c9c:	e8 94       	clt

00001c9e <__udivdi3_umoddi3>:
    1c9e:	8f 92       	push	r8
    1ca0:	9f 92       	push	r9
    1ca2:	cf 93       	push	r28
    1ca4:	df 93       	push	r29
    1ca6:	05 d0       	rcall	.+10     	; 0x1cb2 <__udivmod64>
    1ca8:	df 91       	pop	r29
    1caa:	cf 91       	pop	r28
    1cac:	9f 90       	pop	r9
    1cae:	8f 90       	pop	r8
    1cb0:	08 95       	ret

00001cb2 <__udivmod64>:
    1cb2:	88 24       	eor	r8, r8
    1cb4:	99 24       	eor	r9, r9
    1cb6:	f4 01       	movw	r30, r8
    1cb8:	e4 01       	movw	r28, r8
    1cba:	b0 e4       	ldi	r27, 0x40	; 64
    1cbc:	9f 93       	push	r25
    1cbe:	aa 27       	eor	r26, r26
    1cc0:	9a 15       	cp	r25, r10
    1cc2:	8b 04       	cpc	r8, r11
    1cc4:	9c 04       	cpc	r9, r12
    1cc6:	ed 05       	cpc	r30, r13
    1cc8:	fe 05       	cpc	r31, r14
    1cca:	cf 05       	cpc	r28, r15
    1ccc:	d0 07       	cpc	r29, r16
    1cce:	a1 07       	cpc	r26, r17
    1cd0:	98 f4       	brcc	.+38     	; 0x1cf8 <__udivmod64+0x46>
    1cd2:	ad 2f       	mov	r26, r29
    1cd4:	dc 2f       	mov	r29, r28
    1cd6:	cf 2f       	mov	r28, r31
    1cd8:	fe 2f       	mov	r31, r30
    1cda:	e9 2d       	mov	r30, r9
    1cdc:	98 2c       	mov	r9, r8
    1cde:	89 2e       	mov	r8, r25
    1ce0:	98 2f       	mov	r25, r24
    1ce2:	87 2f       	mov	r24, r23
    1ce4:	76 2f       	mov	r23, r22
    1ce6:	65 2f       	mov	r22, r21
    1ce8:	54 2f       	mov	r21, r20
    1cea:	43 2f       	mov	r20, r19
    1cec:	32 2f       	mov	r19, r18
    1cee:	22 27       	eor	r18, r18
    1cf0:	b8 50       	subi	r27, 0x08	; 8
    1cf2:	31 f7       	brne	.-52     	; 0x1cc0 <__udivmod64+0xe>
    1cf4:	bf 91       	pop	r27
    1cf6:	27 c0       	rjmp	.+78     	; 0x1d46 <__udivmod64+0x94>
    1cf8:	1b 2e       	mov	r1, r27
    1cfa:	bf 91       	pop	r27
    1cfc:	bb 27       	eor	r27, r27
    1cfe:	22 0f       	add	r18, r18
    1d00:	33 1f       	adc	r19, r19
    1d02:	44 1f       	adc	r20, r20
    1d04:	55 1f       	adc	r21, r21
    1d06:	66 1f       	adc	r22, r22
    1d08:	77 1f       	adc	r23, r23
    1d0a:	88 1f       	adc	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	88 1c       	adc	r8, r8
    1d10:	99 1c       	adc	r9, r9
    1d12:	ee 1f       	adc	r30, r30
    1d14:	ff 1f       	adc	r31, r31
    1d16:	cc 1f       	adc	r28, r28
    1d18:	dd 1f       	adc	r29, r29
    1d1a:	aa 1f       	adc	r26, r26
    1d1c:	bb 1f       	adc	r27, r27
    1d1e:	8a 14       	cp	r8, r10
    1d20:	9b 04       	cpc	r9, r11
    1d22:	ec 05       	cpc	r30, r12
    1d24:	fd 05       	cpc	r31, r13
    1d26:	ce 05       	cpc	r28, r14
    1d28:	df 05       	cpc	r29, r15
    1d2a:	a0 07       	cpc	r26, r16
    1d2c:	b1 07       	cpc	r27, r17
    1d2e:	48 f0       	brcs	.+18     	; 0x1d42 <__udivmod64+0x90>
    1d30:	8a 18       	sub	r8, r10
    1d32:	9b 08       	sbc	r9, r11
    1d34:	ec 09       	sbc	r30, r12
    1d36:	fd 09       	sbc	r31, r13
    1d38:	ce 09       	sbc	r28, r14
    1d3a:	df 09       	sbc	r29, r15
    1d3c:	a0 0b       	sbc	r26, r16
    1d3e:	b1 0b       	sbc	r27, r17
    1d40:	21 60       	ori	r18, 0x01	; 1
    1d42:	1a 94       	dec	r1
    1d44:	e1 f6       	brne	.-72     	; 0x1cfe <__udivmod64+0x4c>
    1d46:	2e f4       	brtc	.+10     	; 0x1d52 <__udivmod64+0xa0>
    1d48:	94 01       	movw	r18, r8
    1d4a:	af 01       	movw	r20, r30
    1d4c:	be 01       	movw	r22, r28
    1d4e:	cd 01       	movw	r24, r26
    1d50:	00 0c       	add	r0, r0
    1d52:	08 95       	ret

00001d54 <__negdi2>:
    1d54:	60 95       	com	r22
    1d56:	70 95       	com	r23
    1d58:	80 95       	com	r24
    1d5a:	90 95       	com	r25
    1d5c:	30 95       	com	r19
    1d5e:	40 95       	com	r20
    1d60:	50 95       	com	r21
    1d62:	21 95       	neg	r18
    1d64:	3f 4f       	sbci	r19, 0xFF	; 255
    1d66:	4f 4f       	sbci	r20, 0xFF	; 255
    1d68:	5f 4f       	sbci	r21, 0xFF	; 255
    1d6a:	6f 4f       	sbci	r22, 0xFF	; 255
    1d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d6e:	8f 4f       	sbci	r24, 0xFF	; 255
    1d70:	9f 4f       	sbci	r25, 0xFF	; 255
    1d72:	08 95       	ret

00001d74 <__prologue_saves__>:
    1d74:	2f 92       	push	r2
    1d76:	3f 92       	push	r3
    1d78:	4f 92       	push	r4
    1d7a:	5f 92       	push	r5
    1d7c:	6f 92       	push	r6
    1d7e:	7f 92       	push	r7
    1d80:	8f 92       	push	r8
    1d82:	9f 92       	push	r9
    1d84:	af 92       	push	r10
    1d86:	bf 92       	push	r11
    1d88:	cf 92       	push	r12
    1d8a:	df 92       	push	r13
    1d8c:	ef 92       	push	r14
    1d8e:	ff 92       	push	r15
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	cf 93       	push	r28
    1d96:	df 93       	push	r29
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
    1d9c:	ca 1b       	sub	r28, r26
    1d9e:	db 0b       	sbc	r29, r27
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	09 94       	ijmp

00001dac <__epilogue_restores__>:
    1dac:	2a 88       	ldd	r2, Y+18	; 0x12
    1dae:	39 88       	ldd	r3, Y+17	; 0x11
    1db0:	48 88       	ldd	r4, Y+16	; 0x10
    1db2:	5f 84       	ldd	r5, Y+15	; 0x0f
    1db4:	6e 84       	ldd	r6, Y+14	; 0x0e
    1db6:	7d 84       	ldd	r7, Y+13	; 0x0d
    1db8:	8c 84       	ldd	r8, Y+12	; 0x0c
    1dba:	9b 84       	ldd	r9, Y+11	; 0x0b
    1dbc:	aa 84       	ldd	r10, Y+10	; 0x0a
    1dbe:	b9 84       	ldd	r11, Y+9	; 0x09
    1dc0:	c8 84       	ldd	r12, Y+8	; 0x08
    1dc2:	df 80       	ldd	r13, Y+7	; 0x07
    1dc4:	ee 80       	ldd	r14, Y+6	; 0x06
    1dc6:	fd 80       	ldd	r15, Y+5	; 0x05
    1dc8:	0c 81       	ldd	r16, Y+4	; 0x04
    1dca:	1b 81       	ldd	r17, Y+3	; 0x03
    1dcc:	aa 81       	ldd	r26, Y+2	; 0x02
    1dce:	b9 81       	ldd	r27, Y+1	; 0x01
    1dd0:	ce 0f       	add	r28, r30
    1dd2:	d1 1d       	adc	r29, r1
    1dd4:	0f b6       	in	r0, 0x3f	; 63
    1dd6:	f8 94       	cli
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	0f be       	out	0x3f, r0	; 63
    1ddc:	cd bf       	out	0x3d, r28	; 61
    1dde:	ed 01       	movw	r28, r26
    1de0:	08 95       	ret

00001de2 <__ashldi3>:
    1de2:	0f 93       	push	r16
    1de4:	08 30       	cpi	r16, 0x08	; 8
    1de6:	90 f0       	brcs	.+36     	; 0x1e0c <__ashldi3+0x2a>
    1de8:	98 2f       	mov	r25, r24
    1dea:	87 2f       	mov	r24, r23
    1dec:	76 2f       	mov	r23, r22
    1dee:	65 2f       	mov	r22, r21
    1df0:	54 2f       	mov	r21, r20
    1df2:	43 2f       	mov	r20, r19
    1df4:	32 2f       	mov	r19, r18
    1df6:	22 27       	eor	r18, r18
    1df8:	08 50       	subi	r16, 0x08	; 8
    1dfa:	f4 cf       	rjmp	.-24     	; 0x1de4 <__ashldi3+0x2>
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	44 1f       	adc	r20, r20
    1e02:	55 1f       	adc	r21, r21
    1e04:	66 1f       	adc	r22, r22
    1e06:	77 1f       	adc	r23, r23
    1e08:	88 1f       	adc	r24, r24
    1e0a:	99 1f       	adc	r25, r25
    1e0c:	0a 95       	dec	r16
    1e0e:	b2 f7       	brpl	.-20     	; 0x1dfc <__ashldi3+0x1a>
    1e10:	0f 91       	pop	r16
    1e12:	08 95       	ret

00001e14 <__ashrdi3>:
    1e14:	97 fb       	bst	r25, 7
    1e16:	10 f8       	bld	r1, 0

00001e18 <__lshrdi3>:
    1e18:	16 94       	lsr	r1
    1e1a:	00 08       	sbc	r0, r0
    1e1c:	0f 93       	push	r16
    1e1e:	08 30       	cpi	r16, 0x08	; 8
    1e20:	98 f0       	brcs	.+38     	; 0x1e48 <__lshrdi3+0x30>
    1e22:	08 50       	subi	r16, 0x08	; 8
    1e24:	23 2f       	mov	r18, r19
    1e26:	34 2f       	mov	r19, r20
    1e28:	45 2f       	mov	r20, r21
    1e2a:	56 2f       	mov	r21, r22
    1e2c:	67 2f       	mov	r22, r23
    1e2e:	78 2f       	mov	r23, r24
    1e30:	89 2f       	mov	r24, r25
    1e32:	90 2d       	mov	r25, r0
    1e34:	f4 cf       	rjmp	.-24     	; 0x1e1e <__lshrdi3+0x6>
    1e36:	05 94       	asr	r0
    1e38:	97 95       	ror	r25
    1e3a:	87 95       	ror	r24
    1e3c:	77 95       	ror	r23
    1e3e:	67 95       	ror	r22
    1e40:	57 95       	ror	r21
    1e42:	47 95       	ror	r20
    1e44:	37 95       	ror	r19
    1e46:	27 95       	ror	r18
    1e48:	0a 95       	dec	r16
    1e4a:	aa f7       	brpl	.-22     	; 0x1e36 <__lshrdi3+0x1e>
    1e4c:	0f 91       	pop	r16
    1e4e:	08 95       	ret

00001e50 <__adddi3>:
    1e50:	2a 0d       	add	r18, r10
    1e52:	3b 1d       	adc	r19, r11
    1e54:	4c 1d       	adc	r20, r12
    1e56:	5d 1d       	adc	r21, r13
    1e58:	6e 1d       	adc	r22, r14
    1e5a:	7f 1d       	adc	r23, r15
    1e5c:	80 1f       	adc	r24, r16
    1e5e:	91 1f       	adc	r25, r17
    1e60:	08 95       	ret

00001e62 <__subdi3>:
    1e62:	2a 19       	sub	r18, r10
    1e64:	3b 09       	sbc	r19, r11
    1e66:	4c 09       	sbc	r20, r12
    1e68:	5d 09       	sbc	r21, r13
    1e6a:	6e 09       	sbc	r22, r14
    1e6c:	7f 09       	sbc	r23, r15
    1e6e:	80 0b       	sbc	r24, r16
    1e70:	91 0b       	sbc	r25, r17
    1e72:	08 95       	ret

00001e74 <__cmpdi2_s8>:
    1e74:	00 24       	eor	r0, r0
    1e76:	a7 fd       	sbrc	r26, 7
    1e78:	00 94       	com	r0
    1e7a:	2a 17       	cp	r18, r26
    1e7c:	30 05       	cpc	r19, r0
    1e7e:	40 05       	cpc	r20, r0
    1e80:	50 05       	cpc	r21, r0
    1e82:	60 05       	cpc	r22, r0
    1e84:	70 05       	cpc	r23, r0
    1e86:	80 05       	cpc	r24, r0
    1e88:	90 05       	cpc	r25, r0
    1e8a:	08 95       	ret

00001e8c <__umulhisi3>:
    1e8c:	a2 9f       	mul	r26, r18
    1e8e:	b0 01       	movw	r22, r0
    1e90:	b3 9f       	mul	r27, r19
    1e92:	c0 01       	movw	r24, r0
    1e94:	a3 9f       	mul	r26, r19
    1e96:	70 0d       	add	r23, r0
    1e98:	81 1d       	adc	r24, r1
    1e9a:	11 24       	eor	r1, r1
    1e9c:	91 1d       	adc	r25, r1
    1e9e:	b2 9f       	mul	r27, r18
    1ea0:	70 0d       	add	r23, r0
    1ea2:	81 1d       	adc	r24, r1
    1ea4:	11 24       	eor	r1, r1
    1ea6:	91 1d       	adc	r25, r1
    1ea8:	08 95       	ret

00001eaa <printf>:
    1eaa:	a0 e0       	ldi	r26, 0x00	; 0
    1eac:	b0 e0       	ldi	r27, 0x00	; 0
    1eae:	ea e5       	ldi	r30, 0x5A	; 90
    1eb0:	ff e0       	ldi	r31, 0x0F	; 15
    1eb2:	70 cf       	rjmp	.-288    	; 0x1d94 <__prologue_saves__+0x20>
    1eb4:	ae 01       	movw	r20, r28
    1eb6:	4b 5f       	subi	r20, 0xFB	; 251
    1eb8:	5f 4f       	sbci	r21, 0xFF	; 255
    1eba:	fa 01       	movw	r30, r20
    1ebc:	61 91       	ld	r22, Z+
    1ebe:	71 91       	ld	r23, Z+
    1ec0:	af 01       	movw	r20, r30
    1ec2:	80 91 70 08 	lds	r24, 0x0870	; 0x800870 <__iob+0x2>
    1ec6:	90 91 71 08 	lds	r25, 0x0871	; 0x800871 <__iob+0x3>
    1eca:	07 d0       	rcall	.+14     	; 0x1eda <vfprintf>
    1ecc:	e2 e0       	ldi	r30, 0x02	; 2
    1ece:	7e cf       	rjmp	.-260    	; 0x1dcc <__epilogue_restores__+0x20>

00001ed0 <putchar>:
    1ed0:	60 91 70 08 	lds	r22, 0x0870	; 0x800870 <__iob+0x2>
    1ed4:	70 91 71 08 	lds	r23, 0x0871	; 0x800871 <__iob+0x3>
    1ed8:	d9 c1       	rjmp	.+946    	; 0x228c <fputc>

00001eda <vfprintf>:
    1eda:	ac e0       	ldi	r26, 0x0C	; 12
    1edc:	b0 e0       	ldi	r27, 0x00	; 0
    1ede:	e2 e7       	ldi	r30, 0x72	; 114
    1ee0:	ff e0       	ldi	r31, 0x0F	; 15
    1ee2:	48 cf       	rjmp	.-368    	; 0x1d74 <__prologue_saves__>
    1ee4:	7c 01       	movw	r14, r24
    1ee6:	6b 01       	movw	r12, r22
    1ee8:	8a 01       	movw	r16, r20
    1eea:	fc 01       	movw	r30, r24
    1eec:	17 82       	std	Z+7, r1	; 0x07
    1eee:	16 82       	std	Z+6, r1	; 0x06
    1ef0:	83 81       	ldd	r24, Z+3	; 0x03
    1ef2:	81 ff       	sbrs	r24, 1
    1ef4:	b0 c1       	rjmp	.+864    	; 0x2256 <vfprintf+0x37c>
    1ef6:	ce 01       	movw	r24, r28
    1ef8:	01 96       	adiw	r24, 0x01	; 1
    1efa:	4c 01       	movw	r8, r24
    1efc:	f7 01       	movw	r30, r14
    1efe:	93 81       	ldd	r25, Z+3	; 0x03
    1f00:	f6 01       	movw	r30, r12
    1f02:	93 fd       	sbrc	r25, 3
    1f04:	85 91       	lpm	r24, Z+
    1f06:	93 ff       	sbrs	r25, 3
    1f08:	81 91       	ld	r24, Z+
    1f0a:	6f 01       	movw	r12, r30
    1f0c:	88 23       	and	r24, r24
    1f0e:	09 f4       	brne	.+2      	; 0x1f12 <vfprintf+0x38>
    1f10:	9e c1       	rjmp	.+828    	; 0x224e <vfprintf+0x374>
    1f12:	85 32       	cpi	r24, 0x25	; 37
    1f14:	39 f4       	brne	.+14     	; 0x1f24 <vfprintf+0x4a>
    1f16:	93 fd       	sbrc	r25, 3
    1f18:	85 91       	lpm	r24, Z+
    1f1a:	93 ff       	sbrs	r25, 3
    1f1c:	81 91       	ld	r24, Z+
    1f1e:	6f 01       	movw	r12, r30
    1f20:	85 32       	cpi	r24, 0x25	; 37
    1f22:	21 f4       	brne	.+8      	; 0x1f2c <vfprintf+0x52>
    1f24:	b7 01       	movw	r22, r14
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	b1 d1       	rcall	.+866    	; 0x228c <fputc>
    1f2a:	e8 cf       	rjmp	.-48     	; 0x1efc <vfprintf+0x22>
    1f2c:	51 2c       	mov	r5, r1
    1f2e:	31 2c       	mov	r3, r1
    1f30:	20 e0       	ldi	r18, 0x00	; 0
    1f32:	20 32       	cpi	r18, 0x20	; 32
    1f34:	a0 f4       	brcc	.+40     	; 0x1f5e <vfprintf+0x84>
    1f36:	8b 32       	cpi	r24, 0x2B	; 43
    1f38:	69 f0       	breq	.+26     	; 0x1f54 <vfprintf+0x7a>
    1f3a:	30 f4       	brcc	.+12     	; 0x1f48 <vfprintf+0x6e>
    1f3c:	80 32       	cpi	r24, 0x20	; 32
    1f3e:	59 f0       	breq	.+22     	; 0x1f56 <vfprintf+0x7c>
    1f40:	83 32       	cpi	r24, 0x23	; 35
    1f42:	69 f4       	brne	.+26     	; 0x1f5e <vfprintf+0x84>
    1f44:	20 61       	ori	r18, 0x10	; 16
    1f46:	2c c0       	rjmp	.+88     	; 0x1fa0 <vfprintf+0xc6>
    1f48:	8d 32       	cpi	r24, 0x2D	; 45
    1f4a:	39 f0       	breq	.+14     	; 0x1f5a <vfprintf+0x80>
    1f4c:	80 33       	cpi	r24, 0x30	; 48
    1f4e:	39 f4       	brne	.+14     	; 0x1f5e <vfprintf+0x84>
    1f50:	21 60       	ori	r18, 0x01	; 1
    1f52:	26 c0       	rjmp	.+76     	; 0x1fa0 <vfprintf+0xc6>
    1f54:	22 60       	ori	r18, 0x02	; 2
    1f56:	24 60       	ori	r18, 0x04	; 4
    1f58:	23 c0       	rjmp	.+70     	; 0x1fa0 <vfprintf+0xc6>
    1f5a:	28 60       	ori	r18, 0x08	; 8
    1f5c:	21 c0       	rjmp	.+66     	; 0x1fa0 <vfprintf+0xc6>
    1f5e:	27 fd       	sbrc	r18, 7
    1f60:	27 c0       	rjmp	.+78     	; 0x1fb0 <vfprintf+0xd6>
    1f62:	30 ed       	ldi	r19, 0xD0	; 208
    1f64:	38 0f       	add	r19, r24
    1f66:	3a 30       	cpi	r19, 0x0A	; 10
    1f68:	78 f4       	brcc	.+30     	; 0x1f88 <vfprintf+0xae>
    1f6a:	26 ff       	sbrs	r18, 6
    1f6c:	06 c0       	rjmp	.+12     	; 0x1f7a <vfprintf+0xa0>
    1f6e:	fa e0       	ldi	r31, 0x0A	; 10
    1f70:	5f 9e       	mul	r5, r31
    1f72:	30 0d       	add	r19, r0
    1f74:	11 24       	eor	r1, r1
    1f76:	53 2e       	mov	r5, r19
    1f78:	13 c0       	rjmp	.+38     	; 0x1fa0 <vfprintf+0xc6>
    1f7a:	8a e0       	ldi	r24, 0x0A	; 10
    1f7c:	38 9e       	mul	r3, r24
    1f7e:	30 0d       	add	r19, r0
    1f80:	11 24       	eor	r1, r1
    1f82:	33 2e       	mov	r3, r19
    1f84:	20 62       	ori	r18, 0x20	; 32
    1f86:	0c c0       	rjmp	.+24     	; 0x1fa0 <vfprintf+0xc6>
    1f88:	8e 32       	cpi	r24, 0x2E	; 46
    1f8a:	21 f4       	brne	.+8      	; 0x1f94 <vfprintf+0xba>
    1f8c:	26 fd       	sbrc	r18, 6
    1f8e:	5f c1       	rjmp	.+702    	; 0x224e <vfprintf+0x374>
    1f90:	20 64       	ori	r18, 0x40	; 64
    1f92:	06 c0       	rjmp	.+12     	; 0x1fa0 <vfprintf+0xc6>
    1f94:	8c 36       	cpi	r24, 0x6C	; 108
    1f96:	11 f4       	brne	.+4      	; 0x1f9c <vfprintf+0xc2>
    1f98:	20 68       	ori	r18, 0x80	; 128
    1f9a:	02 c0       	rjmp	.+4      	; 0x1fa0 <vfprintf+0xc6>
    1f9c:	88 36       	cpi	r24, 0x68	; 104
    1f9e:	41 f4       	brne	.+16     	; 0x1fb0 <vfprintf+0xd6>
    1fa0:	f6 01       	movw	r30, r12
    1fa2:	93 fd       	sbrc	r25, 3
    1fa4:	85 91       	lpm	r24, Z+
    1fa6:	93 ff       	sbrs	r25, 3
    1fa8:	81 91       	ld	r24, Z+
    1faa:	6f 01       	movw	r12, r30
    1fac:	81 11       	cpse	r24, r1
    1fae:	c1 cf       	rjmp	.-126    	; 0x1f32 <vfprintf+0x58>
    1fb0:	98 2f       	mov	r25, r24
    1fb2:	9f 7d       	andi	r25, 0xDF	; 223
    1fb4:	95 54       	subi	r25, 0x45	; 69
    1fb6:	93 30       	cpi	r25, 0x03	; 3
    1fb8:	28 f4       	brcc	.+10     	; 0x1fc4 <vfprintf+0xea>
    1fba:	0c 5f       	subi	r16, 0xFC	; 252
    1fbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1fbe:	ff e3       	ldi	r31, 0x3F	; 63
    1fc0:	f9 83       	std	Y+1, r31	; 0x01
    1fc2:	0d c0       	rjmp	.+26     	; 0x1fde <vfprintf+0x104>
    1fc4:	83 36       	cpi	r24, 0x63	; 99
    1fc6:	31 f0       	breq	.+12     	; 0x1fd4 <vfprintf+0xfa>
    1fc8:	83 37       	cpi	r24, 0x73	; 115
    1fca:	71 f0       	breq	.+28     	; 0x1fe8 <vfprintf+0x10e>
    1fcc:	83 35       	cpi	r24, 0x53	; 83
    1fce:	09 f0       	breq	.+2      	; 0x1fd2 <vfprintf+0xf8>
    1fd0:	57 c0       	rjmp	.+174    	; 0x2080 <vfprintf+0x1a6>
    1fd2:	21 c0       	rjmp	.+66     	; 0x2016 <vfprintf+0x13c>
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	80 81       	ld	r24, Z
    1fd8:	89 83       	std	Y+1, r24	; 0x01
    1fda:	0e 5f       	subi	r16, 0xFE	; 254
    1fdc:	1f 4f       	sbci	r17, 0xFF	; 255
    1fde:	44 24       	eor	r4, r4
    1fe0:	43 94       	inc	r4
    1fe2:	51 2c       	mov	r5, r1
    1fe4:	54 01       	movw	r10, r8
    1fe6:	14 c0       	rjmp	.+40     	; 0x2010 <vfprintf+0x136>
    1fe8:	38 01       	movw	r6, r16
    1fea:	f2 e0       	ldi	r31, 0x02	; 2
    1fec:	6f 0e       	add	r6, r31
    1fee:	71 1c       	adc	r7, r1
    1ff0:	f8 01       	movw	r30, r16
    1ff2:	a0 80       	ld	r10, Z
    1ff4:	b1 80       	ldd	r11, Z+1	; 0x01
    1ff6:	26 ff       	sbrs	r18, 6
    1ff8:	03 c0       	rjmp	.+6      	; 0x2000 <vfprintf+0x126>
    1ffa:	65 2d       	mov	r22, r5
    1ffc:	70 e0       	ldi	r23, 0x00	; 0
    1ffe:	02 c0       	rjmp	.+4      	; 0x2004 <vfprintf+0x12a>
    2000:	6f ef       	ldi	r22, 0xFF	; 255
    2002:	7f ef       	ldi	r23, 0xFF	; 255
    2004:	c5 01       	movw	r24, r10
    2006:	2c 87       	std	Y+12, r18	; 0x0c
    2008:	36 d1       	rcall	.+620    	; 0x2276 <strnlen>
    200a:	2c 01       	movw	r4, r24
    200c:	83 01       	movw	r16, r6
    200e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2010:	2f 77       	andi	r18, 0x7F	; 127
    2012:	22 2e       	mov	r2, r18
    2014:	16 c0       	rjmp	.+44     	; 0x2042 <vfprintf+0x168>
    2016:	38 01       	movw	r6, r16
    2018:	f2 e0       	ldi	r31, 0x02	; 2
    201a:	6f 0e       	add	r6, r31
    201c:	71 1c       	adc	r7, r1
    201e:	f8 01       	movw	r30, r16
    2020:	a0 80       	ld	r10, Z
    2022:	b1 80       	ldd	r11, Z+1	; 0x01
    2024:	26 ff       	sbrs	r18, 6
    2026:	03 c0       	rjmp	.+6      	; 0x202e <vfprintf+0x154>
    2028:	65 2d       	mov	r22, r5
    202a:	70 e0       	ldi	r23, 0x00	; 0
    202c:	02 c0       	rjmp	.+4      	; 0x2032 <vfprintf+0x158>
    202e:	6f ef       	ldi	r22, 0xFF	; 255
    2030:	7f ef       	ldi	r23, 0xFF	; 255
    2032:	c5 01       	movw	r24, r10
    2034:	2c 87       	std	Y+12, r18	; 0x0c
    2036:	14 d1       	rcall	.+552    	; 0x2260 <strnlen_P>
    2038:	2c 01       	movw	r4, r24
    203a:	2c 85       	ldd	r18, Y+12	; 0x0c
    203c:	20 68       	ori	r18, 0x80	; 128
    203e:	22 2e       	mov	r2, r18
    2040:	83 01       	movw	r16, r6
    2042:	23 fc       	sbrc	r2, 3
    2044:	19 c0       	rjmp	.+50     	; 0x2078 <vfprintf+0x19e>
    2046:	83 2d       	mov	r24, r3
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	48 16       	cp	r4, r24
    204c:	59 06       	cpc	r5, r25
    204e:	a0 f4       	brcc	.+40     	; 0x2078 <vfprintf+0x19e>
    2050:	b7 01       	movw	r22, r14
    2052:	80 e2       	ldi	r24, 0x20	; 32
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	1a d1       	rcall	.+564    	; 0x228c <fputc>
    2058:	3a 94       	dec	r3
    205a:	f5 cf       	rjmp	.-22     	; 0x2046 <vfprintf+0x16c>
    205c:	f5 01       	movw	r30, r10
    205e:	27 fc       	sbrc	r2, 7
    2060:	85 91       	lpm	r24, Z+
    2062:	27 fe       	sbrs	r2, 7
    2064:	81 91       	ld	r24, Z+
    2066:	5f 01       	movw	r10, r30
    2068:	b7 01       	movw	r22, r14
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	0f d1       	rcall	.+542    	; 0x228c <fputc>
    206e:	31 10       	cpse	r3, r1
    2070:	3a 94       	dec	r3
    2072:	f1 e0       	ldi	r31, 0x01	; 1
    2074:	4f 1a       	sub	r4, r31
    2076:	51 08       	sbc	r5, r1
    2078:	41 14       	cp	r4, r1
    207a:	51 04       	cpc	r5, r1
    207c:	79 f7       	brne	.-34     	; 0x205c <vfprintf+0x182>
    207e:	de c0       	rjmp	.+444    	; 0x223c <vfprintf+0x362>
    2080:	84 36       	cpi	r24, 0x64	; 100
    2082:	11 f0       	breq	.+4      	; 0x2088 <vfprintf+0x1ae>
    2084:	89 36       	cpi	r24, 0x69	; 105
    2086:	31 f5       	brne	.+76     	; 0x20d4 <vfprintf+0x1fa>
    2088:	f8 01       	movw	r30, r16
    208a:	27 ff       	sbrs	r18, 7
    208c:	07 c0       	rjmp	.+14     	; 0x209c <vfprintf+0x1c2>
    208e:	60 81       	ld	r22, Z
    2090:	71 81       	ldd	r23, Z+1	; 0x01
    2092:	82 81       	ldd	r24, Z+2	; 0x02
    2094:	93 81       	ldd	r25, Z+3	; 0x03
    2096:	0c 5f       	subi	r16, 0xFC	; 252
    2098:	1f 4f       	sbci	r17, 0xFF	; 255
    209a:	08 c0       	rjmp	.+16     	; 0x20ac <vfprintf+0x1d2>
    209c:	60 81       	ld	r22, Z
    209e:	71 81       	ldd	r23, Z+1	; 0x01
    20a0:	07 2e       	mov	r0, r23
    20a2:	00 0c       	add	r0, r0
    20a4:	88 0b       	sbc	r24, r24
    20a6:	99 0b       	sbc	r25, r25
    20a8:	0e 5f       	subi	r16, 0xFE	; 254
    20aa:	1f 4f       	sbci	r17, 0xFF	; 255
    20ac:	2f 76       	andi	r18, 0x6F	; 111
    20ae:	72 2e       	mov	r7, r18
    20b0:	97 ff       	sbrs	r25, 7
    20b2:	09 c0       	rjmp	.+18     	; 0x20c6 <vfprintf+0x1ec>
    20b4:	90 95       	com	r25
    20b6:	80 95       	com	r24
    20b8:	70 95       	com	r23
    20ba:	61 95       	neg	r22
    20bc:	7f 4f       	sbci	r23, 0xFF	; 255
    20be:	8f 4f       	sbci	r24, 0xFF	; 255
    20c0:	9f 4f       	sbci	r25, 0xFF	; 255
    20c2:	20 68       	ori	r18, 0x80	; 128
    20c4:	72 2e       	mov	r7, r18
    20c6:	2a e0       	ldi	r18, 0x0A	; 10
    20c8:	30 e0       	ldi	r19, 0x00	; 0
    20ca:	a4 01       	movw	r20, r8
    20cc:	17 d1       	rcall	.+558    	; 0x22fc <__ultoa_invert>
    20ce:	a8 2e       	mov	r10, r24
    20d0:	a8 18       	sub	r10, r8
    20d2:	43 c0       	rjmp	.+134    	; 0x215a <vfprintf+0x280>
    20d4:	85 37       	cpi	r24, 0x75	; 117
    20d6:	29 f4       	brne	.+10     	; 0x20e2 <vfprintf+0x208>
    20d8:	2f 7e       	andi	r18, 0xEF	; 239
    20da:	b2 2e       	mov	r11, r18
    20dc:	2a e0       	ldi	r18, 0x0A	; 10
    20de:	30 e0       	ldi	r19, 0x00	; 0
    20e0:	25 c0       	rjmp	.+74     	; 0x212c <vfprintf+0x252>
    20e2:	f2 2f       	mov	r31, r18
    20e4:	f9 7f       	andi	r31, 0xF9	; 249
    20e6:	bf 2e       	mov	r11, r31
    20e8:	8f 36       	cpi	r24, 0x6F	; 111
    20ea:	c1 f0       	breq	.+48     	; 0x211c <vfprintf+0x242>
    20ec:	18 f4       	brcc	.+6      	; 0x20f4 <vfprintf+0x21a>
    20ee:	88 35       	cpi	r24, 0x58	; 88
    20f0:	79 f0       	breq	.+30     	; 0x2110 <vfprintf+0x236>
    20f2:	ad c0       	rjmp	.+346    	; 0x224e <vfprintf+0x374>
    20f4:	80 37       	cpi	r24, 0x70	; 112
    20f6:	19 f0       	breq	.+6      	; 0x20fe <vfprintf+0x224>
    20f8:	88 37       	cpi	r24, 0x78	; 120
    20fa:	21 f0       	breq	.+8      	; 0x2104 <vfprintf+0x22a>
    20fc:	a8 c0       	rjmp	.+336    	; 0x224e <vfprintf+0x374>
    20fe:	2f 2f       	mov	r18, r31
    2100:	20 61       	ori	r18, 0x10	; 16
    2102:	b2 2e       	mov	r11, r18
    2104:	b4 fe       	sbrs	r11, 4
    2106:	0d c0       	rjmp	.+26     	; 0x2122 <vfprintf+0x248>
    2108:	8b 2d       	mov	r24, r11
    210a:	84 60       	ori	r24, 0x04	; 4
    210c:	b8 2e       	mov	r11, r24
    210e:	09 c0       	rjmp	.+18     	; 0x2122 <vfprintf+0x248>
    2110:	24 ff       	sbrs	r18, 4
    2112:	0a c0       	rjmp	.+20     	; 0x2128 <vfprintf+0x24e>
    2114:	9f 2f       	mov	r25, r31
    2116:	96 60       	ori	r25, 0x06	; 6
    2118:	b9 2e       	mov	r11, r25
    211a:	06 c0       	rjmp	.+12     	; 0x2128 <vfprintf+0x24e>
    211c:	28 e0       	ldi	r18, 0x08	; 8
    211e:	30 e0       	ldi	r19, 0x00	; 0
    2120:	05 c0       	rjmp	.+10     	; 0x212c <vfprintf+0x252>
    2122:	20 e1       	ldi	r18, 0x10	; 16
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	02 c0       	rjmp	.+4      	; 0x212c <vfprintf+0x252>
    2128:	20 e1       	ldi	r18, 0x10	; 16
    212a:	32 e0       	ldi	r19, 0x02	; 2
    212c:	f8 01       	movw	r30, r16
    212e:	b7 fe       	sbrs	r11, 7
    2130:	07 c0       	rjmp	.+14     	; 0x2140 <vfprintf+0x266>
    2132:	60 81       	ld	r22, Z
    2134:	71 81       	ldd	r23, Z+1	; 0x01
    2136:	82 81       	ldd	r24, Z+2	; 0x02
    2138:	93 81       	ldd	r25, Z+3	; 0x03
    213a:	0c 5f       	subi	r16, 0xFC	; 252
    213c:	1f 4f       	sbci	r17, 0xFF	; 255
    213e:	06 c0       	rjmp	.+12     	; 0x214c <vfprintf+0x272>
    2140:	60 81       	ld	r22, Z
    2142:	71 81       	ldd	r23, Z+1	; 0x01
    2144:	80 e0       	ldi	r24, 0x00	; 0
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	0e 5f       	subi	r16, 0xFE	; 254
    214a:	1f 4f       	sbci	r17, 0xFF	; 255
    214c:	a4 01       	movw	r20, r8
    214e:	d6 d0       	rcall	.+428    	; 0x22fc <__ultoa_invert>
    2150:	a8 2e       	mov	r10, r24
    2152:	a8 18       	sub	r10, r8
    2154:	fb 2d       	mov	r31, r11
    2156:	ff 77       	andi	r31, 0x7F	; 127
    2158:	7f 2e       	mov	r7, r31
    215a:	76 fe       	sbrs	r7, 6
    215c:	0b c0       	rjmp	.+22     	; 0x2174 <vfprintf+0x29a>
    215e:	37 2d       	mov	r19, r7
    2160:	3e 7f       	andi	r19, 0xFE	; 254
    2162:	a5 14       	cp	r10, r5
    2164:	50 f4       	brcc	.+20     	; 0x217a <vfprintf+0x2a0>
    2166:	74 fe       	sbrs	r7, 4
    2168:	0a c0       	rjmp	.+20     	; 0x217e <vfprintf+0x2a4>
    216a:	72 fc       	sbrc	r7, 2
    216c:	08 c0       	rjmp	.+16     	; 0x217e <vfprintf+0x2a4>
    216e:	37 2d       	mov	r19, r7
    2170:	3e 7e       	andi	r19, 0xEE	; 238
    2172:	05 c0       	rjmp	.+10     	; 0x217e <vfprintf+0x2a4>
    2174:	ba 2c       	mov	r11, r10
    2176:	37 2d       	mov	r19, r7
    2178:	03 c0       	rjmp	.+6      	; 0x2180 <vfprintf+0x2a6>
    217a:	ba 2c       	mov	r11, r10
    217c:	01 c0       	rjmp	.+2      	; 0x2180 <vfprintf+0x2a6>
    217e:	b5 2c       	mov	r11, r5
    2180:	34 ff       	sbrs	r19, 4
    2182:	0d c0       	rjmp	.+26     	; 0x219e <vfprintf+0x2c4>
    2184:	fe 01       	movw	r30, r28
    2186:	ea 0d       	add	r30, r10
    2188:	f1 1d       	adc	r31, r1
    218a:	80 81       	ld	r24, Z
    218c:	80 33       	cpi	r24, 0x30	; 48
    218e:	11 f4       	brne	.+4      	; 0x2194 <vfprintf+0x2ba>
    2190:	39 7e       	andi	r19, 0xE9	; 233
    2192:	09 c0       	rjmp	.+18     	; 0x21a6 <vfprintf+0x2cc>
    2194:	32 ff       	sbrs	r19, 2
    2196:	06 c0       	rjmp	.+12     	; 0x21a4 <vfprintf+0x2ca>
    2198:	b3 94       	inc	r11
    219a:	b3 94       	inc	r11
    219c:	04 c0       	rjmp	.+8      	; 0x21a6 <vfprintf+0x2cc>
    219e:	83 2f       	mov	r24, r19
    21a0:	86 78       	andi	r24, 0x86	; 134
    21a2:	09 f0       	breq	.+2      	; 0x21a6 <vfprintf+0x2cc>
    21a4:	b3 94       	inc	r11
    21a6:	33 fd       	sbrc	r19, 3
    21a8:	12 c0       	rjmp	.+36     	; 0x21ce <vfprintf+0x2f4>
    21aa:	30 ff       	sbrs	r19, 0
    21ac:	06 c0       	rjmp	.+12     	; 0x21ba <vfprintf+0x2e0>
    21ae:	5a 2c       	mov	r5, r10
    21b0:	b3 14       	cp	r11, r3
    21b2:	18 f4       	brcc	.+6      	; 0x21ba <vfprintf+0x2e0>
    21b4:	53 0c       	add	r5, r3
    21b6:	5b 18       	sub	r5, r11
    21b8:	b3 2c       	mov	r11, r3
    21ba:	b3 14       	cp	r11, r3
    21bc:	60 f4       	brcc	.+24     	; 0x21d6 <vfprintf+0x2fc>
    21be:	b7 01       	movw	r22, r14
    21c0:	80 e2       	ldi	r24, 0x20	; 32
    21c2:	90 e0       	ldi	r25, 0x00	; 0
    21c4:	3c 87       	std	Y+12, r19	; 0x0c
    21c6:	62 d0       	rcall	.+196    	; 0x228c <fputc>
    21c8:	b3 94       	inc	r11
    21ca:	3c 85       	ldd	r19, Y+12	; 0x0c
    21cc:	f6 cf       	rjmp	.-20     	; 0x21ba <vfprintf+0x2e0>
    21ce:	b3 14       	cp	r11, r3
    21d0:	10 f4       	brcc	.+4      	; 0x21d6 <vfprintf+0x2fc>
    21d2:	3b 18       	sub	r3, r11
    21d4:	01 c0       	rjmp	.+2      	; 0x21d8 <vfprintf+0x2fe>
    21d6:	31 2c       	mov	r3, r1
    21d8:	34 ff       	sbrs	r19, 4
    21da:	11 c0       	rjmp	.+34     	; 0x21fe <vfprintf+0x324>
    21dc:	b7 01       	movw	r22, r14
    21de:	80 e3       	ldi	r24, 0x30	; 48
    21e0:	90 e0       	ldi	r25, 0x00	; 0
    21e2:	3c 87       	std	Y+12, r19	; 0x0c
    21e4:	53 d0       	rcall	.+166    	; 0x228c <fputc>
    21e6:	3c 85       	ldd	r19, Y+12	; 0x0c
    21e8:	32 ff       	sbrs	r19, 2
    21ea:	16 c0       	rjmp	.+44     	; 0x2218 <vfprintf+0x33e>
    21ec:	31 fd       	sbrc	r19, 1
    21ee:	03 c0       	rjmp	.+6      	; 0x21f6 <vfprintf+0x31c>
    21f0:	88 e7       	ldi	r24, 0x78	; 120
    21f2:	90 e0       	ldi	r25, 0x00	; 0
    21f4:	02 c0       	rjmp	.+4      	; 0x21fa <vfprintf+0x320>
    21f6:	88 e5       	ldi	r24, 0x58	; 88
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	b7 01       	movw	r22, r14
    21fc:	0c c0       	rjmp	.+24     	; 0x2216 <vfprintf+0x33c>
    21fe:	83 2f       	mov	r24, r19
    2200:	86 78       	andi	r24, 0x86	; 134
    2202:	51 f0       	breq	.+20     	; 0x2218 <vfprintf+0x33e>
    2204:	31 ff       	sbrs	r19, 1
    2206:	02 c0       	rjmp	.+4      	; 0x220c <vfprintf+0x332>
    2208:	8b e2       	ldi	r24, 0x2B	; 43
    220a:	01 c0       	rjmp	.+2      	; 0x220e <vfprintf+0x334>
    220c:	80 e2       	ldi	r24, 0x20	; 32
    220e:	37 fd       	sbrc	r19, 7
    2210:	8d e2       	ldi	r24, 0x2D	; 45
    2212:	b7 01       	movw	r22, r14
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	3a d0       	rcall	.+116    	; 0x228c <fputc>
    2218:	a5 14       	cp	r10, r5
    221a:	30 f4       	brcc	.+12     	; 0x2228 <vfprintf+0x34e>
    221c:	b7 01       	movw	r22, r14
    221e:	80 e3       	ldi	r24, 0x30	; 48
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	34 d0       	rcall	.+104    	; 0x228c <fputc>
    2224:	5a 94       	dec	r5
    2226:	f8 cf       	rjmp	.-16     	; 0x2218 <vfprintf+0x33e>
    2228:	aa 94       	dec	r10
    222a:	f4 01       	movw	r30, r8
    222c:	ea 0d       	add	r30, r10
    222e:	f1 1d       	adc	r31, r1
    2230:	80 81       	ld	r24, Z
    2232:	b7 01       	movw	r22, r14
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	2a d0       	rcall	.+84     	; 0x228c <fputc>
    2238:	a1 10       	cpse	r10, r1
    223a:	f6 cf       	rjmp	.-20     	; 0x2228 <vfprintf+0x34e>
    223c:	33 20       	and	r3, r3
    223e:	09 f4       	brne	.+2      	; 0x2242 <vfprintf+0x368>
    2240:	5d ce       	rjmp	.-838    	; 0x1efc <vfprintf+0x22>
    2242:	b7 01       	movw	r22, r14
    2244:	80 e2       	ldi	r24, 0x20	; 32
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	21 d0       	rcall	.+66     	; 0x228c <fputc>
    224a:	3a 94       	dec	r3
    224c:	f7 cf       	rjmp	.-18     	; 0x223c <vfprintf+0x362>
    224e:	f7 01       	movw	r30, r14
    2250:	86 81       	ldd	r24, Z+6	; 0x06
    2252:	97 81       	ldd	r25, Z+7	; 0x07
    2254:	02 c0       	rjmp	.+4      	; 0x225a <vfprintf+0x380>
    2256:	8f ef       	ldi	r24, 0xFF	; 255
    2258:	9f ef       	ldi	r25, 0xFF	; 255
    225a:	2c 96       	adiw	r28, 0x0c	; 12
    225c:	e2 e1       	ldi	r30, 0x12	; 18
    225e:	a6 cd       	rjmp	.-1204   	; 0x1dac <__epilogue_restores__>

00002260 <strnlen_P>:
    2260:	fc 01       	movw	r30, r24
    2262:	05 90       	lpm	r0, Z+
    2264:	61 50       	subi	r22, 0x01	; 1
    2266:	70 40       	sbci	r23, 0x00	; 0
    2268:	01 10       	cpse	r0, r1
    226a:	d8 f7       	brcc	.-10     	; 0x2262 <strnlen_P+0x2>
    226c:	80 95       	com	r24
    226e:	90 95       	com	r25
    2270:	8e 0f       	add	r24, r30
    2272:	9f 1f       	adc	r25, r31
    2274:	08 95       	ret

00002276 <strnlen>:
    2276:	fc 01       	movw	r30, r24
    2278:	61 50       	subi	r22, 0x01	; 1
    227a:	70 40       	sbci	r23, 0x00	; 0
    227c:	01 90       	ld	r0, Z+
    227e:	01 10       	cpse	r0, r1
    2280:	d8 f7       	brcc	.-10     	; 0x2278 <strnlen+0x2>
    2282:	80 95       	com	r24
    2284:	90 95       	com	r25
    2286:	8e 0f       	add	r24, r30
    2288:	9f 1f       	adc	r25, r31
    228a:	08 95       	ret

0000228c <fputc>:
    228c:	0f 93       	push	r16
    228e:	1f 93       	push	r17
    2290:	cf 93       	push	r28
    2292:	df 93       	push	r29
    2294:	fb 01       	movw	r30, r22
    2296:	23 81       	ldd	r18, Z+3	; 0x03
    2298:	21 fd       	sbrc	r18, 1
    229a:	03 c0       	rjmp	.+6      	; 0x22a2 <fputc+0x16>
    229c:	8f ef       	ldi	r24, 0xFF	; 255
    229e:	9f ef       	ldi	r25, 0xFF	; 255
    22a0:	28 c0       	rjmp	.+80     	; 0x22f2 <fputc+0x66>
    22a2:	22 ff       	sbrs	r18, 2
    22a4:	16 c0       	rjmp	.+44     	; 0x22d2 <fputc+0x46>
    22a6:	46 81       	ldd	r20, Z+6	; 0x06
    22a8:	57 81       	ldd	r21, Z+7	; 0x07
    22aa:	24 81       	ldd	r18, Z+4	; 0x04
    22ac:	35 81       	ldd	r19, Z+5	; 0x05
    22ae:	42 17       	cp	r20, r18
    22b0:	53 07       	cpc	r21, r19
    22b2:	44 f4       	brge	.+16     	; 0x22c4 <fputc+0x38>
    22b4:	a0 81       	ld	r26, Z
    22b6:	b1 81       	ldd	r27, Z+1	; 0x01
    22b8:	9d 01       	movw	r18, r26
    22ba:	2f 5f       	subi	r18, 0xFF	; 255
    22bc:	3f 4f       	sbci	r19, 0xFF	; 255
    22be:	31 83       	std	Z+1, r19	; 0x01
    22c0:	20 83       	st	Z, r18
    22c2:	8c 93       	st	X, r24
    22c4:	26 81       	ldd	r18, Z+6	; 0x06
    22c6:	37 81       	ldd	r19, Z+7	; 0x07
    22c8:	2f 5f       	subi	r18, 0xFF	; 255
    22ca:	3f 4f       	sbci	r19, 0xFF	; 255
    22cc:	37 83       	std	Z+7, r19	; 0x07
    22ce:	26 83       	std	Z+6, r18	; 0x06
    22d0:	10 c0       	rjmp	.+32     	; 0x22f2 <fputc+0x66>
    22d2:	eb 01       	movw	r28, r22
    22d4:	09 2f       	mov	r16, r25
    22d6:	18 2f       	mov	r17, r24
    22d8:	00 84       	ldd	r0, Z+8	; 0x08
    22da:	f1 85       	ldd	r31, Z+9	; 0x09
    22dc:	e0 2d       	mov	r30, r0
    22de:	09 95       	icall
    22e0:	89 2b       	or	r24, r25
    22e2:	e1 f6       	brne	.-72     	; 0x229c <fputc+0x10>
    22e4:	8e 81       	ldd	r24, Y+6	; 0x06
    22e6:	9f 81       	ldd	r25, Y+7	; 0x07
    22e8:	01 96       	adiw	r24, 0x01	; 1
    22ea:	9f 83       	std	Y+7, r25	; 0x07
    22ec:	8e 83       	std	Y+6, r24	; 0x06
    22ee:	81 2f       	mov	r24, r17
    22f0:	90 2f       	mov	r25, r16
    22f2:	df 91       	pop	r29
    22f4:	cf 91       	pop	r28
    22f6:	1f 91       	pop	r17
    22f8:	0f 91       	pop	r16
    22fa:	08 95       	ret

000022fc <__ultoa_invert>:
    22fc:	fa 01       	movw	r30, r20
    22fe:	aa 27       	eor	r26, r26
    2300:	28 30       	cpi	r18, 0x08	; 8
    2302:	51 f1       	breq	.+84     	; 0x2358 <__ultoa_invert+0x5c>
    2304:	20 31       	cpi	r18, 0x10	; 16
    2306:	81 f1       	breq	.+96     	; 0x2368 <__ultoa_invert+0x6c>
    2308:	e8 94       	clt
    230a:	6f 93       	push	r22
    230c:	6e 7f       	andi	r22, 0xFE	; 254
    230e:	6e 5f       	subi	r22, 0xFE	; 254
    2310:	7f 4f       	sbci	r23, 0xFF	; 255
    2312:	8f 4f       	sbci	r24, 0xFF	; 255
    2314:	9f 4f       	sbci	r25, 0xFF	; 255
    2316:	af 4f       	sbci	r26, 0xFF	; 255
    2318:	b1 e0       	ldi	r27, 0x01	; 1
    231a:	3e d0       	rcall	.+124    	; 0x2398 <__ultoa_invert+0x9c>
    231c:	b4 e0       	ldi	r27, 0x04	; 4
    231e:	3c d0       	rcall	.+120    	; 0x2398 <__ultoa_invert+0x9c>
    2320:	67 0f       	add	r22, r23
    2322:	78 1f       	adc	r23, r24
    2324:	89 1f       	adc	r24, r25
    2326:	9a 1f       	adc	r25, r26
    2328:	a1 1d       	adc	r26, r1
    232a:	68 0f       	add	r22, r24
    232c:	79 1f       	adc	r23, r25
    232e:	8a 1f       	adc	r24, r26
    2330:	91 1d       	adc	r25, r1
    2332:	a1 1d       	adc	r26, r1
    2334:	6a 0f       	add	r22, r26
    2336:	71 1d       	adc	r23, r1
    2338:	81 1d       	adc	r24, r1
    233a:	91 1d       	adc	r25, r1
    233c:	a1 1d       	adc	r26, r1
    233e:	20 d0       	rcall	.+64     	; 0x2380 <__ultoa_invert+0x84>
    2340:	09 f4       	brne	.+2      	; 0x2344 <__ultoa_invert+0x48>
    2342:	68 94       	set
    2344:	3f 91       	pop	r19
    2346:	2a e0       	ldi	r18, 0x0A	; 10
    2348:	26 9f       	mul	r18, r22
    234a:	11 24       	eor	r1, r1
    234c:	30 19       	sub	r19, r0
    234e:	30 5d       	subi	r19, 0xD0	; 208
    2350:	31 93       	st	Z+, r19
    2352:	de f6       	brtc	.-74     	; 0x230a <__ultoa_invert+0xe>
    2354:	cf 01       	movw	r24, r30
    2356:	08 95       	ret
    2358:	46 2f       	mov	r20, r22
    235a:	47 70       	andi	r20, 0x07	; 7
    235c:	40 5d       	subi	r20, 0xD0	; 208
    235e:	41 93       	st	Z+, r20
    2360:	b3 e0       	ldi	r27, 0x03	; 3
    2362:	0f d0       	rcall	.+30     	; 0x2382 <__ultoa_invert+0x86>
    2364:	c9 f7       	brne	.-14     	; 0x2358 <__ultoa_invert+0x5c>
    2366:	f6 cf       	rjmp	.-20     	; 0x2354 <__ultoa_invert+0x58>
    2368:	46 2f       	mov	r20, r22
    236a:	4f 70       	andi	r20, 0x0F	; 15
    236c:	40 5d       	subi	r20, 0xD0	; 208
    236e:	4a 33       	cpi	r20, 0x3A	; 58
    2370:	18 f0       	brcs	.+6      	; 0x2378 <__ultoa_invert+0x7c>
    2372:	49 5d       	subi	r20, 0xD9	; 217
    2374:	31 fd       	sbrc	r19, 1
    2376:	40 52       	subi	r20, 0x20	; 32
    2378:	41 93       	st	Z+, r20
    237a:	02 d0       	rcall	.+4      	; 0x2380 <__ultoa_invert+0x84>
    237c:	a9 f7       	brne	.-22     	; 0x2368 <__ultoa_invert+0x6c>
    237e:	ea cf       	rjmp	.-44     	; 0x2354 <__ultoa_invert+0x58>
    2380:	b4 e0       	ldi	r27, 0x04	; 4
    2382:	a6 95       	lsr	r26
    2384:	97 95       	ror	r25
    2386:	87 95       	ror	r24
    2388:	77 95       	ror	r23
    238a:	67 95       	ror	r22
    238c:	ba 95       	dec	r27
    238e:	c9 f7       	brne	.-14     	; 0x2382 <__ultoa_invert+0x86>
    2390:	00 97       	sbiw	r24, 0x00	; 0
    2392:	61 05       	cpc	r22, r1
    2394:	71 05       	cpc	r23, r1
    2396:	08 95       	ret
    2398:	9b 01       	movw	r18, r22
    239a:	ac 01       	movw	r20, r24
    239c:	0a 2e       	mov	r0, r26
    239e:	06 94       	lsr	r0
    23a0:	57 95       	ror	r21
    23a2:	47 95       	ror	r20
    23a4:	37 95       	ror	r19
    23a6:	27 95       	ror	r18
    23a8:	ba 95       	dec	r27
    23aa:	c9 f7       	brne	.-14     	; 0x239e <__ultoa_invert+0xa2>
    23ac:	62 0f       	add	r22, r18
    23ae:	73 1f       	adc	r23, r19
    23b0:	84 1f       	adc	r24, r20
    23b2:	95 1f       	adc	r25, r21
    23b4:	a0 1d       	adc	r26, r0
    23b6:	08 95       	ret

000023b8 <eeprom_read_word>:
    23b8:	a8 e1       	ldi	r26, 0x18	; 24
    23ba:	b0 e0       	ldi	r27, 0x00	; 0
    23bc:	42 e0       	ldi	r20, 0x02	; 2
    23be:	50 e0       	ldi	r21, 0x00	; 0
    23c0:	02 c0       	rjmp	.+4      	; 0x23c6 <eeprom_read_blraw>

000023c2 <eeprom_read_block>:
    23c2:	dc 01       	movw	r26, r24
    23c4:	cb 01       	movw	r24, r22

000023c6 <eeprom_read_blraw>:
    23c6:	fc 01       	movw	r30, r24
    23c8:	f9 99       	sbic	0x1f, 1	; 31
    23ca:	fe cf       	rjmp	.-4      	; 0x23c8 <eeprom_read_blraw+0x2>
    23cc:	06 c0       	rjmp	.+12     	; 0x23da <eeprom_read_blraw+0x14>
    23ce:	f2 bd       	out	0x22, r31	; 34
    23d0:	e1 bd       	out	0x21, r30	; 33
    23d2:	f8 9a       	sbi	0x1f, 0	; 31
    23d4:	31 96       	adiw	r30, 0x01	; 1
    23d6:	00 b4       	in	r0, 0x20	; 32
    23d8:	0d 92       	st	X+, r0
    23da:	41 50       	subi	r20, 0x01	; 1
    23dc:	50 40       	sbci	r21, 0x00	; 0
    23de:	b8 f7       	brcc	.-18     	; 0x23ce <eeprom_read_blraw+0x8>
    23e0:	08 95       	ret

000023e2 <_exit>:
    23e2:	f8 94       	cli

000023e4 <__stop_program>:
    23e4:	ff cf       	rjmp	.-2      	; 0x23e4 <__stop_program>
