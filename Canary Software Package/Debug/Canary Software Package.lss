
Canary Software Package.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ca  00800100  0000239a  0000242e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000239a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000508  008001ca  008001ca  000024f8  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000024f8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002554  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000308  00000000  00000000  00002598  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000536d  00000000  00000000  000028a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000019c4  00000000  00000000  00007c0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002418  00000000  00000000  000095d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a04  00000000  00000000  0000b9ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000010d5  00000000  00000000  0000c3f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003a7b  00000000  00000000  0000d4c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  00010f40  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	00 00       	nop
       4:	b3 c0       	rjmp	.+358    	; 0x16c <__bad_interrupt>
       6:	00 00       	nop
       8:	b1 c0       	rjmp	.+354    	; 0x16c <__bad_interrupt>
       a:	00 00       	nop
       c:	af c0       	rjmp	.+350    	; 0x16c <__bad_interrupt>
       e:	00 00       	nop
      10:	ad c0       	rjmp	.+346    	; 0x16c <__bad_interrupt>
      12:	00 00       	nop
      14:	ab c0       	rjmp	.+342    	; 0x16c <__bad_interrupt>
      16:	00 00       	nop
      18:	a9 c0       	rjmp	.+338    	; 0x16c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a7 c0       	rjmp	.+334    	; 0x16c <__bad_interrupt>
      1e:	00 00       	nop
      20:	a5 c0       	rjmp	.+330    	; 0x16c <__bad_interrupt>
      22:	00 00       	nop
      24:	a3 c0       	rjmp	.+326    	; 0x16c <__bad_interrupt>
      26:	00 00       	nop
      28:	a1 c0       	rjmp	.+322    	; 0x16c <__bad_interrupt>
      2a:	00 00       	nop
      2c:	9f c0       	rjmp	.+318    	; 0x16c <__bad_interrupt>
      2e:	00 00       	nop
      30:	9d c0       	rjmp	.+314    	; 0x16c <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 86 0b 	jmp	0x170c	; 0x170c <__vector_13>
      38:	99 c0       	rjmp	.+306    	; 0x16c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	97 c0       	rjmp	.+302    	; 0x16c <__bad_interrupt>
      3e:	00 00       	nop
      40:	0c 94 85 0b 	jmp	0x170a	; 0x170a <__vector_16>
      44:	93 c0       	rjmp	.+294    	; 0x16c <__bad_interrupt>
      46:	00 00       	nop
      48:	91 c0       	rjmp	.+290    	; 0x16c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	8f c0       	rjmp	.+286    	; 0x16c <__bad_interrupt>
      4e:	00 00       	nop
      50:	8d c0       	rjmp	.+282    	; 0x16c <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 c3 0c 	jmp	0x1986	; 0x1986 <__vector_21>
      58:	89 c0       	rjmp	.+274    	; 0x16c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	87 c0       	rjmp	.+270    	; 0x16c <__bad_interrupt>
      5e:	00 00       	nop
      60:	85 c0       	rjmp	.+266    	; 0x16c <__bad_interrupt>
      62:	00 00       	nop
      64:	83 c0       	rjmp	.+262    	; 0x16c <__bad_interrupt>
      66:	00 00       	nop
      68:	0c 94 f4 0b 	jmp	0x17e8	; 0x17e8 <__vector_26>
      6c:	7f c0       	rjmp	.+254    	; 0x16c <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 05 0d 	jmp	0x1a0a	; 0x1a0a <__vector_28>
      74:	7b c0       	rjmp	.+246    	; 0x16c <__bad_interrupt>
      76:	00 00       	nop
      78:	79 c0       	rjmp	.+242    	; 0x16c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	77 c0       	rjmp	.+238    	; 0x16c <__bad_interrupt>
      7e:	00 00       	nop
      80:	75 c0       	rjmp	.+234    	; 0x16c <__bad_interrupt>
      82:	00 00       	nop
      84:	73 c0       	rjmp	.+230    	; 0x16c <__bad_interrupt>
      86:	00 00       	nop
      88:	71 c0       	rjmp	.+226    	; 0x16c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	10 0c       	add	r1, r0
      8e:	62 0c       	add	r6, r2
      90:	62 0c       	add	r6, r2
      92:	62 0c       	add	r6, r2
      94:	62 0c       	add	r6, r2
      96:	62 0c       	add	r6, r2
      98:	62 0c       	add	r6, r2
      9a:	62 0c       	add	r6, r2
      9c:	10 0c       	add	r1, r0
      9e:	62 0c       	add	r6, r2
      a0:	62 0c       	add	r6, r2
      a2:	62 0c       	add	r6, r2
      a4:	62 0c       	add	r6, r2
      a6:	62 0c       	add	r6, r2
      a8:	62 0c       	add	r6, r2
      aa:	62 0c       	add	r6, r2
      ac:	12 0c       	add	r1, r2
      ae:	62 0c       	add	r6, r2
      b0:	62 0c       	add	r6, r2
      b2:	62 0c       	add	r6, r2
      b4:	62 0c       	add	r6, r2
      b6:	62 0c       	add	r6, r2
      b8:	62 0c       	add	r6, r2
      ba:	62 0c       	add	r6, r2
      bc:	62 0c       	add	r6, r2
      be:	62 0c       	add	r6, r2
      c0:	62 0c       	add	r6, r2
      c2:	62 0c       	add	r6, r2
      c4:	62 0c       	add	r6, r2
      c6:	62 0c       	add	r6, r2
      c8:	62 0c       	add	r6, r2
      ca:	62 0c       	add	r6, r2
      cc:	12 0c       	add	r1, r2
      ce:	62 0c       	add	r6, r2
      d0:	62 0c       	add	r6, r2
      d2:	62 0c       	add	r6, r2
      d4:	62 0c       	add	r6, r2
      d6:	62 0c       	add	r6, r2
      d8:	62 0c       	add	r6, r2
      da:	62 0c       	add	r6, r2
      dc:	62 0c       	add	r6, r2
      de:	62 0c       	add	r6, r2
      e0:	62 0c       	add	r6, r2
      e2:	62 0c       	add	r6, r2
      e4:	62 0c       	add	r6, r2
      e6:	62 0c       	add	r6, r2
      e8:	62 0c       	add	r6, r2
      ea:	62 0c       	add	r6, r2
      ec:	5e 0c       	add	r5, r14
      ee:	62 0c       	add	r6, r2
      f0:	62 0c       	add	r6, r2
      f2:	62 0c       	add	r6, r2
      f4:	62 0c       	add	r6, r2
      f6:	62 0c       	add	r6, r2
      f8:	62 0c       	add	r6, r2
      fa:	62 0c       	add	r6, r2
      fc:	3b 0c       	add	r3, r11
      fe:	62 0c       	add	r6, r2
     100:	62 0c       	add	r6, r2
     102:	62 0c       	add	r6, r2
     104:	62 0c       	add	r6, r2
     106:	62 0c       	add	r6, r2
     108:	62 0c       	add	r6, r2
     10a:	62 0c       	add	r6, r2
     10c:	62 0c       	add	r6, r2
     10e:	62 0c       	add	r6, r2
     110:	62 0c       	add	r6, r2
     112:	62 0c       	add	r6, r2
     114:	62 0c       	add	r6, r2
     116:	62 0c       	add	r6, r2
     118:	62 0c       	add	r6, r2
     11a:	62 0c       	add	r6, r2
     11c:	2f 0c       	add	r2, r15
     11e:	62 0c       	add	r6, r2
     120:	62 0c       	add	r6, r2
     122:	62 0c       	add	r6, r2
     124:	62 0c       	add	r6, r2
     126:	62 0c       	add	r6, r2
     128:	62 0c       	add	r6, r2
     12a:	62 0c       	add	r6, r2
     12c:	4d 0c       	add	r4, r13

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	d0 e4       	ldi	r29, 0x40	; 64
     136:	de bf       	out	0x3e, r29	; 62
     138:	cd bf       	out	0x3d, r28	; 61

0000013a <__do_copy_data>:
     13a:	11 e0       	ldi	r17, 0x01	; 1
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	b1 e0       	ldi	r27, 0x01	; 1
     140:	ea e9       	ldi	r30, 0x9A	; 154
     142:	f3 e2       	ldi	r31, 0x23	; 35
     144:	00 e0       	ldi	r16, 0x00	; 0
     146:	0b bf       	out	0x3b, r16	; 59
     148:	02 c0       	rjmp	.+4      	; 0x14e <__do_copy_data+0x14>
     14a:	07 90       	elpm	r0, Z+
     14c:	0d 92       	st	X+, r0
     14e:	aa 3c       	cpi	r26, 0xCA	; 202
     150:	b1 07       	cpc	r27, r17
     152:	d9 f7       	brne	.-10     	; 0x14a <__do_copy_data+0x10>

00000154 <__do_clear_bss>:
     154:	26 e0       	ldi	r18, 0x06	; 6
     156:	aa ec       	ldi	r26, 0xCA	; 202
     158:	b1 e0       	ldi	r27, 0x01	; 1
     15a:	01 c0       	rjmp	.+2      	; 0x15e <.do_clear_bss_start>

0000015c <.do_clear_bss_loop>:
     15c:	1d 92       	st	X+, r1

0000015e <.do_clear_bss_start>:
     15e:	a2 3d       	cpi	r26, 0xD2	; 210
     160:	b2 07       	cpc	r27, r18
     162:	e1 f7       	brne	.-8      	; 0x15c <.do_clear_bss_loop>
     164:	0e 94 4f 0a 	call	0x149e	; 0x149e <main>
     168:	0c 94 cb 11 	jmp	0x2396	; 0x2396 <_exit>

0000016c <__bad_interrupt>:
     16c:	0c 94 70 0b 	jmp	0x16e0	; 0x16e0 <__vector_default>

00000170 <ADC_SetMux>:
********************************************************************************/
void ADC_SetMux(uint8_t source) // 
{
	/* A short routine to clear the ADC input select mux bits then set
	those same bits to the source defined in the input.  */
	ADMUX &= 0b11100000; // Clear the select bits then
     170:	ec e7       	ldi	r30, 0x7C	; 124
     172:	f0 e0       	ldi	r31, 0x00	; 0
     174:	90 81       	ld	r25, Z
     176:	90 7e       	andi	r25, 0xE0	; 224
     178:	90 83       	st	Z, r25
	ADMUX |= source; // Set the ADC input source
     17a:	90 81       	ld	r25, Z
     17c:	89 2b       	or	r24, r25
     17e:	80 83       	st	Z, r24
     180:	08 95       	ret

00000182 <ADC_init>:
}

void ADC_init(void)
{
     182:	cf 93       	push	r28
     184:	df 93       	push	r29
	/* This routine is design to set up the ADC hardware on the ATMega324PA for our use. */
	static volatile int16_t ADC_result;
	
	// Select the external AVCC pin as the ADC reference voltage by setting the REFS[1:0] pin in the ADC MUX register to 0b01
	SetBit(ADMUX, REFS0);
     186:	ec e7       	ldi	r30, 0x7C	; 124
     188:	f0 e0       	ldi	r31, 0x00	; 0
     18a:	80 81       	ld	r24, Z
     18c:	80 64       	ori	r24, 0x40	; 64
     18e:	80 83       	st	Z, r24
	
	// Set clock prescaler to 128 to provide a 156kHz ADC clock.  ADPS[2:0] = 0b111
	SetBit(ADCSRA, ADPS0);
     190:	ca e7       	ldi	r28, 0x7A	; 122
     192:	d0 e0       	ldi	r29, 0x00	; 0
     194:	88 81       	ld	r24, Y
     196:	81 60       	ori	r24, 0x01	; 1
     198:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS1);
     19a:	88 81       	ld	r24, Y
     19c:	82 60       	ori	r24, 0x02	; 2
     19e:	88 83       	st	Y, r24
	SetBit(ADCSRA, ADPS2);
     1a0:	88 81       	ld	r24, Y
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	88 83       	st	Y, r24
	
	// Clears power reduction register to ensure we get power to the ADC hardware
	ClearBit(PRR0, PRADC);
     1a6:	a4 e6       	ldi	r26, 0x64	; 100
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	8c 91       	ld	r24, X
     1ac:	8e 7f       	andi	r24, 0xFE	; 254
     1ae:	8c 93       	st	X, r24
	
	// Clears the Left Adjust Result bit. This means that output will be right adjusted to get the max resolution
	ClearBit(ADMUX, ADLAR);
     1b0:	80 81       	ld	r24, Z
     1b2:	8f 7d       	andi	r24, 0xDF	; 223
     1b4:	80 83       	st	Z, r24
	
	// Sets Digital Input Disable Register. Writing a one to bits in the DIDR0 to disable the digital input circuitry
	DIDR0 = 0b00111111;
     1b6:	8f e3       	ldi	r24, 0x3F	; 63
     1b8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     1bc:	88 81       	ld	r24, Y
     1be:	80 68       	ori	r24, 0x80	; 128
     1c0:	88 83       	st	Y, r24
	// Enable the ADC interrupt
	//*************TURNED OFF FOR LAB TESTING********************************
	// SetBit(ADCSRA, ADIE);  // May have to turn this off for debug
	
	// Set Register ADCSRB to free running mode, single input mode (ADTS[2:0] = 0x00);
	ADCSRB = 0x00;
     1c2:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
	
	//  Select test source = ground (GND;  ADMUX.MUX = 0b11111). Result should be 0V.
	ADC_SetMux(0b00011111); 
     1c6:	8f e1       	ldi	r24, 0x1F	; 31
     1c8:	d3 df       	rcall	.-90     	; 0x170 <ADC_SetMux>
	
	// Discard the first conversion and use the second one
	// Sets ADC Start Conversion bit
	SetBit(ADCSRA, ADSC);
     1ca:	88 81       	ld	r24, Y
     1cc:	80 64       	ori	r24, 0x40	; 64
     1ce:	88 83       	st	Y, r24
	while (BitIsClear(ADCSRA, ADIF))
     1d0:	ea e7       	ldi	r30, 0x7A	; 122
     1d2:	f0 e0       	ldi	r31, 0x00	; 0
     1d4:	80 81       	ld	r24, Z
     1d6:	84 ff       	sbrs	r24, 4
     1d8:	fd cf       	rjmp	.-6      	; 0x1d4 <ADC_init+0x52>
	{
		// Wait for conversion to be complete
	}
	
	//   Restart conversion. We'll use this result.
	SetBit(ADCSRA, ADSC);
     1da:	ea e7       	ldi	r30, 0x7A	; 122
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	80 64       	ori	r24, 0x40	; 64
     1e2:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     1e4:	80 81       	ld	r24, Z
     1e6:	84 ff       	sbrs	r24, 4
     1e8:	fd cf       	rjmp	.-6      	; 0x1e4 <ADC_init+0x62>
	{
		// Wait for conversion to be complete
	}
	
	//  Read result and report error if not real close to zero
	ADC_result = ADCL;
     1ea:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     1f4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     1f8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     1fc:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     200:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     204:	89 2f       	mov	r24, r25
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	98 2f       	mov	r25, r24
     20a:	88 27       	eor	r24, r24
     20c:	82 0f       	add	r24, r18
     20e:	93 1f       	adc	r25, r19
     210:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     214:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >4 ) //   We want to be within a few LSBs of zero.
     218:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     21c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     220:	99 23       	and	r25, r25
     222:	1c f4       	brge	.+6      	; 0x22a <ADC_init+0xa8>
     224:	91 95       	neg	r25
     226:	81 95       	neg	r24
     228:	91 09       	sbc	r25, r1
     22a:	05 97       	sbiw	r24, 0x05	; 5
     22c:	2c f0       	brlt	.+10     	; 0x238 <ADC_init+0xb6>
	{
		SetBit(gas_sensor_initialization_errors, ADC_gnd_test_error);
     22e:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <gas_sensor_initialization_errors>
     232:	81 60       	ori	r24, 0x01	; 1
     234:	80 93 2b 03 	sts	0x032B, r24	; 0x80032b <gas_sensor_initialization_errors>
	}
	
	// Select test source = bandgap (BG;  ADMUX.MUX = 0b11110). Result should be 1.1V
	ADC_SetMux(0b00011110); 
     238:	8e e1       	ldi	r24, 0x1E	; 30
     23a:	9a df       	rcall	.-204    	; 0x170 <ADC_SetMux>
	SetBit(ADCSRA, ADSC); // Start conversion process
     23c:	ea e7       	ldi	r30, 0x7A	; 122
     23e:	f0 e0       	ldi	r31, 0x00	; 0
     240:	80 81       	ld	r24, Z
     242:	80 64       	ori	r24, 0x40	; 64
     244:	80 83       	st	Z, r24
	while (BitIsClear(ADCSRA, ADIF))
     246:	80 81       	ld	r24, Z
     248:	84 ff       	sbrs	r24, 4
     24a:	fd cf       	rjmp	.-6      	; 0x246 <ADC_init+0xc4>
	{
		// Wait for conversion to be complete
	}
	
	// Read result and report error if not 1.1
	ADC_result = ADCL;
     24c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     250:	90 e0       	ldi	r25, 0x00	; 0
     252:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     256:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result = ADC_result + (ADCH<<8);
     25a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     25e:	20 91 ca 01 	lds	r18, 0x01CA	; 0x8001ca <__data_end>
     262:	30 91 cb 01 	lds	r19, 0x01CB	; 0x8001cb <__data_end+0x1>
     266:	89 2f       	mov	r24, r25
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	98 2f       	mov	r25, r24
     26c:	88 27       	eor	r24, r24
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     276:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	ADC_result -= 225;  // 225 is the expected value: 1.1V*1023/5v=225
     27a:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     27e:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     282:	81 5e       	subi	r24, 0xE1	; 225
     284:	91 09       	sbc	r25, r1
     286:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <__data_end+0x1>
     28a:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__data_end>
	if (abs(ADC_result) >= 5)  // We want to be within 4 of target voltage reading.
     28e:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <__data_end>
     292:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <__data_end+0x1>
     296:	99 23       	and	r25, r25
     298:	1c f4       	brge	.+6      	; 0x2a0 <ADC_init+0x11e>
     29a:	91 95       	neg	r25
     29c:	81 95       	neg	r24
     29e:	91 09       	sbc	r25, r1
     2a0:	05 97       	sbiw	r24, 0x05	; 5
     2a2:	2c f0       	brlt	.+10     	; 0x2ae <ADC_init+0x12c>
	{
		SetBit(gas_sensor_initialization_errors, ADC_BG_test_error);
     2a4:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <gas_sensor_initialization_errors>
     2a8:	82 60       	ori	r24, 0x02	; 2
     2aa:	80 93 2b 03 	sts	0x032B, r24	; 0x80032b <gas_sensor_initialization_errors>
	}
	
	// Clear the analog to digital enable bit until we need it again
	ClearBit(ADCSRA, ADEN);
     2ae:	ea e7       	ldi	r30, 0x7A	; 122
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8f 77       	andi	r24, 0x7F	; 127
     2b6:	80 83       	st	Z, r24
     2b8:	df 91       	pop	r29
     2ba:	cf 91       	pop	r28
     2bc:	08 95       	ret

000002be <canary_io_pin_initialization>:
	}
}

void canary_io_pin_initialization(void) {
	// For Canary, Port B pins 0, 1, and 2 are the red, green, and blue LED feedback pins
	DDRB  = 0x07;
     2be:	87 e0       	ldi	r24, 0x07	; 7
     2c0:	84 b9       	out	0x04, r24	; 4
	//
	// Set all LEDs off
	PORTB &= !0x07;
     2c2:	85 b1       	in	r24, 0x05	; 5
     2c4:	15 b8       	out	0x05, r1	; 5
	// The Canary start button is on Port B pin 3.  Set the pull-up resistor for pin 3:
	SetBit(PORTB, PORTB3);
     2c6:	2b 9a       	sbi	0x05, 3	; 5
	//
	// Set the Data Direction Register and pullups for the TWI system
	SetBit(DDRC, PORTC0); // Set clock as output
     2c8:	38 9a       	sbi	0x07, 0	; 7
	SetBit(DDRC, PORTC1); // Data Line as output
     2ca:	39 9a       	sbi	0x07, 1	; 7
	SetBit(PORTC, PORTC0); //Set pull-up resistor for clock
     2cc:	40 9a       	sbi	0x08, 0	; 8
	SetBit(PORTC, PORTC1); //Set pull-up resistor for data
     2ce:	41 9a       	sbi	0x08, 1	; 8
     2d0:	08 95       	ret

000002d2 <get_gas_sensor_limits>:
#include "gas_sensors.h"

/********************************************************************************
						Functions
********************************************************************************/
void get_gas_sensor_limits(void) {
     2d2:	80 e0       	ldi	r24, 0x00	; 0
     2d4:	90 e0       	ldi	r25, 0x00	; 0
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
     2d6:	2f ef       	ldi	r18, 0xFF	; 255
     2d8:	33 e0       	ldi	r19, 0x03	; 3
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = 0;
     2da:	fc 01       	movw	r30, r24
     2dc:	ee 0f       	add	r30, r30
     2de:	ff 1f       	adc	r31, r31
     2e0:	ee 0f       	add	r30, r30
     2e2:	ff 1f       	adc	r31, r31
     2e4:	e0 50       	subi	r30, 0x00	; 0
     2e6:	fd 4f       	sbci	r31, 0xFD	; 253
     2e8:	11 82       	std	Z+1, r1	; 0x01
     2ea:	10 82       	st	Z, r1
		gas_sensor_boundaries[ii][1] = 1023;
     2ec:	33 83       	std	Z+3, r19	; 0x03
     2ee:	22 83       	std	Z+2, r18	; 0x02
     2f0:	01 96       	adiw	r24, 0x01	; 1
void get_gas_sensor_limits(void) {
	uint8_t ii;
	/* THIS IS A TEMPORARY ROUTINE, to be replaced by the EEPROM read commented out below.
	This just sets some upper and lower bounds for the initialization code to use.
	Actual values will need to be derived empirically (using the UCAR test chamber) */
	for (ii=0; ii<5; ii++)
     2f2:	85 30       	cpi	r24, 0x05	; 5
     2f4:	91 05       	cpc	r25, r1
     2f6:	89 f7       	brne	.-30     	; 0x2da <get_gas_sensor_limits+0x8>
	{
		gas_sensor_boundaries[ii][0] = 0;
		gas_sensor_boundaries[ii][1] = 1023;
	}
}
     2f8:	08 95       	ret

000002fa <get_gas_sensor_limits_from_EEPROM>:

void get_gas_sensor_limits_from_EEPROM(void) {
     2fa:	ef 92       	push	r14
     2fc:	ff 92       	push	r15
     2fe:	0f 93       	push	r16
     300:	1f 93       	push	r17
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	0f 2e       	mov	r0, r31
     308:	fa ee       	ldi	r31, 0xEA	; 234
     30a:	ef 2e       	mov	r14, r31
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	ff 2e       	mov	r15, r31
     310:	f0 2d       	mov	r31, r0
     312:	00 e0       	ldi	r16, 0x00	; 0
     314:	10 e0       	ldi	r17, 0x00	; 0
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
     316:	c7 01       	movw	r24, r14
     318:	0e 94 b6 11 	call	0x236c	; 0x236c <eeprom_read_word>
     31c:	e8 01       	movw	r28, r16
     31e:	cc 0f       	add	r28, r28
     320:	dd 1f       	adc	r29, r29
     322:	cc 0f       	add	r28, r28
     324:	dd 1f       	adc	r29, r29
     326:	c0 50       	subi	r28, 0x00	; 0
     328:	dd 4f       	sbci	r29, 0xFD	; 253
     32a:	99 83       	std	Y+1, r25	; 0x01
     32c:	88 83       	st	Y, r24
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
     32e:	c7 01       	movw	r24, r14
     330:	02 96       	adiw	r24, 0x02	; 2
     332:	0e 94 b6 11 	call	0x236c	; 0x236c <eeprom_read_word>
     336:	9b 83       	std	Y+3, r25	; 0x03
     338:	8a 83       	std	Y+2, r24	; 0x02
     33a:	0f 5f       	subi	r16, 0xFF	; 255
     33c:	1f 4f       	sbci	r17, 0xFF	; 255
     33e:	84 e0       	ldi	r24, 0x04	; 4
     340:	e8 0e       	add	r14, r24
     342:	f1 1c       	adc	r15, r1
void get_gas_sensor_limits_from_EEPROM(void) {
	uint8_t ii;
	// This routine reads the empirically derived upper and lower limits
	// for the gas sensors from EEPROM.  We can also use defined constants
	// if we need to...
	for (ii=0; ii<5; ii++)
     344:	05 30       	cpi	r16, 0x05	; 5
     346:	11 05       	cpc	r17, r1
     348:	31 f7       	brne	.-52     	; 0x316 <get_gas_sensor_limits_from_EEPROM+0x1c>
	{
		gas_sensor_boundaries[ii][0] = eeprom_read_word(&gas_sensor_boundary_constants[ii][0]);
		gas_sensor_boundaries[ii][1] = eeprom_read_word(&gas_sensor_boundary_constants[ii][1]);
	}
}
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	1f 91       	pop	r17
     350:	0f 91       	pop	r16
     352:	ff 90       	pop	r15
     354:	ef 90       	pop	r14
     356:	08 95       	ret

00000358 <gas_sensors_init>:

void gas_sensors_init(void)
{
     358:	af 92       	push	r10
     35a:	bf 92       	push	r11
     35c:	cf 92       	push	r12
     35e:	df 92       	push	r13
     360:	ef 92       	push	r14
     362:	ff 92       	push	r15
     364:	0f 93       	push	r16
     366:	1f 93       	push	r17
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	1f 92       	push	r1
     36e:	cd b7       	in	r28, 0x3d	; 61
     370:	de b7       	in	r29, 0x3e	; 62
	volatile uint8_t sensor_id;
	int16_t ADC_result;
	
	// Clear our error trackers
	gas_sensor_initialization_errors=0; // Keeps track (by bit) of errors we've encountered.
     372:	10 92 2b 03 	sts	0x032B, r1	; 0x80032b <gas_sensor_initialization_errors>
	gas_sensor_operational_errors=0;  // Keeps track (by bit) of errors we've encountered.
     376:	10 92 1e 03 	sts	0x031E, r1	; 0x80031e <gas_sensor_operational_errors>
	// Get the upper and lower boundaries on the gas sensors...
	// The first cal is just to test the EEPROM code
	get_gas_sensor_limits_from_EEPROM();
     37a:	bf df       	rcall	.-130    	; 0x2fa <get_gas_sensor_limits_from_EEPROM>
	// This second cal is temporary and simply initializes the array to usable values...
	get_gas_sensor_limits();
     37c:	aa df       	rcall	.-172    	; 0x2d2 <get_gas_sensor_limits>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     37e:	ea e7       	ldi	r30, 0x7A	; 122
     380:	f0 e0       	ldi	r31, 0x00	; 0
     382:	80 81       	ld	r24, Z
     384:	80 68       	ori	r24, 0x80	; 128
     386:	80 83       	st	Z, r24
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     388:	19 82       	std	Y+1, r1	; 0x01
     38a:	89 81       	ldd	r24, Y+1	; 0x01
     38c:	85 30       	cpi	r24, 0x05	; 5
     38e:	08 f0       	brcs	.+2      	; 0x392 <gas_sensors_init+0x3a>
     390:	51 c0       	rjmp	.+162    	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
	{
		ADC_SetMux(sensor_id);
		// Start conversion
		SetBit(ADCSRA, ADSC);
     392:	0a e7       	ldi	r16, 0x7A	; 122
     394:	10 e0       	ldi	r17, 0x00	; 0
		while (BitIsClear(ADCSRA, ADIF))
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     396:	0f 2e       	mov	r0, r31
     398:	f8 e7       	ldi	r31, 0x78	; 120
     39a:	ef 2e       	mov	r14, r31
     39c:	f1 2c       	mov	r15, r1
     39e:	f0 2d       	mov	r31, r0
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3a0:	bb 24       	eor	r11, r11
     3a2:	b3 94       	inc	r11
     3a4:	a1 2c       	mov	r10, r1
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     3a6:	cc 24       	eor	r12, r12
     3a8:	c3 94       	inc	r12
     3aa:	d1 2c       	mov	r13, r1
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     3ac:	89 81       	ldd	r24, Y+1	; 0x01
     3ae:	e0 de       	rcall	.-576    	; 0x170 <ADC_SetMux>
		// Start conversion
		SetBit(ADCSRA, ADSC);
     3b0:	f8 01       	movw	r30, r16
     3b2:	80 81       	ld	r24, Z
     3b4:	80 64       	ori	r24, 0x40	; 64
     3b6:	80 83       	st	Z, r24
		while (BitIsClear(ADCSRA, ADIF))
     3b8:	f8 01       	movw	r30, r16
     3ba:	80 81       	ld	r24, Z
     3bc:	84 ff       	sbrs	r24, 4
     3be:	fc cf       	rjmp	.-8      	; 0x3b8 <gas_sensors_init+0x60>
		{
			// Wait for conversion to be complete
		}
		// Read result
		ADC_result = ADC;
     3c0:	f7 01       	movw	r30, r14
     3c2:	80 81       	ld	r24, Z
     3c4:	91 81       	ldd	r25, Z+1	; 0x01
		// sen0 = ADC_result;
		// Test the reading to ensure it is within acceptable boundaries
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     3c6:	e9 81       	ldd	r30, Y+1	; 0x01
     3c8:	f0 e0       	ldi	r31, 0x00	; 0
     3ca:	ee 0f       	add	r30, r30
     3cc:	ff 1f       	adc	r31, r31
     3ce:	ee 0f       	add	r30, r30
     3d0:	ff 1f       	adc	r31, r31
     3d2:	e0 50       	subi	r30, 0x00	; 0
     3d4:	fd 4f       	sbci	r31, 0xFD	; 253
     3d6:	20 81       	ld	r18, Z
     3d8:	31 81       	ldd	r19, Z+1	; 0x01
     3da:	e9 81       	ldd	r30, Y+1	; 0x01
     3dc:	f0 e0       	ldi	r31, 0x00	; 0
     3de:	ee 0f       	add	r30, r30
     3e0:	ff 1f       	adc	r31, r31
     3e2:	ee 0f       	add	r30, r30
     3e4:	ff 1f       	adc	r31, r31
     3e6:	e0 50       	subi	r30, 0x00	; 0
     3e8:	fd 4f       	sbci	r31, 0xFD	; 253
     3ea:	62 81       	ldd	r22, Z+2	; 0x02
     3ec:	73 81       	ldd	r23, Z+3	; 0x03
     3ee:	4b 2d       	mov	r20, r11
     3f0:	68 17       	cp	r22, r24
     3f2:	79 07       	cpc	r23, r25
     3f4:	08 f0       	brcs	.+2      	; 0x3f8 <gas_sensors_init+0xa0>
     3f6:	4a 2d       	mov	r20, r10
     3f8:	41 11       	cpse	r20, r1
     3fa:	07 c0       	rjmp	.+14     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     3fc:	4b 2d       	mov	r20, r11
     3fe:	82 17       	cp	r24, r18
     400:	93 07       	cpc	r25, r19
     402:	08 f0       	brcs	.+2      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     404:	4a 2d       	mov	r20, r10
     406:	44 23       	and	r20, r20
     408:	71 f0       	breq	.+28     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     40a:	99 81       	ldd	r25, Y+1	; 0x01
     40c:	20 91 2b 03 	lds	r18, 0x032B	; 0x80032b <gas_sensor_initialization_errors>
     410:	9d 5f       	subi	r25, 0xFD	; 253
     412:	a6 01       	movw	r20, r12
     414:	02 c0       	rjmp	.+4      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
     416:	44 0f       	add	r20, r20
     418:	55 1f       	adc	r21, r21
     41a:	9a 95       	dec	r25
     41c:	e2 f7       	brpl	.-8      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
     41e:	ca 01       	movw	r24, r20
     420:	82 2b       	or	r24, r18
     422:	80 93 2b 03 	sts	0x032B, r24	; 0x80032b <gas_sensor_initialization_errors>
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     426:	89 81       	ldd	r24, Y+1	; 0x01
     428:	8f 5f       	subi	r24, 0xFF	; 255
     42a:	89 83       	std	Y+1, r24	; 0x01
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	85 30       	cpi	r24, 0x05	; 5
     430:	08 f4       	brcc	.+2      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
     432:	bc cf       	rjmp	.-136    	; 0x3ac <gas_sensors_init+0x54>
		if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
		{
			SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
		}		
	}
	ClearBit(ADCSRA, ADEN);  //Disable the ADC until we go operational
     434:	ea e7       	ldi	r30, 0x7A	; 122
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	80 81       	ld	r24, Z
     43a:	8f 77       	andi	r24, 0x7F	; 127
     43c:	80 83       	st	Z, r24
	// Report status via the LED that the gas sensors are ready (or not)
	//display_status(gas_sensors, gas_sensor_initialization_errors);
}
     43e:	0f 90       	pop	r0
     440:	df 91       	pop	r29
     442:	cf 91       	pop	r28
     444:	1f 91       	pop	r17
     446:	0f 91       	pop	r16
     448:	ff 90       	pop	r15
     44a:	ef 90       	pop	r14
     44c:	df 90       	pop	r13
     44e:	cf 90       	pop	r12
     450:	bf 90       	pop	r11
     452:	af 90       	pop	r10
     454:	08 95       	ret

00000456 <start_gas_sensor_read>:

void start_gas_sensor_read(void)
{
     456:	8f 92       	push	r8
     458:	9f 92       	push	r9
     45a:	af 92       	push	r10
     45c:	bf 92       	push	r11
     45e:	cf 92       	push	r12
     460:	df 92       	push	r13
     462:	ef 92       	push	r14
     464:	ff 92       	push	r15
     466:	0f 93       	push	r16
     468:	1f 93       	push	r17
     46a:	cf 93       	push	r28
     46c:	df 93       	push	r29
     46e:	00 d0       	rcall	.+0      	; 0x470 <start_gas_sensor_read+0x1a>
     470:	1f 92       	push	r1
     472:	cd b7       	in	r28, 0x3d	; 61
     474:	de b7       	in	r29, 0x3e	; 62
	int16_t ADC_result;
	volatile int16_t total;
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
     476:	ea e7       	ldi	r30, 0x7A	; 122
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	80 81       	ld	r24, Z
     47c:	80 68       	ori	r24, 0x80	; 128
     47e:	80 83       	st	Z, r24
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     480:	19 82       	std	Y+1, r1	; 0x01
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	85 30       	cpi	r24, 0x05	; 5
     486:	08 f0       	brcs	.+2      	; 0x48a <start_gas_sensor_read+0x34>
     488:	76 c0       	rjmp	.+236    	; 0x576 <start_gas_sensor_read+0x120>
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
     48a:	68 94       	set
     48c:	88 24       	eor	r8, r8
     48e:	82 f8       	bld	r8, 2
     490:	91 2c       	mov	r9, r1
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     492:	0a e7       	ldi	r16, 0x7A	; 122
     494:	10 e0       	ldi	r17, 0x00	; 0
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     496:	0f 2e       	mov	r0, r31
     498:	f8 e7       	ldi	r31, 0x78	; 120
     49a:	ef 2e       	mov	r14, r31
     49c:	f1 2c       	mov	r15, r1
     49e:	f0 2d       	mov	r31, r0
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     4a0:	cc 24       	eor	r12, r12
     4a2:	c3 94       	inc	r12
     4a4:	d1 2c       	mov	r13, r1
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4a6:	bb 24       	eor	r11, r11
     4a8:	b3 94       	inc	r11
     4aa:	a1 2c       	mov	r10, r1
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
     4ac:	89 81       	ldd	r24, Y+1	; 0x01
     4ae:	60 de       	rcall	.-832    	; 0x170 <ADC_SetMux>
		total = 0;	// re-zero the average
     4b0:	1b 82       	std	Y+3, r1	; 0x03
     4b2:	1a 82       	std	Y+2, r1	; 0x02
     4b4:	28 2d       	mov	r18, r8
     4b6:	39 2d       	mov	r19, r9
		
		for(int i = 0; i < max_gas_sample_count; i++)
		{
			// Start conversion
			SetBit(ADCSRA, ADSC);
     4b8:	f8 01       	movw	r30, r16
     4ba:	80 81       	ld	r24, Z
     4bc:	80 64       	ori	r24, 0x40	; 64
     4be:	80 83       	st	Z, r24
			while (BitIsClear(ADCSRA, ADIF))
     4c0:	f8 01       	movw	r30, r16
     4c2:	80 81       	ld	r24, Z
     4c4:	84 ff       	sbrs	r24, 4
     4c6:	fc cf       	rjmp	.-8      	; 0x4c0 <start_gas_sensor_read+0x6a>
			{
				// Wait for conversion to be complete
				// NOTE: In production version, we should wait for the interrupt and process in the background
			}
			// Read result
			ADC_result = ADC;
     4c8:	f7 01       	movw	r30, r14
     4ca:	80 81       	ld	r24, Z
     4cc:	91 81       	ldd	r25, Z+1	; 0x01
			// Test the reading to ensure it is within acceptable boundaries
			if ((ADC_result < gas_sensor_boundaries[sensor_id][0])|(ADC_result > gas_sensor_boundaries[sensor_id][1]))
     4ce:	e9 81       	ldd	r30, Y+1	; 0x01
     4d0:	f0 e0       	ldi	r31, 0x00	; 0
     4d2:	ee 0f       	add	r30, r30
     4d4:	ff 1f       	adc	r31, r31
     4d6:	ee 0f       	add	r30, r30
     4d8:	ff 1f       	adc	r31, r31
     4da:	e0 50       	subi	r30, 0x00	; 0
     4dc:	fd 4f       	sbci	r31, 0xFD	; 253
     4de:	40 81       	ld	r20, Z
     4e0:	51 81       	ldd	r21, Z+1	; 0x01
     4e2:	e9 81       	ldd	r30, Y+1	; 0x01
     4e4:	f0 e0       	ldi	r31, 0x00	; 0
     4e6:	ee 0f       	add	r30, r30
     4e8:	ff 1f       	adc	r31, r31
     4ea:	ee 0f       	add	r30, r30
     4ec:	ff 1f       	adc	r31, r31
     4ee:	e0 50       	subi	r30, 0x00	; 0
     4f0:	fd 4f       	sbci	r31, 0xFD	; 253
     4f2:	62 81       	ldd	r22, Z+2	; 0x02
     4f4:	73 81       	ldd	r23, Z+3	; 0x03
     4f6:	eb 2d       	mov	r30, r11
     4f8:	68 17       	cp	r22, r24
     4fa:	79 07       	cpc	r23, r25
     4fc:	08 f0       	brcs	.+2      	; 0x500 <start_gas_sensor_read+0xaa>
     4fe:	ea 2d       	mov	r30, r10
     500:	e1 11       	cpse	r30, r1
     502:	07 c0       	rjmp	.+14     	; 0x512 <start_gas_sensor_read+0xbc>
     504:	6b 2d       	mov	r22, r11
     506:	84 17       	cp	r24, r20
     508:	95 07       	cpc	r25, r21
     50a:	08 f0       	brcs	.+2      	; 0x50e <start_gas_sensor_read+0xb8>
     50c:	6a 2d       	mov	r22, r10
     50e:	66 23       	and	r22, r22
     510:	71 f0       	breq	.+28     	; 0x52e <start_gas_sensor_read+0xd8>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
     512:	59 81       	ldd	r21, Y+1	; 0x01
     514:	60 91 2b 03 	lds	r22, 0x032B	; 0x80032b <gas_sensor_initialization_errors>
     518:	5d 5f       	subi	r21, 0xFD	; 253
     51a:	f6 01       	movw	r30, r12
     51c:	02 c0       	rjmp	.+4      	; 0x522 <start_gas_sensor_read+0xcc>
     51e:	ee 0f       	add	r30, r30
     520:	ff 1f       	adc	r31, r31
     522:	5a 95       	dec	r21
     524:	e2 f7       	brpl	.-8      	; 0x51e <start_gas_sensor_read+0xc8>
     526:	af 01       	movw	r20, r30
     528:	46 2b       	or	r20, r22
     52a:	40 93 2b 03 	sts	0x032B, r20	; 0x80032b <gas_sensor_initialization_errors>
			}
			total += ADC_result;
     52e:	4a 81       	ldd	r20, Y+2	; 0x02
     530:	5b 81       	ldd	r21, Y+3	; 0x03
     532:	84 0f       	add	r24, r20
     534:	95 1f       	adc	r25, r21
     536:	9b 83       	std	Y+3, r25	; 0x03
     538:	8a 83       	std	Y+2, r24	; 0x02
     53a:	21 50       	subi	r18, 0x01	; 1
     53c:	31 09       	sbc	r19, r1
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
	{
		ADC_SetMux(sensor_id);
		total = 0;	// re-zero the average
		
		for(int i = 0; i < max_gas_sample_count; i++)
     53e:	09 f0       	breq	.+2      	; 0x542 <start_gas_sensor_read+0xec>
     540:	bb cf       	rjmp	.-138    	; 0x4b8 <start_gas_sensor_read+0x62>
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     542:	8a 81       	ldd	r24, Y+2	; 0x02
     544:	9b 81       	ldd	r25, Y+3	; 0x03
		raw_gas_vector[sensor_id] = gas_average;
     546:	e9 81       	ldd	r30, Y+1	; 0x01
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	ee 0f       	add	r30, r30
     54c:	ff 1f       	adc	r31, r31
     54e:	e1 5e       	subi	r30, 0xE1	; 225
     550:	fc 4f       	sbci	r31, 0xFC	; 252
			{
				SetBit(gas_sensor_initialization_errors,(sensor_id+3));  // If not, report an error
			}
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
     552:	9c 01       	movw	r18, r24
     554:	99 23       	and	r25, r25
     556:	14 f4       	brge	.+4      	; 0x55c <start_gas_sensor_read+0x106>
     558:	2d 5f       	subi	r18, 0xFD	; 253
     55a:	3f 4f       	sbci	r19, 0xFF	; 255
     55c:	35 95       	asr	r19
     55e:	27 95       	ror	r18
     560:	35 95       	asr	r19
     562:	27 95       	ror	r18
		raw_gas_vector[sensor_id] = gas_average;
     564:	31 83       	std	Z+1, r19	; 0x01
     566:	20 83       	st	Z, r18
	int16_t gas_average;
	
	// Enable the ADC
	SetBit(ADCSRA, ADEN);
	//Read initial value from the sensors
	for(sensor_id = 0; sensor_id < 5; sensor_id++)
     568:	89 81       	ldd	r24, Y+1	; 0x01
     56a:	8f 5f       	subi	r24, 0xFF	; 255
     56c:	89 83       	std	Y+1, r24	; 0x01
     56e:	89 81       	ldd	r24, Y+1	; 0x01
     570:	85 30       	cpi	r24, 0x05	; 5
     572:	08 f4       	brcc	.+2      	; 0x576 <start_gas_sensor_read+0x120>
     574:	9b cf       	rjmp	.-202    	; 0x4ac <start_gas_sensor_read+0x56>
			total += ADC_result;
		}
		gas_average = total / max_gas_sample_count;
		raw_gas_vector[sensor_id] = gas_average;
	}
}
     576:	0f 90       	pop	r0
     578:	0f 90       	pop	r0
     57a:	0f 90       	pop	r0
     57c:	df 91       	pop	r29
     57e:	cf 91       	pop	r28
     580:	1f 91       	pop	r17
     582:	0f 91       	pop	r16
     584:	ff 90       	pop	r15
     586:	ef 90       	pop	r14
     588:	df 90       	pop	r13
     58a:	cf 90       	pop	r12
     58c:	bf 90       	pop	r11
     58e:	af 90       	pop	r10
     590:	9f 90       	pop	r9
     592:	8f 90       	pop	r8
     594:	08 95       	ret

00000596 <LIDAR_distance>:

/********************************************************************************
						Functions
********************************************************************************/

uint16_t LIDAR_distance(void) {
     596:	1f 93       	push	r17
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
	uint16_t Ldistance;
	// From the LIDAR datasheet page 4, simplest way to use the LIDAR:
	// Step 1: Write bias correction use (0x04) to register 0
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     59c:	e2 e3       	ldi	r30, 0x32	; 50
     59e:	f3 e0       	ldi	r31, 0x03	; 3
     5a0:	84 ec       	ldi	r24, 0xC4	; 196
     5a2:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; // Select register 0x00
     5a4:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = LIDAR_USE_BIAS_CORRECTION; // What we're gonna write
     5a6:	84 e0       	ldi	r24, 0x04	; 4
     5a8:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     5aa:	63 e0       	ldi	r22, 0x03	; 3
     5ac:	cf 01       	movw	r24, r30
     5ae:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     5b2:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     5b6:	81 11       	cpse	r24, r1
     5b8:	fc cf       	rjmp	.-8      	; 0x5b2 <LIDAR_distance+0x1c>
	//
	// Step 2: read register 0x01 and watch the low bit.  
	// From page 6, we have to write the address we want to read first...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     5ba:	e2 e3       	ldi	r30, 0x32	; 50
     5bc:	f3 e0       	ldi	r31, 0x03	; 3
     5be:	84 ec       	ldi	r24, 0xC4	; 196
     5c0:	80 83       	st	Z, r24
	messageBuf[1] = 0x01; // Select register 0x01
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5c6:	62 e0       	ldi	r22, 0x02	; 2
     5c8:	cf 01       	movw	r24, r30
     5ca:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
     5ce:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     5d2:	81 11       	cpse	r24, r1
     5d4:	fc cf       	rjmp	.-8      	; 0x5ce <LIDAR_distance+0x38>
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
	{
		messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     5d6:	c2 e3       	ldi	r28, 0x32	; 50
     5d8:	d3 e0       	ldi	r29, 0x03	; 3
     5da:	15 ec       	ldi	r17, 0xC5	; 197
     5dc:	18 83       	st	Y, r17
		messageBuf[1] = 0x00; // Clear the field where reg 0x01 will be written
     5de:	19 82       	std	Y+1, r1	; 0x01
		TWI_Start_Transceiver_With_Data( messageBuf, 2);
     5e0:	62 e0       	ldi	r22, 0x02	; 2
     5e2:	ce 01       	movw	r24, r28
     5e4:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
		while ( TWI_Transceiver_Busy() );	
     5e8:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     5ec:	81 11       	cpse	r24, r1
     5ee:	fc cf       	rjmp	.-8      	; 0x5e8 <LIDAR_distance+0x52>
		// Now get the data we just read...note that it starts in messageBuf[1], not [0]
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 2);
     5f0:	62 e0       	ldi	r22, 0x02	; 2
     5f2:	ce 01       	movw	r24, r28
     5f4:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <TWI_Get_Data_From_Transceiver>
     5f8:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
		testing = messageBuf[1]; //This is here for debug purposes
     5fc:	89 81       	ldd	r24, Y+1	; 0x01
     5fe:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <testing>
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );	
	// Now verify we're talking to the right device...set up a read of the chip ID:
	messageBuf[1] = 0x01; // Set up to wait for 0x01 LSB to go low...
	while (messageBuf[1] & 0x01)
     602:	80 fd       	sbrc	r24, 0
     604:	eb cf       	rjmp	.-42     	; 0x5dc <LIDAR_distance+0x46>
	}
	// return;
	// LSB must now be low, so...
	// Step 3: Read two bytes from 0x8f (distance reg high byte, low byte)
	// First, WRITE the read-from address...
	messageBuf[0] = LIDAR_WRITE; // LIDAR slave address +W.
     606:	e2 e3       	ldi	r30, 0x32	; 50
     608:	f3 e0       	ldi	r31, 0x03	; 3
     60a:	84 ec       	ldi	r24, 0xC4	; 196
     60c:	80 83       	st	Z, r24
	messageBuf[1] = LIDAR_AUTO_INCREMENT_ON_READ | LIDAR_DISTANCE_HIGH_BYTE;
     60e:	8f e8       	ldi	r24, 0x8F	; 143
     610:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( messageBuf, 2);
     612:	62 e0       	ldi	r22, 0x02	; 2
     614:	cf 01       	movw	r24, r30
     616:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while (TWI_Transceiver_Busy());
     61a:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     61e:	81 11       	cpse	r24, r1
     620:	fc cf       	rjmp	.-8      	; 0x61a <LIDAR_distance+0x84>
	// Now READ from that address
	messageBuf[0] = LIDAR_READ; // LIDAR slave address +R.
     622:	e2 e3       	ldi	r30, 0x32	; 50
     624:	f3 e0       	ldi	r31, 0x03	; 3
     626:	85 ec       	ldi	r24, 0xC5	; 197
     628:	80 83       	st	Z, r24
	messageBuf[1] = 0x00; //clear the receive area to see if it gets written
     62a:	11 82       	std	Z+1, r1	; 0x01
	messageBuf[2] = 0x00; //clear the receive area to see if it gets written	
     62c:	12 82       	std	Z+2, r1	; 0x02
	TWI_Start_Transceiver_With_Data( messageBuf, 3);
     62e:	63 e0       	ldi	r22, 0x03	; 3
     630:	cf 01       	movw	r24, r30
     632:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	while ( TWI_Transceiver_Busy() );	
     636:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     63a:	81 11       	cpse	r24, r1
     63c:	fc cf       	rjmp	.-8      	; 0x636 <LIDAR_distance+0xa0>
	// Now transfer the data into our buffer
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(messageBuf, 3);
     63e:	63 e0       	ldi	r22, 0x03	; 3
     640:	82 e3       	ldi	r24, 0x32	; 50
     642:	93 e0       	ldi	r25, 0x03	; 3
     644:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <TWI_Get_Data_From_Transceiver>
     648:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
	Ldistance = (messageBuf[1]<<8) + messageBuf[2];
     64c:	e2 e3       	ldi	r30, 0x32	; 50
     64e:	f3 e0       	ldi	r31, 0x03	; 3
     650:	81 81       	ldd	r24, Z+1	; 0x01
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	98 2f       	mov	r25, r24
     656:	88 27       	eor	r24, r24
     658:	22 81       	ldd	r18, Z+2	; 0x02
	// That's all, folks...
	return(Ldistance);
}
     65a:	82 0f       	add	r24, r18
     65c:	91 1d       	adc	r25, r1
     65e:	df 91       	pop	r29
     660:	cf 91       	pop	r28
     662:	1f 91       	pop	r17
     664:	08 95       	ret

00000666 <BME_read_correction_coefficients>:
// 	// Call the HW initialization routine
// 	rslt = bme280_init(&dev);
// 	
// }

void BME_read_correction_coefficients(void) {
     666:	ff 92       	push	r15
     668:	0f 93       	push	r16
     66a:	1f 93       	push	r17
     66c:	cf 93       	push	r28
     66e:	df 93       	push	r29
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     670:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     674:	88 23       	and	r24, r24
     676:	59 f1       	breq	.+86     	; 0x6ce <BME_read_correction_coefficients+0x68>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     678:	c3 e4       	ldi	r28, 0x43	; 67
     67a:	d3 e0       	ldi	r29, 0x03	; 3
     67c:	0f 2e       	mov	r0, r31
     67e:	fc ee       	ldi	r31, 0xEC	; 236
     680:	ff 2e       	mov	r15, r31
     682:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     684:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     686:	1d ee       	ldi	r17, 0xED	; 237
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     688:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     68a:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     68c:	62 e0       	ldi	r22, 0x02	; 2
     68e:	ce 01       	movw	r24, r28
     690:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     694:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     698:	81 11       	cpse	r24, r1
     69a:	fc cf       	rjmp	.-8      	; 0x694 <BME_read_correction_coefficients+0x2e>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     69c:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 26); //We want one bytes back, so use 2 in the function call.
     69e:	6a e1       	ldi	r22, 0x1A	; 26
     6a0:	ce 01       	movw	r24, r28
     6a2:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     6a6:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     6aa:	81 11       	cpse	r24, r1
     6ac:	fc cf       	rjmp	.-8      	; 0x6a6 <BME_read_correction_coefficients+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
     6ae:	6a e1       	ldi	r22, 0x1A	; 26
     6b0:	ce 01       	movw	r24, r28
     6b2:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <TWI_Get_Data_From_Transceiver>
     6b6:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     6ba:	89 81       	ldd	r24, Y+1	; 0x01
     6bc:	83 fb       	bst	r24, 3
     6be:	88 27       	eor	r24, r24
     6c0:	80 f9       	bld	r24, 0
     6c2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
// 	BMEmessageBuf[1] = 0x88; // The register we want to start reading from
/*	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);*/
	// Let initialization transaction complete...
/*	while ( TWI_Transceiver_Busy() );*/
	static volatile uint8_t BMEbusy = 1;
	while (BMEbusy) {
     6c6:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     6ca:	81 11       	cpse	r24, r1
     6cc:	dd cf       	rjmp	.-70     	; 0x688 <BME_read_correction_coefficients+0x22>
// 	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 26);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
		// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     6ce:	e3 e4       	ldi	r30, 0x43	; 67
     6d0:	f3 e0       	ldi	r31, 0x03	; 3
     6d2:	8c ee       	ldi	r24, 0xEC	; 236
     6d4:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0x88; // The register we want to start reading from 
     6d6:	88 e8       	ldi	r24, 0x88	; 136
     6d8:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     6da:	62 e0       	ldi	r22, 0x02	; 2
     6dc:	cf 01       	movw	r24, r30
     6de:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6e2:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     6e6:	81 11       	cpse	r24, r1
     6e8:	fc cf       	rjmp	.-8      	; 0x6e2 <BME_read_correction_coefficients+0x7c>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     6ea:	8d ee       	ldi	r24, 0xED	; 237
     6ec:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 27); //We want eight bytes back, so use 9 in the function call.
     6f0:	6b e1       	ldi	r22, 0x1B	; 27
     6f2:	83 e4       	ldi	r24, 0x43	; 67
     6f4:	93 e0       	ldi	r25, 0x03	; 3
     6f6:	0e 94 a9 0b 	call	0x1752	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     6fa:	0e 94 a5 0b 	call	0x174a	; 0x174a <TWI_Transceiver_Busy>
     6fe:	81 11       	cpse	r24, r1
     700:	fc cf       	rjmp	.-8      	; 0x6fa <BME_read_correction_coefficients+0x94>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
     702:	6b e1       	ldi	r22, 0x1B	; 27
     704:	83 e4       	ldi	r24, 0x43	; 67
     706:	93 e0       	ldi	r25, 0x03	; 3
     708:	0e 94 d5 0b 	call	0x17aa	; 0x17aa <TWI_Get_Data_From_Transceiver>
     70c:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
     710:	c4 e4       	ldi	r28, 0x44	; 68
     712:	d3 e0       	ldi	r29, 0x03	; 3
     714:	0c e4       	ldi	r16, 0x4C	; 76
     716:	14 e0       	ldi	r17, 0x04	; 4
     718:	2f e5       	ldi	r18, 0x5F	; 95
     71a:	33 e0       	ldi	r19, 0x03	; 3
     71c:	d8 01       	movw	r26, r16
     71e:	fe 01       	movw	r30, r28
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     720:	81 91       	ld	r24, Z+
     722:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 27);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<27;i++) 	{
     724:	e2 17       	cp	r30, r18
     726:	f3 07       	cpc	r31, r19
     728:	d9 f7       	brne	.-10     	; 0x720 <BME_read_correction_coefficients+0xba>
     72a:	8b e1       	ldi	r24, 0x1B	; 27
     72c:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2306>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_T1 = /*0x7069;*/ RawBMEdata[0] | (RawBMEdata[1]<<8);
     730:	ec e4       	ldi	r30, 0x4C	; 76
     732:	f4 e0       	ldi	r31, 0x04	; 4
     734:	81 81       	ldd	r24, Z+1	; 0x01
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	98 2f       	mov	r25, r24
     73a:	88 27       	eor	r24, r24
     73c:	20 81       	ld	r18, Z
     73e:	82 2b       	or	r24, r18
     740:	90 93 47 04 	sts	0x0447, r25	; 0x800447 <dig_T1+0x1>
     744:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <dig_T1>
	dig_T2 = /*0x6738;*/ RawBMEdata[2] | (RawBMEdata[3]<<8);
     748:	83 81       	ldd	r24, Z+3	; 0x03
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	98 2f       	mov	r25, r24
     74e:	88 27       	eor	r24, r24
     750:	22 81       	ldd	r18, Z+2	; 0x02
     752:	82 2b       	or	r24, r18
     754:	90 93 4b 04 	sts	0x044B, r25	; 0x80044b <dig_T2+0x1>
     758:	80 93 4a 04 	sts	0x044A, r24	; 0x80044a <dig_T2>
	dig_T3 = /*0x32; */RawBMEdata[4] | (RawBMEdata[5]<<8);
     75c:	85 81       	ldd	r24, Z+5	; 0x05
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	98 2f       	mov	r25, r24
     762:	88 27       	eor	r24, r24
     764:	24 81       	ldd	r18, Z+4	; 0x04
     766:	82 2b       	or	r24, r18
     768:	90 93 c3 04 	sts	0x04C3, r25	; 0x8004c3 <dig_T3+0x1>
     76c:	80 93 c2 04 	sts	0x04C2, r24	; 0x8004c2 <dig_T3>
	dig_P1 = RawBMEdata[6] | (RawBMEdata[7]<<8);
     770:	87 81       	ldd	r24, Z+7	; 0x07
     772:	90 e0       	ldi	r25, 0x00	; 0
     774:	98 2f       	mov	r25, r24
     776:	88 27       	eor	r24, r24
     778:	26 81       	ldd	r18, Z+6	; 0x06
     77a:	82 2b       	or	r24, r18
     77c:	90 93 b7 04 	sts	0x04B7, r25	; 0x8004b7 <dig_P1+0x1>
     780:	80 93 b6 04 	sts	0x04B6, r24	; 0x8004b6 <dig_P1>
	dig_P2 = RawBMEdata[8] | (RawBMEdata[9]<<8);
     784:	81 85       	ldd	r24, Z+9	; 0x09
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	98 2f       	mov	r25, r24
     78a:	88 27       	eor	r24, r24
     78c:	20 85       	ldd	r18, Z+8	; 0x08
     78e:	82 2b       	or	r24, r18
     790:	90 93 7f 04 	sts	0x047F, r25	; 0x80047f <dig_P2+0x1>
     794:	80 93 7e 04 	sts	0x047E, r24	; 0x80047e <dig_P2>
	dig_P3 = RawBMEdata[10] | (RawBMEdata[11]<<8);
     798:	83 85       	ldd	r24, Z+11	; 0x0b
     79a:	90 e0       	ldi	r25, 0x00	; 0
     79c:	98 2f       	mov	r25, r24
     79e:	88 27       	eor	r24, r24
     7a0:	22 85       	ldd	r18, Z+10	; 0x0a
     7a2:	82 2b       	or	r24, r18
     7a4:	90 93 b9 04 	sts	0x04B9, r25	; 0x8004b9 <dig_P3+0x1>
     7a8:	80 93 b8 04 	sts	0x04B8, r24	; 0x8004b8 <dig_P3>
	dig_P4 = RawBMEdata[12] | (RawBMEdata[13]<<8);
     7ac:	85 85       	ldd	r24, Z+13	; 0x0d
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	98 2f       	mov	r25, r24
     7b2:	88 27       	eor	r24, r24
     7b4:	24 85       	ldd	r18, Z+12	; 0x0c
     7b6:	82 2b       	or	r24, r18
     7b8:	90 93 81 04 	sts	0x0481, r25	; 0x800481 <dig_P4+0x1>
     7bc:	80 93 80 04 	sts	0x0480, r24	; 0x800480 <dig_P4>
	dig_P5 = RawBMEdata[14] | (RawBMEdata[15]<<8);
     7c0:	87 85       	ldd	r24, Z+15	; 0x0f
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	98 2f       	mov	r25, r24
     7c6:	88 27       	eor	r24, r24
     7c8:	26 85       	ldd	r18, Z+14	; 0x0e
     7ca:	82 2b       	or	r24, r18
     7cc:	90 93 90 04 	sts	0x0490, r25	; 0x800490 <dig_P5+0x1>
     7d0:	80 93 8f 04 	sts	0x048F, r24	; 0x80048f <dig_P5>
	dig_P6 = RawBMEdata[16] | (RawBMEdata[17]<<8);
     7d4:	81 89       	ldd	r24, Z+17	; 0x11
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	98 2f       	mov	r25, r24
     7da:	88 27       	eor	r24, r24
     7dc:	20 89       	ldd	r18, Z+16	; 0x10
     7de:	82 2b       	or	r24, r18
     7e0:	90 93 c5 04 	sts	0x04C5, r25	; 0x8004c5 <dig_P6+0x1>
     7e4:	80 93 c4 04 	sts	0x04C4, r24	; 0x8004c4 <dig_P6>
	dig_P7 = RawBMEdata[18] | (RawBMEdata[19]<<8);
     7e8:	83 89       	ldd	r24, Z+19	; 0x13
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	98 2f       	mov	r25, r24
     7ee:	88 27       	eor	r24, r24
     7f0:	22 89       	ldd	r18, Z+18	; 0x12
     7f2:	82 2b       	or	r24, r18
     7f4:	90 93 45 04 	sts	0x0445, r25	; 0x800445 <dig_P7+0x1>
     7f8:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <dig_P7>
	dig_P8 = RawBMEdata[20] | (RawBMEdata[21]<<8);
     7fc:	85 89       	ldd	r24, Z+21	; 0x15
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	98 2f       	mov	r25, r24
     802:	88 27       	eor	r24, r24
     804:	24 89       	ldd	r18, Z+20	; 0x14
     806:	82 2b       	or	r24, r18
     808:	90 93 bb 04 	sts	0x04BB, r25	; 0x8004bb <dig_P8+0x1>
     80c:	80 93 ba 04 	sts	0x04BA, r24	; 0x8004ba <dig_P8>
	dig_P9 = RawBMEdata[22] | (RawBMEdata[23]<<8);
     810:	87 89       	ldd	r24, Z+23	; 0x17
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	98 2f       	mov	r25, r24
     816:	88 27       	eor	r24, r24
     818:	26 89       	ldd	r18, Z+22	; 0x16
     81a:	82 2b       	or	r24, r18
     81c:	90 93 c1 04 	sts	0x04C1, r25	; 0x8004c1 <dig_P9+0x1>
     820:	80 93 c0 04 	sts	0x04C0, r24	; 0x8004c0 <dig_P9>
	dig_H1 = RawBMEdata[25];
     824:	81 8d       	ldd	r24, Z+25	; 0x19
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	90 93 79 04 	sts	0x0479, r25	; 0x800479 <dig_H1+0x1>
     82c:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <dig_H1>
	//Now grab the rest of the humidity sensor data
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     830:	e3 e4       	ldi	r30, 0x43	; 67
     832:	f3 e0       	ldi	r31, 0x03	; 3
     834:	8c ee       	ldi	r24, 0xEC	; 236
     836:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE1; // The register we want to start reading from
     838:	81 ee       	ldi	r24, 0xE1	; 225
     83a:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     83c:	62 e0       	ldi	r22, 0x02	; 2
     83e:	cf 01       	movw	r24, r30
     840:	88 d7       	rcall	.+3856   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     842:	83 d7       	rcall	.+3846   	; 0x174a <TWI_Transceiver_Busy>
     844:	81 11       	cpse	r24, r1
     846:	fd cf       	rjmp	.-6      	; 0x842 <BME_read_correction_coefficients+0x1dc>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     848:	8d ee       	ldi	r24, 0xED	; 237
     84a:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 8); //We want eight bytes back, so use 9 in the function call.
     84e:	68 e0       	ldi	r22, 0x08	; 8
     850:	83 e4       	ldi	r24, 0x43	; 67
     852:	93 e0       	ldi	r25, 0x03	; 3
     854:	7e d7       	rcall	.+3836   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     856:	79 d7       	rcall	.+3826   	; 0x174a <TWI_Transceiver_Busy>
     858:	81 11       	cpse	r24, r1
     85a:	fd cf       	rjmp	.-6      	; 0x856 <BME_read_correction_coefficients+0x1f0>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
     85c:	68 e0       	ldi	r22, 0x08	; 8
     85e:	83 e4       	ldi	r24, 0x43	; 67
     860:	93 e0       	ldi	r25, 0x03	; 3
     862:	a3 d7       	rcall	.+3910   	; 0x17aa <TWI_Get_Data_From_Transceiver>
     864:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
     868:	2b e4       	ldi	r18, 0x4B	; 75
     86a:	33 e0       	ldi	r19, 0x03	; 3
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     86c:	89 91       	ld	r24, Y+
     86e:	f8 01       	movw	r30, r16
     870:	81 93       	st	Z+, r24
     872:	8f 01       	movw	r16, r30
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 8);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<7;i++) 	{
     874:	c2 17       	cp	r28, r18
     876:	d3 07       	cpc	r29, r19
     878:	c9 f7       	brne	.-14     	; 0x86c <BME_read_correction_coefficients+0x206>
     87a:	87 e0       	ldi	r24, 0x07	; 7
     87c:	80 93 cd 01 	sts	0x01CD, r24	; 0x8001cd <i.2306>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	dig_H2 = RawBMEdata[1] | (RawBMEdata[2]<<8); 
     880:	ec e4       	ldi	r30, 0x4C	; 76
     882:	f4 e0       	ldi	r31, 0x04	; 4
     884:	82 81       	ldd	r24, Z+2	; 0x02
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	98 2f       	mov	r25, r24
     88a:	88 27       	eor	r24, r24
     88c:	21 81       	ldd	r18, Z+1	; 0x01
     88e:	82 2b       	or	r24, r18
     890:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <dig_H2+0x1>
     894:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <dig_H2>
	dig_H3 = RawBMEdata[3]; 
     898:	83 81       	ldd	r24, Z+3	; 0x03
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	90 93 bf 04 	sts	0x04BF, r25	; 0x8004bf <dig_H3+0x1>
     8a0:	80 93 be 04 	sts	0x04BE, r24	; 0x8004be <dig_H3>
	dig_H4 = (RawBMEdata[4]<<4) | (RawBMEdata[5]>>5);
     8a4:	85 81       	ldd	r24, Z+5	; 0x05
     8a6:	82 95       	swap	r24
     8a8:	86 95       	lsr	r24
     8aa:	87 70       	andi	r24, 0x07	; 7
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	24 81       	ldd	r18, Z+4	; 0x04
     8b0:	40 e1       	ldi	r20, 0x10	; 16
     8b2:	24 9f       	mul	r18, r20
     8b4:	90 01       	movw	r18, r0
     8b6:	11 24       	eor	r1, r1
     8b8:	28 2b       	or	r18, r24
     8ba:	39 2b       	or	r19, r25
     8bc:	30 93 49 04 	sts	0x0449, r19	; 0x800449 <dig_H4+0x1>
     8c0:	20 93 48 04 	sts	0x0448, r18	; 0x800448 <dig_H4>
	dig_H5 = (RawBMEdata[5]>>5) | (RawBMEdata[6]<<4);
     8c4:	26 81       	ldd	r18, Z+6	; 0x06
     8c6:	40 e1       	ldi	r20, 0x10	; 16
     8c8:	24 9f       	mul	r18, r20
     8ca:	90 01       	movw	r18, r0
     8cc:	11 24       	eor	r1, r1
     8ce:	82 2b       	or	r24, r18
     8d0:	93 2b       	or	r25, r19
     8d2:	90 93 bd 04 	sts	0x04BD, r25	; 0x8004bd <dig_H5+0x1>
     8d6:	80 93 bc 04 	sts	0x04BC, r24	; 0x8004bc <dig_H5>
	dig_H6 = RawBMEdata[7];
     8da:	87 81       	ldd	r24, Z+7	; 0x07
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	90 93 8a 04 	sts	0x048A, r25	; 0x80048a <dig_H6+0x1>
     8e2:	80 93 89 04 	sts	0x0489, r24	; 0x800489 <dig_H6>
}
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	1f 91       	pop	r17
     8ec:	0f 91       	pop	r16
     8ee:	ff 90       	pop	r15
     8f0:	08 95       	ret

000008f2 <bme280basic_init>:
	// 3) Send the two bytes and restart
	// 4) First byte is the sensor I2C address (x2) and the read/write bit set to 1
	// 5) Start the transaction and send a NACK after you've received the last byte you want.
	//
	// First, reset the device per section 5.4.2 of the data sheet
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     8f2:	e3 e4       	ldi	r30, 0x43	; 67
     8f4:	f3 e0       	ldi	r31, 0x03	; 3
     8f6:	8c ee       	ldi	r24, 0xEC	; 236
     8f8:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xE0; // The register we want to write to
     8fa:	80 ee       	ldi	r24, 0xE0	; 224
     8fc:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = 0xB6; // This value forces a reset to the device
     8fe:	86 eb       	ldi	r24, 0xB6	; 182
     900:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     902:	63 e0       	ldi	r22, 0x03	; 3
     904:	cf 01       	movw	r24, r30
     906:	25 d7       	rcall	.+3658   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     908:	20 d7       	rcall	.+3648   	; 0x174a <TWI_Transceiver_Busy>
     90a:	81 11       	cpse	r24, r1
     90c:	fd cf       	rjmp	.-6      	; 0x908 <bme280basic_init+0x16>
	//
	// Now read the chip ID from register 0x0D
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     90e:	e3 e4       	ldi	r30, 0x43	; 67
     910:	f3 e0       	ldi	r31, 0x03	; 3
     912:	8c ee       	ldi	r24, 0xEC	; 236
     914:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xD0; // The register we want to read from
     916:	80 ed       	ldi	r24, 0xD0	; 208
     918:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     91a:	62 e0       	ldi	r22, 0x02	; 2
     91c:	cf 01       	movw	r24, r30
     91e:	19 d7       	rcall	.+3634   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     920:	14 d7       	rcall	.+3624   	; 0x174a <TWI_Transceiver_Busy>
     922:	81 11       	cpse	r24, r1
     924:	fd cf       	rjmp	.-6      	; 0x920 <bme280basic_init+0x2e>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read one byte, we pass "2".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     926:	8d ee       	ldi	r24, 0xED	; 237
     928:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We only want one byte back, so use 2 in the function call.
     92c:	62 e0       	ldi	r22, 0x02	; 2
     92e:	83 e4       	ldi	r24, 0x43	; 67
     930:	93 e0       	ldi	r25, 0x03	; 3
     932:	0f d7       	rcall	.+3614   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     934:	0a d7       	rcall	.+3604   	; 0x174a <TWI_Transceiver_Busy>
     936:	81 11       	cpse	r24, r1
     938:	fd cf       	rjmp	.-6      	; 0x934 <bme280basic_init+0x42>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     93a:	62 e0       	ldi	r22, 0x02	; 2
     93c:	83 e4       	ldi	r24, 0x43	; 67
     93e:	93 e0       	ldi	r25, 0x03	; 3
     940:	34 d7       	rcall	.+3688   	; 0x17aa <TWI_Get_Data_From_Transceiver>
     942:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	if (BMEmessageBuf[1]==0x60) { 
     946:	80 91 44 03 	lds	r24, 0x0344	; 0x800344 <BMEmessageBuf+0x1>
     94a:	80 36       	cpi	r24, 0x60	; 96
     94c:	69 f5       	brne	.+90     	; 0x9a8 <bme280basic_init+0xb6>
		// We're talking to the right device.  Set up the control registers...
		//
		// We want Humidity oversampling set to x1 (ctrl_hum (0xF2) [2:0] = 0b001)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     94e:	e3 e4       	ldi	r30, 0x43	; 67
     950:	f3 e0       	ldi	r31, 0x03	; 3
     952:	8c ee       	ldi	r24, 0xEC	; 236
     954:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF2; // The register we want to write to
     956:	82 ef       	ldi	r24, 0xF2	; 242
     958:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = 0x01; // Set humidity oversampling to x1
     95a:	81 e0       	ldi	r24, 0x01	; 1
     95c:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     95e:	63 e0       	ldi	r22, 0x03	; 3
     960:	cf 01       	movw	r24, r30
     962:	f7 d6       	rcall	.+3566   	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     964:	f2 d6       	rcall	.+3556   	; 0x174a <TWI_Transceiver_Busy>
     966:	81 11       	cpse	r24, r1
     968:	fd cf       	rjmp	.-6      	; 0x964 <bme280basic_init+0x72>
		//		
		//Set Tstandby to its smallest value (0)
		//  Per table 12 and 28 we want the filter coefficient at 16 (config (0xF5) [4:2] = 0b100)
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     96a:	e3 e4       	ldi	r30, 0x43	; 67
     96c:	f3 e0       	ldi	r31, 0x03	; 3
     96e:	8c ee       	ldi	r24, 0xEC	; 236
     970:	80 83       	st	Z, r24
		BMEmessageBuf[1] = 0xF5; // The register we want to write to
     972:	85 ef       	ldi	r24, 0xF5	; 245
     974:	81 83       	std	Z+1, r24	; 0x01
		BMEmessageBuf[2] = (0b100<<2); // Set temp, pressure, and mode
     976:	80 e1       	ldi	r24, 0x10	; 16
     978:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     97a:	63 e0       	ldi	r22, 0x03	; 3
     97c:	cf 01       	movw	r24, r30
     97e:	e9 d6       	rcall	.+3538   	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     980:	e4 d6       	rcall	.+3528   	; 0x174a <TWI_Transceiver_Busy>
     982:	81 11       	cpse	r24, r1
     984:	fd cf       	rjmp	.-6      	; 0x980 <bme280basic_init+0x8e>
		//
		BME_read_correction_coefficients();
     986:	6f de       	rcall	.-802    	; 0x666 <BME_read_correction_coefficients>
		// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
		// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
		// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
		BMEtriggerbyte = (0b01<<5) | (0b100<<2) | (0b01<<0);
     988:	81 e3       	ldi	r24, 0x31	; 49
     98a:	80 93 82 04 	sts	0x0482, r24	; 0x800482 <BMEtriggerbyte>
		// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     98e:	e3 e4       	ldi	r30, 0x43	; 67
     990:	f3 e0       	ldi	r31, 0x03	; 3
     992:	9c ee       	ldi	r25, 0xEC	; 236
     994:	90 83       	st	Z, r25
		BMEmessageBuf[1] = 0xF4; // The register we want to write to
     996:	94 ef       	ldi	r25, 0xF4	; 244
     998:	91 83       	std	Z+1, r25	; 0x01
		BMEmessageBuf[2] = BMEtriggerbyte; // Set temp, pressure, and mode
     99a:	82 83       	std	Z+2, r24	; 0x02
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     99c:	63 e0       	ldi	r22, 0x03	; 3
     99e:	cf 01       	movw	r24, r30
     9a0:	d8 d6       	rcall	.+3504   	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Wait for the transaction to complete...
		while ( TWI_Transceiver_Busy() );
     9a2:	d3 d6       	rcall	.+3494   	; 0x174a <TWI_Transceiver_Busy>
     9a4:	81 11       	cpse	r24, r1
     9a6:	fd cf       	rjmp	.-6      	; 0x9a2 <bme280basic_init+0xb0>
     9a8:	08 95       	ret

000009aa <bme280basic_bulk_data_read>:
		//  All done - and first measurement cycle has  been kicked off!
	}
}

void bme280basic_bulk_data_read(void) {
     9aa:	ff 92       	push	r15
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
	// See the bme280basic_init routine for the read and write protocols for using this sensor...
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2360>
	while (BMEbusy) {
     9ba:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2360>
     9be:	88 23       	and	r24, r24
     9c0:	31 f1       	breq	.+76     	; 0xa0e <bme280basic_bulk_data_read+0x64>
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9c2:	c3 e4       	ldi	r28, 0x43	; 67
     9c4:	d3 e0       	ldi	r29, 0x03	; 3
     9c6:	0f 2e       	mov	r0, r31
     9c8:	fc ee       	ldi	r31, 0xEC	; 236
     9ca:	ff 2e       	mov	r15, r31
     9cc:	f0 2d       	mov	r31, r0
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9ce:	03 ef       	ldi	r16, 0xF3	; 243
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9d0:	1d ee       	ldi	r17, 0xED	; 237
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
		BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     9d2:	f8 82       	st	Y, r15
		BMEmessageBuf[1] = 0xF3; // The BME280 status register
     9d4:	09 83       	std	Y+1, r16	; 0x01
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     9d6:	62 e0       	ldi	r22, 0x02	; 2
     9d8:	ce 01       	movw	r24, r28
     9da:	bb d6       	rcall	.+3446   	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9dc:	b6 d6       	rcall	.+3436   	; 0x174a <TWI_Transceiver_Busy>
     9de:	81 11       	cpse	r24, r1
     9e0:	fd cf       	rjmp	.-6      	; 0x9dc <bme280basic_bulk_data_read+0x32>
		// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). 
		BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     9e2:	18 83       	st	Y, r17
		TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2); //We want one bytes back, so use 2 in the function call.
     9e4:	62 e0       	ldi	r22, 0x02	; 2
     9e6:	ce 01       	movw	r24, r28
     9e8:	b4 d6       	rcall	.+3432   	; 0x1752 <TWI_Start_Transceiver_With_Data>
		// Let initialization transaction complete...
		while ( TWI_Transceiver_Busy() );
     9ea:	af d6       	rcall	.+3422   	; 0x174a <TWI_Transceiver_Busy>
     9ec:	81 11       	cpse	r24, r1
     9ee:	fd cf       	rjmp	.-6      	; 0x9ea <bme280basic_bulk_data_read+0x40>
		// Copy the data we want...
		TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 2);
     9f0:	62 e0       	ldi	r22, 0x02	; 2
     9f2:	ce 01       	movw	r24, r28
     9f4:	da d6       	rcall	.+3508   	; 0x17aa <TWI_Get_Data_From_Transceiver>
     9f6:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
		// CHeck to see if things are still busy
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
     9fa:	89 81       	ldd	r24, Y+1	; 0x01
     9fc:	83 fb       	bst	r24, 3
     9fe:	88 27       	eor	r24, r24
     a00:	80 f9       	bld	r24, 0
     a02:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <BMEbusy.2360>
	uint8_t i;
	static volatile uint8_t BMEbusy;
	//
	// Ensure the device has completed the read cycle...
	BMEbusy = 1;
	while (BMEbusy) {
     a06:	80 91 cc 01 	lds	r24, 0x01CC	; 0x8001cc <BMEbusy.2360>
     a0a:	81 11       	cpse	r24, r1
     a0c:	e2 cf       	rjmp	.-60     	; 0x9d2 <bme280basic_bulk_data_read+0x28>
		BMEbusy = ((0b00001000 & BMEmessageBuf[1])>>3);
	}
	//
	// Device is completed the measurement cycle, now get the temperature data...
	// We want to start reading the data from register 0xF7 and read to register 0xFE - 8 bytes total
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     a0e:	e3 e4       	ldi	r30, 0x43	; 67
     a10:	f3 e0       	ldi	r31, 0x03	; 3
     a12:	8c ee       	ldi	r24, 0xEC	; 236
     a14:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF7; // The register we want to start reading from 
     a16:	87 ef       	ldi	r24, 0xF7	; 247
     a18:	81 83       	std	Z+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 2);
     a1a:	62 e0       	ldi	r22, 0x02	; 2
     a1c:	cf 01       	movw	r24, r30
     a1e:	99 d6       	rcall	.+3378   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a20:	94 d6       	rcall	.+3368   	; 0x174a <TWI_Transceiver_Busy>
     a22:	81 11       	cpse	r24, r1
     a24:	fd cf       	rjmp	.-6      	; 0xa20 <bme280basic_bulk_data_read+0x76>
	// Now for the read part...
	// Bytes to read = (number_of_bytes_to_read (on next cycle) +1). Zero origin.   If we want to read eight bytes, we pass "9".
	BMEmessageBuf[0] = BME_READ_ADDRESS; // The first byte must always have TWI slave address.
     a26:	8d ee       	ldi	r24, 0xED	; 237
     a28:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <BMEmessageBuf>
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 9); //We want eight bytes back, so use 9 in the function call.
     a2c:	69 e0       	ldi	r22, 0x09	; 9
     a2e:	83 e4       	ldi	r24, 0x43	; 67
     a30:	93 e0       	ldi	r25, 0x03	; 3
     a32:	8f d6       	rcall	.+3358   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Let initialization transaction complete...
	while ( TWI_Transceiver_Busy() );
     a34:	8a d6       	rcall	.+3348   	; 0x174a <TWI_Transceiver_Busy>
     a36:	81 11       	cpse	r24, r1
     a38:	fd cf       	rjmp	.-6      	; 0xa34 <bme280basic_bulk_data_read+0x8a>
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
     a3a:	69 e0       	ldi	r22, 0x09	; 9
     a3c:	83 e4       	ldi	r24, 0x43	; 67
     a3e:	93 e0       	ldi	r25, 0x03	; 3
     a40:	b4 d6       	rcall	.+3432   	; 0x17aa <TWI_Get_Data_From_Transceiver>
     a42:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <TWI_XFER_STATUS>
     a46:	e4 e4       	ldi	r30, 0x44	; 68
     a48:	f3 e0       	ldi	r31, 0x03	; 3
     a4a:	ac e4       	ldi	r26, 0x4C	; 76
     a4c:	b4 e0       	ldi	r27, 0x04	; 4
     a4e:	2c e4       	ldi	r18, 0x4C	; 76
     a50:	33 e0       	ldi	r19, 0x03	; 3
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
		RawBMEdata[i] = BMEmessageBuf[i+1];
     a52:	81 91       	ld	r24, Z+
     a54:	8d 93       	st	X+, r24
	while ( TWI_Transceiver_Busy() );
	// Now get the data we just read...note this call just copies the data from the TWI routine buffer to our local buffer (BMEmessageBuf)...
	TWI_XFER_STATUS = TWI_Get_Data_From_Transceiver(BMEmessageBuf, 9);
	// Note that the data we want starts in BMEmessageBuf[1], not BMEmessageBuf[0]
	// Transfer the data to a variable we can manipulate to get our data out...
	for (i=0;i<8;i++) 	{
     a56:	e2 17       	cp	r30, r18
     a58:	f3 07       	cpc	r31, r19
     a5a:	d9 f7       	brne	.-10     	; 0xa52 <bme280basic_bulk_data_read+0xa8>
		RawBMEdata[i] = BMEmessageBuf[i+1];
	}
	rawPress = ((uint32_t)RawBMEdata[0]<<12) | ((uint32_t)RawBMEdata[1]<<4) | ((uint32_t)RawBMEdata[2]>>4);
     a5c:	ec e4       	ldi	r30, 0x4C	; 76
     a5e:	f4 e0       	ldi	r31, 0x04	; 4
     a60:	81 81       	ldd	r24, Z+1	; 0x01
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	a0 e0       	ldi	r26, 0x00	; 0
     a66:	b0 e0       	ldi	r27, 0x00	; 0
     a68:	88 0f       	add	r24, r24
     a6a:	99 1f       	adc	r25, r25
     a6c:	aa 1f       	adc	r26, r26
     a6e:	bb 1f       	adc	r27, r27
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	aa 1f       	adc	r26, r26
     a76:	bb 1f       	adc	r27, r27
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	aa 1f       	adc	r26, r26
     a7e:	bb 1f       	adc	r27, r27
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	aa 1f       	adc	r26, r26
     a86:	bb 1f       	adc	r27, r27
     a88:	40 81       	ld	r20, Z
     a8a:	50 e0       	ldi	r21, 0x00	; 0
     a8c:	60 e0       	ldi	r22, 0x00	; 0
     a8e:	70 e0       	ldi	r23, 0x00	; 0
     a90:	03 2e       	mov	r0, r19
     a92:	3c e0       	ldi	r19, 0x0C	; 12
     a94:	44 0f       	add	r20, r20
     a96:	55 1f       	adc	r21, r21
     a98:	66 1f       	adc	r22, r22
     a9a:	77 1f       	adc	r23, r23
     a9c:	3a 95       	dec	r19
     a9e:	d1 f7       	brne	.-12     	; 0xa94 <bme280basic_bulk_data_read+0xea>
     aa0:	30 2d       	mov	r19, r0
     aa2:	84 2b       	or	r24, r20
     aa4:	95 2b       	or	r25, r21
     aa6:	a6 2b       	or	r26, r22
     aa8:	b7 2b       	or	r27, r23
     aaa:	22 81       	ldd	r18, Z+2	; 0x02
     aac:	22 95       	swap	r18
     aae:	2f 70       	andi	r18, 0x0F	; 15
     ab0:	82 2b       	or	r24, r18
     ab2:	80 93 92 04 	sts	0x0492, r24	; 0x800492 <rawPress>
     ab6:	90 93 93 04 	sts	0x0493, r25	; 0x800493 <rawPress+0x1>
     aba:	a0 93 94 04 	sts	0x0494, r26	; 0x800494 <rawPress+0x2>
     abe:	b0 93 95 04 	sts	0x0495, r27	; 0x800495 <rawPress+0x3>
	rawTemp = ((uint32_t)RawBMEdata[3]<<12) | ((uint32_t)RawBMEdata[4]<<4) | ((uint32_t)RawBMEdata[5]>>4);
     ac2:	84 81       	ldd	r24, Z+4	; 0x04
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	a0 e0       	ldi	r26, 0x00	; 0
     ac8:	b0 e0       	ldi	r27, 0x00	; 0
     aca:	88 0f       	add	r24, r24
     acc:	99 1f       	adc	r25, r25
     ace:	aa 1f       	adc	r26, r26
     ad0:	bb 1f       	adc	r27, r27
     ad2:	88 0f       	add	r24, r24
     ad4:	99 1f       	adc	r25, r25
     ad6:	aa 1f       	adc	r26, r26
     ad8:	bb 1f       	adc	r27, r27
     ada:	88 0f       	add	r24, r24
     adc:	99 1f       	adc	r25, r25
     ade:	aa 1f       	adc	r26, r26
     ae0:	bb 1f       	adc	r27, r27
     ae2:	88 0f       	add	r24, r24
     ae4:	99 1f       	adc	r25, r25
     ae6:	aa 1f       	adc	r26, r26
     ae8:	bb 1f       	adc	r27, r27
     aea:	43 81       	ldd	r20, Z+3	; 0x03
     aec:	50 e0       	ldi	r21, 0x00	; 0
     aee:	60 e0       	ldi	r22, 0x00	; 0
     af0:	70 e0       	ldi	r23, 0x00	; 0
     af2:	03 2e       	mov	r0, r19
     af4:	3c e0       	ldi	r19, 0x0C	; 12
     af6:	44 0f       	add	r20, r20
     af8:	55 1f       	adc	r21, r21
     afa:	66 1f       	adc	r22, r22
     afc:	77 1f       	adc	r23, r23
     afe:	3a 95       	dec	r19
     b00:	d1 f7       	brne	.-12     	; 0xaf6 <bme280basic_bulk_data_read+0x14c>
     b02:	30 2d       	mov	r19, r0
     b04:	84 2b       	or	r24, r20
     b06:	95 2b       	or	r25, r21
     b08:	a6 2b       	or	r26, r22
     b0a:	b7 2b       	or	r27, r23
     b0c:	25 81       	ldd	r18, Z+5	; 0x05
     b0e:	22 95       	swap	r18
     b10:	2f 70       	andi	r18, 0x0F	; 15
     b12:	82 2b       	or	r24, r18
     b14:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <rawTemp>
     b18:	90 93 7b 04 	sts	0x047B, r25	; 0x80047b <rawTemp+0x1>
     b1c:	a0 93 7c 04 	sts	0x047C, r26	; 0x80047c <rawTemp+0x2>
     b20:	b0 93 7d 04 	sts	0x047D, r27	; 0x80047d <rawTemp+0x3>
	rawHum = ((uint32_t)RawBMEdata[6]<<8) | (uint32_t)RawBMEdata[7];
     b24:	86 81       	ldd	r24, Z+6	; 0x06
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	a0 e0       	ldi	r26, 0x00	; 0
     b2a:	b0 e0       	ldi	r27, 0x00	; 0
     b2c:	ba 2f       	mov	r27, r26
     b2e:	a9 2f       	mov	r26, r25
     b30:	98 2f       	mov	r25, r24
     b32:	88 27       	eor	r24, r24
     b34:	27 81       	ldd	r18, Z+7	; 0x07
     b36:	82 2b       	or	r24, r18
     b38:	80 93 96 04 	sts	0x0496, r24	; 0x800496 <rawHum>
     b3c:	90 93 97 04 	sts	0x0497, r25	; 0x800497 <rawHum+0x1>
     b40:	a0 93 98 04 	sts	0x0498, r26	; 0x800498 <rawHum+0x2>
     b44:	b0 93 99 04 	sts	0x0499, r27	; 0x800499 <rawHum+0x3>
	// We want Temperature oversampling set to x1 (ctrl_meas (0xF4) [7:5] = 0b001)
	// We want Pressure oversampling set to x8 (ctrl_meas (0xF4) [4:2] = 0b100)
	// Put the device into Forced mode (we want to tell the device to "go measure") (ctrl_meas (0xF4) [1:0] = 0b01)
	// BMEtriggerbyte ^= 0x03; // toggle the forced mode (not sure this is required)
	// NOTE: THIS BYTE MUST BE RESENT EACH TIME TO GET A NEW MEASUREMENT
	BMEmessageBuf[0] = BME_WRITE_ADDRESS; // The first byte must always have TWI slave address.
     b48:	e3 e4       	ldi	r30, 0x43	; 67
     b4a:	f3 e0       	ldi	r31, 0x03	; 3
     b4c:	8c ee       	ldi	r24, 0xEC	; 236
     b4e:	80 83       	st	Z, r24
	BMEmessageBuf[1] = 0xF4; // The register we want to write to
     b50:	84 ef       	ldi	r24, 0xF4	; 244
     b52:	81 83       	std	Z+1, r24	; 0x01
	BMEmessageBuf[2] = (0b01<<5) | (0b100<<2) | (0b01<<0); // Set temp, pressure, and mode
     b54:	81 e3       	ldi	r24, 0x31	; 49
     b56:	82 83       	std	Z+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( BMEmessageBuf, 3);
     b58:	63 e0       	ldi	r22, 0x03	; 3
     b5a:	cf 01       	movw	r24, r30
     b5c:	fa d5       	rcall	.+3060   	; 0x1752 <TWI_Start_Transceiver_With_Data>
	// Wait for the transaction to complete...
	while ( TWI_Transceiver_Busy() );
     b5e:	f5 d5       	rcall	.+3050   	; 0x174a <TWI_Transceiver_Busy>
     b60:	81 11       	cpse	r24, r1
     b62:	fd cf       	rjmp	.-6      	; 0xb5e <bme280basic_bulk_data_read+0x1b4>
	//  All done - and the next measurement cycle has  been kicked off!
}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	ff 90       	pop	r15
     b6e:	08 95       	ret

00000b70 <BME280_compensate_T_int32>:

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
     b70:	8f 92       	push	r8
     b72:	9f 92       	push	r9
     b74:	af 92       	push	r10
     b76:	bf 92       	push	r11
     b78:	cf 92       	push	r12
     b7a:	df 92       	push	r13
     b7c:	ef 92       	push	r14
     b7e:	ff 92       	push	r15
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     b80:	20 91 46 04 	lds	r18, 0x0446	; 0x800446 <dig_T1>
     b84:	30 91 47 04 	lds	r19, 0x0447	; 0x800447 <dig_T1+0x1>
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     b88:	6b 01       	movw	r12, r22
     b8a:	7c 01       	movw	r14, r24
     b8c:	68 94       	set
     b8e:	13 f8       	bld	r1, 3
     b90:	f5 94       	asr	r15
     b92:	e7 94       	ror	r14
     b94:	d7 94       	ror	r13
     b96:	c7 94       	ror	r12
     b98:	16 94       	lsr	r1
     b9a:	d1 f7       	brne	.-12     	; 0xb90 <BME280_compensate_T_int32+0x20>
     b9c:	c2 1a       	sub	r12, r18
     b9e:	d3 0a       	sbc	r13, r19
     ba0:	e1 08       	sbc	r14, r1
     ba2:	f1 08       	sbc	r15, r1

// Returns temperature in DegC, resolution is 0.01 DegC. Output value of ?5123? equals 51.23 Deg C.
// t_fine carries fine temperature as global value
long BME280_compensate_T_int32(long adc_T) {
	long var1, var2, T;
	var1  = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11;
     ba4:	dc 01       	movw	r26, r24
     ba6:	cb 01       	movw	r24, r22
     ba8:	68 94       	set
     baa:	12 f8       	bld	r1, 2
     bac:	b5 95       	asr	r27
     bae:	a7 95       	ror	r26
     bb0:	97 95       	ror	r25
     bb2:	87 95       	ror	r24
     bb4:	16 94       	lsr	r1
     bb6:	d1 f7       	brne	.-12     	; 0xbac <BME280_compensate_T_int32+0x3c>
     bb8:	22 0f       	add	r18, r18
     bba:	33 1f       	adc	r19, r19
     bbc:	4c 01       	movw	r8, r24
     bbe:	5d 01       	movw	r10, r26
     bc0:	82 1a       	sub	r8, r18
     bc2:	93 0a       	sbc	r9, r19
     bc4:	a1 08       	sbc	r10, r1
     bc6:	b1 08       	sbc	r11, r1
     bc8:	a5 01       	movw	r20, r10
     bca:	94 01       	movw	r18, r8
     bcc:	a0 91 4a 04 	lds	r26, 0x044A	; 0x80044a <dig_T2>
     bd0:	b0 91 4b 04 	lds	r27, 0x044B	; 0x80044b <dig_T2+0x1>
     bd4:	93 d7       	rcall	.+3878   	; 0x1afc <__mulshisi3>
     bd6:	4b 01       	movw	r8, r22
     bd8:	5c 01       	movw	r10, r24
     bda:	07 2e       	mov	r0, r23
     bdc:	7b e0       	ldi	r23, 0x0B	; 11
     bde:	b5 94       	asr	r11
     be0:	a7 94       	ror	r10
     be2:	97 94       	ror	r9
     be4:	87 94       	ror	r8
     be6:	7a 95       	dec	r23
     be8:	d1 f7       	brne	.-12     	; 0xbde <BME280_compensate_T_int32+0x6e>
     bea:	70 2d       	mov	r23, r0
	var2  = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - (dig_T1))) >> 12) * (dig_T3)) >> 14;
     bec:	a7 01       	movw	r20, r14
     bee:	96 01       	movw	r18, r12
     bf0:	c7 01       	movw	r24, r14
     bf2:	b6 01       	movw	r22, r12
     bf4:	61 d7       	rcall	.+3778   	; 0x1ab8 <__mulsi3>
     bf6:	9b 01       	movw	r18, r22
     bf8:	ac 01       	movw	r20, r24
     bfa:	01 2e       	mov	r0, r17
     bfc:	1c e0       	ldi	r17, 0x0C	; 12
     bfe:	55 95       	asr	r21
     c00:	47 95       	ror	r20
     c02:	37 95       	ror	r19
     c04:	27 95       	ror	r18
     c06:	1a 95       	dec	r17
     c08:	d1 f7       	brne	.-12     	; 0xbfe <BME280_compensate_T_int32+0x8e>
     c0a:	10 2d       	mov	r17, r0
     c0c:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <dig_T3>
     c10:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <dig_T3+0x1>
     c14:	73 d7       	rcall	.+3814   	; 0x1afc <__mulshisi3>
     c16:	dc 01       	movw	r26, r24
     c18:	cb 01       	movw	r24, r22
     c1a:	07 2e       	mov	r0, r23
     c1c:	7e e0       	ldi	r23, 0x0E	; 14
     c1e:	b5 95       	asr	r27
     c20:	a7 95       	ror	r26
     c22:	97 95       	ror	r25
     c24:	87 95       	ror	r24
     c26:	7a 95       	dec	r23
     c28:	d1 f7       	brne	.-12     	; 0xc1e <BME280_compensate_T_int32+0xae>
     c2a:	70 2d       	mov	r23, r0
	t_fine = var1 + var2;
     c2c:	88 0d       	add	r24, r8
     c2e:	99 1d       	adc	r25, r9
     c30:	aa 1d       	adc	r26, r10
     c32:	bb 1d       	adc	r27, r11
     c34:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <t_fine>
     c38:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <t_fine+0x1>
     c3c:	a0 93 ca 04 	sts	0x04CA, r26	; 0x8004ca <t_fine+0x2>
     c40:	b0 93 cb 04 	sts	0x04CB, r27	; 0x8004cb <t_fine+0x3>
	T  = (t_fine * 5 + 128) >> 8;
     c44:	6c 01       	movw	r12, r24
     c46:	7d 01       	movw	r14, r26
     c48:	cc 0c       	add	r12, r12
     c4a:	dd 1c       	adc	r13, r13
     c4c:	ee 1c       	adc	r14, r14
     c4e:	ff 1c       	adc	r15, r15
     c50:	cc 0c       	add	r12, r12
     c52:	dd 1c       	adc	r13, r13
     c54:	ee 1c       	adc	r14, r14
     c56:	ff 1c       	adc	r15, r15
     c58:	8c 0d       	add	r24, r12
     c5a:	9d 1d       	adc	r25, r13
     c5c:	ae 1d       	adc	r26, r14
     c5e:	bf 1d       	adc	r27, r15
     c60:	80 58       	subi	r24, 0x80	; 128
     c62:	9f 4f       	sbci	r25, 0xFF	; 255
     c64:	af 4f       	sbci	r26, 0xFF	; 255
     c66:	bf 4f       	sbci	r27, 0xFF	; 255
     c68:	69 2f       	mov	r22, r25
     c6a:	7a 2f       	mov	r23, r26
     c6c:	8b 2f       	mov	r24, r27
     c6e:	99 27       	eor	r25, r25
     c70:	87 fd       	sbrc	r24, 7
     c72:	9a 95       	dec	r25
	return T;
}
     c74:	ff 90       	pop	r15
     c76:	ef 90       	pop	r14
     c78:	df 90       	pop	r13
     c7a:	cf 90       	pop	r12
     c7c:	bf 90       	pop	r11
     c7e:	af 90       	pop	r10
     c80:	9f 90       	pop	r9
     c82:	8f 90       	pop	r8
     c84:	08 95       	ret

00000c86 <BME280_compensate_P_int64>:


//Return pressure in Pa as unsigned 32 bit int in Q24.8 format(24 int bits, 8 fractional)
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
     c86:	2f 92       	push	r2
     c88:	3f 92       	push	r3
     c8a:	4f 92       	push	r4
     c8c:	5f 92       	push	r5
     c8e:	6f 92       	push	r6
     c90:	7f 92       	push	r7
     c92:	8f 92       	push	r8
     c94:	9f 92       	push	r9
     c96:	af 92       	push	r10
     c98:	bf 92       	push	r11
     c9a:	cf 92       	push	r12
     c9c:	df 92       	push	r13
     c9e:	ef 92       	push	r14
     ca0:	ff 92       	push	r15
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	cf 93       	push	r28
     ca8:	df 93       	push	r29
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
     cae:	6e 97       	sbiw	r28, 0x1e	; 30
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	6e 8b       	std	Y+22, r22	; 0x16
     cbc:	7f 8b       	std	Y+23, r23	; 0x17
     cbe:	88 8f       	std	Y+24, r24	; 0x18
     cc0:	99 8f       	std	Y+25, r25	; 0x19
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
     cc2:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <t_fine>
     cc6:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <t_fine+0x1>
     cca:	a0 91 ca 04 	lds	r26, 0x04CA	; 0x8004ca <t_fine+0x2>
     cce:	b0 91 cb 04 	lds	r27, 0x04CB	; 0x8004cb <t_fine+0x3>
     cd2:	8c 01       	movw	r16, r24
     cd4:	9d 01       	movw	r18, r26
     cd6:	14 5f       	subi	r17, 0xF4	; 244
     cd8:	21 40       	sbci	r18, 0x01	; 1
     cda:	31 09       	sbc	r19, r1
     cdc:	09 83       	std	Y+1, r16	; 0x01
     cde:	1a 83       	std	Y+2, r17	; 0x02
     ce0:	2b 83       	std	Y+3, r18	; 0x03
     ce2:	3c 83       	std	Y+4, r19	; 0x04
     ce4:	33 0f       	add	r19, r19
     ce6:	00 0b       	sbc	r16, r16
     ce8:	10 2f       	mov	r17, r16
     cea:	98 01       	movw	r18, r16
     cec:	0d 83       	std	Y+5, r16	; 0x05
     cee:	1e 83       	std	Y+6, r17	; 0x06
     cf0:	2f 83       	std	Y+7, r18	; 0x07
     cf2:	38 87       	std	Y+8, r19	; 0x08
	var2 = var1*var1*(long)dig_P6;
     cf4:	a9 80       	ldd	r10, Y+1	; 0x01
     cf6:	ba 80       	ldd	r11, Y+2	; 0x02
     cf8:	cb 80       	ldd	r12, Y+3	; 0x03
     cfa:	dc 80       	ldd	r13, Y+4	; 0x04
     cfc:	ed 80       	ldd	r14, Y+5	; 0x05
     cfe:	fe 2c       	mov	r15, r14
     d00:	0e 2d       	mov	r16, r14
     d02:	1e 2d       	mov	r17, r14
     d04:	2a 2d       	mov	r18, r10
     d06:	3b 2d       	mov	r19, r11
     d08:	4c 2d       	mov	r20, r12
     d0a:	5d 2d       	mov	r21, r13
     d0c:	60 2f       	mov	r22, r16
     d0e:	70 2f       	mov	r23, r16
     d10:	80 2f       	mov	r24, r16
     d12:	9e 2d       	mov	r25, r14
     d14:	f9 d6       	rcall	.+3570   	; 0x1b08 <__muldi3>
     d16:	2d 87       	std	Y+13, r18	; 0x0d
     d18:	3e 87       	std	Y+14, r19	; 0x0e
     d1a:	4f 87       	std	Y+15, r20	; 0x0f
     d1c:	58 8b       	std	Y+16, r21	; 0x10
     d1e:	69 8b       	std	Y+17, r22	; 0x11
     d20:	7a 8b       	std	Y+18, r23	; 0x12
     d22:	8b 8b       	std	Y+19, r24	; 0x13
     d24:	9c 8b       	std	Y+20, r25	; 0x14
     d26:	10 91 c4 04 	lds	r17, 0x04C4	; 0x8004c4 <dig_P6>
     d2a:	1a 8f       	std	Y+26, r17	; 0x1a
     d2c:	20 91 c5 04 	lds	r18, 0x04C5	; 0x8004c5 <dig_P6+0x1>
     d30:	2e 8f       	std	Y+30, r18	; 0x1e
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     d32:	30 91 8f 04 	lds	r19, 0x048F	; 0x80048f <dig_P5>
     d36:	3b 8f       	std	Y+27, r19	; 0x1b
     d38:	40 91 90 04 	lds	r20, 0x0490	; 0x800490 <dig_P5+0x1>
     d3c:	4d 8f       	std	Y+29, r20	; 0x1d
	var2 = var2 + (((long long)dig_P4)<<35);
     d3e:	50 91 80 04 	lds	r21, 0x0480	; 0x800480 <dig_P4>
     d42:	5c 8f       	std	Y+28, r21	; 0x1c
     d44:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <dig_P4+0x1>
     d48:	8d 8b       	std	Y+21, r24	; 0x15
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
     d4a:	30 91 7f 04 	lds	r19, 0x047F	; 0x80047f <dig_P2+0x1>
     d4e:	20 91 7e 04 	lds	r18, 0x047E	; 0x80047e <dig_P2>
     d52:	93 2f       	mov	r25, r19
     d54:	99 0f       	add	r25, r25
     d56:	99 0b       	sbc	r25, r25
     d58:	fe 2c       	mov	r15, r14
     d5a:	0e 2d       	mov	r16, r14
     d5c:	1e 2d       	mov	r17, r14
     d5e:	49 2f       	mov	r20, r25
     d60:	59 2f       	mov	r21, r25
     d62:	69 2f       	mov	r22, r25
     d64:	79 2f       	mov	r23, r25
     d66:	89 2f       	mov	r24, r25
     d68:	cf d6       	rcall	.+3486   	; 0x1b08 <__muldi3>
     d6a:	0c e0       	ldi	r16, 0x0C	; 12
     d6c:	ee d7       	rcall	.+4060   	; 0x1d4a <__ashldi3>
     d6e:	42 2e       	mov	r4, r18
     d70:	53 2e       	mov	r5, r19
     d72:	64 2e       	mov	r6, r20
     d74:	75 2e       	mov	r7, r21
     d76:	86 2e       	mov	r8, r22
     d78:	97 2e       	mov	r9, r23
     d7a:	28 2e       	mov	r2, r24
     d7c:	39 2e       	mov	r3, r25
     d7e:	b0 90 b9 04 	lds	r11, 0x04B9	; 0x8004b9 <dig_P3+0x1>
     d82:	a0 90 b8 04 	lds	r10, 0x04B8	; 0x8004b8 <dig_P3>
     d86:	1b 2d       	mov	r17, r11
     d88:	11 0f       	add	r17, r17
     d8a:	11 0b       	sbc	r17, r17
     d8c:	c1 2e       	mov	r12, r17
     d8e:	d1 2e       	mov	r13, r17
     d90:	e1 2e       	mov	r14, r17
     d92:	f1 2e       	mov	r15, r17
     d94:	01 2f       	mov	r16, r17
     d96:	2d 85       	ldd	r18, Y+13	; 0x0d
     d98:	3e 85       	ldd	r19, Y+14	; 0x0e
     d9a:	4f 85       	ldd	r20, Y+15	; 0x0f
     d9c:	58 89       	ldd	r21, Y+16	; 0x10
     d9e:	69 89       	ldd	r22, Y+17	; 0x11
     da0:	7a 89       	ldd	r23, Y+18	; 0x12
     da2:	8b 89       	ldd	r24, Y+19	; 0x13
     da4:	9c 89       	ldd	r25, Y+20	; 0x14
     da6:	b0 d6       	rcall	.+3424   	; 0x1b08 <__muldi3>
     da8:	08 e0       	ldi	r16, 0x08	; 8
     daa:	e8 d7       	rcall	.+4048   	; 0x1d7c <__ashrdi3>
     dac:	a4 2c       	mov	r10, r4
     dae:	b5 2c       	mov	r11, r5
     db0:	c6 2c       	mov	r12, r6
     db2:	d7 2c       	mov	r13, r7
     db4:	e8 2c       	mov	r14, r8
     db6:	f9 2c       	mov	r15, r9
     db8:	02 2d       	mov	r16, r2
     dba:	13 2d       	mov	r17, r3
     dbc:	fd d7       	rcall	.+4090   	; 0x1db8 <__adddi3>
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
     dbe:	70 58       	subi	r23, 0x80	; 128
     dc0:	8f 4f       	sbci	r24, 0xFF	; 255
     dc2:	9f 4f       	sbci	r25, 0xFF	; 255
     dc4:	20 90 b6 04 	lds	r2, 0x04B6	; 0x8004b6 <dig_P1>
     dc8:	30 90 b7 04 	lds	r3, 0x04B7	; 0x8004b7 <dig_P1+0x1>
     dcc:	a2 2c       	mov	r10, r2
     dce:	b3 2c       	mov	r11, r3
     dd0:	c1 2c       	mov	r12, r1
     dd2:	d1 2c       	mov	r13, r1
     dd4:	e1 2c       	mov	r14, r1
     dd6:	f1 2c       	mov	r15, r1
     dd8:	00 e0       	ldi	r16, 0x00	; 0
     dda:	10 e0       	ldi	r17, 0x00	; 0
     ddc:	95 d6       	rcall	.+3370   	; 0x1b08 <__muldi3>
     dde:	01 e2       	ldi	r16, 0x21	; 33
     de0:	cd d7       	rcall	.+3994   	; 0x1d7c <__ashrdi3>
     de2:	29 87       	std	Y+9, r18	; 0x09
     de4:	3a 87       	std	Y+10, r19	; 0x0a
     de6:	4b 87       	std	Y+11, r20	; 0x0b
     de8:	45 2e       	mov	r4, r21
     dea:	56 2e       	mov	r5, r22
     dec:	7c 87       	std	Y+12, r23	; 0x0c
     dee:	38 2e       	mov	r3, r24
     df0:	29 2e       	mov	r2, r25
	if (var1 == 0)
     df2:	65 2d       	mov	r22, r5
     df4:	83 2d       	mov	r24, r3
     df6:	92 2d       	mov	r25, r2
     df8:	a0 e0       	ldi	r26, 0x00	; 0
     dfa:	f0 d7       	rcall	.+4064   	; 0x1ddc <__cmpdi2_s8>
     dfc:	09 f4       	brne	.+2      	; 0xe00 <BME280_compensate_P_int64+0x17a>
     dfe:	6c c1       	rjmp	.+728    	; 0x10d8 <BME280_compensate_P_int64+0x452>
//Output value of "24674867" represents 24674867/256 = 96386.2 Pa = 963.862 hPa
long BME280_compensate_P_int64(long adc_P)
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
     e00:	aa 8c       	ldd	r10, Y+26	; 0x1a
     e02:	1e 8d       	ldd	r17, Y+30	; 0x1e
     e04:	11 0f       	add	r17, r17
     e06:	11 0b       	sbc	r17, r17
     e08:	be 8c       	ldd	r11, Y+30	; 0x1e
     e0a:	c1 2e       	mov	r12, r17
     e0c:	d1 2e       	mov	r13, r17
     e0e:	e1 2e       	mov	r14, r17
     e10:	f1 2e       	mov	r15, r17
     e12:	01 2f       	mov	r16, r17
     e14:	2d 85       	ldd	r18, Y+13	; 0x0d
     e16:	3e 85       	ldd	r19, Y+14	; 0x0e
     e18:	4f 85       	ldd	r20, Y+15	; 0x0f
     e1a:	58 89       	ldd	r21, Y+16	; 0x10
     e1c:	69 89       	ldd	r22, Y+17	; 0x11
     e1e:	7a 89       	ldd	r23, Y+18	; 0x12
     e20:	8b 89       	ldd	r24, Y+19	; 0x13
     e22:	9c 89       	ldd	r25, Y+20	; 0x14
     e24:	71 d6       	rcall	.+3298   	; 0x1b08 <__muldi3>
     e26:	2d 87       	std	Y+13, r18	; 0x0d
     e28:	3e 87       	std	Y+14, r19	; 0x0e
     e2a:	64 2e       	mov	r6, r20
     e2c:	75 2e       	mov	r7, r21
     e2e:	86 2e       	mov	r8, r22
     e30:	97 2e       	mov	r9, r23
     e32:	88 8b       	std	Y+16, r24	; 0x10
     e34:	9f 87       	std	Y+15, r25	; 0x0f
	var2 = var2 + ((var1*(long)dig_P5)<<17);
     e36:	2b 8d       	ldd	r18, Y+27	; 0x1b
     e38:	9d 8d       	ldd	r25, Y+29	; 0x1d
     e3a:	99 0f       	add	r25, r25
     e3c:	99 0b       	sbc	r25, r25
     e3e:	a9 80       	ldd	r10, Y+1	; 0x01
     e40:	ba 80       	ldd	r11, Y+2	; 0x02
     e42:	cb 80       	ldd	r12, Y+3	; 0x03
     e44:	dc 80       	ldd	r13, Y+4	; 0x04
     e46:	ed 80       	ldd	r14, Y+5	; 0x05
     e48:	fe 2c       	mov	r15, r14
     e4a:	0e 2d       	mov	r16, r14
     e4c:	1e 2d       	mov	r17, r14
     e4e:	3d 8d       	ldd	r19, Y+29	; 0x1d
     e50:	49 2f       	mov	r20, r25
     e52:	59 2f       	mov	r21, r25
     e54:	69 2f       	mov	r22, r25
     e56:	79 2f       	mov	r23, r25
     e58:	89 2f       	mov	r24, r25
     e5a:	56 d6       	rcall	.+3244   	; 0x1b08 <__muldi3>
     e5c:	01 e1       	ldi	r16, 0x11	; 17
     e5e:	75 d7       	rcall	.+3818   	; 0x1d4a <__ashldi3>
     e60:	ad 84       	ldd	r10, Y+13	; 0x0d
     e62:	be 84       	ldd	r11, Y+14	; 0x0e
     e64:	c6 2c       	mov	r12, r6
     e66:	d7 2c       	mov	r13, r7
     e68:	e8 2c       	mov	r14, r8
     e6a:	f9 2c       	mov	r15, r9
     e6c:	08 89       	ldd	r16, Y+16	; 0x10
     e6e:	1f 85       	ldd	r17, Y+15	; 0x0f
     e70:	a3 d7       	rcall	.+3910   	; 0x1db8 <__adddi3>
     e72:	a2 2e       	mov	r10, r18
     e74:	b3 2e       	mov	r11, r19
     e76:	c4 2e       	mov	r12, r20
     e78:	d5 2e       	mov	r13, r21
     e7a:	e6 2e       	mov	r14, r22
     e7c:	f7 2e       	mov	r15, r23
     e7e:	e8 2f       	mov	r30, r24
     e80:	19 2f       	mov	r17, r25
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	a0 e1       	ldi	r26, 0x10	; 16
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	2e 89       	ldd	r18, Y+22	; 0x16
     e8c:	3f 89       	ldd	r19, Y+23	; 0x17
     e8e:	48 8d       	ldd	r20, Y+24	; 0x18
     e90:	59 8d       	ldd	r21, Y+25	; 0x19
     e92:	82 1b       	sub	r24, r18
     e94:	93 0b       	sbc	r25, r19
     e96:	a4 0b       	sbc	r26, r20
     e98:	b5 0b       	sbc	r27, r21
     e9a:	3c 01       	movw	r6, r24
     e9c:	4d 01       	movw	r8, r26
     e9e:	99 0c       	add	r9, r9
     ea0:	66 08       	sbc	r6, r6
     ea2:	76 2c       	mov	r7, r6
     ea4:	43 01       	movw	r8, r6
	p = (((p<<31)-var2)*3125)/var1;
     ea6:	28 2f       	mov	r18, r24
     ea8:	39 2f       	mov	r19, r25
     eaa:	4a 2f       	mov	r20, r26
     eac:	5b 2f       	mov	r21, r27
     eae:	66 2d       	mov	r22, r6
     eb0:	76 2d       	mov	r23, r6
     eb2:	86 2d       	mov	r24, r6
     eb4:	96 2d       	mov	r25, r6
     eb6:	0f e1       	ldi	r16, 0x1F	; 31
     eb8:	48 d7       	rcall	.+3728   	; 0x1d4a <__ashldi3>
     eba:	82 2e       	mov	r8, r18
     ebc:	93 2e       	mov	r9, r19
     ebe:	f4 2f       	mov	r31, r20
     ec0:	75 2e       	mov	r7, r21
     ec2:	b6 2f       	mov	r27, r22
     ec4:	a7 2f       	mov	r26, r23
     ec6:	68 2e       	mov	r6, r24
     ec8:	9d 83       	std	Y+5, r25	; 0x05
{
	long long var1, var2, p;
	var1 = ((long)t_fine)-128000;
	var2 = var1*var1*(long)dig_P6;
	var2 = var2 + ((var1*(long)dig_P5)<<17);
	var2 = var2 + (((long long)dig_P4)<<35);
     eca:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ecc:	9d 89       	ldd	r25, Y+21	; 0x15
     ece:	99 0f       	add	r25, r25
     ed0:	99 0b       	sbc	r25, r25
     ed2:	3d 89       	ldd	r19, Y+21	; 0x15
     ed4:	49 2f       	mov	r20, r25
     ed6:	59 2f       	mov	r21, r25
     ed8:	69 2f       	mov	r22, r25
     eda:	79 2f       	mov	r23, r25
     edc:	89 2f       	mov	r24, r25
     ede:	03 e2       	ldi	r16, 0x23	; 35
     ee0:	34 d7       	rcall	.+3688   	; 0x1d4a <__ashldi3>
     ee2:	0e 2f       	mov	r16, r30
     ee4:	69 d7       	rcall	.+3794   	; 0x1db8 <__adddi3>
     ee6:	a2 2e       	mov	r10, r18
     ee8:	b3 2e       	mov	r11, r19
     eea:	c4 2e       	mov	r12, r20
     eec:	d5 2e       	mov	r13, r21
     eee:	e6 2e       	mov	r14, r22
     ef0:	f7 2e       	mov	r15, r23
     ef2:	08 2f       	mov	r16, r24
     ef4:	19 2f       	mov	r17, r25
	if (var1 == 0)
	{
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
     ef6:	28 2d       	mov	r18, r8
     ef8:	39 2d       	mov	r19, r9
     efa:	4f 2f       	mov	r20, r31
     efc:	57 2d       	mov	r21, r7
     efe:	6b 2f       	mov	r22, r27
     f00:	7a 2f       	mov	r23, r26
     f02:	86 2d       	mov	r24, r6
     f04:	9d 81       	ldd	r25, Y+5	; 0x05
     f06:	61 d7       	rcall	.+3778   	; 0x1dca <__subdi3>
     f08:	82 2e       	mov	r8, r18
     f0a:	93 2e       	mov	r9, r19
     f0c:	49 83       	std	Y+1, r20	; 0x01
     f0e:	65 2e       	mov	r6, r21
     f10:	b6 2f       	mov	r27, r22
     f12:	a7 2f       	mov	r26, r23
     f14:	f8 2f       	mov	r31, r24
     f16:	e9 2f       	mov	r30, r25
     f18:	03 e0       	ldi	r16, 0x03	; 3
     f1a:	17 d7       	rcall	.+3630   	; 0x1d4a <__ashldi3>
     f1c:	a8 2c       	mov	r10, r8
     f1e:	b9 2c       	mov	r11, r9
     f20:	c9 80       	ldd	r12, Y+1	; 0x01
     f22:	d6 2c       	mov	r13, r6
     f24:	eb 2e       	mov	r14, r27
     f26:	fa 2e       	mov	r15, r26
     f28:	0f 2f       	mov	r16, r31
     f2a:	1e 2f       	mov	r17, r30
     f2c:	4e d7       	rcall	.+3740   	; 0x1dca <__subdi3>
     f2e:	a2 2e       	mov	r10, r18
     f30:	b3 2e       	mov	r11, r19
     f32:	c4 2e       	mov	r12, r20
     f34:	d5 2e       	mov	r13, r21
     f36:	e6 2e       	mov	r14, r22
     f38:	f7 2e       	mov	r15, r23
     f3a:	78 2e       	mov	r7, r24
     f3c:	19 2f       	mov	r17, r25
     f3e:	03 e0       	ldi	r16, 0x03	; 3
     f40:	04 d7       	rcall	.+3592   	; 0x1d4a <__ashldi3>
     f42:	07 2d       	mov	r16, r7
     f44:	42 d7       	rcall	.+3716   	; 0x1dca <__subdi3>
     f46:	03 e0       	ldi	r16, 0x03	; 3
     f48:	00 d7       	rcall	.+3584   	; 0x1d4a <__ashldi3>
     f4a:	a8 2c       	mov	r10, r8
     f4c:	b9 2c       	mov	r11, r9
     f4e:	c9 80       	ldd	r12, Y+1	; 0x01
     f50:	d6 2c       	mov	r13, r6
     f52:	eb 2e       	mov	r14, r27
     f54:	fa 2e       	mov	r15, r26
     f56:	0f 2f       	mov	r16, r31
     f58:	1e 2f       	mov	r17, r30
     f5a:	37 d7       	rcall	.+3694   	; 0x1dca <__subdi3>
     f5c:	02 e0       	ldi	r16, 0x02	; 2
     f5e:	f5 d6       	rcall	.+3562   	; 0x1d4a <__ashldi3>
     f60:	0f 2f       	mov	r16, r31
     f62:	33 d7       	rcall	.+3686   	; 0x1dca <__subdi3>
     f64:	01 e0       	ldi	r16, 0x01	; 1
     f66:	f1 d6       	rcall	.+3554   	; 0x1d4a <__ashldi3>
     f68:	0f 2f       	mov	r16, r31
     f6a:	2f d7       	rcall	.+3678   	; 0x1dca <__subdi3>
     f6c:	a9 84       	ldd	r10, Y+9	; 0x09
     f6e:	ba 84       	ldd	r11, Y+10	; 0x0a
     f70:	cb 84       	ldd	r12, Y+11	; 0x0b
     f72:	d4 2c       	mov	r13, r4
     f74:	e5 2c       	mov	r14, r5
     f76:	fc 84       	ldd	r15, Y+12	; 0x0c
     f78:	03 2d       	mov	r16, r3
     f7a:	12 2d       	mov	r17, r2
     f7c:	18 d6       	rcall	.+3120   	; 0x1bae <__divdi3>
     f7e:	2e 87       	std	Y+14, r18	; 0x0e
     f80:	3d 87       	std	Y+13, r19	; 0x0d
     f82:	49 83       	std	Y+1, r20	; 0x01
     f84:	5d 83       	std	Y+5, r21	; 0x05
     f86:	69 87       	std	Y+9, r22	; 0x09
     f88:	7a 87       	std	Y+10, r23	; 0x0a
     f8a:	8b 87       	std	Y+11, r24	; 0x0b
     f8c:	9c 87       	std	Y+12, r25	; 0x0c
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
     f8e:	0d e0       	ldi	r16, 0x0D	; 13
     f90:	f5 d6       	rcall	.+3562   	; 0x1d7c <__ashrdi3>
     f92:	82 2e       	mov	r8, r18
     f94:	93 2e       	mov	r9, r19
     f96:	74 2e       	mov	r7, r20
     f98:	65 2e       	mov	r6, r21
     f9a:	56 2e       	mov	r5, r22
     f9c:	47 2e       	mov	r4, r23
     f9e:	38 2e       	mov	r3, r24
     fa0:	29 2e       	mov	r2, r25
     fa2:	30 91 c1 04 	lds	r19, 0x04C1	; 0x8004c1 <dig_P9+0x1>
     fa6:	20 91 c0 04 	lds	r18, 0x04C0	; 0x8004c0 <dig_P9>
     faa:	93 2f       	mov	r25, r19
     fac:	99 0f       	add	r25, r25
     fae:	99 0b       	sbc	r25, r25
     fb0:	a8 2c       	mov	r10, r8
     fb2:	b9 2c       	mov	r11, r9
     fb4:	c7 2c       	mov	r12, r7
     fb6:	d6 2c       	mov	r13, r6
     fb8:	e5 2c       	mov	r14, r5
     fba:	f4 2c       	mov	r15, r4
     fbc:	03 2d       	mov	r16, r3
     fbe:	12 2d       	mov	r17, r2
     fc0:	49 2f       	mov	r20, r25
     fc2:	59 2f       	mov	r21, r25
     fc4:	69 2f       	mov	r22, r25
     fc6:	79 2f       	mov	r23, r25
     fc8:	89 2f       	mov	r24, r25
     fca:	9e d5       	rcall	.+2876   	; 0x1b08 <__muldi3>
     fcc:	a2 2e       	mov	r10, r18
     fce:	b3 2e       	mov	r11, r19
     fd0:	c4 2e       	mov	r12, r20
     fd2:	d5 2e       	mov	r13, r21
     fd4:	e6 2e       	mov	r14, r22
     fd6:	f7 2e       	mov	r15, r23
     fd8:	08 2f       	mov	r16, r24
     fda:	19 2f       	mov	r17, r25
     fdc:	28 2d       	mov	r18, r8
     fde:	39 2d       	mov	r19, r9
     fe0:	47 2d       	mov	r20, r7
     fe2:	56 2d       	mov	r21, r6
     fe4:	65 2d       	mov	r22, r5
     fe6:	74 2d       	mov	r23, r4
     fe8:	83 2d       	mov	r24, r3
     fea:	92 2d       	mov	r25, r2
     fec:	8d d5       	rcall	.+2842   	; 0x1b08 <__muldi3>
     fee:	09 e1       	ldi	r16, 0x19	; 25
     ff0:	c5 d6       	rcall	.+3466   	; 0x1d7c <__ashrdi3>
     ff2:	a2 2e       	mov	r10, r18
     ff4:	b3 2e       	mov	r11, r19
     ff6:	c4 2e       	mov	r12, r20
     ff8:	d5 2e       	mov	r13, r21
     ffa:	e6 2e       	mov	r14, r22
     ffc:	f7 2e       	mov	r15, r23
     ffe:	08 2f       	mov	r16, r24
    1000:	19 2f       	mov	r17, r25
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1002:	2e 85       	ldd	r18, Y+14	; 0x0e
    1004:	3d 85       	ldd	r19, Y+13	; 0x0d
    1006:	49 81       	ldd	r20, Y+1	; 0x01
    1008:	5d 81       	ldd	r21, Y+5	; 0x05
    100a:	69 85       	ldd	r22, Y+9	; 0x09
    100c:	7a 85       	ldd	r23, Y+10	; 0x0a
    100e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1010:	9c 85       	ldd	r25, Y+12	; 0x0c
    1012:	d2 d6       	rcall	.+3492   	; 0x1db8 <__adddi3>
    1014:	22 2e       	mov	r2, r18
    1016:	33 2e       	mov	r3, r19
    1018:	44 2e       	mov	r4, r20
    101a:	55 2e       	mov	r5, r21
    101c:	66 2e       	mov	r6, r22
    101e:	77 2e       	mov	r7, r23
    1020:	88 2e       	mov	r8, r24
    1022:	99 2e       	mov	r9, r25
		return 0;
	}
	p = 1048576 - adc_P;
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
    1024:	30 91 bb 04 	lds	r19, 0x04BB	; 0x8004bb <dig_P8+0x1>
    1028:	20 91 ba 04 	lds	r18, 0x04BA	; 0x8004ba <dig_P8>
    102c:	93 2f       	mov	r25, r19
    102e:	99 0f       	add	r25, r25
    1030:	99 0b       	sbc	r25, r25
    1032:	ae 84       	ldd	r10, Y+14	; 0x0e
    1034:	bd 84       	ldd	r11, Y+13	; 0x0d
    1036:	c9 80       	ldd	r12, Y+1	; 0x01
    1038:	dd 80       	ldd	r13, Y+5	; 0x05
    103a:	e9 84       	ldd	r14, Y+9	; 0x09
    103c:	fa 84       	ldd	r15, Y+10	; 0x0a
    103e:	0b 85       	ldd	r16, Y+11	; 0x0b
    1040:	1c 85       	ldd	r17, Y+12	; 0x0c
    1042:	49 2f       	mov	r20, r25
    1044:	59 2f       	mov	r21, r25
    1046:	69 2f       	mov	r22, r25
    1048:	79 2f       	mov	r23, r25
    104a:	89 2f       	mov	r24, r25
    104c:	5d d5       	rcall	.+2746   	; 0x1b08 <__muldi3>
    104e:	03 e1       	ldi	r16, 0x13	; 19
    1050:	95 d6       	rcall	.+3370   	; 0x1d7c <__ashrdi3>
    1052:	a2 2e       	mov	r10, r18
    1054:	b3 2e       	mov	r11, r19
    1056:	c4 2e       	mov	r12, r20
    1058:	d5 2e       	mov	r13, r21
    105a:	e6 2e       	mov	r14, r22
    105c:	f7 2e       	mov	r15, r23
    105e:	08 2f       	mov	r16, r24
    1060:	19 2f       	mov	r17, r25
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
    1062:	22 2d       	mov	r18, r2
    1064:	33 2d       	mov	r19, r3
    1066:	44 2d       	mov	r20, r4
    1068:	55 2d       	mov	r21, r5
    106a:	66 2d       	mov	r22, r6
    106c:	77 2d       	mov	r23, r7
    106e:	88 2d       	mov	r24, r8
    1070:	99 2d       	mov	r25, r9
    1072:	a2 d6       	rcall	.+3396   	; 0x1db8 <__adddi3>
    1074:	08 e0       	ldi	r16, 0x08	; 8
    1076:	82 d6       	rcall	.+3332   	; 0x1d7c <__ashrdi3>
    1078:	40 90 44 04 	lds	r4, 0x0444	; 0x800444 <dig_P7>
    107c:	50 90 45 04 	lds	r5, 0x0445	; 0x800445 <dig_P7+0x1>
    1080:	05 2c       	mov	r0, r5
    1082:	00 0c       	add	r0, r0
    1084:	66 08       	sbc	r6, r6
    1086:	77 08       	sbc	r7, r7
    1088:	44 0c       	add	r4, r4
    108a:	55 1c       	adc	r5, r5
    108c:	66 1c       	adc	r6, r6
    108e:	77 1c       	adc	r7, r7
    1090:	44 0c       	add	r4, r4
    1092:	55 1c       	adc	r5, r5
    1094:	66 1c       	adc	r6, r6
    1096:	77 1c       	adc	r7, r7
    1098:	44 0c       	add	r4, r4
    109a:	55 1c       	adc	r5, r5
    109c:	66 1c       	adc	r6, r6
    109e:	77 1c       	adc	r7, r7
    10a0:	44 0c       	add	r4, r4
    10a2:	55 1c       	adc	r5, r5
    10a4:	66 1c       	adc	r6, r6
    10a6:	77 1c       	adc	r7, r7
    10a8:	83 01       	movw	r16, r6
    10aa:	72 01       	movw	r14, r4
    10ac:	11 0f       	add	r17, r17
    10ae:	ee 08       	sbc	r14, r14
    10b0:	fe 2c       	mov	r15, r14
    10b2:	87 01       	movw	r16, r14
    10b4:	e9 82       	std	Y+1, r14	; 0x01
    10b6:	fa 82       	std	Y+2, r15	; 0x02
    10b8:	0b 83       	std	Y+3, r16	; 0x03
    10ba:	1c 83       	std	Y+4, r17	; 0x04
    10bc:	a4 2c       	mov	r10, r4
    10be:	b5 2c       	mov	r11, r5
    10c0:	c6 2c       	mov	r12, r6
    10c2:	d7 2c       	mov	r13, r7
    10c4:	e9 80       	ldd	r14, Y+1	; 0x01
    10c6:	fe 2c       	mov	r15, r14
    10c8:	0e 2d       	mov	r16, r14
    10ca:	1e 2d       	mov	r17, r14
    10cc:	75 d6       	rcall	.+3306   	; 0x1db8 <__adddi3>
	return(long)p;
    10ce:	62 2f       	mov	r22, r18
    10d0:	73 2f       	mov	r23, r19
    10d2:	84 2f       	mov	r24, r20
    10d4:	95 2f       	mov	r25, r21
    10d6:	04 c0       	rjmp	.+8      	; 0x10e0 <BME280_compensate_P_int64+0x45a>
	var2 = var2 + (((long long)dig_P4)<<35);
	var1 = ((var1*var1*(long)dig_P3)>>8)+((var1*(long)dig_P2)<<12);
	var1 = (((((long long)1)<<47)+var1))*((long long)dig_P1)>>33;
	if (var1 == 0)
	{
		return 0;
    10d8:	60 e0       	ldi	r22, 0x00	; 0
    10da:	70 e0       	ldi	r23, 0x00	; 0
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	90 e0       	ldi	r25, 0x00	; 0
	p = (((p<<31)-var2)*3125)/var1;
	var1 = (((long)dig_P9)*(p>>13)*(p>>13))>>25;
	var2 = (((long)dig_P8)*p)>>19;
	p = ((p+var1+var2)>>8)+(((long)dig_P7)<<4);
	return(long)p;
}
    10e0:	6e 96       	adiw	r28, 0x1e	; 30
    10e2:	0f b6       	in	r0, 0x3f	; 63
    10e4:	f8 94       	cli
    10e6:	de bf       	out	0x3e, r29	; 62
    10e8:	0f be       	out	0x3f, r0	; 63
    10ea:	cd bf       	out	0x3d, r28	; 61
    10ec:	df 91       	pop	r29
    10ee:	cf 91       	pop	r28
    10f0:	1f 91       	pop	r17
    10f2:	0f 91       	pop	r16
    10f4:	ff 90       	pop	r15
    10f6:	ef 90       	pop	r14
    10f8:	df 90       	pop	r13
    10fa:	cf 90       	pop	r12
    10fc:	bf 90       	pop	r11
    10fe:	af 90       	pop	r10
    1100:	9f 90       	pop	r9
    1102:	8f 90       	pop	r8
    1104:	7f 90       	pop	r7
    1106:	6f 90       	pop	r6
    1108:	5f 90       	pop	r5
    110a:	4f 90       	pop	r4
    110c:	3f 90       	pop	r3
    110e:	2f 90       	pop	r2
    1110:	08 95       	ret

00001112 <bme280_compensate_H_int32>:

// Returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits).
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
    1112:	2f 92       	push	r2
    1114:	3f 92       	push	r3
    1116:	4f 92       	push	r4
    1118:	5f 92       	push	r5
    111a:	6f 92       	push	r6
    111c:	7f 92       	push	r7
    111e:	8f 92       	push	r8
    1120:	9f 92       	push	r9
    1122:	af 92       	push	r10
    1124:	bf 92       	push	r11
    1126:	cf 92       	push	r12
    1128:	df 92       	push	r13
    112a:	ef 92       	push	r14
    112c:	ff 92       	push	r15
    112e:	0f 93       	push	r16
    1130:	1f 93       	push	r17
    1132:	cf 93       	push	r28
    1134:	df 93       	push	r29
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	67 97       	sbiw	r28, 0x17	; 23
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	f8 94       	cli
    1140:	de bf       	out	0x3e, r29	; 62
    1142:	0f be       	out	0x3f, r0	; 63
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	2b 01       	movw	r4, r22
    1148:	3c 01       	movw	r6, r24
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
    114a:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <t_fine>
    114e:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <t_fine+0x1>
    1152:	a0 91 ca 04 	lds	r26, 0x04CA	; 0x8004ca <t_fine+0x2>
    1156:	b0 91 cb 04 	lds	r27, 0x04CB	; 0x8004cb <t_fine+0x3>
    115a:	6c 01       	movw	r12, r24
    115c:	7d 01       	movw	r14, r26
    115e:	ff 0c       	add	r15, r15
    1160:	cc 08       	sbc	r12, r12
    1162:	dc 2c       	mov	r13, r12
    1164:	76 01       	movw	r14, r12
    1166:	28 2f       	mov	r18, r24
    1168:	39 2f       	mov	r19, r25
    116a:	4a 2f       	mov	r20, r26
    116c:	5b 2f       	mov	r21, r27
    116e:	6c 2d       	mov	r22, r12
    1170:	7c 2d       	mov	r23, r12
    1172:	8c 2d       	mov	r24, r12
    1174:	9c 2d       	mov	r25, r12
    1176:	3c 52       	subi	r19, 0x2C	; 44
    1178:	41 40       	sbci	r20, 0x01	; 1
    117a:	51 09       	sbc	r21, r1
    117c:	61 09       	sbc	r22, r1
    117e:	71 09       	sbc	r23, r1
    1180:	81 09       	sbc	r24, r1
    1182:	91 09       	sbc	r25, r1
    1184:	2f 8b       	std	Y+23, r18	; 0x17
    1186:	3e 8b       	std	Y+22, r19	; 0x16
    1188:	49 83       	std	Y+1, r20	; 0x01
    118a:	59 87       	std	Y+9, r21	; 0x09
    118c:	6a 87       	std	Y+10, r22	; 0x0a
    118e:	7b 87       	std	Y+11, r23	; 0x0b
    1190:	8c 87       	std	Y+12, r24	; 0x0c
    1192:	9d 87       	std	Y+13, r25	; 0x0d
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    1194:	03 2e       	mov	r0, r19
    1196:	3e e0       	ldi	r19, 0x0E	; 14
    1198:	44 0c       	add	r4, r4
    119a:	55 1c       	adc	r5, r5
    119c:	66 1c       	adc	r6, r6
    119e:	77 1c       	adc	r7, r7
    11a0:	3a 95       	dec	r19
    11a2:	d1 f7       	brne	.-12     	; 0x1198 <bme280_compensate_H_int32+0x86>
    11a4:	30 2d       	mov	r19, r0
    11a6:	53 01       	movw	r10, r6
    11a8:	42 01       	movw	r8, r4
    11aa:	bb 0c       	add	r11, r11
    11ac:	88 08       	sbc	r8, r8
    11ae:	98 2c       	mov	r9, r8
    11b0:	54 01       	movw	r10, r8
    11b2:	30 91 49 04 	lds	r19, 0x0449	; 0x800449 <dig_H4+0x1>
    11b6:	20 91 48 04 	lds	r18, 0x0448	; 0x800448 <dig_H4>
    11ba:	93 2f       	mov	r25, r19
    11bc:	99 0f       	add	r25, r25
    11be:	99 0b       	sbc	r25, r25
    11c0:	49 2f       	mov	r20, r25
    11c2:	59 2f       	mov	r21, r25
    11c4:	69 2f       	mov	r22, r25
    11c6:	79 2f       	mov	r23, r25
    11c8:	89 2f       	mov	r24, r25
    11ca:	04 e1       	ldi	r16, 0x14	; 20
    11cc:	be d5       	rcall	.+2940   	; 0x1d4a <__ashldi3>
    11ce:	f2 2f       	mov	r31, r18
    11d0:	e3 2f       	mov	r30, r19
    11d2:	c4 2e       	mov	r12, r20
    11d4:	d5 2e       	mov	r13, r21
    11d6:	e6 2e       	mov	r14, r22
    11d8:	f7 2e       	mov	r15, r23
    11da:	08 2f       	mov	r16, r24
    11dc:	19 2f       	mov	r17, r25
    11de:	24 2d       	mov	r18, r4
    11e0:	35 2d       	mov	r19, r5
    11e2:	46 2d       	mov	r20, r6
    11e4:	57 2d       	mov	r21, r7
    11e6:	68 2d       	mov	r22, r8
    11e8:	78 2d       	mov	r23, r8
    11ea:	88 2d       	mov	r24, r8
    11ec:	98 2d       	mov	r25, r8
    11ee:	af 2e       	mov	r10, r31
    11f0:	be 2e       	mov	r11, r30
    11f2:	eb d5       	rcall	.+3030   	; 0x1dca <__subdi3>
    11f4:	22 2e       	mov	r2, r18
    11f6:	33 2e       	mov	r3, r19
    11f8:	44 2e       	mov	r4, r20
    11fa:	55 2e       	mov	r5, r21
    11fc:	66 2e       	mov	r6, r22
    11fe:	77 2e       	mov	r7, r23
    1200:	88 2e       	mov	r8, r24
    1202:	99 2e       	mov	r9, r25
    1204:	30 91 bd 04 	lds	r19, 0x04BD	; 0x8004bd <dig_H5+0x1>
    1208:	20 91 bc 04 	lds	r18, 0x04BC	; 0x8004bc <dig_H5>
    120c:	93 2f       	mov	r25, r19
    120e:	99 0f       	add	r25, r25
    1210:	99 0b       	sbc	r25, r25
    1212:	af 88       	ldd	r10, Y+23	; 0x17
    1214:	be 88       	ldd	r11, Y+22	; 0x16
    1216:	c9 80       	ldd	r12, Y+1	; 0x01
    1218:	d9 84       	ldd	r13, Y+9	; 0x09
    121a:	ea 84       	ldd	r14, Y+10	; 0x0a
    121c:	fb 84       	ldd	r15, Y+11	; 0x0b
    121e:	0c 85       	ldd	r16, Y+12	; 0x0c
    1220:	1d 85       	ldd	r17, Y+13	; 0x0d
    1222:	49 2f       	mov	r20, r25
    1224:	59 2f       	mov	r21, r25
    1226:	69 2f       	mov	r22, r25
    1228:	79 2f       	mov	r23, r25
    122a:	89 2f       	mov	r24, r25
    122c:	6d d4       	rcall	.+2266   	; 0x1b08 <__muldi3>
    122e:	a2 2e       	mov	r10, r18
    1230:	b3 2e       	mov	r11, r19
    1232:	c4 2e       	mov	r12, r20
    1234:	d5 2e       	mov	r13, r21
    1236:	e6 2e       	mov	r14, r22
    1238:	f7 2e       	mov	r15, r23
    123a:	08 2f       	mov	r16, r24
    123c:	19 2f       	mov	r17, r25
    123e:	22 2d       	mov	r18, r2
    1240:	33 2d       	mov	r19, r3
    1242:	44 2d       	mov	r20, r4
    1244:	55 2d       	mov	r21, r5
    1246:	66 2d       	mov	r22, r6
    1248:	77 2d       	mov	r23, r7
    124a:	88 2d       	mov	r24, r8
    124c:	99 2d       	mov	r25, r9
    124e:	bd d5       	rcall	.+2938   	; 0x1dca <__subdi3>
    1250:	30 5c       	subi	r19, 0xC0	; 192
    1252:	4f 4f       	sbci	r20, 0xFF	; 255
    1254:	5f 4f       	sbci	r21, 0xFF	; 255
    1256:	6f 4f       	sbci	r22, 0xFF	; 255
    1258:	7f 4f       	sbci	r23, 0xFF	; 255
    125a:	8f 4f       	sbci	r24, 0xFF	; 255
    125c:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    125e:	0f e0       	ldi	r16, 0x0F	; 15
    1260:	8d d5       	rcall	.+2842   	; 0x1d7c <__ashrdi3>
    1262:	2e 87       	std	Y+14, r18	; 0x0e
    1264:	3f 87       	std	Y+15, r19	; 0x0f
    1266:	48 8b       	std	Y+16, r20	; 0x10
    1268:	59 8b       	std	Y+17, r21	; 0x11
    126a:	6a 8b       	std	Y+18, r22	; 0x12
    126c:	7b 8b       	std	Y+19, r23	; 0x13
    126e:	8c 8b       	std	Y+20, r24	; 0x14
    1270:	9d 8b       	std	Y+21, r25	; 0x15
    1272:	30 91 8a 04 	lds	r19, 0x048A	; 0x80048a <dig_H6+0x1>
    1276:	20 91 89 04 	lds	r18, 0x0489	; 0x800489 <dig_H6>
    127a:	93 2f       	mov	r25, r19
    127c:	99 0f       	add	r25, r25
    127e:	99 0b       	sbc	r25, r25
    1280:	af 88       	ldd	r10, Y+23	; 0x17
    1282:	be 88       	ldd	r11, Y+22	; 0x16
    1284:	c9 80       	ldd	r12, Y+1	; 0x01
    1286:	d9 84       	ldd	r13, Y+9	; 0x09
    1288:	ea 84       	ldd	r14, Y+10	; 0x0a
    128a:	fb 84       	ldd	r15, Y+11	; 0x0b
    128c:	0c 85       	ldd	r16, Y+12	; 0x0c
    128e:	1d 85       	ldd	r17, Y+13	; 0x0d
    1290:	49 2f       	mov	r20, r25
    1292:	59 2f       	mov	r21, r25
    1294:	69 2f       	mov	r22, r25
    1296:	79 2f       	mov	r23, r25
    1298:	89 2f       	mov	r24, r25
    129a:	36 d4       	rcall	.+2156   	; 0x1b08 <__muldi3>
    129c:	0a e0       	ldi	r16, 0x0A	; 10
    129e:	6e d5       	rcall	.+2780   	; 0x1d7c <__ashrdi3>
    12a0:	82 2e       	mov	r8, r18
    12a2:	93 2e       	mov	r9, r19
    12a4:	74 2e       	mov	r7, r20
    12a6:	65 2e       	mov	r6, r21
    12a8:	56 2e       	mov	r5, r22
    12aa:	47 2e       	mov	r4, r23
    12ac:	38 2e       	mov	r3, r24
    12ae:	29 2e       	mov	r2, r25
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12b0:	40 91 be 04 	lds	r20, 0x04BE	; 0x8004be <dig_H3>
    12b4:	50 91 bf 04 	lds	r21, 0x04BF	; 0x8004bf <dig_H3+0x1>
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12b8:	0c 85       	ldd	r16, Y+12	; 0x0c
    12ba:	24 2f       	mov	r18, r20
    12bc:	35 2f       	mov	r19, r21
    12be:	40 e0       	ldi	r20, 0x00	; 0
    12c0:	50 e0       	ldi	r21, 0x00	; 0
    12c2:	60 e0       	ldi	r22, 0x00	; 0
    12c4:	70 e0       	ldi	r23, 0x00	; 0
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	1e d4       	rcall	.+2108   	; 0x1b08 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    12cc:	0b e0       	ldi	r16, 0x0B	; 11
    12ce:	56 d5       	rcall	.+2732   	; 0x1d7c <__ashrdi3>
    12d0:	30 58       	subi	r19, 0x80	; 128
    12d2:	4f 4f       	sbci	r20, 0xFF	; 255
    12d4:	5f 4f       	sbci	r21, 0xFF	; 255
    12d6:	6f 4f       	sbci	r22, 0xFF	; 255
    12d8:	7f 4f       	sbci	r23, 0xFF	; 255
    12da:	8f 4f       	sbci	r24, 0xFF	; 255
    12dc:	9f 4f       	sbci	r25, 0xFF	; 255
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
    12de:	a2 2e       	mov	r10, r18
    12e0:	b3 2e       	mov	r11, r19
    12e2:	c4 2e       	mov	r12, r20
    12e4:	d5 2e       	mov	r13, r21
    12e6:	e6 2e       	mov	r14, r22
    12e8:	f7 2e       	mov	r15, r23
    12ea:	08 2f       	mov	r16, r24
    12ec:	19 2f       	mov	r17, r25
    12ee:	28 2d       	mov	r18, r8
    12f0:	39 2d       	mov	r19, r9
    12f2:	47 2d       	mov	r20, r7
    12f4:	56 2d       	mov	r21, r6
    12f6:	65 2d       	mov	r22, r5
    12f8:	74 2d       	mov	r23, r4
    12fa:	83 2d       	mov	r24, r3
    12fc:	92 2d       	mov	r25, r2
    12fe:	04 d4       	rcall	.+2056   	; 0x1b08 <__muldi3>
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    1300:	0a e0       	ldi	r16, 0x0A	; 10
    1302:	3c d5       	rcall	.+2680   	; 0x1d7c <__ashrdi3>
    1304:	40 5e       	subi	r20, 0xE0	; 224
    1306:	5f 4f       	sbci	r21, 0xFF	; 255
    1308:	6f 4f       	sbci	r22, 0xFF	; 255
    130a:	7f 4f       	sbci	r23, 0xFF	; 255
    130c:	8f 4f       	sbci	r24, 0xFF	; 255
    130e:	9f 4f       	sbci	r25, 0xFF	; 255
	((long long)dig_H2) + 8192) >> 14));
    1310:	b0 90 c7 04 	lds	r11, 0x04C7	; 0x8004c7 <dig_H2+0x1>
    1314:	a0 90 c6 04 	lds	r10, 0x04C6	; 0x8004c6 <dig_H2>
    1318:	1b 2d       	mov	r17, r11
    131a:	11 0f       	add	r17, r17
    131c:	11 0b       	sbc	r17, r17
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
    131e:	c1 2e       	mov	r12, r17
    1320:	d1 2e       	mov	r13, r17
    1322:	e1 2e       	mov	r14, r17
    1324:	f1 2e       	mov	r15, r17
    1326:	01 2f       	mov	r16, r17
    1328:	ef d3       	rcall	.+2014   	; 0x1b08 <__muldi3>
	((long long)dig_H2) + 8192) >> 14));
    132a:	30 5e       	subi	r19, 0xE0	; 224
    132c:	4f 4f       	sbci	r20, 0xFF	; 255
    132e:	5f 4f       	sbci	r21, 0xFF	; 255
    1330:	6f 4f       	sbci	r22, 0xFF	; 255
    1332:	7f 4f       	sbci	r23, 0xFF	; 255
    1334:	8f 4f       	sbci	r24, 0xFF	; 255
    1336:	9f 4f       	sbci	r25, 0xFF	; 255
    1338:	0e e0       	ldi	r16, 0x0E	; 14
    133a:	20 d5       	rcall	.+2624   	; 0x1d7c <__ashrdi3>
// Output value of ?47445? represents 47445/1024 = 46.333 %RH
long bme280_compensate_H_int32(long adc_H)
{
	long long v_x1_u32r;
	v_x1_u32r = (t_fine - ((long long)76800));
	v_x1_u32r = (((((adc_H << 14) - (((long long)dig_H4) << 20) - (((long long)dig_H5) * v_x1_u32r)) +
    133c:	a2 2e       	mov	r10, r18
    133e:	b3 2e       	mov	r11, r19
    1340:	c4 2e       	mov	r12, r20
    1342:	d5 2e       	mov	r13, r21
    1344:	e6 2e       	mov	r14, r22
    1346:	f7 2e       	mov	r15, r23
    1348:	08 2f       	mov	r16, r24
    134a:	19 2f       	mov	r17, r25
    134c:	2e 85       	ldd	r18, Y+14	; 0x0e
    134e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1350:	48 89       	ldd	r20, Y+16	; 0x10
    1352:	59 89       	ldd	r21, Y+17	; 0x11
    1354:	6a 89       	ldd	r22, Y+18	; 0x12
    1356:	7b 89       	ldd	r23, Y+19	; 0x13
    1358:	8c 89       	ldd	r24, Y+20	; 0x14
    135a:	9d 89       	ldd	r25, Y+21	; 0x15
    135c:	d5 d3       	rcall	.+1962   	; 0x1b08 <__muldi3>
    135e:	42 2e       	mov	r4, r18
    1360:	53 2e       	mov	r5, r19
    1362:	64 2e       	mov	r6, r20
    1364:	75 2e       	mov	r7, r21
    1366:	86 2e       	mov	r8, r22
    1368:	97 2e       	mov	r9, r23
    136a:	28 2e       	mov	r2, r24
    136c:	39 2e       	mov	r3, r25
	((long long)16384)) >> 15) * (((((((v_x1_u32r * ((long long)dig_H6)) >> 10) * (((v_x1_u32r *
	((long long)dig_H3)) >> 11) + ((long long)32768))) >> 10) + ((long long)2097152)) *
	((long long)dig_H2) + 8192) >> 14));
	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((long long)dig_H1)) >> 4));
    136e:	0f e0       	ldi	r16, 0x0F	; 15
    1370:	05 d5       	rcall	.+2570   	; 0x1d7c <__ashrdi3>
    1372:	a2 2e       	mov	r10, r18
    1374:	b3 2e       	mov	r11, r19
    1376:	c4 2e       	mov	r12, r20
    1378:	d5 2e       	mov	r13, r21
    137a:	e6 2e       	mov	r14, r22
    137c:	f7 2e       	mov	r15, r23
    137e:	08 2f       	mov	r16, r24
    1380:	19 2f       	mov	r17, r25
    1382:	c2 d3       	rcall	.+1924   	; 0x1b08 <__muldi3>
    1384:	07 e0       	ldi	r16, 0x07	; 7
    1386:	fa d4       	rcall	.+2548   	; 0x1d7c <__ashrdi3>
    1388:	e0 91 78 04 	lds	r30, 0x0478	; 0x800478 <dig_H1>
    138c:	f0 91 79 04 	lds	r31, 0x0479	; 0x800479 <dig_H1+0x1>
    1390:	5f 01       	movw	r10, r30
    1392:	c1 2c       	mov	r12, r1
    1394:	d1 2c       	mov	r13, r1
    1396:	e1 2c       	mov	r14, r1
    1398:	f1 2c       	mov	r15, r1
    139a:	87 01       	movw	r16, r14
    139c:	e9 83       	std	Y+1, r30	; 0x01
    139e:	ba 82       	std	Y+2, r11	; 0x02
    13a0:	cb 82       	std	Y+3, r12	; 0x03
    13a2:	dc 82       	std	Y+4, r13	; 0x04
    13a4:	ed 82       	std	Y+5, r14	; 0x05
    13a6:	fe 82       	std	Y+6, r15	; 0x06
    13a8:	0f 83       	std	Y+7, r16	; 0x07
    13aa:	18 87       	std	Y+8, r17	; 0x08
    13ac:	c1 2c       	mov	r12, r1
    13ae:	d1 2c       	mov	r13, r1
    13b0:	e1 2c       	mov	r14, r1
    13b2:	f1 2c       	mov	r15, r1
    13b4:	00 e0       	ldi	r16, 0x00	; 0
    13b6:	10 e0       	ldi	r17, 0x00	; 0
    13b8:	a7 d3       	rcall	.+1870   	; 0x1b08 <__muldi3>
    13ba:	04 e0       	ldi	r16, 0x04	; 4
    13bc:	df d4       	rcall	.+2494   	; 0x1d7c <__ashrdi3>
    13be:	a2 2e       	mov	r10, r18
    13c0:	b3 2e       	mov	r11, r19
    13c2:	c4 2e       	mov	r12, r20
    13c4:	d5 2e       	mov	r13, r21
    13c6:	e6 2e       	mov	r14, r22
    13c8:	f7 2e       	mov	r15, r23
    13ca:	08 2f       	mov	r16, r24
    13cc:	19 2f       	mov	r17, r25
    13ce:	24 2d       	mov	r18, r4
    13d0:	35 2d       	mov	r19, r5
    13d2:	46 2d       	mov	r20, r6
    13d4:	57 2d       	mov	r21, r7
    13d6:	68 2d       	mov	r22, r8
    13d8:	79 2d       	mov	r23, r9
    13da:	82 2d       	mov	r24, r2
    13dc:	93 2d       	mov	r25, r3
    13de:	f5 d4       	rcall	.+2538   	; 0x1dca <__subdi3>
	v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
    13e0:	f2 2e       	mov	r15, r18
    13e2:	03 2f       	mov	r16, r19
    13e4:	14 2f       	mov	r17, r20
    13e6:	65 2e       	mov	r6, r21
    13e8:	76 2e       	mov	r7, r22
    13ea:	b7 2f       	mov	r27, r23
    13ec:	f8 2f       	mov	r31, r24
    13ee:	e9 2f       	mov	r30, r25
    13f0:	a0 e0       	ldi	r26, 0x00	; 0
    13f2:	f4 d4       	rcall	.+2536   	; 0x1ddc <__cmpdi2_s8>
    13f4:	44 f4       	brge	.+16     	; 0x1406 <bme280_compensate_H_int32+0x2f4>
    13f6:	f1 2c       	mov	r15, r1
    13f8:	00 e0       	ldi	r16, 0x00	; 0
    13fa:	10 e0       	ldi	r17, 0x00	; 0
    13fc:	61 2c       	mov	r6, r1
    13fe:	71 2c       	mov	r7, r1
    1400:	b0 e0       	ldi	r27, 0x00	; 0
    1402:	f0 e0       	ldi	r31, 0x00	; 0
    1404:	e0 e0       	ldi	r30, 0x00	; 0
	v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
    1406:	8f 2c       	mov	r8, r15
    1408:	90 2e       	mov	r9, r16
    140a:	a1 2e       	mov	r10, r17
    140c:	b6 2c       	mov	r11, r6
    140e:	c7 2c       	mov	r12, r7
    1410:	db 2e       	mov	r13, r27
    1412:	ef 2e       	mov	r14, r31
    1414:	ae 2f       	mov	r26, r30
    1416:	2f 2d       	mov	r18, r15
    1418:	30 2f       	mov	r19, r16
    141a:	41 2f       	mov	r20, r17
    141c:	56 2d       	mov	r21, r6
    141e:	67 2d       	mov	r22, r7
    1420:	7b 2f       	mov	r23, r27
    1422:	8f 2f       	mov	r24, r31
    1424:	9e 2f       	mov	r25, r30
    1426:	21 15       	cp	r18, r1
    1428:	31 05       	cpc	r19, r1
    142a:	41 05       	cpc	r20, r1
    142c:	59 41       	sbci	r21, 0x19	; 25
    142e:	61 05       	cpc	r22, r1
    1430:	71 05       	cpc	r23, r1
    1432:	81 05       	cpc	r24, r1
    1434:	91 05       	cpc	r25, r1
    1436:	61 f0       	breq	.+24     	; 0x1450 <bme280_compensate_H_int32+0x33e>
    1438:	5c f0       	brlt	.+22     	; 0x1450 <bme280_compensate_H_int32+0x33e>
    143a:	81 2c       	mov	r8, r1
    143c:	91 2c       	mov	r9, r1
    143e:	a1 2c       	mov	r10, r1
    1440:	0f 2e       	mov	r0, r31
    1442:	f9 e1       	ldi	r31, 0x19	; 25
    1444:	bf 2e       	mov	r11, r31
    1446:	f0 2d       	mov	r31, r0
    1448:	c1 2c       	mov	r12, r1
    144a:	d1 2c       	mov	r13, r1
    144c:	e1 2c       	mov	r14, r1
    144e:	a0 e0       	ldi	r26, 0x00	; 0
	return (long)(v_x1_u32r>>12);
    1450:	28 2d       	mov	r18, r8
    1452:	39 2d       	mov	r19, r9
    1454:	4a 2d       	mov	r20, r10
    1456:	5b 2d       	mov	r21, r11
    1458:	6c 2d       	mov	r22, r12
    145a:	7d 2d       	mov	r23, r13
    145c:	8e 2d       	mov	r24, r14
    145e:	9a 2f       	mov	r25, r26
    1460:	0c e0       	ldi	r16, 0x0C	; 12
    1462:	8c d4       	rcall	.+2328   	; 0x1d7c <__ashrdi3>
    1464:	62 2f       	mov	r22, r18
    1466:	73 2f       	mov	r23, r19
    1468:	84 2f       	mov	r24, r20
    146a:	95 2f       	mov	r25, r21
}
    146c:	67 96       	adiw	r28, 0x17	; 23
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	de bf       	out	0x3e, r29	; 62
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	cd bf       	out	0x3d, r28	; 61
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	cf 90       	pop	r12
    1488:	bf 90       	pop	r11
    148a:	af 90       	pop	r10
    148c:	9f 90       	pop	r9
    148e:	8f 90       	pop	r8
    1490:	7f 90       	pop	r7
    1492:	6f 90       	pop	r6
    1494:	5f 90       	pop	r5
    1496:	4f 90       	pop	r4
    1498:	3f 90       	pop	r3
    149a:	2f 90       	pop	r2
    149c:	08 95       	ret

0000149e <main>:
	// *************************************************************************
	//        Initialization code & device configuration
	// *************************************************************************
 	//
	// Set the I/O pins
	canary_io_pin_initialization();
    149e:	0e 94 5f 01 	call	0x2be	; 0x2be <canary_io_pin_initialization>
	//
	// Set a simple counter for the loop below.  Debug only.
	seconds=0;
    14a2:	10 92 b5 04 	sts	0x04B5, r1	; 0x8004b5 <seconds+0x1>
    14a6:	10 92 b4 04 	sts	0x04B4, r1	; 0x8004b4 <seconds>
	ItsTime=0;
    14aa:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <ItsTime>
	//
	// set up our output for handling printf and string operations,,,
	stdout = &mystdout;
    14ae:	8b e2       	ldi	r24, 0x2B	; 43
    14b0:	91 e0       	ldi	r25, 0x01	; 1
    14b2:	90 93 cf 06 	sts	0x06CF, r25	; 0x8006cf <__iob+0x3>
    14b6:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <__iob+0x2>
	//
	// Initialize the timer counter 1 for 1Hz interrupt
	// This interrupt is only enabled if we don't have the GPS sensor connected.
	initialize_timer_counter_1();
    14ba:	1d d1       	rcall	.+570    	; 0x16f6 <initialize_timer_counter_1>
	//
	// Initialize our main communication to the ground (UART0)
	USART0_init(MYUBRR0);
    14bc:	81 e8       	ldi	r24, 0x81	; 129
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	17 d2       	rcall	.+1070   	; 0x18f0 <USART0_init>
	//
	// Initialize the connection to the GPS sensor (UART1)
	USART1_init(MYUBRR1);
    14c2:	81 e8       	ldi	r24, 0x81	; 129
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	8e d2       	rcall	.+1308   	; 0x19e4 <USART1_init>
	//
	// Initialize the TWI peripheral
	TWI_Master_Initialise();
    14c8:	36 d1       	rcall	.+620    	; 0x1736 <TWI_Master_Initialise>
	//
	// Initialize the Analog to digital hardware - and test the I/F.
	ADC_init();
    14ca:	0e 94 c1 00 	call	0x182	; 0x182 <ADC_init>
	//
	// initialize the gas sensors
	gas_sensors_init();
    14ce:	0e 94 ac 01 	call	0x358	; 0x358 <gas_sensors_init>
	//
	// Test our bad interrupt light...
	SetBit(PORTB, PORTB2);
    14d2:	2a 9a       	sbi	0x05, 2	; 5
	ClearBit(PORTB, PORTB2);
    14d4:	2a 98       	cbi	0x05, 2	; 5
	// 
	// Start all interrupts
	sei();
    14d6:	78 94       	sei
	//
	// Initialize and check the BME interface...
	bme280basic_init();
    14d8:	0c da       	rcall	.-3048   	; 0x8f2 <bme280basic_init>
	// Wait here for the start/standby button to be selected.. (PORTB pin 3).
	// Now call the routines to "kick off" the sensor measurements
	//
	// ===================================================
	// The next few lines are for debugging the (working at one time) UART0 routines...remove these lines once it is working again.
	USART0_putstring(String);
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	91 e0       	ldi	r25, 0x01	; 1
    14de:	45 d2       	rcall	.+1162   	; 0x196a <USART0_putstring>
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
			ItsTime = 0; 
			seconds++;
			printf("\nSeconds = %u", seconds);
    14e0:	0f 2e       	mov	r0, r31
    14e2:	fa e3       	ldi	r31, 0x3A	; 58
    14e4:	af 2e       	mov	r10, r31
    14e6:	f1 e0       	ldi	r31, 0x01	; 1
    14e8:	bf 2e       	mov	r11, r31
    14ea:	f0 2d       	mov	r31, r0
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    14ec:	0f 2e       	mov	r0, r31
    14ee:	fc ec       	ldi	r31, 0xCC	; 204
    14f0:	cf 2e       	mov	r12, r31
    14f2:	f5 e0       	ldi	r31, 0x05	; 5
    14f4:	df 2e       	mov	r13, r31
    14f6:	f0 2d       	mov	r31, r0
    14f8:	0f 2e       	mov	r0, r31
    14fa:	f8 e4       	ldi	r31, 0x48	; 72
    14fc:	ef 2e       	mov	r14, r31
    14fe:	f1 e0       	ldi	r31, 0x01	; 1
    1500:	ff 2e       	mov	r15, r31
    1502:	f0 2d       	mov	r31, r0
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
 			printf("LIDAR distance = %u", distance);
    1504:	0c e4       	ldi	r16, 0x4C	; 76
    1506:	11 e0       	ldi	r17, 0x01	; 1
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1508:	cf e1       	ldi	r28, 0x1F	; 31
    150a:	d3 e0       	ldi	r29, 0x03	; 3
    150c:	0f 2e       	mov	r0, r31
    150e:	f0 e6       	ldi	r31, 0x60	; 96
    1510:	8f 2e       	mov	r8, r31
    1512:	f1 e0       	ldi	r31, 0x01	; 1
    1514:	9f 2e       	mov	r9, r31
    1516:	f0 2d       	mov	r31, r0
 			printf("\nH = %u", raw_gas_vector[1]);
    1518:	0f 2e       	mov	r0, r31
    151a:	f9 e6       	ldi	r31, 0x69	; 105
    151c:	2f 2e       	mov	r2, r31
    151e:	f1 e0       	ldi	r31, 0x01	; 1
    1520:	3f 2e       	mov	r3, r31
    1522:	f0 2d       	mov	r31, r0
		// reached steady state...do nothing for the moment - wait for interrupts.
		// The variable ItsTime gets set to 1 every second using the 1Hz interrupt
		// When GPS is connected and enabled, then ItsTime gets set 
		// to 1 whenever we get a $GPGGA message from that sensor.
		///////////////////////////////////////////////////////////
		if (ItsTime == 1){ //wait for our 1Hz flag (from GPS or Interrupt)
    1524:	80 91 ff 02 	lds	r24, 0x02FF	; 0x8002ff <ItsTime>
    1528:	81 30       	cpi	r24, 0x01	; 1
    152a:	e1 f7       	brne	.-8      	; 0x1524 <main+0x86>
			ItsTime = 0; 
    152c:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <ItsTime>
			seconds++;
    1530:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <seconds>
    1534:	90 91 b5 04 	lds	r25, 0x04B5	; 0x8004b5 <seconds+0x1>
    1538:	01 96       	adiw	r24, 0x01	; 1
    153a:	90 93 b5 04 	sts	0x04B5, r25	; 0x8004b5 <seconds+0x1>
    153e:	80 93 b4 04 	sts	0x04B4, r24	; 0x8004b4 <seconds>
			printf("\nSeconds = %u", seconds);
    1542:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <seconds>
    1546:	90 91 b5 04 	lds	r25, 0x04B5	; 0x8004b5 <seconds+0x1>
    154a:	9f 93       	push	r25
    154c:	8f 93       	push	r24
    154e:	bf 92       	push	r11
    1550:	af 92       	push	r10
    1552:	5f d4       	rcall	.+2238   	; 0x1e12 <printf>
			// - do a blocking read of the sensor
			// - Send the data over the serial port
			// - go to the next sensor 
			//**********************************
			// The GPS message triggers the whole collection cycle, so we can send it now...
			printf("\n%s",messageWant);
    1554:	df 92       	push	r13
    1556:	cf 92       	push	r12
    1558:	ff 92       	push	r15
    155a:	ef 92       	push	r14
    155c:	5a d4       	rcall	.+2228   	; 0x1e12 <printf>
			// Now we want to read each sensor - and send out the data,
			// each time through this loop.  Comment out the code you
			// don't want to use when debugging the code you are adding... 
			//============================
			 //Now test reading the LIDAR interface
 			distance = LIDAR_distance();
    155e:	1b d8       	rcall	.-4042   	; 0x596 <LIDAR_distance>
    1560:	80 93 1a 03 	sts	0x031A, r24	; 0x80031a <distance>
    1564:	90 93 1b 03 	sts	0x031B, r25	; 0x80031b <distance+0x1>
 			printf("LIDAR distance = %u", distance);
    1568:	9f 93       	push	r25
    156a:	8f 93       	push	r24
    156c:	1f 93       	push	r17
    156e:	0f 93       	push	r16
    1570:	50 d4       	rcall	.+2208   	; 0x1e12 <printf>
// 				}
// 			}
// 			printf("Z");
			//============================
			// Now test the gas sensor interface...
			start_gas_sensor_read();
    1572:	0e 94 2b 02 	call	0x456	; 0x456 <start_gas_sensor_read>
//  			printf("\nCarbon Monoxide = %u", raw_gas_vector[0]);
//  			printf("\nHydrogen = %u", raw_gas_vector[1]);
//  			printf("\nAmmonia = %u", raw_gas_vector[2]);
//  			printf("\nMethane = %u", raw_gas_vector[3]);
//  			printf("\nOzone = %u\n", raw_gas_vector[4]);
 			printf("\nCO = %u", raw_gas_vector[0]);
    1576:	89 81       	ldd	r24, Y+1	; 0x01
    1578:	8f 93       	push	r24
    157a:	88 81       	ld	r24, Y
    157c:	8f 93       	push	r24
    157e:	9f 92       	push	r9
    1580:	8f 92       	push	r8
    1582:	47 d4       	rcall	.+2190   	; 0x1e12 <printf>
 			printf("\nH = %u", raw_gas_vector[1]);
    1584:	8b 81       	ldd	r24, Y+3	; 0x03
    1586:	8f 93       	push	r24
    1588:	8a 81       	ldd	r24, Y+2	; 0x02
    158a:	8f 93       	push	r24
    158c:	3f 92       	push	r3
    158e:	2f 92       	push	r2
    1590:	40 d4       	rcall	.+2176   	; 0x1e12 <printf>
 			printf("\nNA = %u", raw_gas_vector[2]);
    1592:	8d 81       	ldd	r24, Y+5	; 0x05
    1594:	8f 93       	push	r24
    1596:	8c 81       	ldd	r24, Y+4	; 0x04
    1598:	8f 93       	push	r24
    159a:	a1 e7       	ldi	r26, 0x71	; 113
    159c:	b1 e0       	ldi	r27, 0x01	; 1
    159e:	bf 93       	push	r27
    15a0:	af 93       	push	r26
    15a2:	37 d4       	rcall	.+2158   	; 0x1e12 <printf>
 			printf("\nCH4 = %u", raw_gas_vector[3]);
    15a4:	8f 81       	ldd	r24, Y+7	; 0x07
    15a6:	8f 93       	push	r24
    15a8:	8e 81       	ldd	r24, Y+6	; 0x06
    15aa:	8f 93       	push	r24
    15ac:	aa e7       	ldi	r26, 0x7A	; 122
    15ae:	b1 e0       	ldi	r27, 0x01	; 1
    15b0:	bf 93       	push	r27
    15b2:	af 93       	push	r26
    15b4:	2e d4       	rcall	.+2140   	; 0x1e12 <printf>
 			printf("\nO3 = %u", raw_gas_vector[4]);
    15b6:	89 85       	ldd	r24, Y+9	; 0x09
    15b8:	8f 93       	push	r24
    15ba:	88 85       	ldd	r24, Y+8	; 0x08
    15bc:	8f 93       	push	r24
    15be:	a4 e8       	ldi	r26, 0x84	; 132
    15c0:	b1 e0       	ldi	r27, 0x01	; 1
    15c2:	bf 93       	push	r27
    15c4:	af 93       	push	r26
    15c6:	25 d4       	rcall	.+2122   	; 0x1e12 <printf>
			while(UART0TransmitCompleteFlag != 0) {}
			//
			//============================
			// Now read the BME interface...
 			bme280basic_bulk_data_read();
    15c8:	ad b7       	in	r26, 0x3d	; 61
    15ca:	be b7       	in	r27, 0x3e	; 62
    15cc:	90 96       	adiw	r26, 0x20	; 32
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	be bf       	out	0x3e, r27	; 62
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	ad bf       	out	0x3d, r26	; 61
    15d8:	e8 d9       	rcall	.-3120   	; 0x9aa <bme280basic_bulk_data_read>
 			tempCelsius = BME280_compensate_T_int32(rawTemp);
    15da:	60 91 7a 04 	lds	r22, 0x047A	; 0x80047a <rawTemp>
    15de:	70 91 7b 04 	lds	r23, 0x047B	; 0x80047b <rawTemp+0x1>
    15e2:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <rawTemp+0x2>
    15e6:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <rawTemp+0x3>
    15ea:	c2 da       	rcall	.-2684   	; 0xb70 <BME280_compensate_T_int32>
    15ec:	60 93 74 04 	sts	0x0474, r22	; 0x800474 <tempCelsius>
    15f0:	70 93 75 04 	sts	0x0475, r23	; 0x800475 <tempCelsius+0x1>
    15f4:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <tempCelsius+0x2>
    15f8:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <tempCelsius+0x3>
// 			sprintf(temperatureBuf, "%lu", tempCelsius);
  			printf("\nCelsius = %lu", tempCelsius);
    15fc:	9f 93       	push	r25
    15fe:	8f 93       	push	r24
    1600:	7f 93       	push	r23
    1602:	6f 93       	push	r22
    1604:	ad e8       	ldi	r26, 0x8D	; 141
    1606:	b1 e0       	ldi	r27, 0x01	; 1
    1608:	bf 93       	push	r27
    160a:	af 93       	push	r26
    160c:	02 d4       	rcall	.+2052   	; 0x1e12 <printf>
 			pressure = BME280_compensate_P_int64(rawPress);
    160e:	60 91 92 04 	lds	r22, 0x0492	; 0x800492 <rawPress>
    1612:	70 91 93 04 	lds	r23, 0x0493	; 0x800493 <rawPress+0x1>
    1616:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <rawPress+0x2>
    161a:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <rawPress+0x3>
    161e:	33 db       	rcall	.-2458   	; 0xc86 <BME280_compensate_P_int64>
    1620:	60 93 83 04 	sts	0x0483, r22	; 0x800483 <pressure>
    1624:	70 93 84 04 	sts	0x0484, r23	; 0x800484 <pressure+0x1>
    1628:	80 93 85 04 	sts	0x0485, r24	; 0x800485 <pressure+0x2>
    162c:	90 93 86 04 	sts	0x0486, r25	; 0x800486 <pressure+0x3>
 			printf("\nPressure in Pa = %lu", pressure>>8);
    1630:	bb 27       	eor	r27, r27
    1632:	97 fd       	sbrc	r25, 7
    1634:	ba 95       	dec	r27
    1636:	a9 2f       	mov	r26, r25
    1638:	98 2f       	mov	r25, r24
    163a:	87 2f       	mov	r24, r23
    163c:	bf 93       	push	r27
    163e:	af 93       	push	r26
    1640:	9f 93       	push	r25
    1642:	8f 93       	push	r24
    1644:	ac e9       	ldi	r26, 0x9C	; 156
    1646:	b1 e0       	ldi	r27, 0x01	; 1
    1648:	bf 93       	push	r27
    164a:	af 93       	push	r26
    164c:	e2 d3       	rcall	.+1988   	; 0x1e12 <printf>
 			humidity = bme280_compensate_H_int32(rawHum);
    164e:	60 91 96 04 	lds	r22, 0x0496	; 0x800496 <rawHum>
    1652:	70 91 97 04 	lds	r23, 0x0497	; 0x800497 <rawHum+0x1>
    1656:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <rawHum+0x2>
    165a:	90 91 99 04 	lds	r25, 0x0499	; 0x800499 <rawHum+0x3>
    165e:	59 dd       	rcall	.-1358   	; 0x1112 <bme280_compensate_H_int32>
    1660:	2b 01       	movw	r4, r22
    1662:	3c 01       	movw	r6, r24
    1664:	60 93 8b 04 	sts	0x048B, r22	; 0x80048b <humidity>
    1668:	70 93 8c 04 	sts	0x048C, r23	; 0x80048c <humidity+0x1>
    166c:	80 93 8d 04 	sts	0x048D, r24	; 0x80048d <humidity+0x2>
    1670:	90 93 8e 04 	sts	0x048E, r25	; 0x80048e <humidity+0x3>
 			printf("\nHumidity%% = %lu.%lu\n", humidity>>10, ((humidity*1000)>>10));
    1674:	a8 ee       	ldi	r26, 0xE8	; 232
    1676:	b3 e0       	ldi	r27, 0x03	; 3
    1678:	9b 01       	movw	r18, r22
    167a:	ac 01       	movw	r20, r24
    167c:	35 d2       	rcall	.+1130   	; 0x1ae8 <__muluhisi3>
    167e:	dc 01       	movw	r26, r24
    1680:	cb 01       	movw	r24, r22
    1682:	07 2e       	mov	r0, r23
    1684:	7a e0       	ldi	r23, 0x0A	; 10
    1686:	b5 95       	asr	r27
    1688:	a7 95       	ror	r26
    168a:	97 95       	ror	r25
    168c:	87 95       	ror	r24
    168e:	7a 95       	dec	r23
    1690:	d1 f7       	brne	.-12     	; 0x1686 <main+0x1e8>
    1692:	70 2d       	mov	r23, r0
    1694:	bf 93       	push	r27
    1696:	af 93       	push	r26
    1698:	9f 93       	push	r25
    169a:	8f 93       	push	r24
    169c:	d3 01       	movw	r26, r6
    169e:	c2 01       	movw	r24, r4
    16a0:	07 2e       	mov	r0, r23
    16a2:	7a e0       	ldi	r23, 0x0A	; 10
    16a4:	b5 95       	asr	r27
    16a6:	a7 95       	ror	r26
    16a8:	97 95       	ror	r25
    16aa:	87 95       	ror	r24
    16ac:	7a 95       	dec	r23
    16ae:	d1 f7       	brne	.-12     	; 0x16a4 <main+0x206>
    16b0:	70 2d       	mov	r23, r0
    16b2:	bf 93       	push	r27
    16b4:	af 93       	push	r26
    16b6:	9f 93       	push	r25
    16b8:	8f 93       	push	r24
    16ba:	a2 eb       	ldi	r26, 0xB2	; 178
    16bc:	b1 e0       	ldi	r27, 0x01	; 1
    16be:	bf 93       	push	r27
    16c0:	af 93       	push	r26
    16c2:	a7 d3       	rcall	.+1870   	; 0x1e12 <printf>
    16c4:	ad b7       	in	r26, 0x3d	; 61
    16c6:	be b7       	in	r27, 0x3e	; 62
    16c8:	56 96       	adiw	r26, 0x16	; 22
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	be bf       	out	0x3e, r27	; 62
    16d0:	0f be       	out	0x3f, r0	; 63
    16d2:	ad bf       	out	0x3d, r26	; 61
			while(UART0TransmitCompleteFlag != 0) {}
// 			printf("\n BME message = http://canary.chordsrt.com/measurements/url_create?instrument_id=1&temp=%.5s.%.5s&pres=%lu&hum=%lu&key=4e6fba7420ec9e881f510bcddb%.3s:%.4s:%.3s", temp, temp+2, pressure, humidity, time, time+2, time+4); //need key
			//
			//============================
			//re-enable the GPS receiver & interrupt after processing all sensor data
			UCSR1B |= ((1<<RXCIE1)|(1<<RXEN1));
    16d4:	e9 ec       	ldi	r30, 0xC9	; 201
    16d6:	f0 e0       	ldi	r31, 0x00	; 0
    16d8:	80 81       	ld	r24, Z
    16da:	80 69       	ori	r24, 0x90	; 144
    16dc:	80 83       	st	Z, r24
    16de:	22 cf       	rjmp	.-444    	; 0x1524 <main+0x86>

000016e0 <__vector_default>:
						Interrupt Service Routines
*********************************************************************************
********************************************************************************/

ISR(BADISR_vect)
{
    16e0:	1f 92       	push	r1
    16e2:	0f 92       	push	r0
    16e4:	0f b6       	in	r0, 0x3f	; 63
    16e6:	0f 92       	push	r0
    16e8:	11 24       	eor	r1, r1
	// Code should never reach this point.  This is a bad interrupt trap.
	SetBit(PORTB, PORTB2);
    16ea:	2a 9a       	sbi	0x05, 2	; 5
    16ec:	0f 90       	pop	r0
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	0f 90       	pop	r0
    16f2:	1f 90       	pop	r1
    16f4:	18 95       	reti

000016f6 <initialize_timer_counter_1>:
	Not using any of the other compare features, so all other CR bits are 0
	Finally, we have to enable the interrupt vector on compare register A
	TCCR1A = 0; Control Register A is reset to 0x00 on startup. */
	//  
	// Set the WGM mode and prescaler select in control register B
	TCCR1B = ((1<<WGM12) | (1<<CS12) | (1<<CS10));
    16f6:	8d e0       	ldi	r24, 0x0D	; 13
    16f8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	// TCCR1C = 0; Control Register C is reset to 0x00 on startup.
	// Now we need to enter out TOP value in OCR1A
	OCR1A = 19530;
    16fc:	8a e4       	ldi	r24, 0x4A	; 74
    16fe:	9c e4       	ldi	r25, 0x4C	; 76
    1700:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1704:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    1708:	08 95       	ret

0000170a <__vector_16>:
*********************************************************************************
********************************************************************************/


// 100Hz timer interrupt generated by OC0A and used by the FATFS code.
EMPTY_INTERRUPT(TIMER0_COMPA_vect);
    170a:	18 95       	reti

0000170c <__vector_13>:
// }



ISR(TIMER1_COMPA_vect)
{
    170c:	1f 92       	push	r1
    170e:	0f 92       	push	r0
    1710:	0f b6       	in	r0, 0x3f	; 63
    1712:	0f 92       	push	r0
    1714:	11 24       	eor	r1, r1
    1716:	8f 93       	push	r24
    1718:	9f 93       	push	r25
	ToggleBit(PORTB, PORTB1); //for now, just toggle the green status LED
    171a:	95 b1       	in	r25, 0x05	; 5
    171c:	82 e0       	ldi	r24, 0x02	; 2
    171e:	89 27       	eor	r24, r25
    1720:	85 b9       	out	0x05, r24	; 5
	ItsTime = 1;
    1722:	81 e0       	ldi	r24, 0x01	; 1
    1724:	80 93 ff 02 	sts	0x02FF, r24	; 0x8002ff <ItsTime>
}
    1728:	9f 91       	pop	r25
    172a:	8f 91       	pop	r24
    172c:	0f 90       	pop	r0
    172e:	0f be       	out	0x3f, r0	; 63
    1730:	0f 90       	pop	r0
    1732:	1f 90       	pop	r1
    1734:	18 95       	reti

00001736 <TWI_Master_Initialise>:
void TWI_Start_Transceiver( void )
{
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
  TWI_statusReg.all = 0;      
  TWI_state         = TWI_NO_STATE ;
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1736:	81 e1       	ldi	r24, 0x11	; 17
    1738:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    173c:	8f ef       	ldi	r24, 0xFF	; 255
    173e:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    1742:	84 e0       	ldi	r24, 0x04	; 4
    1744:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1748:	08 95       	ret

0000174a <TWI_Transceiver_Busy>:
    174a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    174e:	81 78       	andi	r24, 0x81	; 129
    1750:	08 95       	ret

00001752 <TWI_Start_Transceiver_With_Data>:
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ec 01       	movw	r28, r24
    1758:	ec eb       	ldi	r30, 0xBC	; 188
    175a:	f0 e0       	ldi	r31, 0x00	; 0
    175c:	90 81       	ld	r25, Z
    175e:	91 78       	andi	r25, 0x81	; 129
    1760:	e9 f7       	brne	.-6      	; 0x175c <TWI_Start_Transceiver_With_Data+0xa>
    1762:	60 93 d0 01 	sts	0x01D0, r22	; 0x8001d0 <TWI_msgSize>
    1766:	88 81       	ld	r24, Y
    1768:	80 93 d1 01 	sts	0x01D1, r24	; 0x8001d1 <TWI_buf>
    176c:	80 fd       	sbrc	r24, 0
    176e:	12 c0       	rjmp	.+36     	; 0x1794 <TWI_Start_Transceiver_With_Data+0x42>
    1770:	62 30       	cpi	r22, 0x02	; 2
    1772:	80 f0       	brcs	.+32     	; 0x1794 <TWI_Start_Transceiver_With_Data+0x42>
    1774:	fe 01       	movw	r30, r28
    1776:	31 96       	adiw	r30, 0x01	; 1
    1778:	a2 ed       	ldi	r26, 0xD2	; 210
    177a:	b1 e0       	ldi	r27, 0x01	; 1
    177c:	62 50       	subi	r22, 0x02	; 2
    177e:	26 2f       	mov	r18, r22
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	2e 5f       	subi	r18, 0xFE	; 254
    1784:	3f 4f       	sbci	r19, 0xFF	; 255
    1786:	2c 0f       	add	r18, r28
    1788:	3d 1f       	adc	r19, r29
    178a:	91 91       	ld	r25, Z+
    178c:	9d 93       	st	X+, r25
    178e:	e2 17       	cp	r30, r18
    1790:	f3 07       	cpc	r31, r19
    1792:	d9 f7       	brne	.-10     	; 0x178a <TWI_Start_Transceiver_With_Data+0x38>
    1794:	10 92 cf 01 	sts	0x01CF, r1	; 0x8001cf <TWI_statusReg>
    1798:	88 ef       	ldi	r24, 0xF8	; 248
    179a:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
    179e:	85 ea       	ldi	r24, 0xA5	; 165
    17a0:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    17a4:	df 91       	pop	r29
    17a6:	cf 91       	pop	r28
    17a8:	08 95       	ret

000017aa <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    17aa:	ac 01       	movw	r20, r24
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
  return ( TWCR & ((1<<TWIE)|(1<<TWINT)));                  // IF TWI Interrupt is enabled then the Transceiver is busy
    17ac:	ec eb       	ldi	r30, 0xBC	; 188
    17ae:	f0 e0       	ldi	r31, 0x00	; 0
    17b0:	90 81       	ld	r25, Z
    17b2:	91 78       	andi	r25, 0x81	; 129
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    17b4:	e9 f7       	brne	.-6      	; 0x17b0 <TWI_Get_Data_From_Transceiver+0x6>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    17b6:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    17ba:	80 ff       	sbrs	r24, 0
    17bc:	11 c0       	rjmp	.+34     	; 0x17e0 <TWI_Get_Data_From_Transceiver+0x36>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    17be:	66 23       	and	r22, r22
    17c0:	79 f0       	breq	.+30     	; 0x17e0 <TWI_Get_Data_From_Transceiver+0x36>
    17c2:	a1 ed       	ldi	r26, 0xD1	; 209
    17c4:	b1 e0       	ldi	r27, 0x01	; 1
    17c6:	fa 01       	movw	r30, r20
    17c8:	61 50       	subi	r22, 0x01	; 1
    17ca:	26 2f       	mov	r18, r22
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	2f 5f       	subi	r18, 0xFF	; 255
    17d0:	3f 4f       	sbci	r19, 0xFF	; 255
    17d2:	24 0f       	add	r18, r20
    17d4:	35 1f       	adc	r19, r21
    {
      msg[ i ] = TWI_buf[ i ];
    17d6:	9d 91       	ld	r25, X+
    17d8:	91 93       	st	Z+, r25

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    17da:	e2 17       	cp	r30, r18
    17dc:	f3 07       	cpc	r31, r19
    17de:	d9 f7       	brne	.-10     	; 0x17d6 <TWI_Get_Data_From_Transceiver+0x2c>
    {
      msg[ i ] = TWI_buf[ i ];
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
    17e0:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
}
    17e4:	81 70       	andi	r24, 0x01	; 1
    17e6:	08 95       	ret

000017e8 <__vector_26>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
    17e8:	1f 92       	push	r1
    17ea:	0f 92       	push	r0
    17ec:	0f b6       	in	r0, 0x3f	; 63
    17ee:	0f 92       	push	r0
    17f0:	11 24       	eor	r1, r1
    17f2:	0b b6       	in	r0, 0x3b	; 59
    17f4:	0f 92       	push	r0
    17f6:	2f 93       	push	r18
    17f8:	3f 93       	push	r19
    17fa:	8f 93       	push	r24
    17fc:	9f 93       	push	r25
    17fe:	af 93       	push	r26
    1800:	bf 93       	push	r27
    1802:	ef 93       	push	r30
    1804:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1806:	e0 91 b9 00 	lds	r30, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    180a:	8e 2f       	mov	r24, r30
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	fc 01       	movw	r30, r24
    1810:	38 97       	sbiw	r30, 0x08	; 8
    1812:	e1 35       	cpi	r30, 0x51	; 81
    1814:	f1 05       	cpc	r31, r1
    1816:	08 f0       	brcs	.+2      	; 0x181a <__vector_26+0x32>
    1818:	55 c0       	rjmp	.+170    	; 0x18c4 <__vector_26+0xdc>
    181a:	ea 5b       	subi	r30, 0xBA	; 186
    181c:	ff 4f       	sbci	r31, 0xFF	; 255
    181e:	5b c1       	rjmp	.+694    	; 0x1ad6 <__tablejump2__>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
    1820:	10 92 ce 01 	sts	0x01CE, r1	; 0x8001ce <TWI_bufPtr.1555>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
    1824:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    1828:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    182c:	e8 17       	cp	r30, r24
    182e:	70 f4       	brcc	.+28     	; 0x184c <__vector_26+0x64>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	8e 0f       	add	r24, r30
    1834:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1555>
    1838:	f0 e0       	ldi	r31, 0x00	; 0
    183a:	ef 52       	subi	r30, 0x2F	; 47
    183c:	fe 4f       	sbci	r31, 0xFE	; 254
    183e:	80 81       	ld	r24, Z
    1840:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1844:	85 e8       	ldi	r24, 0x85	; 133
    1846:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    184a:	43 c0       	rjmp	.+134    	; 0x18d2 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to send byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
               (0<<TWWC);                                 //  
      }else                    // Send STOP after last byte
      {
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    184c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    1850:	81 60       	ori	r24, 0x01	; 1
    1852:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1856:	84 e9       	ldi	r24, 0x94	; 148
    1858:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    185c:	3a c0       	rjmp	.+116    	; 0x18d2 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
    185e:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	8e 0f       	add	r24, r30
    1866:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <TWI_bufPtr.1555>
    186a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    186e:	f0 e0       	ldi	r31, 0x00	; 0
    1870:	ef 52       	subi	r30, 0x2F	; 47
    1872:	fe 4f       	sbci	r31, 0xFE	; 254
    1874:	80 83       	st	Z, r24
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1876:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    187a:	30 e0       	ldi	r19, 0x00	; 0
    187c:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <TWI_msgSize>
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	01 97       	sbiw	r24, 0x01	; 1
    1884:	28 17       	cp	r18, r24
    1886:	39 07       	cpc	r19, r25
    1888:	24 f4       	brge	.+8      	; 0x1892 <__vector_26+0xaa>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    188a:	85 ec       	ldi	r24, 0xC5	; 197
    188c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1890:	20 c0       	rjmp	.+64     	; 0x18d2 <__vector_26+0xea>
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
               (0<<TWWC);                                 //  
      }else                    // Send NACK after next reception
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1892:	85 e8       	ldi	r24, 0x85	; 133
    1894:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    1898:	1c c0       	rjmp	.+56     	; 0x18d2 <__vector_26+0xea>
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
    189a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
    189e:	e0 91 ce 01 	lds	r30, 0x01CE	; 0x8001ce <TWI_bufPtr.1555>
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	ef 52       	subi	r30, 0x2F	; 47
    18a6:	fe 4f       	sbci	r31, 0xFE	; 254
    18a8:	80 83       	st	Z, r24
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    18aa:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <TWI_statusReg>
    18ae:	81 60       	ori	r24, 0x01	; 1
    18b0:	80 93 cf 01 	sts	0x01CF, r24	; 0x8001cf <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18b4:	84 e9       	ldi	r24, 0x94	; 148
    18b6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
    18ba:	0b c0       	rjmp	.+22     	; 0x18d2 <__vector_26+0xea>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    18bc:	85 ea       	ldi	r24, 0xA5	; 165
    18be:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
    18c2:	07 c0       	rjmp	.+14     	; 0x18d2 <__vector_26+0xea>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    18c4:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    18c8:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    18cc:	84 e0       	ldi	r24, 0x04	; 4
    18ce:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    18d2:	ff 91       	pop	r31
    18d4:	ef 91       	pop	r30
    18d6:	bf 91       	pop	r27
    18d8:	af 91       	pop	r26
    18da:	9f 91       	pop	r25
    18dc:	8f 91       	pop	r24
    18de:	3f 91       	pop	r19
    18e0:	2f 91       	pop	r18
    18e2:	0f 90       	pop	r0
    18e4:	0b be       	out	0x3b, r0	; 59
    18e6:	0f 90       	pop	r0
    18e8:	0f be       	out	0x3f, r0	; 63
    18ea:	0f 90       	pop	r0
    18ec:	1f 90       	pop	r1
    18ee:	18 95       	reti

000018f0 <USART0_init>:
	tmptail = (UART0_RxTail + 1) & UART0_RX_BUFFER_MASK;
	// Store new index 
	UART0_RxTail = tmptail;
	// Return data 
	return UART0_RxBuf[tmptail];
}
    18f0:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    18f4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    18f8:	88 e0       	ldi	r24, 0x08	; 8
    18fa:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    18fe:	86 e0       	ldi	r24, 0x06	; 6
    1900:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1904:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <UART0_RxTail>
    1908:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <UART0_RxHead>
    190c:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <UART0_TxTail>
    1910:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <UART0_TxHead>
    1914:	08 95       	ret

00001916 <USART0_TransmitByte>:

void USART0_TransmitByte(unsigned char data)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    1916:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    191a:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    191c:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1920:	29 17       	cp	r18, r25
    1922:	e1 f3       	breq	.-8      	; 0x191c <USART0_TransmitByte+0x6>
	// Store data in buffer 
	UART0_TxBuf[tmphead] = data;
    1924:	e2 2f       	mov	r30, r18
    1926:	f0 e0       	ldi	r31, 0x00	; 0
    1928:	ed 51       	subi	r30, 0x1D	; 29
    192a:	fe 4f       	sbci	r31, 0xFE	; 254
    192c:	80 83       	st	Z, r24
	// Store new index 
	UART0_TxHead = tmphead;
    192e:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt 
	UCSR0B |= (1<<UDRIE0);
    1932:	e1 ec       	ldi	r30, 0xC1	; 193
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	80 81       	ld	r24, Z
    1938:	80 62       	ori	r24, 0x20	; 32
    193a:	80 83       	st	Z, r24
    193c:	08 95       	ret

0000193e <USART0_Transmit_IO>:
//This version is used to send formatted strings...
int USART0_Transmit_IO(char data, FILE *stream)
{
	unsigned char tmphead;
	// Calculate buffer index
	tmphead = (UART0_TxHead + 1) & UART0_TX_BUFFER_MASK;
    193e:	20 91 e2 01 	lds	r18, 0x01E2	; 0x8001e2 <UART0_TxHead>
    1942:	2f 5f       	subi	r18, 0xFF	; 255
	// Wait for free space in buffer
	while (tmphead == UART0_TxTail);
    1944:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <UART0_TxTail>
    1948:	29 17       	cp	r18, r25
    194a:	e1 f3       	breq	.-8      	; 0x1944 <USART0_Transmit_IO+0x6>
	// Store data in buffer
	UART0_TxBuf[tmphead] = data;
    194c:	e2 2f       	mov	r30, r18
    194e:	f0 e0       	ldi	r31, 0x00	; 0
    1950:	ed 51       	subi	r30, 0x1D	; 29
    1952:	fe 4f       	sbci	r31, 0xFE	; 254
    1954:	80 83       	st	Z, r24
	// Store new index
	UART0_TxHead = tmphead;
    1956:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <UART0_TxHead>
	// Enable UDRE interrupt
	UCSR0B |= (1<<UDRIE0);
    195a:	e1 ec       	ldi	r30, 0xC1	; 193
    195c:	f0 e0       	ldi	r31, 0x00	; 0
    195e:	80 81       	ld	r24, Z
    1960:	80 62       	ori	r24, 0x20	; 32
    1962:	80 83       	st	Z, r24
	return(0);
	UART0TransmitCompleteFlag = 1;
}
    1964:	80 e0       	ldi	r24, 0x00	; 0
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	08 95       	ret

0000196a <USART0_putstring>:

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
    196a:	cf 93       	push	r28
    196c:	df 93       	push	r29
    196e:	ec 01       	movw	r28, r24
	while(*StringPtr != 0x00) {
    1970:	88 81       	ld	r24, Y
    1972:	88 23       	and	r24, r24
    1974:	29 f0       	breq	.+10     	; 0x1980 <USART0_putstring+0x16>
    1976:	21 96       	adiw	r28, 0x01	; 1
		USART0_TransmitByte(*StringPtr);
    1978:	ce df       	rcall	.-100    	; 0x1916 <USART0_TransmitByte>
}

// This put string function stops when it reaches the end of a string, which is
// always a null character (0x00) in c.
void USART0_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
    197a:	89 91       	ld	r24, Y+
    197c:	81 11       	cpse	r24, r1
    197e:	fc cf       	rjmp	.-8      	; 0x1978 <USART0_putstring+0xe>
		USART0_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	08 95       	ret

00001986 <__vector_21>:
	// Store received data in buffer 
	UART0_RxBuf[tmphead] = data;
}*/

ISR(USART0_UDRE_vect)
{
    1986:	1f 92       	push	r1
    1988:	0f 92       	push	r0
    198a:	0f b6       	in	r0, 0x3f	; 63
    198c:	0f 92       	push	r0
    198e:	11 24       	eor	r1, r1
    1990:	0b b6       	in	r0, 0x3b	; 59
    1992:	0f 92       	push	r0
    1994:	8f 93       	push	r24
    1996:	9f 93       	push	r25
    1998:	ef 93       	push	r30
    199a:	ff 93       	push	r31
	unsigned char tmptail;
	// Check if all data is transmitted 
	if (UART0_TxHead != UART0_TxTail) {
    199c:	90 91 e2 01 	lds	r25, 0x01E2	; 0x8001e2 <UART0_TxHead>
    19a0:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <UART0_TxTail>
    19a4:	98 17       	cp	r25, r24
    19a6:	61 f0       	breq	.+24     	; 0x19c0 <__vector_21+0x3a>
		// Calculate buffer index
		tmptail = ( UART0_TxTail + 1 ) & UART0_TX_BUFFER_MASK;
    19a8:	e0 91 e1 01 	lds	r30, 0x01E1	; 0x8001e1 <UART0_TxTail>
    19ac:	ef 5f       	subi	r30, 0xFF	; 255
		// Store new index 
		UART0_TxTail = tmptail;
    19ae:	e0 93 e1 01 	sts	0x01E1, r30	; 0x8001e1 <UART0_TxTail>
		// Start transmission 
		UDR0 = UART0_TxBuf[tmptail];
    19b2:	f0 e0       	ldi	r31, 0x00	; 0
    19b4:	ed 51       	subi	r30, 0x1D	; 29
    19b6:	fe 4f       	sbci	r31, 0xFE	; 254
    19b8:	80 81       	ld	r24, Z
    19ba:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    19be:	07 c0       	rjmp	.+14     	; 0x19ce <__vector_21+0x48>
		} else {
		// Disable UDRE interrupt 
		UCSR0B &= ~(1<<UDRIE0);
    19c0:	e1 ec       	ldi	r30, 0xC1	; 193
    19c2:	f0 e0       	ldi	r31, 0x00	; 0
    19c4:	80 81       	ld	r24, Z
    19c6:	8f 7d       	andi	r24, 0xDF	; 223
    19c8:	80 83       	st	Z, r24
		UART0TransmitCompleteFlag = 0;
    19ca:	10 92 e5 02 	sts	0x02E5, r1	; 0x8002e5 <UART0TransmitCompleteFlag>
	}
    19ce:	ff 91       	pop	r31
    19d0:	ef 91       	pop	r30
    19d2:	9f 91       	pop	r25
    19d4:	8f 91       	pop	r24
    19d6:	0f 90       	pop	r0
    19d8:	0b be       	out	0x3b, r0	; 59
    19da:	0f 90       	pop	r0
    19dc:	0f be       	out	0x3f, r0	; 63
    19de:	0f 90       	pop	r0
    19e0:	1f 90       	pop	r1
    19e2:	18 95       	reti

000019e4 <USART1_init>:
void USART1_putstring(char* StringPtr) {
	while(*StringPtr != 0x00) {
		USART1_TransmitByte(*StringPtr);
		StringPtr++;
	}
}
    19e4:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    19e8:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
    19ec:	80 e9       	ldi	r24, 0x90	; 144
    19ee:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
    19f2:	86 e0       	ldi	r24, 0x06	; 6
    19f4:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
    19f8:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxTail>
    19fc:	10 92 e9 02 	sts	0x02E9, r1	; 0x8002e9 <UART1_RxHead>
    1a00:	10 92 e6 02 	sts	0x02E6, r1	; 0x8002e6 <UART1_TxTail>
    1a04:	10 92 e7 02 	sts	0x02E7, r1	; 0x8002e7 <UART1_TxHead>
    1a08:	08 95       	ret

00001a0a <__vector_28>:
*********************************************************************************
********************************************************************************/


ISR(USART1_RX_vect)
{
    1a0a:	1f 92       	push	r1
    1a0c:	0f 92       	push	r0
    1a0e:	0f b6       	in	r0, 0x3f	; 63
    1a10:	0f 92       	push	r0
    1a12:	11 24       	eor	r1, r1
    1a14:	0b b6       	in	r0, 0x3b	; 59
    1a16:	0f 92       	push	r0
    1a18:	2f 93       	push	r18
    1a1a:	3f 93       	push	r19
    1a1c:	8f 93       	push	r24
    1a1e:	9f 93       	push	r25
    1a20:	af 93       	push	r26
    1a22:	bf 93       	push	r27
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
    1a28:	ef 93       	push	r30
    1a2a:	ff 93       	push	r31
	unsigned char data;
	unsigned char tmphead;
	unsigned char i;
	// Read the received data 
	data = UDR1;
    1a2c:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
	// Calculate buffer index 
	tmphead = (UART1_RxHead + 1) & UART1_RX_BUFFER_MASK;
    1a30:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <UART1_RxHead>
    1a34:	8f 5f       	subi	r24, 0xFF	; 255
	// Store new index 
	UART1_RxHead = tmphead;
    1a36:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <UART1_RxHead>

	if (tmphead == UART1_RxTail) {
    1a3a:	20 91 e8 02 	lds	r18, 0x02E8	; 0x8002e8 <UART1_RxTail>
		// ERROR! Receive buffer overflow 
	}
	// Store received data in buffer 
	UART1_RxBuf[tmphead] = data;
    1a3e:	e8 2f       	mov	r30, r24
    1a40:	f0 e0       	ldi	r31, 0x00	; 0
    1a42:	e4 53       	subi	r30, 0x34	; 52
    1a44:	fb 4f       	sbci	r31, 0xFB	; 251
    1a46:	90 83       	st	Z, r25
	
	if (data == 10)
    1a48:	9a 30       	cpi	r25, 0x0A	; 10
    1a4a:	29 f5       	brne	.+74     	; 0x1a96 <__vector_28+0x8c>
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
    1a4c:	90 91 d1 04 	lds	r25, 0x04D1	; 0x8004d1 <UART1_RxBuf+0x5>
    1a50:	97 34       	cpi	r25, 0x47	; 71
    1a52:	e9 f4       	brne	.+58     	; 0x1a8e <__vector_28+0x84>
    1a54:	e0 e0       	ldi	r30, 0x00	; 0
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];
    1a56:	2e 2f       	mov	r18, r30
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	d9 01       	movw	r26, r18
    1a5c:	a4 53       	subi	r26, 0x34	; 52
    1a5e:	ba 4f       	sbci	r27, 0xFA	; 250
    1a60:	e9 01       	movw	r28, r18
    1a62:	c4 53       	subi	r28, 0x34	; 52
    1a64:	db 4f       	sbci	r29, 0xFB	; 251
    1a66:	99 81       	ldd	r25, Y+1	; 0x01
    1a68:	9c 93       	st	X, r25
	{
		//USART0_TransmitByte('n');
		if (UART1_RxBuf[5] == 'G')
		{
			//USART0_TransmitByte(UART1_RxBuf[5]);
			for (i = 0; i<= tmphead; i++)
    1a6a:	ef 5f       	subi	r30, 0xFF	; 255
    1a6c:	8e 17       	cp	r24, r30
    1a6e:	98 f7       	brcc	.-26     	; 0x1a56 <__vector_28+0x4c>
			{
				messageWant[i] = UART1_RxBuf[i+1]; //UART1_RxBuf[i];

			}
			messageWant[i]=0x00; //messageWant[i+1]=0x00;
    1a70:	f0 e0       	ldi	r31, 0x00	; 0
    1a72:	e4 53       	subi	r30, 0x34	; 52
    1a74:	fa 4f       	sbci	r31, 0xFA	; 250
    1a76:	10 82       	st	Z, r1
 			UCSR1B &= !((1<<RXCIE1)|(1<<RXEN1));  //Clear the receive interrupt on USART 1 until we're done reading all other sensors.
    1a78:	e9 ec       	ldi	r30, 0xC9	; 201
    1a7a:	f0 e0       	ldi	r31, 0x00	; 0
    1a7c:	80 81       	ld	r24, Z
    1a7e:	10 82       	st	Z, r1
 			ItsTime = 1;
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	80 93 ff 02 	sts	0x02FF, r24	; 0x8002ff <ItsTime>
 			ToggleBit(PORTB, PORTB1);
    1a86:	95 b1       	in	r25, 0x05	; 5
    1a88:	82 e0       	ldi	r24, 0x02	; 2
    1a8a:	89 27       	eor	r24, r25
    1a8c:	85 b9       	out	0x05, r24	; 5
		}
		UART1_RxTail = 0;
    1a8e:	10 92 e8 02 	sts	0x02E8, r1	; 0x8002e8 <UART1_RxTail>
		UART1_RxHead = 0;
    1a92:	10 92 e9 02 	sts	0x02E9, r1	; 0x8002e9 <UART1_RxHead>
	}
}
    1a96:	ff 91       	pop	r31
    1a98:	ef 91       	pop	r30
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	bf 91       	pop	r27
    1aa0:	af 91       	pop	r26
    1aa2:	9f 91       	pop	r25
    1aa4:	8f 91       	pop	r24
    1aa6:	3f 91       	pop	r19
    1aa8:	2f 91       	pop	r18
    1aaa:	0f 90       	pop	r0
    1aac:	0b be       	out	0x3b, r0	; 59
    1aae:	0f 90       	pop	r0
    1ab0:	0f be       	out	0x3f, r0	; 63
    1ab2:	0f 90       	pop	r0
    1ab4:	1f 90       	pop	r1
    1ab6:	18 95       	reti

00001ab8 <__mulsi3>:
    1ab8:	db 01       	movw	r26, r22
    1aba:	8f 93       	push	r24
    1abc:	9f 93       	push	r25
    1abe:	14 d0       	rcall	.+40     	; 0x1ae8 <__muluhisi3>
    1ac0:	bf 91       	pop	r27
    1ac2:	af 91       	pop	r26
    1ac4:	a2 9f       	mul	r26, r18
    1ac6:	80 0d       	add	r24, r0
    1ac8:	91 1d       	adc	r25, r1
    1aca:	a3 9f       	mul	r26, r19
    1acc:	90 0d       	add	r25, r0
    1ace:	b2 9f       	mul	r27, r18
    1ad0:	90 0d       	add	r25, r0
    1ad2:	11 24       	eor	r1, r1
    1ad4:	08 95       	ret

00001ad6 <__tablejump2__>:
    1ad6:	ee 0f       	add	r30, r30
    1ad8:	ff 1f       	adc	r31, r31
    1ada:	00 24       	eor	r0, r0
    1adc:	00 1c       	adc	r0, r0
    1ade:	0b be       	out	0x3b, r0	; 59
    1ae0:	07 90       	elpm	r0, Z+
    1ae2:	f6 91       	elpm	r31, Z
    1ae4:	e0 2d       	mov	r30, r0
    1ae6:	09 94       	ijmp

00001ae8 <__muluhisi3>:
    1ae8:	85 d1       	rcall	.+778    	; 0x1df4 <__umulhisi3>
    1aea:	a5 9f       	mul	r26, r21
    1aec:	90 0d       	add	r25, r0
    1aee:	b4 9f       	mul	r27, r20
    1af0:	90 0d       	add	r25, r0
    1af2:	a4 9f       	mul	r26, r20
    1af4:	80 0d       	add	r24, r0
    1af6:	91 1d       	adc	r25, r1
    1af8:	11 24       	eor	r1, r1
    1afa:	08 95       	ret

00001afc <__mulshisi3>:
    1afc:	b7 ff       	sbrs	r27, 7
    1afe:	f4 cf       	rjmp	.-24     	; 0x1ae8 <__muluhisi3>

00001b00 <__mulohisi3>:
    1b00:	f3 df       	rcall	.-26     	; 0x1ae8 <__muluhisi3>
    1b02:	82 1b       	sub	r24, r18
    1b04:	93 0b       	sbc	r25, r19
    1b06:	08 95       	ret

00001b08 <__muldi3>:
    1b08:	df 93       	push	r29
    1b0a:	cf 93       	push	r28
    1b0c:	1f 93       	push	r17
    1b0e:	0f 93       	push	r16
    1b10:	9a 9d       	mul	r25, r10
    1b12:	f0 2d       	mov	r31, r0
    1b14:	21 9f       	mul	r18, r17
    1b16:	f0 0d       	add	r31, r0
    1b18:	8b 9d       	mul	r24, r11
    1b1a:	f0 0d       	add	r31, r0
    1b1c:	8a 9d       	mul	r24, r10
    1b1e:	e0 2d       	mov	r30, r0
    1b20:	f1 0d       	add	r31, r1
    1b22:	03 9f       	mul	r16, r19
    1b24:	f0 0d       	add	r31, r0
    1b26:	02 9f       	mul	r16, r18
    1b28:	e0 0d       	add	r30, r0
    1b2a:	f1 1d       	adc	r31, r1
    1b2c:	4e 9d       	mul	r20, r14
    1b2e:	e0 0d       	add	r30, r0
    1b30:	f1 1d       	adc	r31, r1
    1b32:	5e 9d       	mul	r21, r14
    1b34:	f0 0d       	add	r31, r0
    1b36:	4f 9d       	mul	r20, r15
    1b38:	f0 0d       	add	r31, r0
    1b3a:	7f 93       	push	r23
    1b3c:	6f 93       	push	r22
    1b3e:	bf 92       	push	r11
    1b40:	af 92       	push	r10
    1b42:	5f 93       	push	r21
    1b44:	4f 93       	push	r20
    1b46:	d5 01       	movw	r26, r10
    1b48:	55 d1       	rcall	.+682    	; 0x1df4 <__umulhisi3>
    1b4a:	8b 01       	movw	r16, r22
    1b4c:	ac 01       	movw	r20, r24
    1b4e:	d7 01       	movw	r26, r14
    1b50:	51 d1       	rcall	.+674    	; 0x1df4 <__umulhisi3>
    1b52:	eb 01       	movw	r28, r22
    1b54:	e8 0f       	add	r30, r24
    1b56:	f9 1f       	adc	r31, r25
    1b58:	d6 01       	movw	r26, r12
    1b5a:	1f d0       	rcall	.+62     	; 0x1b9a <__muldi3_6>
    1b5c:	2f 91       	pop	r18
    1b5e:	3f 91       	pop	r19
    1b60:	d6 01       	movw	r26, r12
    1b62:	48 d1       	rcall	.+656    	; 0x1df4 <__umulhisi3>
    1b64:	c6 0f       	add	r28, r22
    1b66:	d7 1f       	adc	r29, r23
    1b68:	e8 1f       	adc	r30, r24
    1b6a:	f9 1f       	adc	r31, r25
    1b6c:	af 91       	pop	r26
    1b6e:	bf 91       	pop	r27
    1b70:	14 d0       	rcall	.+40     	; 0x1b9a <__muldi3_6>
    1b72:	2f 91       	pop	r18
    1b74:	3f 91       	pop	r19
    1b76:	3e d1       	rcall	.+636    	; 0x1df4 <__umulhisi3>
    1b78:	c6 0f       	add	r28, r22
    1b7a:	d7 1f       	adc	r29, r23
    1b7c:	e8 1f       	adc	r30, r24
    1b7e:	f9 1f       	adc	r31, r25
    1b80:	d6 01       	movw	r26, r12
    1b82:	38 d1       	rcall	.+624    	; 0x1df4 <__umulhisi3>
    1b84:	e6 0f       	add	r30, r22
    1b86:	f7 1f       	adc	r31, r23
    1b88:	98 01       	movw	r18, r16
    1b8a:	be 01       	movw	r22, r28
    1b8c:	cf 01       	movw	r24, r30
    1b8e:	11 24       	eor	r1, r1
    1b90:	0f 91       	pop	r16
    1b92:	1f 91       	pop	r17
    1b94:	cf 91       	pop	r28
    1b96:	df 91       	pop	r29
    1b98:	08 95       	ret

00001b9a <__muldi3_6>:
    1b9a:	2c d1       	rcall	.+600    	; 0x1df4 <__umulhisi3>
    1b9c:	46 0f       	add	r20, r22
    1b9e:	57 1f       	adc	r21, r23
    1ba0:	c8 1f       	adc	r28, r24
    1ba2:	d9 1f       	adc	r29, r25
    1ba4:	08 f4       	brcc	.+2      	; 0x1ba8 <__muldi3_6+0xe>
    1ba6:	31 96       	adiw	r30, 0x01	; 1
    1ba8:	08 95       	ret

00001baa <__moddi3>:
    1baa:	68 94       	set
    1bac:	01 c0       	rjmp	.+2      	; 0x1bb0 <__divdi3_moddi3>

00001bae <__divdi3>:
    1bae:	e8 94       	clt

00001bb0 <__divdi3_moddi3>:
    1bb0:	f9 2f       	mov	r31, r25
    1bb2:	f1 2b       	or	r31, r17
    1bb4:	0a f0       	brmi	.+2      	; 0x1bb8 <__divdi3_moddi3+0x8>
    1bb6:	27 c0       	rjmp	.+78     	; 0x1c06 <__udivdi3_umoddi3>
    1bb8:	a0 e0       	ldi	r26, 0x00	; 0
    1bba:	b0 e0       	ldi	r27, 0x00	; 0
    1bbc:	e1 ee       	ldi	r30, 0xE1	; 225
    1bbe:	fd e0       	ldi	r31, 0x0D	; 13
    1bc0:	93 c0       	rjmp	.+294    	; 0x1ce8 <__prologue_saves__+0xc>
    1bc2:	09 2e       	mov	r0, r25
    1bc4:	05 94       	asr	r0
    1bc6:	1a f4       	brpl	.+6      	; 0x1bce <__divdi3_moddi3+0x1e>
    1bc8:	79 d0       	rcall	.+242    	; 0x1cbc <__negdi2>
    1bca:	11 23       	and	r17, r17
    1bcc:	92 f4       	brpl	.+36     	; 0x1bf2 <__divdi3_moddi3+0x42>
    1bce:	f0 e8       	ldi	r31, 0x80	; 128
    1bd0:	0f 26       	eor	r0, r31
    1bd2:	ff ef       	ldi	r31, 0xFF	; 255
    1bd4:	e0 94       	com	r14
    1bd6:	f0 94       	com	r15
    1bd8:	00 95       	com	r16
    1bda:	10 95       	com	r17
    1bdc:	b0 94       	com	r11
    1bde:	c0 94       	com	r12
    1be0:	d0 94       	com	r13
    1be2:	a1 94       	neg	r10
    1be4:	bf 0a       	sbc	r11, r31
    1be6:	cf 0a       	sbc	r12, r31
    1be8:	df 0a       	sbc	r13, r31
    1bea:	ef 0a       	sbc	r14, r31
    1bec:	ff 0a       	sbc	r15, r31
    1bee:	0f 0b       	sbc	r16, r31
    1bf0:	1f 0b       	sbc	r17, r31
    1bf2:	13 d0       	rcall	.+38     	; 0x1c1a <__udivmod64>
    1bf4:	07 fc       	sbrc	r0, 7
    1bf6:	62 d0       	rcall	.+196    	; 0x1cbc <__negdi2>
    1bf8:	cd b7       	in	r28, 0x3d	; 61
    1bfa:	de b7       	in	r29, 0x3e	; 62
    1bfc:	ec e0       	ldi	r30, 0x0C	; 12
    1bfe:	90 c0       	rjmp	.+288    	; 0x1d20 <__epilogue_restores__+0xc>

00001c00 <__umoddi3>:
    1c00:	68 94       	set
    1c02:	01 c0       	rjmp	.+2      	; 0x1c06 <__udivdi3_umoddi3>

00001c04 <__udivdi3>:
    1c04:	e8 94       	clt

00001c06 <__udivdi3_umoddi3>:
    1c06:	8f 92       	push	r8
    1c08:	9f 92       	push	r9
    1c0a:	cf 93       	push	r28
    1c0c:	df 93       	push	r29
    1c0e:	05 d0       	rcall	.+10     	; 0x1c1a <__udivmod64>
    1c10:	df 91       	pop	r29
    1c12:	cf 91       	pop	r28
    1c14:	9f 90       	pop	r9
    1c16:	8f 90       	pop	r8
    1c18:	08 95       	ret

00001c1a <__udivmod64>:
    1c1a:	88 24       	eor	r8, r8
    1c1c:	99 24       	eor	r9, r9
    1c1e:	f4 01       	movw	r30, r8
    1c20:	e4 01       	movw	r28, r8
    1c22:	b0 e4       	ldi	r27, 0x40	; 64
    1c24:	9f 93       	push	r25
    1c26:	aa 27       	eor	r26, r26
    1c28:	9a 15       	cp	r25, r10
    1c2a:	8b 04       	cpc	r8, r11
    1c2c:	9c 04       	cpc	r9, r12
    1c2e:	ed 05       	cpc	r30, r13
    1c30:	fe 05       	cpc	r31, r14
    1c32:	cf 05       	cpc	r28, r15
    1c34:	d0 07       	cpc	r29, r16
    1c36:	a1 07       	cpc	r26, r17
    1c38:	98 f4       	brcc	.+38     	; 0x1c60 <__udivmod64+0x46>
    1c3a:	ad 2f       	mov	r26, r29
    1c3c:	dc 2f       	mov	r29, r28
    1c3e:	cf 2f       	mov	r28, r31
    1c40:	fe 2f       	mov	r31, r30
    1c42:	e9 2d       	mov	r30, r9
    1c44:	98 2c       	mov	r9, r8
    1c46:	89 2e       	mov	r8, r25
    1c48:	98 2f       	mov	r25, r24
    1c4a:	87 2f       	mov	r24, r23
    1c4c:	76 2f       	mov	r23, r22
    1c4e:	65 2f       	mov	r22, r21
    1c50:	54 2f       	mov	r21, r20
    1c52:	43 2f       	mov	r20, r19
    1c54:	32 2f       	mov	r19, r18
    1c56:	22 27       	eor	r18, r18
    1c58:	b8 50       	subi	r27, 0x08	; 8
    1c5a:	31 f7       	brne	.-52     	; 0x1c28 <__udivmod64+0xe>
    1c5c:	bf 91       	pop	r27
    1c5e:	27 c0       	rjmp	.+78     	; 0x1cae <__udivmod64+0x94>
    1c60:	1b 2e       	mov	r1, r27
    1c62:	bf 91       	pop	r27
    1c64:	bb 27       	eor	r27, r27
    1c66:	22 0f       	add	r18, r18
    1c68:	33 1f       	adc	r19, r19
    1c6a:	44 1f       	adc	r20, r20
    1c6c:	55 1f       	adc	r21, r21
    1c6e:	66 1f       	adc	r22, r22
    1c70:	77 1f       	adc	r23, r23
    1c72:	88 1f       	adc	r24, r24
    1c74:	99 1f       	adc	r25, r25
    1c76:	88 1c       	adc	r8, r8
    1c78:	99 1c       	adc	r9, r9
    1c7a:	ee 1f       	adc	r30, r30
    1c7c:	ff 1f       	adc	r31, r31
    1c7e:	cc 1f       	adc	r28, r28
    1c80:	dd 1f       	adc	r29, r29
    1c82:	aa 1f       	adc	r26, r26
    1c84:	bb 1f       	adc	r27, r27
    1c86:	8a 14       	cp	r8, r10
    1c88:	9b 04       	cpc	r9, r11
    1c8a:	ec 05       	cpc	r30, r12
    1c8c:	fd 05       	cpc	r31, r13
    1c8e:	ce 05       	cpc	r28, r14
    1c90:	df 05       	cpc	r29, r15
    1c92:	a0 07       	cpc	r26, r16
    1c94:	b1 07       	cpc	r27, r17
    1c96:	48 f0       	brcs	.+18     	; 0x1caa <__udivmod64+0x90>
    1c98:	8a 18       	sub	r8, r10
    1c9a:	9b 08       	sbc	r9, r11
    1c9c:	ec 09       	sbc	r30, r12
    1c9e:	fd 09       	sbc	r31, r13
    1ca0:	ce 09       	sbc	r28, r14
    1ca2:	df 09       	sbc	r29, r15
    1ca4:	a0 0b       	sbc	r26, r16
    1ca6:	b1 0b       	sbc	r27, r17
    1ca8:	21 60       	ori	r18, 0x01	; 1
    1caa:	1a 94       	dec	r1
    1cac:	e1 f6       	brne	.-72     	; 0x1c66 <__udivmod64+0x4c>
    1cae:	2e f4       	brtc	.+10     	; 0x1cba <__udivmod64+0xa0>
    1cb0:	94 01       	movw	r18, r8
    1cb2:	af 01       	movw	r20, r30
    1cb4:	be 01       	movw	r22, r28
    1cb6:	cd 01       	movw	r24, r26
    1cb8:	00 0c       	add	r0, r0
    1cba:	08 95       	ret

00001cbc <__negdi2>:
    1cbc:	60 95       	com	r22
    1cbe:	70 95       	com	r23
    1cc0:	80 95       	com	r24
    1cc2:	90 95       	com	r25
    1cc4:	30 95       	com	r19
    1cc6:	40 95       	com	r20
    1cc8:	50 95       	com	r21
    1cca:	21 95       	neg	r18
    1ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cce:	4f 4f       	sbci	r20, 0xFF	; 255
    1cd0:	5f 4f       	sbci	r21, 0xFF	; 255
    1cd2:	6f 4f       	sbci	r22, 0xFF	; 255
    1cd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd6:	8f 4f       	sbci	r24, 0xFF	; 255
    1cd8:	9f 4f       	sbci	r25, 0xFF	; 255
    1cda:	08 95       	ret

00001cdc <__prologue_saves__>:
    1cdc:	2f 92       	push	r2
    1cde:	3f 92       	push	r3
    1ce0:	4f 92       	push	r4
    1ce2:	5f 92       	push	r5
    1ce4:	6f 92       	push	r6
    1ce6:	7f 92       	push	r7
    1ce8:	8f 92       	push	r8
    1cea:	9f 92       	push	r9
    1cec:	af 92       	push	r10
    1cee:	bf 92       	push	r11
    1cf0:	cf 92       	push	r12
    1cf2:	df 92       	push	r13
    1cf4:	ef 92       	push	r14
    1cf6:	ff 92       	push	r15
    1cf8:	0f 93       	push	r16
    1cfa:	1f 93       	push	r17
    1cfc:	cf 93       	push	r28
    1cfe:	df 93       	push	r29
    1d00:	cd b7       	in	r28, 0x3d	; 61
    1d02:	de b7       	in	r29, 0x3e	; 62
    1d04:	ca 1b       	sub	r28, r26
    1d06:	db 0b       	sbc	r29, r27
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	de bf       	out	0x3e, r29	; 62
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	cd bf       	out	0x3d, r28	; 61
    1d12:	09 94       	ijmp

00001d14 <__epilogue_restores__>:
    1d14:	2a 88       	ldd	r2, Y+18	; 0x12
    1d16:	39 88       	ldd	r3, Y+17	; 0x11
    1d18:	48 88       	ldd	r4, Y+16	; 0x10
    1d1a:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d1c:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d1e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d20:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d22:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d24:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d26:	b9 84       	ldd	r11, Y+9	; 0x09
    1d28:	c8 84       	ldd	r12, Y+8	; 0x08
    1d2a:	df 80       	ldd	r13, Y+7	; 0x07
    1d2c:	ee 80       	ldd	r14, Y+6	; 0x06
    1d2e:	fd 80       	ldd	r15, Y+5	; 0x05
    1d30:	0c 81       	ldd	r16, Y+4	; 0x04
    1d32:	1b 81       	ldd	r17, Y+3	; 0x03
    1d34:	aa 81       	ldd	r26, Y+2	; 0x02
    1d36:	b9 81       	ldd	r27, Y+1	; 0x01
    1d38:	ce 0f       	add	r28, r30
    1d3a:	d1 1d       	adc	r29, r1
    1d3c:	0f b6       	in	r0, 0x3f	; 63
    1d3e:	f8 94       	cli
    1d40:	de bf       	out	0x3e, r29	; 62
    1d42:	0f be       	out	0x3f, r0	; 63
    1d44:	cd bf       	out	0x3d, r28	; 61
    1d46:	ed 01       	movw	r28, r26
    1d48:	08 95       	ret

00001d4a <__ashldi3>:
    1d4a:	0f 93       	push	r16
    1d4c:	08 30       	cpi	r16, 0x08	; 8
    1d4e:	90 f0       	brcs	.+36     	; 0x1d74 <__ashldi3+0x2a>
    1d50:	98 2f       	mov	r25, r24
    1d52:	87 2f       	mov	r24, r23
    1d54:	76 2f       	mov	r23, r22
    1d56:	65 2f       	mov	r22, r21
    1d58:	54 2f       	mov	r21, r20
    1d5a:	43 2f       	mov	r20, r19
    1d5c:	32 2f       	mov	r19, r18
    1d5e:	22 27       	eor	r18, r18
    1d60:	08 50       	subi	r16, 0x08	; 8
    1d62:	f4 cf       	rjmp	.-24     	; 0x1d4c <__ashldi3+0x2>
    1d64:	22 0f       	add	r18, r18
    1d66:	33 1f       	adc	r19, r19
    1d68:	44 1f       	adc	r20, r20
    1d6a:	55 1f       	adc	r21, r21
    1d6c:	66 1f       	adc	r22, r22
    1d6e:	77 1f       	adc	r23, r23
    1d70:	88 1f       	adc	r24, r24
    1d72:	99 1f       	adc	r25, r25
    1d74:	0a 95       	dec	r16
    1d76:	b2 f7       	brpl	.-20     	; 0x1d64 <__ashldi3+0x1a>
    1d78:	0f 91       	pop	r16
    1d7a:	08 95       	ret

00001d7c <__ashrdi3>:
    1d7c:	97 fb       	bst	r25, 7
    1d7e:	10 f8       	bld	r1, 0

00001d80 <__lshrdi3>:
    1d80:	16 94       	lsr	r1
    1d82:	00 08       	sbc	r0, r0
    1d84:	0f 93       	push	r16
    1d86:	08 30       	cpi	r16, 0x08	; 8
    1d88:	98 f0       	brcs	.+38     	; 0x1db0 <__lshrdi3+0x30>
    1d8a:	08 50       	subi	r16, 0x08	; 8
    1d8c:	23 2f       	mov	r18, r19
    1d8e:	34 2f       	mov	r19, r20
    1d90:	45 2f       	mov	r20, r21
    1d92:	56 2f       	mov	r21, r22
    1d94:	67 2f       	mov	r22, r23
    1d96:	78 2f       	mov	r23, r24
    1d98:	89 2f       	mov	r24, r25
    1d9a:	90 2d       	mov	r25, r0
    1d9c:	f4 cf       	rjmp	.-24     	; 0x1d86 <__lshrdi3+0x6>
    1d9e:	05 94       	asr	r0
    1da0:	97 95       	ror	r25
    1da2:	87 95       	ror	r24
    1da4:	77 95       	ror	r23
    1da6:	67 95       	ror	r22
    1da8:	57 95       	ror	r21
    1daa:	47 95       	ror	r20
    1dac:	37 95       	ror	r19
    1dae:	27 95       	ror	r18
    1db0:	0a 95       	dec	r16
    1db2:	aa f7       	brpl	.-22     	; 0x1d9e <__lshrdi3+0x1e>
    1db4:	0f 91       	pop	r16
    1db6:	08 95       	ret

00001db8 <__adddi3>:
    1db8:	2a 0d       	add	r18, r10
    1dba:	3b 1d       	adc	r19, r11
    1dbc:	4c 1d       	adc	r20, r12
    1dbe:	5d 1d       	adc	r21, r13
    1dc0:	6e 1d       	adc	r22, r14
    1dc2:	7f 1d       	adc	r23, r15
    1dc4:	80 1f       	adc	r24, r16
    1dc6:	91 1f       	adc	r25, r17
    1dc8:	08 95       	ret

00001dca <__subdi3>:
    1dca:	2a 19       	sub	r18, r10
    1dcc:	3b 09       	sbc	r19, r11
    1dce:	4c 09       	sbc	r20, r12
    1dd0:	5d 09       	sbc	r21, r13
    1dd2:	6e 09       	sbc	r22, r14
    1dd4:	7f 09       	sbc	r23, r15
    1dd6:	80 0b       	sbc	r24, r16
    1dd8:	91 0b       	sbc	r25, r17
    1dda:	08 95       	ret

00001ddc <__cmpdi2_s8>:
    1ddc:	00 24       	eor	r0, r0
    1dde:	a7 fd       	sbrc	r26, 7
    1de0:	00 94       	com	r0
    1de2:	2a 17       	cp	r18, r26
    1de4:	30 05       	cpc	r19, r0
    1de6:	40 05       	cpc	r20, r0
    1de8:	50 05       	cpc	r21, r0
    1dea:	60 05       	cpc	r22, r0
    1dec:	70 05       	cpc	r23, r0
    1dee:	80 05       	cpc	r24, r0
    1df0:	90 05       	cpc	r25, r0
    1df2:	08 95       	ret

00001df4 <__umulhisi3>:
    1df4:	a2 9f       	mul	r26, r18
    1df6:	b0 01       	movw	r22, r0
    1df8:	b3 9f       	mul	r27, r19
    1dfa:	c0 01       	movw	r24, r0
    1dfc:	a3 9f       	mul	r26, r19
    1dfe:	70 0d       	add	r23, r0
    1e00:	81 1d       	adc	r24, r1
    1e02:	11 24       	eor	r1, r1
    1e04:	91 1d       	adc	r25, r1
    1e06:	b2 9f       	mul	r27, r18
    1e08:	70 0d       	add	r23, r0
    1e0a:	81 1d       	adc	r24, r1
    1e0c:	11 24       	eor	r1, r1
    1e0e:	91 1d       	adc	r25, r1
    1e10:	08 95       	ret

00001e12 <printf>:
    1e12:	cf 93       	push	r28
    1e14:	df 93       	push	r29
    1e16:	cd b7       	in	r28, 0x3d	; 61
    1e18:	de b7       	in	r29, 0x3e	; 62
    1e1a:	ae 01       	movw	r20, r28
    1e1c:	4b 5f       	subi	r20, 0xFB	; 251
    1e1e:	5f 4f       	sbci	r21, 0xFF	; 255
    1e20:	fa 01       	movw	r30, r20
    1e22:	61 91       	ld	r22, Z+
    1e24:	71 91       	ld	r23, Z+
    1e26:	af 01       	movw	r20, r30
    1e28:	80 91 ce 06 	lds	r24, 0x06CE	; 0x8006ce <__iob+0x2>
    1e2c:	90 91 cf 06 	lds	r25, 0x06CF	; 0x8006cf <__iob+0x3>
    1e30:	03 d0       	rcall	.+6      	; 0x1e38 <vfprintf>
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret

00001e38 <vfprintf>:
    1e38:	2f 92       	push	r2
    1e3a:	3f 92       	push	r3
    1e3c:	4f 92       	push	r4
    1e3e:	5f 92       	push	r5
    1e40:	6f 92       	push	r6
    1e42:	7f 92       	push	r7
    1e44:	8f 92       	push	r8
    1e46:	9f 92       	push	r9
    1e48:	af 92       	push	r10
    1e4a:	bf 92       	push	r11
    1e4c:	cf 92       	push	r12
    1e4e:	df 92       	push	r13
    1e50:	ef 92       	push	r14
    1e52:	ff 92       	push	r15
    1e54:	0f 93       	push	r16
    1e56:	1f 93       	push	r17
    1e58:	cf 93       	push	r28
    1e5a:	df 93       	push	r29
    1e5c:	cd b7       	in	r28, 0x3d	; 61
    1e5e:	de b7       	in	r29, 0x3e	; 62
    1e60:	2c 97       	sbiw	r28, 0x0c	; 12
    1e62:	0f b6       	in	r0, 0x3f	; 63
    1e64:	f8 94       	cli
    1e66:	de bf       	out	0x3e, r29	; 62
    1e68:	0f be       	out	0x3f, r0	; 63
    1e6a:	cd bf       	out	0x3d, r28	; 61
    1e6c:	7c 01       	movw	r14, r24
    1e6e:	6b 01       	movw	r12, r22
    1e70:	8a 01       	movw	r16, r20
    1e72:	fc 01       	movw	r30, r24
    1e74:	17 82       	std	Z+7, r1	; 0x07
    1e76:	16 82       	std	Z+6, r1	; 0x06
    1e78:	83 81       	ldd	r24, Z+3	; 0x03
    1e7a:	81 ff       	sbrs	r24, 1
    1e7c:	b0 c1       	rjmp	.+864    	; 0x21de <vfprintf+0x3a6>
    1e7e:	ce 01       	movw	r24, r28
    1e80:	01 96       	adiw	r24, 0x01	; 1
    1e82:	4c 01       	movw	r8, r24
    1e84:	f7 01       	movw	r30, r14
    1e86:	93 81       	ldd	r25, Z+3	; 0x03
    1e88:	f6 01       	movw	r30, r12
    1e8a:	93 fd       	sbrc	r25, 3
    1e8c:	85 91       	lpm	r24, Z+
    1e8e:	93 ff       	sbrs	r25, 3
    1e90:	81 91       	ld	r24, Z+
    1e92:	6f 01       	movw	r12, r30
    1e94:	88 23       	and	r24, r24
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <vfprintf+0x62>
    1e98:	9e c1       	rjmp	.+828    	; 0x21d6 <vfprintf+0x39e>
    1e9a:	85 32       	cpi	r24, 0x25	; 37
    1e9c:	39 f4       	brne	.+14     	; 0x1eac <vfprintf+0x74>
    1e9e:	93 fd       	sbrc	r25, 3
    1ea0:	85 91       	lpm	r24, Z+
    1ea2:	93 ff       	sbrs	r25, 3
    1ea4:	81 91       	ld	r24, Z+
    1ea6:	6f 01       	movw	r12, r30
    1ea8:	85 32       	cpi	r24, 0x25	; 37
    1eaa:	21 f4       	brne	.+8      	; 0x1eb4 <vfprintf+0x7c>
    1eac:	b7 01       	movw	r22, r14
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	c7 d1       	rcall	.+910    	; 0x2240 <fputc>
    1eb2:	e8 cf       	rjmp	.-48     	; 0x1e84 <vfprintf+0x4c>
    1eb4:	51 2c       	mov	r5, r1
    1eb6:	31 2c       	mov	r3, r1
    1eb8:	20 e0       	ldi	r18, 0x00	; 0
    1eba:	20 32       	cpi	r18, 0x20	; 32
    1ebc:	a0 f4       	brcc	.+40     	; 0x1ee6 <vfprintf+0xae>
    1ebe:	8b 32       	cpi	r24, 0x2B	; 43
    1ec0:	69 f0       	breq	.+26     	; 0x1edc <vfprintf+0xa4>
    1ec2:	30 f4       	brcc	.+12     	; 0x1ed0 <vfprintf+0x98>
    1ec4:	80 32       	cpi	r24, 0x20	; 32
    1ec6:	59 f0       	breq	.+22     	; 0x1ede <vfprintf+0xa6>
    1ec8:	83 32       	cpi	r24, 0x23	; 35
    1eca:	69 f4       	brne	.+26     	; 0x1ee6 <vfprintf+0xae>
    1ecc:	20 61       	ori	r18, 0x10	; 16
    1ece:	2c c0       	rjmp	.+88     	; 0x1f28 <vfprintf+0xf0>
    1ed0:	8d 32       	cpi	r24, 0x2D	; 45
    1ed2:	39 f0       	breq	.+14     	; 0x1ee2 <vfprintf+0xaa>
    1ed4:	80 33       	cpi	r24, 0x30	; 48
    1ed6:	39 f4       	brne	.+14     	; 0x1ee6 <vfprintf+0xae>
    1ed8:	21 60       	ori	r18, 0x01	; 1
    1eda:	26 c0       	rjmp	.+76     	; 0x1f28 <vfprintf+0xf0>
    1edc:	22 60       	ori	r18, 0x02	; 2
    1ede:	24 60       	ori	r18, 0x04	; 4
    1ee0:	23 c0       	rjmp	.+70     	; 0x1f28 <vfprintf+0xf0>
    1ee2:	28 60       	ori	r18, 0x08	; 8
    1ee4:	21 c0       	rjmp	.+66     	; 0x1f28 <vfprintf+0xf0>
    1ee6:	27 fd       	sbrc	r18, 7
    1ee8:	27 c0       	rjmp	.+78     	; 0x1f38 <vfprintf+0x100>
    1eea:	30 ed       	ldi	r19, 0xD0	; 208
    1eec:	38 0f       	add	r19, r24
    1eee:	3a 30       	cpi	r19, 0x0A	; 10
    1ef0:	78 f4       	brcc	.+30     	; 0x1f10 <vfprintf+0xd8>
    1ef2:	26 ff       	sbrs	r18, 6
    1ef4:	06 c0       	rjmp	.+12     	; 0x1f02 <vfprintf+0xca>
    1ef6:	fa e0       	ldi	r31, 0x0A	; 10
    1ef8:	5f 9e       	mul	r5, r31
    1efa:	30 0d       	add	r19, r0
    1efc:	11 24       	eor	r1, r1
    1efe:	53 2e       	mov	r5, r19
    1f00:	13 c0       	rjmp	.+38     	; 0x1f28 <vfprintf+0xf0>
    1f02:	8a e0       	ldi	r24, 0x0A	; 10
    1f04:	38 9e       	mul	r3, r24
    1f06:	30 0d       	add	r19, r0
    1f08:	11 24       	eor	r1, r1
    1f0a:	33 2e       	mov	r3, r19
    1f0c:	20 62       	ori	r18, 0x20	; 32
    1f0e:	0c c0       	rjmp	.+24     	; 0x1f28 <vfprintf+0xf0>
    1f10:	8e 32       	cpi	r24, 0x2E	; 46
    1f12:	21 f4       	brne	.+8      	; 0x1f1c <vfprintf+0xe4>
    1f14:	26 fd       	sbrc	r18, 6
    1f16:	5f c1       	rjmp	.+702    	; 0x21d6 <vfprintf+0x39e>
    1f18:	20 64       	ori	r18, 0x40	; 64
    1f1a:	06 c0       	rjmp	.+12     	; 0x1f28 <vfprintf+0xf0>
    1f1c:	8c 36       	cpi	r24, 0x6C	; 108
    1f1e:	11 f4       	brne	.+4      	; 0x1f24 <vfprintf+0xec>
    1f20:	20 68       	ori	r18, 0x80	; 128
    1f22:	02 c0       	rjmp	.+4      	; 0x1f28 <vfprintf+0xf0>
    1f24:	88 36       	cpi	r24, 0x68	; 104
    1f26:	41 f4       	brne	.+16     	; 0x1f38 <vfprintf+0x100>
    1f28:	f6 01       	movw	r30, r12
    1f2a:	93 fd       	sbrc	r25, 3
    1f2c:	85 91       	lpm	r24, Z+
    1f2e:	93 ff       	sbrs	r25, 3
    1f30:	81 91       	ld	r24, Z+
    1f32:	6f 01       	movw	r12, r30
    1f34:	81 11       	cpse	r24, r1
    1f36:	c1 cf       	rjmp	.-126    	; 0x1eba <vfprintf+0x82>
    1f38:	98 2f       	mov	r25, r24
    1f3a:	9f 7d       	andi	r25, 0xDF	; 223
    1f3c:	95 54       	subi	r25, 0x45	; 69
    1f3e:	93 30       	cpi	r25, 0x03	; 3
    1f40:	28 f4       	brcc	.+10     	; 0x1f4c <vfprintf+0x114>
    1f42:	0c 5f       	subi	r16, 0xFC	; 252
    1f44:	1f 4f       	sbci	r17, 0xFF	; 255
    1f46:	ff e3       	ldi	r31, 0x3F	; 63
    1f48:	f9 83       	std	Y+1, r31	; 0x01
    1f4a:	0d c0       	rjmp	.+26     	; 0x1f66 <vfprintf+0x12e>
    1f4c:	83 36       	cpi	r24, 0x63	; 99
    1f4e:	31 f0       	breq	.+12     	; 0x1f5c <vfprintf+0x124>
    1f50:	83 37       	cpi	r24, 0x73	; 115
    1f52:	71 f0       	breq	.+28     	; 0x1f70 <vfprintf+0x138>
    1f54:	83 35       	cpi	r24, 0x53	; 83
    1f56:	09 f0       	breq	.+2      	; 0x1f5a <vfprintf+0x122>
    1f58:	57 c0       	rjmp	.+174    	; 0x2008 <vfprintf+0x1d0>
    1f5a:	21 c0       	rjmp	.+66     	; 0x1f9e <vfprintf+0x166>
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	80 81       	ld	r24, Z
    1f60:	89 83       	std	Y+1, r24	; 0x01
    1f62:	0e 5f       	subi	r16, 0xFE	; 254
    1f64:	1f 4f       	sbci	r17, 0xFF	; 255
    1f66:	44 24       	eor	r4, r4
    1f68:	43 94       	inc	r4
    1f6a:	51 2c       	mov	r5, r1
    1f6c:	54 01       	movw	r10, r8
    1f6e:	14 c0       	rjmp	.+40     	; 0x1f98 <vfprintf+0x160>
    1f70:	38 01       	movw	r6, r16
    1f72:	f2 e0       	ldi	r31, 0x02	; 2
    1f74:	6f 0e       	add	r6, r31
    1f76:	71 1c       	adc	r7, r1
    1f78:	f8 01       	movw	r30, r16
    1f7a:	a0 80       	ld	r10, Z
    1f7c:	b1 80       	ldd	r11, Z+1	; 0x01
    1f7e:	26 ff       	sbrs	r18, 6
    1f80:	03 c0       	rjmp	.+6      	; 0x1f88 <vfprintf+0x150>
    1f82:	65 2d       	mov	r22, r5
    1f84:	70 e0       	ldi	r23, 0x00	; 0
    1f86:	02 c0       	rjmp	.+4      	; 0x1f8c <vfprintf+0x154>
    1f88:	6f ef       	ldi	r22, 0xFF	; 255
    1f8a:	7f ef       	ldi	r23, 0xFF	; 255
    1f8c:	c5 01       	movw	r24, r10
    1f8e:	2c 87       	std	Y+12, r18	; 0x0c
    1f90:	4c d1       	rcall	.+664    	; 0x222a <strnlen>
    1f92:	2c 01       	movw	r4, r24
    1f94:	83 01       	movw	r16, r6
    1f96:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f98:	2f 77       	andi	r18, 0x7F	; 127
    1f9a:	22 2e       	mov	r2, r18
    1f9c:	16 c0       	rjmp	.+44     	; 0x1fca <vfprintf+0x192>
    1f9e:	38 01       	movw	r6, r16
    1fa0:	f2 e0       	ldi	r31, 0x02	; 2
    1fa2:	6f 0e       	add	r6, r31
    1fa4:	71 1c       	adc	r7, r1
    1fa6:	f8 01       	movw	r30, r16
    1fa8:	a0 80       	ld	r10, Z
    1faa:	b1 80       	ldd	r11, Z+1	; 0x01
    1fac:	26 ff       	sbrs	r18, 6
    1fae:	03 c0       	rjmp	.+6      	; 0x1fb6 <vfprintf+0x17e>
    1fb0:	65 2d       	mov	r22, r5
    1fb2:	70 e0       	ldi	r23, 0x00	; 0
    1fb4:	02 c0       	rjmp	.+4      	; 0x1fba <vfprintf+0x182>
    1fb6:	6f ef       	ldi	r22, 0xFF	; 255
    1fb8:	7f ef       	ldi	r23, 0xFF	; 255
    1fba:	c5 01       	movw	r24, r10
    1fbc:	2c 87       	std	Y+12, r18	; 0x0c
    1fbe:	2a d1       	rcall	.+596    	; 0x2214 <strnlen_P>
    1fc0:	2c 01       	movw	r4, r24
    1fc2:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fc4:	20 68       	ori	r18, 0x80	; 128
    1fc6:	22 2e       	mov	r2, r18
    1fc8:	83 01       	movw	r16, r6
    1fca:	23 fc       	sbrc	r2, 3
    1fcc:	19 c0       	rjmp	.+50     	; 0x2000 <vfprintf+0x1c8>
    1fce:	83 2d       	mov	r24, r3
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	48 16       	cp	r4, r24
    1fd4:	59 06       	cpc	r5, r25
    1fd6:	a0 f4       	brcc	.+40     	; 0x2000 <vfprintf+0x1c8>
    1fd8:	b7 01       	movw	r22, r14
    1fda:	80 e2       	ldi	r24, 0x20	; 32
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	30 d1       	rcall	.+608    	; 0x2240 <fputc>
    1fe0:	3a 94       	dec	r3
    1fe2:	f5 cf       	rjmp	.-22     	; 0x1fce <vfprintf+0x196>
    1fe4:	f5 01       	movw	r30, r10
    1fe6:	27 fc       	sbrc	r2, 7
    1fe8:	85 91       	lpm	r24, Z+
    1fea:	27 fe       	sbrs	r2, 7
    1fec:	81 91       	ld	r24, Z+
    1fee:	5f 01       	movw	r10, r30
    1ff0:	b7 01       	movw	r22, r14
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	25 d1       	rcall	.+586    	; 0x2240 <fputc>
    1ff6:	31 10       	cpse	r3, r1
    1ff8:	3a 94       	dec	r3
    1ffa:	f1 e0       	ldi	r31, 0x01	; 1
    1ffc:	4f 1a       	sub	r4, r31
    1ffe:	51 08       	sbc	r5, r1
    2000:	41 14       	cp	r4, r1
    2002:	51 04       	cpc	r5, r1
    2004:	79 f7       	brne	.-34     	; 0x1fe4 <vfprintf+0x1ac>
    2006:	de c0       	rjmp	.+444    	; 0x21c4 <vfprintf+0x38c>
    2008:	84 36       	cpi	r24, 0x64	; 100
    200a:	11 f0       	breq	.+4      	; 0x2010 <vfprintf+0x1d8>
    200c:	89 36       	cpi	r24, 0x69	; 105
    200e:	31 f5       	brne	.+76     	; 0x205c <vfprintf+0x224>
    2010:	f8 01       	movw	r30, r16
    2012:	27 ff       	sbrs	r18, 7
    2014:	07 c0       	rjmp	.+14     	; 0x2024 <vfprintf+0x1ec>
    2016:	60 81       	ld	r22, Z
    2018:	71 81       	ldd	r23, Z+1	; 0x01
    201a:	82 81       	ldd	r24, Z+2	; 0x02
    201c:	93 81       	ldd	r25, Z+3	; 0x03
    201e:	0c 5f       	subi	r16, 0xFC	; 252
    2020:	1f 4f       	sbci	r17, 0xFF	; 255
    2022:	08 c0       	rjmp	.+16     	; 0x2034 <vfprintf+0x1fc>
    2024:	60 81       	ld	r22, Z
    2026:	71 81       	ldd	r23, Z+1	; 0x01
    2028:	07 2e       	mov	r0, r23
    202a:	00 0c       	add	r0, r0
    202c:	88 0b       	sbc	r24, r24
    202e:	99 0b       	sbc	r25, r25
    2030:	0e 5f       	subi	r16, 0xFE	; 254
    2032:	1f 4f       	sbci	r17, 0xFF	; 255
    2034:	2f 76       	andi	r18, 0x6F	; 111
    2036:	72 2e       	mov	r7, r18
    2038:	97 ff       	sbrs	r25, 7
    203a:	09 c0       	rjmp	.+18     	; 0x204e <vfprintf+0x216>
    203c:	90 95       	com	r25
    203e:	80 95       	com	r24
    2040:	70 95       	com	r23
    2042:	61 95       	neg	r22
    2044:	7f 4f       	sbci	r23, 0xFF	; 255
    2046:	8f 4f       	sbci	r24, 0xFF	; 255
    2048:	9f 4f       	sbci	r25, 0xFF	; 255
    204a:	20 68       	ori	r18, 0x80	; 128
    204c:	72 2e       	mov	r7, r18
    204e:	2a e0       	ldi	r18, 0x0A	; 10
    2050:	30 e0       	ldi	r19, 0x00	; 0
    2052:	a4 01       	movw	r20, r8
    2054:	2d d1       	rcall	.+602    	; 0x22b0 <__ultoa_invert>
    2056:	a8 2e       	mov	r10, r24
    2058:	a8 18       	sub	r10, r8
    205a:	43 c0       	rjmp	.+134    	; 0x20e2 <vfprintf+0x2aa>
    205c:	85 37       	cpi	r24, 0x75	; 117
    205e:	29 f4       	brne	.+10     	; 0x206a <vfprintf+0x232>
    2060:	2f 7e       	andi	r18, 0xEF	; 239
    2062:	b2 2e       	mov	r11, r18
    2064:	2a e0       	ldi	r18, 0x0A	; 10
    2066:	30 e0       	ldi	r19, 0x00	; 0
    2068:	25 c0       	rjmp	.+74     	; 0x20b4 <vfprintf+0x27c>
    206a:	f2 2f       	mov	r31, r18
    206c:	f9 7f       	andi	r31, 0xF9	; 249
    206e:	bf 2e       	mov	r11, r31
    2070:	8f 36       	cpi	r24, 0x6F	; 111
    2072:	c1 f0       	breq	.+48     	; 0x20a4 <vfprintf+0x26c>
    2074:	18 f4       	brcc	.+6      	; 0x207c <vfprintf+0x244>
    2076:	88 35       	cpi	r24, 0x58	; 88
    2078:	79 f0       	breq	.+30     	; 0x2098 <vfprintf+0x260>
    207a:	ad c0       	rjmp	.+346    	; 0x21d6 <vfprintf+0x39e>
    207c:	80 37       	cpi	r24, 0x70	; 112
    207e:	19 f0       	breq	.+6      	; 0x2086 <vfprintf+0x24e>
    2080:	88 37       	cpi	r24, 0x78	; 120
    2082:	21 f0       	breq	.+8      	; 0x208c <vfprintf+0x254>
    2084:	a8 c0       	rjmp	.+336    	; 0x21d6 <vfprintf+0x39e>
    2086:	2f 2f       	mov	r18, r31
    2088:	20 61       	ori	r18, 0x10	; 16
    208a:	b2 2e       	mov	r11, r18
    208c:	b4 fe       	sbrs	r11, 4
    208e:	0d c0       	rjmp	.+26     	; 0x20aa <vfprintf+0x272>
    2090:	8b 2d       	mov	r24, r11
    2092:	84 60       	ori	r24, 0x04	; 4
    2094:	b8 2e       	mov	r11, r24
    2096:	09 c0       	rjmp	.+18     	; 0x20aa <vfprintf+0x272>
    2098:	24 ff       	sbrs	r18, 4
    209a:	0a c0       	rjmp	.+20     	; 0x20b0 <vfprintf+0x278>
    209c:	9f 2f       	mov	r25, r31
    209e:	96 60       	ori	r25, 0x06	; 6
    20a0:	b9 2e       	mov	r11, r25
    20a2:	06 c0       	rjmp	.+12     	; 0x20b0 <vfprintf+0x278>
    20a4:	28 e0       	ldi	r18, 0x08	; 8
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	05 c0       	rjmp	.+10     	; 0x20b4 <vfprintf+0x27c>
    20aa:	20 e1       	ldi	r18, 0x10	; 16
    20ac:	30 e0       	ldi	r19, 0x00	; 0
    20ae:	02 c0       	rjmp	.+4      	; 0x20b4 <vfprintf+0x27c>
    20b0:	20 e1       	ldi	r18, 0x10	; 16
    20b2:	32 e0       	ldi	r19, 0x02	; 2
    20b4:	f8 01       	movw	r30, r16
    20b6:	b7 fe       	sbrs	r11, 7
    20b8:	07 c0       	rjmp	.+14     	; 0x20c8 <vfprintf+0x290>
    20ba:	60 81       	ld	r22, Z
    20bc:	71 81       	ldd	r23, Z+1	; 0x01
    20be:	82 81       	ldd	r24, Z+2	; 0x02
    20c0:	93 81       	ldd	r25, Z+3	; 0x03
    20c2:	0c 5f       	subi	r16, 0xFC	; 252
    20c4:	1f 4f       	sbci	r17, 0xFF	; 255
    20c6:	06 c0       	rjmp	.+12     	; 0x20d4 <vfprintf+0x29c>
    20c8:	60 81       	ld	r22, Z
    20ca:	71 81       	ldd	r23, Z+1	; 0x01
    20cc:	80 e0       	ldi	r24, 0x00	; 0
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	0e 5f       	subi	r16, 0xFE	; 254
    20d2:	1f 4f       	sbci	r17, 0xFF	; 255
    20d4:	a4 01       	movw	r20, r8
    20d6:	ec d0       	rcall	.+472    	; 0x22b0 <__ultoa_invert>
    20d8:	a8 2e       	mov	r10, r24
    20da:	a8 18       	sub	r10, r8
    20dc:	fb 2d       	mov	r31, r11
    20de:	ff 77       	andi	r31, 0x7F	; 127
    20e0:	7f 2e       	mov	r7, r31
    20e2:	76 fe       	sbrs	r7, 6
    20e4:	0b c0       	rjmp	.+22     	; 0x20fc <vfprintf+0x2c4>
    20e6:	37 2d       	mov	r19, r7
    20e8:	3e 7f       	andi	r19, 0xFE	; 254
    20ea:	a5 14       	cp	r10, r5
    20ec:	50 f4       	brcc	.+20     	; 0x2102 <vfprintf+0x2ca>
    20ee:	74 fe       	sbrs	r7, 4
    20f0:	0a c0       	rjmp	.+20     	; 0x2106 <vfprintf+0x2ce>
    20f2:	72 fc       	sbrc	r7, 2
    20f4:	08 c0       	rjmp	.+16     	; 0x2106 <vfprintf+0x2ce>
    20f6:	37 2d       	mov	r19, r7
    20f8:	3e 7e       	andi	r19, 0xEE	; 238
    20fa:	05 c0       	rjmp	.+10     	; 0x2106 <vfprintf+0x2ce>
    20fc:	ba 2c       	mov	r11, r10
    20fe:	37 2d       	mov	r19, r7
    2100:	03 c0       	rjmp	.+6      	; 0x2108 <vfprintf+0x2d0>
    2102:	ba 2c       	mov	r11, r10
    2104:	01 c0       	rjmp	.+2      	; 0x2108 <vfprintf+0x2d0>
    2106:	b5 2c       	mov	r11, r5
    2108:	34 ff       	sbrs	r19, 4
    210a:	0d c0       	rjmp	.+26     	; 0x2126 <vfprintf+0x2ee>
    210c:	fe 01       	movw	r30, r28
    210e:	ea 0d       	add	r30, r10
    2110:	f1 1d       	adc	r31, r1
    2112:	80 81       	ld	r24, Z
    2114:	80 33       	cpi	r24, 0x30	; 48
    2116:	11 f4       	brne	.+4      	; 0x211c <vfprintf+0x2e4>
    2118:	39 7e       	andi	r19, 0xE9	; 233
    211a:	09 c0       	rjmp	.+18     	; 0x212e <vfprintf+0x2f6>
    211c:	32 ff       	sbrs	r19, 2
    211e:	06 c0       	rjmp	.+12     	; 0x212c <vfprintf+0x2f4>
    2120:	b3 94       	inc	r11
    2122:	b3 94       	inc	r11
    2124:	04 c0       	rjmp	.+8      	; 0x212e <vfprintf+0x2f6>
    2126:	83 2f       	mov	r24, r19
    2128:	86 78       	andi	r24, 0x86	; 134
    212a:	09 f0       	breq	.+2      	; 0x212e <vfprintf+0x2f6>
    212c:	b3 94       	inc	r11
    212e:	33 fd       	sbrc	r19, 3
    2130:	12 c0       	rjmp	.+36     	; 0x2156 <vfprintf+0x31e>
    2132:	30 ff       	sbrs	r19, 0
    2134:	06 c0       	rjmp	.+12     	; 0x2142 <vfprintf+0x30a>
    2136:	5a 2c       	mov	r5, r10
    2138:	b3 14       	cp	r11, r3
    213a:	18 f4       	brcc	.+6      	; 0x2142 <vfprintf+0x30a>
    213c:	53 0c       	add	r5, r3
    213e:	5b 18       	sub	r5, r11
    2140:	b3 2c       	mov	r11, r3
    2142:	b3 14       	cp	r11, r3
    2144:	60 f4       	brcc	.+24     	; 0x215e <vfprintf+0x326>
    2146:	b7 01       	movw	r22, r14
    2148:	80 e2       	ldi	r24, 0x20	; 32
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	3c 87       	std	Y+12, r19	; 0x0c
    214e:	78 d0       	rcall	.+240    	; 0x2240 <fputc>
    2150:	b3 94       	inc	r11
    2152:	3c 85       	ldd	r19, Y+12	; 0x0c
    2154:	f6 cf       	rjmp	.-20     	; 0x2142 <vfprintf+0x30a>
    2156:	b3 14       	cp	r11, r3
    2158:	10 f4       	brcc	.+4      	; 0x215e <vfprintf+0x326>
    215a:	3b 18       	sub	r3, r11
    215c:	01 c0       	rjmp	.+2      	; 0x2160 <vfprintf+0x328>
    215e:	31 2c       	mov	r3, r1
    2160:	34 ff       	sbrs	r19, 4
    2162:	11 c0       	rjmp	.+34     	; 0x2186 <vfprintf+0x34e>
    2164:	b7 01       	movw	r22, r14
    2166:	80 e3       	ldi	r24, 0x30	; 48
    2168:	90 e0       	ldi	r25, 0x00	; 0
    216a:	3c 87       	std	Y+12, r19	; 0x0c
    216c:	69 d0       	rcall	.+210    	; 0x2240 <fputc>
    216e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2170:	32 ff       	sbrs	r19, 2
    2172:	16 c0       	rjmp	.+44     	; 0x21a0 <vfprintf+0x368>
    2174:	31 fd       	sbrc	r19, 1
    2176:	03 c0       	rjmp	.+6      	; 0x217e <vfprintf+0x346>
    2178:	88 e7       	ldi	r24, 0x78	; 120
    217a:	90 e0       	ldi	r25, 0x00	; 0
    217c:	02 c0       	rjmp	.+4      	; 0x2182 <vfprintf+0x34a>
    217e:	88 e5       	ldi	r24, 0x58	; 88
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	b7 01       	movw	r22, r14
    2184:	0c c0       	rjmp	.+24     	; 0x219e <vfprintf+0x366>
    2186:	83 2f       	mov	r24, r19
    2188:	86 78       	andi	r24, 0x86	; 134
    218a:	51 f0       	breq	.+20     	; 0x21a0 <vfprintf+0x368>
    218c:	31 ff       	sbrs	r19, 1
    218e:	02 c0       	rjmp	.+4      	; 0x2194 <vfprintf+0x35c>
    2190:	8b e2       	ldi	r24, 0x2B	; 43
    2192:	01 c0       	rjmp	.+2      	; 0x2196 <vfprintf+0x35e>
    2194:	80 e2       	ldi	r24, 0x20	; 32
    2196:	37 fd       	sbrc	r19, 7
    2198:	8d e2       	ldi	r24, 0x2D	; 45
    219a:	b7 01       	movw	r22, r14
    219c:	90 e0       	ldi	r25, 0x00	; 0
    219e:	50 d0       	rcall	.+160    	; 0x2240 <fputc>
    21a0:	a5 14       	cp	r10, r5
    21a2:	30 f4       	brcc	.+12     	; 0x21b0 <vfprintf+0x378>
    21a4:	b7 01       	movw	r22, r14
    21a6:	80 e3       	ldi	r24, 0x30	; 48
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	4a d0       	rcall	.+148    	; 0x2240 <fputc>
    21ac:	5a 94       	dec	r5
    21ae:	f8 cf       	rjmp	.-16     	; 0x21a0 <vfprintf+0x368>
    21b0:	aa 94       	dec	r10
    21b2:	f4 01       	movw	r30, r8
    21b4:	ea 0d       	add	r30, r10
    21b6:	f1 1d       	adc	r31, r1
    21b8:	80 81       	ld	r24, Z
    21ba:	b7 01       	movw	r22, r14
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	40 d0       	rcall	.+128    	; 0x2240 <fputc>
    21c0:	a1 10       	cpse	r10, r1
    21c2:	f6 cf       	rjmp	.-20     	; 0x21b0 <vfprintf+0x378>
    21c4:	33 20       	and	r3, r3
    21c6:	09 f4       	brne	.+2      	; 0x21ca <vfprintf+0x392>
    21c8:	5d ce       	rjmp	.-838    	; 0x1e84 <vfprintf+0x4c>
    21ca:	b7 01       	movw	r22, r14
    21cc:	80 e2       	ldi	r24, 0x20	; 32
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	37 d0       	rcall	.+110    	; 0x2240 <fputc>
    21d2:	3a 94       	dec	r3
    21d4:	f7 cf       	rjmp	.-18     	; 0x21c4 <vfprintf+0x38c>
    21d6:	f7 01       	movw	r30, r14
    21d8:	86 81       	ldd	r24, Z+6	; 0x06
    21da:	97 81       	ldd	r25, Z+7	; 0x07
    21dc:	02 c0       	rjmp	.+4      	; 0x21e2 <vfprintf+0x3aa>
    21de:	8f ef       	ldi	r24, 0xFF	; 255
    21e0:	9f ef       	ldi	r25, 0xFF	; 255
    21e2:	2c 96       	adiw	r28, 0x0c	; 12
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	de bf       	out	0x3e, r29	; 62
    21ea:	0f be       	out	0x3f, r0	; 63
    21ec:	cd bf       	out	0x3d, r28	; 61
    21ee:	df 91       	pop	r29
    21f0:	cf 91       	pop	r28
    21f2:	1f 91       	pop	r17
    21f4:	0f 91       	pop	r16
    21f6:	ff 90       	pop	r15
    21f8:	ef 90       	pop	r14
    21fa:	df 90       	pop	r13
    21fc:	cf 90       	pop	r12
    21fe:	bf 90       	pop	r11
    2200:	af 90       	pop	r10
    2202:	9f 90       	pop	r9
    2204:	8f 90       	pop	r8
    2206:	7f 90       	pop	r7
    2208:	6f 90       	pop	r6
    220a:	5f 90       	pop	r5
    220c:	4f 90       	pop	r4
    220e:	3f 90       	pop	r3
    2210:	2f 90       	pop	r2
    2212:	08 95       	ret

00002214 <strnlen_P>:
    2214:	fc 01       	movw	r30, r24
    2216:	05 90       	lpm	r0, Z+
    2218:	61 50       	subi	r22, 0x01	; 1
    221a:	70 40       	sbci	r23, 0x00	; 0
    221c:	01 10       	cpse	r0, r1
    221e:	d8 f7       	brcc	.-10     	; 0x2216 <strnlen_P+0x2>
    2220:	80 95       	com	r24
    2222:	90 95       	com	r25
    2224:	8e 0f       	add	r24, r30
    2226:	9f 1f       	adc	r25, r31
    2228:	08 95       	ret

0000222a <strnlen>:
    222a:	fc 01       	movw	r30, r24
    222c:	61 50       	subi	r22, 0x01	; 1
    222e:	70 40       	sbci	r23, 0x00	; 0
    2230:	01 90       	ld	r0, Z+
    2232:	01 10       	cpse	r0, r1
    2234:	d8 f7       	brcc	.-10     	; 0x222c <strnlen+0x2>
    2236:	80 95       	com	r24
    2238:	90 95       	com	r25
    223a:	8e 0f       	add	r24, r30
    223c:	9f 1f       	adc	r25, r31
    223e:	08 95       	ret

00002240 <fputc>:
    2240:	0f 93       	push	r16
    2242:	1f 93       	push	r17
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
    2248:	fb 01       	movw	r30, r22
    224a:	23 81       	ldd	r18, Z+3	; 0x03
    224c:	21 fd       	sbrc	r18, 1
    224e:	03 c0       	rjmp	.+6      	; 0x2256 <fputc+0x16>
    2250:	8f ef       	ldi	r24, 0xFF	; 255
    2252:	9f ef       	ldi	r25, 0xFF	; 255
    2254:	28 c0       	rjmp	.+80     	; 0x22a6 <fputc+0x66>
    2256:	22 ff       	sbrs	r18, 2
    2258:	16 c0       	rjmp	.+44     	; 0x2286 <fputc+0x46>
    225a:	46 81       	ldd	r20, Z+6	; 0x06
    225c:	57 81       	ldd	r21, Z+7	; 0x07
    225e:	24 81       	ldd	r18, Z+4	; 0x04
    2260:	35 81       	ldd	r19, Z+5	; 0x05
    2262:	42 17       	cp	r20, r18
    2264:	53 07       	cpc	r21, r19
    2266:	44 f4       	brge	.+16     	; 0x2278 <fputc+0x38>
    2268:	a0 81       	ld	r26, Z
    226a:	b1 81       	ldd	r27, Z+1	; 0x01
    226c:	9d 01       	movw	r18, r26
    226e:	2f 5f       	subi	r18, 0xFF	; 255
    2270:	3f 4f       	sbci	r19, 0xFF	; 255
    2272:	31 83       	std	Z+1, r19	; 0x01
    2274:	20 83       	st	Z, r18
    2276:	8c 93       	st	X, r24
    2278:	26 81       	ldd	r18, Z+6	; 0x06
    227a:	37 81       	ldd	r19, Z+7	; 0x07
    227c:	2f 5f       	subi	r18, 0xFF	; 255
    227e:	3f 4f       	sbci	r19, 0xFF	; 255
    2280:	37 83       	std	Z+7, r19	; 0x07
    2282:	26 83       	std	Z+6, r18	; 0x06
    2284:	10 c0       	rjmp	.+32     	; 0x22a6 <fputc+0x66>
    2286:	eb 01       	movw	r28, r22
    2288:	09 2f       	mov	r16, r25
    228a:	18 2f       	mov	r17, r24
    228c:	00 84       	ldd	r0, Z+8	; 0x08
    228e:	f1 85       	ldd	r31, Z+9	; 0x09
    2290:	e0 2d       	mov	r30, r0
    2292:	09 95       	icall
    2294:	89 2b       	or	r24, r25
    2296:	e1 f6       	brne	.-72     	; 0x2250 <fputc+0x10>
    2298:	8e 81       	ldd	r24, Y+6	; 0x06
    229a:	9f 81       	ldd	r25, Y+7	; 0x07
    229c:	01 96       	adiw	r24, 0x01	; 1
    229e:	9f 83       	std	Y+7, r25	; 0x07
    22a0:	8e 83       	std	Y+6, r24	; 0x06
    22a2:	81 2f       	mov	r24, r17
    22a4:	90 2f       	mov	r25, r16
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	08 95       	ret

000022b0 <__ultoa_invert>:
    22b0:	fa 01       	movw	r30, r20
    22b2:	aa 27       	eor	r26, r26
    22b4:	28 30       	cpi	r18, 0x08	; 8
    22b6:	51 f1       	breq	.+84     	; 0x230c <__ultoa_invert+0x5c>
    22b8:	20 31       	cpi	r18, 0x10	; 16
    22ba:	81 f1       	breq	.+96     	; 0x231c <__ultoa_invert+0x6c>
    22bc:	e8 94       	clt
    22be:	6f 93       	push	r22
    22c0:	6e 7f       	andi	r22, 0xFE	; 254
    22c2:	6e 5f       	subi	r22, 0xFE	; 254
    22c4:	7f 4f       	sbci	r23, 0xFF	; 255
    22c6:	8f 4f       	sbci	r24, 0xFF	; 255
    22c8:	9f 4f       	sbci	r25, 0xFF	; 255
    22ca:	af 4f       	sbci	r26, 0xFF	; 255
    22cc:	b1 e0       	ldi	r27, 0x01	; 1
    22ce:	3e d0       	rcall	.+124    	; 0x234c <__ultoa_invert+0x9c>
    22d0:	b4 e0       	ldi	r27, 0x04	; 4
    22d2:	3c d0       	rcall	.+120    	; 0x234c <__ultoa_invert+0x9c>
    22d4:	67 0f       	add	r22, r23
    22d6:	78 1f       	adc	r23, r24
    22d8:	89 1f       	adc	r24, r25
    22da:	9a 1f       	adc	r25, r26
    22dc:	a1 1d       	adc	r26, r1
    22de:	68 0f       	add	r22, r24
    22e0:	79 1f       	adc	r23, r25
    22e2:	8a 1f       	adc	r24, r26
    22e4:	91 1d       	adc	r25, r1
    22e6:	a1 1d       	adc	r26, r1
    22e8:	6a 0f       	add	r22, r26
    22ea:	71 1d       	adc	r23, r1
    22ec:	81 1d       	adc	r24, r1
    22ee:	91 1d       	adc	r25, r1
    22f0:	a1 1d       	adc	r26, r1
    22f2:	20 d0       	rcall	.+64     	; 0x2334 <__ultoa_invert+0x84>
    22f4:	09 f4       	brne	.+2      	; 0x22f8 <__ultoa_invert+0x48>
    22f6:	68 94       	set
    22f8:	3f 91       	pop	r19
    22fa:	2a e0       	ldi	r18, 0x0A	; 10
    22fc:	26 9f       	mul	r18, r22
    22fe:	11 24       	eor	r1, r1
    2300:	30 19       	sub	r19, r0
    2302:	30 5d       	subi	r19, 0xD0	; 208
    2304:	31 93       	st	Z+, r19
    2306:	de f6       	brtc	.-74     	; 0x22be <__ultoa_invert+0xe>
    2308:	cf 01       	movw	r24, r30
    230a:	08 95       	ret
    230c:	46 2f       	mov	r20, r22
    230e:	47 70       	andi	r20, 0x07	; 7
    2310:	40 5d       	subi	r20, 0xD0	; 208
    2312:	41 93       	st	Z+, r20
    2314:	b3 e0       	ldi	r27, 0x03	; 3
    2316:	0f d0       	rcall	.+30     	; 0x2336 <__ultoa_invert+0x86>
    2318:	c9 f7       	brne	.-14     	; 0x230c <__ultoa_invert+0x5c>
    231a:	f6 cf       	rjmp	.-20     	; 0x2308 <__ultoa_invert+0x58>
    231c:	46 2f       	mov	r20, r22
    231e:	4f 70       	andi	r20, 0x0F	; 15
    2320:	40 5d       	subi	r20, 0xD0	; 208
    2322:	4a 33       	cpi	r20, 0x3A	; 58
    2324:	18 f0       	brcs	.+6      	; 0x232c <__ultoa_invert+0x7c>
    2326:	49 5d       	subi	r20, 0xD9	; 217
    2328:	31 fd       	sbrc	r19, 1
    232a:	40 52       	subi	r20, 0x20	; 32
    232c:	41 93       	st	Z+, r20
    232e:	02 d0       	rcall	.+4      	; 0x2334 <__ultoa_invert+0x84>
    2330:	a9 f7       	brne	.-22     	; 0x231c <__ultoa_invert+0x6c>
    2332:	ea cf       	rjmp	.-44     	; 0x2308 <__ultoa_invert+0x58>
    2334:	b4 e0       	ldi	r27, 0x04	; 4
    2336:	a6 95       	lsr	r26
    2338:	97 95       	ror	r25
    233a:	87 95       	ror	r24
    233c:	77 95       	ror	r23
    233e:	67 95       	ror	r22
    2340:	ba 95       	dec	r27
    2342:	c9 f7       	brne	.-14     	; 0x2336 <__ultoa_invert+0x86>
    2344:	00 97       	sbiw	r24, 0x00	; 0
    2346:	61 05       	cpc	r22, r1
    2348:	71 05       	cpc	r23, r1
    234a:	08 95       	ret
    234c:	9b 01       	movw	r18, r22
    234e:	ac 01       	movw	r20, r24
    2350:	0a 2e       	mov	r0, r26
    2352:	06 94       	lsr	r0
    2354:	57 95       	ror	r21
    2356:	47 95       	ror	r20
    2358:	37 95       	ror	r19
    235a:	27 95       	ror	r18
    235c:	ba 95       	dec	r27
    235e:	c9 f7       	brne	.-14     	; 0x2352 <__ultoa_invert+0xa2>
    2360:	62 0f       	add	r22, r18
    2362:	73 1f       	adc	r23, r19
    2364:	84 1f       	adc	r24, r20
    2366:	95 1f       	adc	r25, r21
    2368:	a0 1d       	adc	r26, r0
    236a:	08 95       	ret

0000236c <eeprom_read_word>:
    236c:	a8 e1       	ldi	r26, 0x18	; 24
    236e:	b0 e0       	ldi	r27, 0x00	; 0
    2370:	42 e0       	ldi	r20, 0x02	; 2
    2372:	50 e0       	ldi	r21, 0x00	; 0
    2374:	02 c0       	rjmp	.+4      	; 0x237a <eeprom_read_blraw>

00002376 <eeprom_read_block>:
    2376:	dc 01       	movw	r26, r24
    2378:	cb 01       	movw	r24, r22

0000237a <eeprom_read_blraw>:
    237a:	fc 01       	movw	r30, r24
    237c:	f9 99       	sbic	0x1f, 1	; 31
    237e:	fe cf       	rjmp	.-4      	; 0x237c <eeprom_read_blraw+0x2>
    2380:	06 c0       	rjmp	.+12     	; 0x238e <eeprom_read_blraw+0x14>
    2382:	f2 bd       	out	0x22, r31	; 34
    2384:	e1 bd       	out	0x21, r30	; 33
    2386:	f8 9a       	sbi	0x1f, 0	; 31
    2388:	31 96       	adiw	r30, 0x01	; 1
    238a:	00 b4       	in	r0, 0x20	; 32
    238c:	0d 92       	st	X+, r0
    238e:	41 50       	subi	r20, 0x01	; 1
    2390:	50 40       	sbci	r21, 0x00	; 0
    2392:	b8 f7       	brcc	.-18     	; 0x2382 <eeprom_read_blraw+0x8>
    2394:	08 95       	ret

00002396 <_exit>:
    2396:	f8 94       	cli

00002398 <__stop_program>:
    2398:	ff cf       	rjmp	.-2      	; 0x2398 <__stop_program>
